(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.decaffeinate = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('magic-string'), require('babel-traverse'), require('babylon')) :
	typeof define === 'function' && define.amd ? define(['magic-string', 'babel-traverse', 'babylon'], factory) :
	(global.addVariableDeclarations = factory(global.MagicString,global.traverse,global.babylon));
}(this, (function (MagicString,traverse,babylon) { 'use strict';

MagicString = 'default' in MagicString ? MagicString['default'] : MagicString;
traverse = 'default' in traverse ? traverse['default'] : traverse;

function getFirstStatementInBlock(node) {
  switch (node.type) {
    case 'BlockStatement':
    case 'Program':
      return node.body[0];

    case 'FunctionDeclaration':
    case 'FunctionExpression':
    case 'ForStatement':
    case 'ObjectMethod':
    case 'ClassMethod':
      return getFirstStatementInBlock(node.body);

    case 'ArrowFunctionExpression':
      if (node.body.type === 'BlockStatement') {
        return getFirstStatementInBlock(node.body);
      } else {
        return null;
      }

    default:
      return null;
  }
}

function getIndentForLineContainingOffset(source, offset) {
  var lastNewlineIndex = source.lastIndexOf('\n', offset);

  for (var i = lastNewlineIndex + 1; i < source.length; i++) {
    switch (source[i]) {
      case ' ':
      case '\t':
        break;

      default:
        return source.slice(lastNewlineIndex + 1, i);
    }
  }

  return source.slice(lastNewlineIndex + 1);
}

function buildDeclarationForNames(names, source, offset) {
  var nameList = names.sort(function (a, b) {
    return a.localeCompare(b);
  }).join(', ');
  var indent = getIndentForLineContainingOffset(source, offset);
  return 'var ' + nameList + ';\n' + indent;
}

function getParenthesesRanges(node, tokens) {
  var leftParenTokens = [];
  var rightParenTokens = [];

  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];
    if (token.start === node.start) {
      for (var j = i - 1; j >= 0; j--) {
        if (tokens[j].type.label === '(') {
          leftParenTokens.unshift(tokens[j]);
        } else {
          break;
        }
      }
    } else if (token.end === node.end) {
      for (var _j = i + 1; _j < tokens.length; _j++) {
        if (tokens[_j].type.label === ')') {
          rightParenTokens.push(tokens[_j]);
        } else {
          break;
        }
      }
      break;
    }
  }

  if (leftParenTokens.length === 0 || leftParenTokens.length !== rightParenTokens.length) {
    return [];
  }

  return [{
    start: leftParenTokens[0].start,
    end: leftParenTokens[leftParenTokens.length - 1].end
  }, {
    start: rightParenTokens[0].start,
    end: rightParenTokens[rightParenTokens.length - 1].end
  }];
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();



























var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/**
 * The state of one proposed binding. As new usages are seen, the
 * mostSpecificScope field is updated accordingly.
 */

var BindingState = function () {
  function BindingState(name, scope) {
    classCallCheck(this, BindingState);
    this.isInOriginalPosition = true;

    this.name = name;
    this.mostSpecificScope = scope;
  }

  createClass(BindingState, [{
    key: 'handleSeenScope',
    value: function handleSeenScope(scope) {
      var newScopes = new Set();
      for (var newScope = scope; newScope; newScope = newScope.parent) {
        newScopes.add(newScope);
      }
      while (!newScopes.has(this.mostSpecificScope)) {
        this.mostSpecificScope = this.mostSpecificScope.parent;
        this.isInOriginalPosition = false;
      }
    }
  }]);
  return BindingState;
}();

/**
 * Information about an "inline binding", a potential opportunity to insert
 * `var` directly at the variable declaration.
 */


/**
 * Mutable structure containing the current declarations in the traversal. Each
 * TraverseState object corresponds to one scope in the source code (which could
 * be any block, not just a function scope), so the full set of TraverseState
 * objects forms a tree structure, but any any point in time, the current
 * TraverseState forms a path through all parent scopes.
 *
 * Even though every scope gets a TraverseState, only function scopes can
 * actually "own" bindings. This makes it easy to detect when two variables are
 * the same.
 */
var TraverseState = function () {
  function TraverseState(scope) {
    var parentState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    classCallCheck(this, TraverseState);
    this.ownedBindings = new Map();
    this.ownedInlineBindings = [];

    this.scope = scope;
    this.parentState = parentState;
  }

  /**
   * Declare that there is an assignment to a variable with this name in this
   * scope.
   */


  createClass(TraverseState, [{
    key: 'addBinding',
    value: function addBinding(name) {
      var searchResult = this.resolveName(name);
      if (searchResult === 'NOT_FOUND') {
        this.createBinding(name, this.scope);
      } else if (searchResult !== 'ALREADY_DECLARED') {
        searchResult.handleSeenScope(this.scope);
      }
    }

    /**
     * Note that this identifier appears in this scope. This won't create
     * bindings, but might update the most specific scope for existing bindings.
     */

  }, {
    key: 'handleSeenIdentifier',
    value: function handleSeenIdentifier(name) {
      var searchResult = this.resolveName(name);
      if (searchResult !== 'NOT_FOUND' && searchResult !== 'ALREADY_DECLARED') {
        searchResult.handleSeenScope(this.scope);
      }
    }

    /**
     * Declare that, if possible, the given names should all have declarations
     * added by inserting `var` at the start of the specified node. If any of them
     * end up changing scopes due to later information, or if any of them are
     * already declared, we'll just add the names to the most specific scope.
     *
     * To make calling code simpler, this method allows an empty array of names
     * (in which case it's a no-op) and allows names that are already defined
     * (in which case we immediately know that we won't be able to do an inline
     * binding).
     */

  }, {
    key: 'addInlineBinding',
    value: function addInlineBinding(node, names, _ref) {
      var _this = this;

      var shouldRemoveParens = _ref.shouldRemoveParens;

      if (names.length === 0) {
        return;
      }
      // This is only eligible as an inline binding if every name is distinct and not yet taken.
      if (names.every(function (name) {
        return _this.resolveName(name) === 'NOT_FOUND';
      }) && new Set(names).size === names.length) {
        var newBindings = names.map(function (name) {
          return _this.createBinding(name, _this.scope);
        });
        var bindingOwner = this.getEnclosingBindingOwner();
        bindingOwner.ownedInlineBindings.push({
          node: node,
          bindings: newBindings,
          shouldRemoveParens: shouldRemoveParens
        });
      } else {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = names[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var name = _step.value;

            this.addBinding(name);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    }
  }, {
    key: 'createBinding',
    value: function createBinding(name, scope) {
      var bindingOwner = this.getEnclosingBindingOwner();
      if (bindingOwner.ownedBindings.has(name)) {
        throw new Error('Tried to create a binding for a name that is already taken.');
      }
      var newState = new BindingState(name, scope);
      bindingOwner.ownedBindings.set(name, newState);
      return newState;
    }
  }, {
    key: 'getEnclosingBindingOwner',
    value: function getEnclosingBindingOwner() {
      if (this.canOwnBindings()) {
        return this;
      } else {
        return this.parentState.getEnclosingBindingOwner();
      }
    }
  }, {
    key: 'canOwnBindings',
    value: function canOwnBindings() {
      if (!this.parentState) {
        return true;
      }
      switch (this.scope.block.type) {
        case 'FunctionDeclaration':
        case 'FunctionExpression':
        case 'ObjectMethod':
        case 'ClassMethod':
          return true;

        default:
          return false;
      }
    }
  }, {
    key: 'resolveName',
    value: function resolveName(name) {
      if (this.scope.getBinding(name)) {
        return 'ALREADY_DECLARED';
      }
      if (this.ownedBindings.has(name)) {
        return this.ownedBindings.get(name);
      }
      if (this.parentState) {
        return this.parentState.resolveName(name);
      } else {
        return 'NOT_FOUND';
      }
    }

    /**
     * When we finish processing a function, we know that we have all information
     * we need for variables scoped to this function, so we can insert the `var`
     * declarations at the right places.
     */

  }, {
    key: 'commitDeclarations',
    value: function commitDeclarations(editor, source, tokens) {
      var usedNames = new Set();
      // Defer `var` insertions so that magic-string will insert things in the
      // right order.
      var varInsertionPoints = [];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.ownedInlineBindings[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var inlineBinding = _step2.value;

          if (inlineBinding.bindings.every(function (binding) {
            return binding.isInOriginalPosition;
          })) {
            var _node = inlineBinding.node,
                _shouldRemoveParens = inlineBinding.shouldRemoveParens;

            if (_shouldRemoveParens) {
              var _iteratorNormalCompletion5 = true;
              var _didIteratorError5 = false;
              var _iteratorError5 = undefined;

              try {
                for (var _iterator5 = getParenthesesRanges(_node, tokens)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                  var _step5$value = _step5.value,
                      start = _step5$value.start,
                      end = _step5$value.end;

                  editor.remove(start, end);
                }
              } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion5 && _iterator5.return) {
                    _iterator5.return();
                  }
                } finally {
                  if (_didIteratorError5) {
                    throw _iteratorError5;
                  }
                }
              }
            }
            varInsertionPoints.push(_node.start);
            var _iteratorNormalCompletion6 = true;
            var _didIteratorError6 = false;
            var _iteratorError6 = undefined;

            try {
              for (var _iterator6 = inlineBinding.bindings[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                var binding = _step6.value;

                usedNames.add(binding.name);
              }
            } catch (err) {
              _didIteratorError6 = true;
              _iteratorError6 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion6 && _iterator6.return) {
                  _iterator6.return();
                }
              } finally {
                if (_didIteratorError6) {
                  throw _iteratorError6;
                }
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.getBindingNamesByScope(usedNames).entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _step3$value = slicedToArray(_step3.value, 2),
              scope = _step3$value[0],
              names = _step3$value[1];

          var firstStatement = this.getFirstStatementForScope(scope);
          if (firstStatement) {
            editor.appendLeft(firstStatement.start, buildDeclarationForNames(names, source, firstStatement.start));
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = varInsertionPoints[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var insertionPoint = _step4.value;

          editor.appendLeft(insertionPoint, 'var ');
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }

    /**
     * Get all names that we still need to declare (ones not in usedNames), sorted
     * and grouped by scope.
     */

  }, {
    key: 'getBindingNamesByScope',
    value: function getBindingNamesByScope(usedNames) {
      var bindingNamesByScope = new Map();
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = this.ownedBindings.values()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var _step7$value = _step7.value,
              name = _step7$value.name,
              mostSpecificScope = _step7$value.mostSpecificScope;

          if (usedNames.has(name)) {
            continue;
          }
          if (bindingNamesByScope.has(mostSpecificScope)) {
            bindingNamesByScope.get(mostSpecificScope).push(name);
          } else {
            bindingNamesByScope.set(mostSpecificScope, [name]);
          }
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = bindingNamesByScope.values()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var names = _step8.value;

          names.sort();
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }

      return bindingNamesByScope;
    }
  }, {
    key: 'getFirstStatementForScope',
    value: function getFirstStatementForScope(scope) {
      var firstStatement = void 0;
      var insertionScope = scope;
      do {
        firstStatement = getFirstStatementInBlock(insertionScope.block);
        insertionScope = insertionScope.parent;
      } while (!firstStatement);
      return firstStatement;
    }
  }]);
  return TraverseState;
}();

function flatMap(list, map) {
  return list.reduce(function (memo, item) {
    return memo.concat(map(item));
  }, []);
}

/**
 * Gets the names to be bound in the LHS of an assignment.
 *
 *   a = 1;                         // [ 'a' ]
 *   ({ b, c } = {});               // [ 'b', 'c' ]
 *   [ d, e ] = [];                 // [ 'd', 'e' ]
 *   ({ f: g, h: [ i, j ] } = {});  // [ 'g', 'i', 'j' ]
 *   [ k.l, ...m ] = [];            // [ 'm' ]
 */
function getBindingIdentifiersFromLHS(node) {
  switch (node.type) {
    case 'Identifier':
      return [node];

    case 'ObjectPattern':
      return flatMap(node.properties, function (property) {
        return getBindingIdentifiersFromLHS(property.value);
      });

    case 'ArrayPattern':
      return flatMap(node.elements, getBindingIdentifiersFromLHS);

    case 'RestElement':
      return getBindingIdentifiersFromLHS(node.argument);

    default:
      return [];
  }
}

/**
 * Determines if any assignments are to properties or other non-identifiers. If
 * so, then it's illegal to put `var` to the left of the assignment.
 *
 *   a = 1;                         // false
 *   ({ b, c } = {});               // false
 *   [ d, e.f ] = [];               // true
 */
function lhsHasNonIdentifierAssignment(node) {
  switch (node.type) {
    case 'Identifier':
      return false;

    case 'ObjectPattern':
      return node.properties.some(function (property) {
        return lhsHasNonIdentifierAssignment(property.value);
      });

    case 'ArrayPattern':
      return node.elements.some(lhsHasNonIdentifierAssignment);

    case 'RestElement':
      // JS allows array and object destructuring on a rest assignee, but they
      // can't be used in an inline assignment.
      return node.argument.type !== 'Identifier';

    default:
      return true;
  }
}

var BABYLON_PLUGINS = ['flow', 'jsx', 'asyncFunctions', 'asyncGenerators', 'classConstructorCall', 'classProperties', 'decorators', 'doExpressions', 'exponentiationOperator', 'exportExtensions', 'functionBind', 'functionSent', 'objectRestSpread', 'trailingFunctionCommas'];

function addVariableDeclarations(source) {
  var editor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new MagicString(source);
  var ast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : babylon.parse(source, {
    plugins: BABYLON_PLUGINS,
    sourceType: 'module',
    allowReturnOutsideFunction: true
  });

  var state = null;
  var savedStates = [];
  var seen = new Set();

  traverse(ast, {
    /**
     * Adds `var` for assignments, either in place or at the top of the scope.
     *
     *   a = 1;      // can add `var` inline
     *   b(c = 2);   // needs standalone `var` at the top of scope
     */
    AssignmentExpression: function AssignmentExpression(path) {
      var node = path.node;


      if (node.operator !== '=') {
        // Ignore e.g. `+=`.
        return;
      }

      if (seen.has(node)) {
        // We've already processed this one.
        return;
      }

      var state = getState();
      var names = getBindingIdentifiersFromLHS(node.left).map(function (id) {
        return id.name;
      });
      var canInsertVar = !lhsHasNonIdentifierAssignment(node.left) && (path.parent.type === 'ExpressionStatement' || path.parent.type === 'ForStatement' && node === path.parent.init);
      if (canInsertVar) {
        state.addInlineBinding(node, names, { shouldRemoveParens: true });
      } else {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = names[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var name = _step.value;

            state.addBinding(name);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    },


    /**
     * We want to declare each variable at its most specific scope across all
     * assignments and usages, so note each usage, since it might affect that
     * scope.
     */
    Identifier: function Identifier(path) {
      var state = getState();
      state.handleSeenIdentifier(path.node.name);
    },


    /**
     * Adds `var` to `for-in` and `for-of` loops, e.g.
     *
     *   for (key in object) {
     *     …
     *   }
     *
     *   for (item of list) {
     *     …
     *   }
     */
    ForXStatement: function ForXStatement(path) {
      var state = getState();
      var node = path.node;

      var names = getBindingIdentifiersFromLHS(node.left).map(function (id) {
        return id.name;
      });
      if (lhsHasNonIdentifierAssignment(node.left)) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = names[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var name = _step2.value;

            state.addBinding(name);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      } else {
        state.addInlineBinding(node.left, names, { shouldRemoveParens: false });
      }
    },


    /**
     * Optimizes for the case where there are multiple assignments in one
     * sequence of expressions, e.g.
     *
     *   for (i = 0, length = list.length; i < length; i++) {
     *     …
     *   }
     */
    SequenceExpression: function SequenceExpression(path) {
      var state = getState();
      var node = path.node;

      var names = [];

      if (path.parent.type !== 'ExpressionStatement' && !(path.parent.type === 'ForStatement' && node === path.parent.init)) {
        return;
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = node.expressions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var expression = _step3.value;

          if (expression.type !== 'AssignmentExpression') {
            return;
          }

          var identifiers = getBindingIdentifiersFromLHS(expression.left);
          if (identifiers.length === 0) {
            return;
          }
          if (lhsHasNonIdentifierAssignment(expression.left)) {
            return;
          }

          names.push.apply(names, toConsumableArray(identifiers.map(function (identifier) {
            return identifier.name;
          })));
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      state.addInlineBinding(node, names, { shouldRemoveParens: true });
      node.expressions.forEach(function (expression) {
        return seen.add(expression);
      });
    },


    Scope: {
      enter: function enter(path) {
        state = new TraverseState(path.scope, state);
      },
      exit: function exit() {
        if (state) {
          state.commitDeclarations(editor, source, ast.tokens);
          state = state.parentState;
        }
      }
    },

    enter: function enter(path) {
      // ObjectMethod and ClassMethod nodes are strange in that their key name
      // is in the outer scope, not the method scope, so we get the wrong scope
      // if we use the usual scope enter and exit hooks. To work around this,
      // pretend to be one scope higher while in the key, then restore the state
      // afterward.
      if (path.parent.type === 'ObjectMethod' && path.key === 'key' || path.parent.type === 'ClassMethod' && path.key === 'key') {
        savedStates.push(state);
        state = state.parentState;
      }
    },
    exit: function exit(path) {
      if (path.parent.type === 'ObjectMethod' && path.key === 'key' || path.parent.type === 'ClassMethod' && path.key === 'key') {
        state = savedStates.pop();
      }
    }
  });

  function getState() {
    if (!state) {
      throw new Error('BUG: state is not set');
    } else {
      return state;
    }
  }

  return {
    code: editor.toString(),
    map: editor.generateMap()
  };
}

return addVariableDeclarations;

})));

},{"babel-traverse":25,"babylon":62,"magic-string":2}],2:[function(require,module,exports){
(function (process,Buffer){
'use strict';

var vlq = require('vlq');

function Chunk ( start, end, content ) {
	this.start = start;
	this.end = end;
	this.original = content;

	this.intro = '';
	this.outro = '';

	this.content = content;
	this.storeName = false;
	this.edited = false;

	// we make these non-enumerable, for sanity while debugging
	Object.defineProperties( this, {
		previous: { writable: true, value: null },
		next: { writable: true, value: null }
	});
}

Chunk.prototype = {
	appendLeft: function appendLeft ( content ) {
		this.outro += content;
	},

	appendRight: function appendRight ( content ) {
		this.intro = this.intro + content;
	},

	clone: function clone () {
		var chunk = new Chunk( this.start, this.end, this.original );

		chunk.intro = this.intro;
		chunk.outro = this.outro;
		chunk.content = this.content;
		chunk.storeName = this.storeName;
		chunk.edited = this.edited;

		return chunk;
	},

	contains: function contains ( index ) {
		return this.start < index && index < this.end;
	},

	eachNext: function eachNext ( fn ) {
		var chunk = this;
		while ( chunk ) {
			fn( chunk );
			chunk = chunk.next;
		}
	},

	eachPrevious: function eachPrevious ( fn ) {
		var chunk = this;
		while ( chunk ) {
			fn( chunk );
			chunk = chunk.previous;
		}
	},

	edit: function edit ( content, storeName ) {
		this.content = content;
		this.intro = '';
		this.outro = '';
		this.storeName = storeName;

		this.edited = true;

		return this;
	},

	prependLeft: function prependLeft ( content ) {
		this.outro = content + this.outro;
	},

	prependRight: function prependRight ( content ) {
		this.intro = content + this.intro;
	},

	split: function split ( index ) {
		var sliceIndex = index - this.start;

		var originalBefore = this.original.slice( 0, sliceIndex );
		var originalAfter = this.original.slice( sliceIndex );

		this.original = originalBefore;

		var newChunk = new Chunk( index, this.end, originalAfter );
		newChunk.outro = this.outro;
		this.outro = '';

		this.end = index;

		if ( this.edited ) {
			// TODO is this block necessary?...
			newChunk.edit( '', false );
			this.content = '';
		} else {
			this.content = originalBefore;
		}

		newChunk.next = this.next;
		if ( newChunk.next ) { newChunk.next.previous = newChunk; }
		newChunk.previous = this;
		this.next = newChunk;

		return newChunk;
	},

	toString: function toString () {
		return this.intro + this.content + this.outro;
	},

	trimEnd: function trimEnd ( rx ) {
		this.outro = this.outro.replace( rx, '' );
		if ( this.outro.length ) { return true; }

		var trimmed = this.content.replace( rx, '' );

		if ( trimmed.length ) {
			if ( trimmed !== this.content ) {
				this.split( this.start + trimmed.length ).edit( '', false );
			}

			return true;
		} else {
			this.edit( '', false );

			this.intro = this.intro.replace( rx, '' );
			if ( this.intro.length ) { return true; }
		}
	},

	trimStart: function trimStart ( rx ) {
		this.intro = this.intro.replace( rx, '' );
		if ( this.intro.length ) { return true; }

		var trimmed = this.content.replace( rx, '' );

		if ( trimmed.length ) {
			if ( trimmed !== this.content ) {
				this.split( this.end - trimmed.length );
				this.edit( '', false );
			}

			return true;
		} else {
			this.edit( '', false );

			this.outro = this.outro.replace( rx, '' );
			if ( this.outro.length ) { return true; }
		}
	}
};

var _btoa;

if ( typeof window !== 'undefined' && typeof window.btoa === 'function' ) {
	_btoa = window.btoa;
} else if ( typeof Buffer === 'function' ) {
	_btoa = function (str) { return new Buffer( str ).toString( 'base64' ); };
} else {
	_btoa = function () {
		throw new Error( 'Unsupported environment: `window.btoa` or `Buffer` should be supported.' );
	};
}

var btoa = _btoa;

function SourceMap ( properties ) {
	this.version = 3;

	this.file           = properties.file;
	this.sources        = properties.sources;
	this.sourcesContent = properties.sourcesContent;
	this.names          = properties.names;
	this.mappings       = properties.mappings;
}

SourceMap.prototype = {
	toString: function toString () {
		return JSON.stringify( this );
	},

	toUrl: function toUrl () {
		return 'data:application/json;charset=utf-8;base64,' + btoa( this.toString() );
	}
};

function guessIndent ( code ) {
	var lines = code.split( '\n' );

	var tabbed = lines.filter( function (line) { return /^\t+/.test( line ); } );
	var spaced = lines.filter( function (line) { return /^ {2,}/.test( line ); } );

	if ( tabbed.length === 0 && spaced.length === 0 ) {
		return null;
	}

	// More lines tabbed than spaced? Assume tabs, and
	// default to tabs in the case of a tie (or nothing
	// to go on)
	if ( tabbed.length >= spaced.length ) {
		return '\t';
	}

	// Otherwise, we need to guess the multiple
	var min = spaced.reduce( function ( previous, current ) {
		var numSpaces = /^ +/.exec( current )[0].length;
		return Math.min( numSpaces, previous );
	}, Infinity );

	return new Array( min + 1 ).join( ' ' );
}

function getRelativePath ( from, to ) {
	var fromParts = from.split( /[\/\\]/ );
	var toParts = to.split( /[\/\\]/ );

	fromParts.pop(); // get dirname

	while ( fromParts[0] === toParts[0] ) {
		fromParts.shift();
		toParts.shift();
	}

	if ( fromParts.length ) {
		var i = fromParts.length;
		while ( i-- ) { fromParts[i] = '..'; }
	}

	return fromParts.concat( toParts ).join( '/' );
}

var toString$1 = Object.prototype.toString;

function isObject ( thing ) {
	return toString$1.call( thing ) === '[object Object]';
}

function getLocator ( source ) {
	var originalLines = source.split( '\n' );

	var start = 0;
	var lineRanges = originalLines.map( function ( line, i ) {
		var end = start + line.length + 1;
		var range = { start: start, end: end, line: i };

		start = end;
		return range;
	});

	var i = 0;

	function rangeContains ( range, index ) {
		return range.start <= index && index < range.end;
	}

	function getLocation ( range, index ) {
		return { line: range.line, column: index - range.start };
	}

	return function locate ( index ) {
		var range = lineRanges[i];

		var d = index >= range.end ? 1 : -1;

		while ( range ) {
			if ( rangeContains( range, index ) ) { return getLocation( range, index ); }

			i += d;
			range = lineRanges[i];
		}
	};
}

function Mappings ( hires ) {
	var this$1 = this;

	var offsets = {
		generatedCodeColumn: 0,
		sourceIndex: 0,
		sourceCodeLine: 0,
		sourceCodeColumn: 0,
		sourceCodeName: 0
	};

	var generatedCodeLine = 0;
	var generatedCodeColumn = 0;

	this.raw = [];
	var rawSegments = this.raw[ generatedCodeLine ] = [];

	var pending = null;

	this.addEdit = function ( sourceIndex, content, original, loc, nameIndex ) {
		if ( content.length ) {
			rawSegments.push([
				generatedCodeColumn,
				sourceIndex,
				loc.line,
				loc.column,
				nameIndex ]);
		} else if ( pending ) {
			rawSegments.push( pending );
		}

		this$1.advance( content );
		pending = null;
	};

	this.addUneditedChunk = function ( sourceIndex, chunk, original, loc, sourcemapLocations ) {
		var originalCharIndex = chunk.start;
		var first = true;

		while ( originalCharIndex < chunk.end ) {
			if ( hires || first || sourcemapLocations[ originalCharIndex ] ) {
				rawSegments.push([
					generatedCodeColumn,
					sourceIndex,
					loc.line,
					loc.column,
					-1
				]);
			}

			if ( original[ originalCharIndex ] === '\n' ) {
				loc.line += 1;
				loc.column = 0;
				generatedCodeLine += 1;
				this$1.raw[ generatedCodeLine ] = rawSegments = [];
				generatedCodeColumn = 0;
			} else {
				loc.column += 1;
				generatedCodeColumn += 1;
			}

			originalCharIndex += 1;
			first = false;
		}

		pending = [
			generatedCodeColumn,
			sourceIndex,
			loc.line,
			loc.column,
			-1 ];
	};

	this.advance = function (str) {
		if ( !str ) { return; }

		var lines = str.split( '\n' );
		var lastLine = lines.pop();

		if ( lines.length ) {
			generatedCodeLine += lines.length;
			this$1.raw[ generatedCodeLine ] = rawSegments = [];
			generatedCodeColumn = lastLine.length;
		} else {
			generatedCodeColumn += lastLine.length;
		}
	};

	this.encode = function () {
		return this$1.raw.map( function (segments) {
			var generatedCodeColumn = 0;

			return segments.map( function (segment) {
				var arr = [
					segment[0] - generatedCodeColumn,
					segment[1] - offsets.sourceIndex,
					segment[2] - offsets.sourceCodeLine,
					segment[3] - offsets.sourceCodeColumn
				];

				generatedCodeColumn = segment[0];
				offsets.sourceIndex = segment[1];
				offsets.sourceCodeLine = segment[2];
				offsets.sourceCodeColumn = segment[3];

				if ( ~segment[4] ) {
					arr.push( segment[4] - offsets.sourceCodeName );
					offsets.sourceCodeName = segment[4];
				}

				return vlq.encode( arr );
			}).join( ',' );
		}).join( ';' );
	};
}

var Stats = function Stats () {
	Object.defineProperties( this, {
		startTimes: { value: {} }
	});
};

Stats.prototype.time = function time ( label ) {
	this.startTimes[ label ] = process.hrtime();
};

Stats.prototype.timeEnd = function timeEnd ( label ) {
	var elapsed = process.hrtime( this.startTimes[ label ] );

	if ( !this[ label ] ) { this[ label ] = 0; }
	this[ label ] += elapsed[0] * 1e3 + elapsed[1] * 1e-6;
};

var warned = {
	insertLeft: false,
	insertRight: false
};

function MagicString$1 ( string, options ) {
	if ( options === void 0 ) options = {};

	var chunk = new Chunk( 0, string.length, string );

	Object.defineProperties( this, {
		original:              { writable: true, value: string },
		outro:                 { writable: true, value: '' },
		intro:                 { writable: true, value: '' },
		firstChunk:            { writable: true, value: chunk },
		lastChunk:             { writable: true, value: chunk },
		lastSearchedChunk:     { writable: true, value: chunk },
		byStart:               { writable: true, value: {} },
		byEnd:                 { writable: true, value: {} },
		filename:              { writable: true, value: options.filename },
		indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
		sourcemapLocations:    { writable: true, value: {} },
		storedNames:           { writable: true, value: {} },
		indentStr:             { writable: true, value: guessIndent( string ) }
	});

	this.byStart[ 0 ] = chunk;
	this.byEnd[ string.length ] = chunk;
}

MagicString$1.prototype = {
	addSourcemapLocation: function addSourcemapLocation ( char ) {
		this.sourcemapLocations[ char ] = true;
	},

	append: function append ( content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'outro content must be a string' ); }

		this.outro += content;
		return this;
	},

	appendLeft: function appendLeft ( index, content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }

		this._split( index );

		var chunk = this.byEnd[ index ];

		if ( chunk ) {
			chunk.appendLeft( content );
		} else {
			this.intro += content;
		}

		return this;
	},

	appendRight: function appendRight ( index, content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }

		this._split( index );

		var chunk = this.byStart[ index ];

		if ( chunk ) {
			chunk.appendRight( content );
		} else {
			this.outro += content;
		}

		return this;
	},

	clone: function clone () {
		var cloned = new MagicString$1( this.original, { filename: this.filename });

		var originalChunk = this.firstChunk;
		var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();

		while ( originalChunk ) {
			cloned.byStart[ clonedChunk.start ] = clonedChunk;
			cloned.byEnd[ clonedChunk.end ] = clonedChunk;

			var nextOriginalChunk = originalChunk.next;
			var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();

			if ( nextClonedChunk ) {
				clonedChunk.next = nextClonedChunk;
				nextClonedChunk.previous = clonedChunk;

				clonedChunk = nextClonedChunk;
			}

			originalChunk = nextOriginalChunk;
		}

		cloned.lastChunk = clonedChunk;

		if ( this.indentExclusionRanges ) {
			cloned.indentExclusionRanges = typeof this.indentExclusionRanges[0] === 'number' ?
				[ this.indentExclusionRanges[0], this.indentExclusionRanges[1] ] :
				this.indentExclusionRanges.map( function (range) { return [ range.start, range.end ]; } );
		}

		Object.keys( this.sourcemapLocations ).forEach( function (loc) {
			cloned.sourcemapLocations[ loc ] = true;
		});

		return cloned;
	},

	generateMap: function generateMap ( options ) {
		var this$1 = this;

		options = options || {};

		var sourceIndex = 0;
		var names = Object.keys( this.storedNames );
		var mappings = new Mappings( options.hires );

		var locate = getLocator( this.original );

		if ( this.intro ) {
			mappings.advance( this.intro );
		}

		this.firstChunk.eachNext( function (chunk) {
			var loc = locate( chunk.start );

			if ( chunk.intro.length ) { mappings.advance( chunk.intro ); }

			if ( chunk.edited ) {
				mappings.addEdit( sourceIndex, chunk.content, chunk.original, loc, chunk.storeName ? names.indexOf( chunk.original ) : -1 );
			} else {
				mappings.addUneditedChunk( sourceIndex, chunk, this$1.original, loc, this$1.sourcemapLocations );
			}

			if ( chunk.outro.length ) { mappings.advance( chunk.outro ); }
		});

		var map = new SourceMap({
			file: ( options.file ? options.file.split( /[\/\\]/ ).pop() : null ),
			sources: [ options.source ? getRelativePath( options.file || '', options.source ) : null ],
			sourcesContent: options.includeContent ? [ this.original ] : [ null ],
			names: names,
			mappings: mappings.encode()
		});
		return map;
	},

	getIndentString: function getIndentString () {
		return this.indentStr === null ? '\t' : this.indentStr;
	},

	indent: function indent ( indentStr, options ) {
		var this$1 = this;

		var pattern = /^[^\r\n]/gm;

		if ( isObject( indentStr ) ) {
			options = indentStr;
			indentStr = undefined;
		}

		indentStr = indentStr !== undefined ? indentStr : ( this.indentStr || '\t' );

		if ( indentStr === '' ) { return this; } // noop

		options = options || {};

		// Process exclusion ranges
		var isExcluded = {};

		if ( options.exclude ) {
			var exclusions = typeof options.exclude[0] === 'number' ? [ options.exclude ] : options.exclude;
			exclusions.forEach( function (exclusion) {
				for ( var i = exclusion[0]; i < exclusion[1]; i += 1 ) {
					isExcluded[i] = true;
				}
			});
		}

		var shouldIndentNextCharacter = options.indentStart !== false;
		var replacer = function (match) {
			if ( shouldIndentNextCharacter ) { return ("" + indentStr + match); }
			shouldIndentNextCharacter = true;
			return match;
		};

		this.intro = this.intro.replace( pattern, replacer );

		var charIndex = 0;

		var chunk = this.firstChunk;

		while ( chunk ) {
			var end = chunk.end;

			if ( chunk.edited ) {
				if ( !isExcluded[ charIndex ] ) {
					chunk.content = chunk.content.replace( pattern, replacer );

					if ( chunk.content.length ) {
						shouldIndentNextCharacter = chunk.content[ chunk.content.length - 1 ] === '\n';
					}
				}
			} else {
				charIndex = chunk.start;

				while ( charIndex < end ) {
					if ( !isExcluded[ charIndex ] ) {
						var char = this$1.original[ charIndex ];

						if ( char === '\n' ) {
							shouldIndentNextCharacter = true;
						} else if ( char !== '\r' && shouldIndentNextCharacter ) {
							shouldIndentNextCharacter = false;

							if ( charIndex === chunk.start ) {
								chunk.prependRight( indentStr );
							} else {
								var rhs = chunk.split( charIndex );
								rhs.prependRight( indentStr );

								this$1.byStart[ charIndex ] = rhs;
								this$1.byEnd[ charIndex ] = chunk;

								chunk = rhs;
							}
						}
					}

					charIndex += 1;
				}
			}

			charIndex = chunk.end;
			chunk = chunk.next;
		}

		this.outro = this.outro.replace( pattern, replacer );

		return this;
	},

	insert: function insert () {
		throw new Error( 'magicString.insert(...) is deprecated. Use insertRight(...) or insertLeft(...)' );
	},

	insertLeft: function insertLeft ( index, content ) {
		if ( !warned.insertLeft ) {
			console.warn( 'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead' ); // eslint-disable-line no-console
			warned.insertLeft = true;
		}

		return this.appendLeft( index, content );
	},

	insertRight: function insertRight ( index, content ) {
		if ( !warned.insertRight ) {
			console.warn( 'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead' ); // eslint-disable-line no-console
			warned.insertRight = true;
		}

		return this.prependRight( index, content );
	},

	move: function move ( start, end, index ) {
		if ( index >= start && index <= end ) { throw new Error( 'Cannot move a selection inside itself' ); }

		this._split( start );
		this._split( end );
		this._split( index );

		var first = this.byStart[ start ];
		var last = this.byEnd[ end ];

		var oldLeft = first.previous;
		var oldRight = last.next;

		var newRight = this.byStart[ index ];
		if ( !newRight && last === this.lastChunk ) { return this; }
		var newLeft = newRight ? newRight.previous : this.lastChunk;

		if ( oldLeft ) { oldLeft.next = oldRight; }
		if ( oldRight ) { oldRight.previous = oldLeft; }

		if ( newLeft ) { newLeft.next = first; }
		if ( newRight ) { newRight.previous = last; }

		if ( !first.previous ) { this.firstChunk = last.next; }
		if ( !last.next ) {
			this.lastChunk = first.previous;
			this.lastChunk.next = null;
		}

		first.previous = newLeft;
		last.next = newRight;

		if ( !newLeft ) { this.firstChunk = first; }
		if ( !newRight ) { this.lastChunk = last; }

		return this;
	},

	overwrite: function overwrite ( start, end, content, storeName ) {
		var this$1 = this;

		if ( typeof content !== 'string' ) { throw new TypeError( 'replacement content must be a string' ); }

		while ( start < 0 ) { start += this$1.original.length; }
		while ( end < 0 ) { end += this$1.original.length; }

		if ( end > this.original.length ) { throw new Error( 'end is out of bounds' ); }
		if ( start === end ) { throw new Error( 'Cannot overwrite a zero-length range – use insertLeft or insertRight instead' ); }

		this._split( start );
		this._split( end );

		if ( storeName ) {
			var original = this.original.slice( start, end );
			this.storedNames[ original ] = true;
		}

		var first = this.byStart[ start ];
		var last = this.byEnd[ end ];

		if ( first ) {
			first.edit( content, storeName );

			if ( last ) {
				first.next = last.next;
			} else {
				first.next = null;
				this.lastChunk = first;
			}

			first.original = this.original.slice( start, end );
			first.end = end;
		}

		else {
			// must be inserting at the end
			var newChunk = new Chunk( start, end, '' ).edit( content, storeName );

			// TODO last chunk in the array may not be the last chunk, if it's moved...
			last.next = newChunk;
			newChunk.previous = last;
		}

		return this;
	},

	prepend: function prepend ( content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'outro content must be a string' ); }

		this.intro = content + this.intro;
		return this;
	},

	prependLeft: function prependLeft ( index, content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }

		this._split( index );

		var chunk = this.byEnd[ index ];

		if ( chunk ) {
			chunk.prependLeft( content );
		} else {
			this.intro = content + this.intro;
		}

		return this;
	},

	prependRight: function prependRight ( index, content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }

		this._split( index );

		var chunk = this.byStart[ index ];

		if ( chunk ) {
			chunk.prependRight( content );
		} else {
			this.outro = content + this.outro;
		}

		return this;
	},

	remove: function remove ( start, end ) {
		var this$1 = this;

		while ( start < 0 ) { start += this$1.original.length; }
		while ( end < 0 ) { end += this$1.original.length; }

		if ( start === end ) { return this; }

		if ( start < 0 || end > this.original.length ) { throw new Error( 'Character is out of bounds' ); }
		if ( start > end ) { throw new Error( 'end must be greater than start' ); }

		return this.overwrite( start, end, '', false );
	},

	slice: function slice ( start, end ) {
		var this$1 = this;
		if ( start === void 0 ) start = 0;
		if ( end === void 0 ) end = this.original.length;

		while ( start < 0 ) { start += this$1.original.length; }
		while ( end < 0 ) { end += this$1.original.length; }

		var result = '';

		// find start chunk
		var chunk = this.firstChunk;
		while ( chunk && ( chunk.start > start || chunk.end <= start ) ) {

			// found end chunk before start
			if ( chunk.start < end && chunk.end >= end ) {
				return result;
			}

			chunk = chunk.next;
		}

		if ( chunk && chunk.edited && chunk.start !== start ) { throw new Error(("Cannot use replaced character " + start + " as slice start anchor.")); }

		var startChunk = chunk;
		while ( chunk ) {
			if ( chunk.intro && ( startChunk !== chunk || chunk.start === start ) ) {
				result += chunk.intro;
			}

			var containsEnd = chunk.start < end && chunk.end >= end;
			if ( containsEnd && chunk.edited && chunk.end !== end ) { throw new Error(("Cannot use replaced character " + end + " as slice end anchor.")); }

			var sliceStart = startChunk === chunk ? start - chunk.start : 0;
			var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;

			result += chunk.content.slice( sliceStart, sliceEnd );

			if ( chunk.outro && ( !containsEnd || chunk.end === end ) ) {
				result += chunk.outro;
			}

			if ( containsEnd ) {
				break;
			}

			chunk = chunk.next;
		}

		return result;
	},

	// TODO deprecate this? not really very useful
	snip: function snip ( start, end ) {
		var clone = this.clone();
		clone.remove( 0, start );
		clone.remove( end, clone.original.length );

		return clone;
	},

	_split: function _split ( index ) {
		var this$1 = this;

		if ( this.byStart[ index ] || this.byEnd[ index ] ) { return; }

		var chunk = this.lastSearchedChunk;
		var searchForward = index > chunk.end;

		while ( true ) {
			if ( chunk.contains( index ) ) { return this$1._splitChunk( chunk, index ); }

			chunk = searchForward ?
				this$1.byStart[ chunk.end ] :
				this$1.byEnd[ chunk.start ];
		}
	},

	_splitChunk: function _splitChunk ( chunk, index ) {
		if ( chunk.edited && chunk.content.length ) { // zero-length edited chunks are a special case (overlapping replacements)
			var loc = getLocator( this.original )( index );
			throw new Error( ("Cannot split a chunk that has already been edited (" + (loc.line) + ":" + (loc.column) + " – \"" + (chunk.original) + "\")") );
		}

		var newChunk = chunk.split( index );

		this.byEnd[ index ] = chunk;
		this.byStart[ index ] = newChunk;
		this.byEnd[ newChunk.end ] = newChunk;

		if ( chunk === this.lastChunk ) { this.lastChunk = newChunk; }

		this.lastSearchedChunk = chunk;
		return true;
	},

	toString: function toString () {
		var str = this.intro;

		var chunk = this.firstChunk;
		while ( chunk ) {
			str += chunk.toString();
			chunk = chunk.next;
		}

		return str + this.outro;
	},

	trimLines: function trimLines () {
		return this.trim('[\\r\\n]');
	},

	trim: function trim ( charType ) {
		return this.trimStart( charType ).trimEnd( charType );
	},

	trimEnd: function trimEnd ( charType ) {
		var this$1 = this;

		var rx = new RegExp( ( charType || '\\s' ) + '+$' );

		this.outro = this.outro.replace( rx, '' );
		if ( this.outro.length ) { return this; }

		var chunk = this.lastChunk;

		do {
			var end = chunk.end;
			var aborted = chunk.trimEnd( rx );

			// if chunk was trimmed, we have a new lastChunk
			if ( chunk.end !== end ) {
				this$1.lastChunk = chunk.next;

				this$1.byEnd[ chunk.end ] = chunk;
				this$1.byStart[ chunk.next.start ] = chunk.next;
			}

			if ( aborted ) { return this$1; }
			chunk = chunk.previous;
		} while ( chunk );

		return this;
	},

	trimStart: function trimStart ( charType ) {
		var this$1 = this;

		var rx = new RegExp( '^' + ( charType || '\\s' ) + '+' );

		this.intro = this.intro.replace( rx, '' );
		if ( this.intro.length ) { return this; }

		var chunk = this.firstChunk;

		do {
			var end = chunk.end;
			var aborted = chunk.trimStart( rx );

			if ( chunk.end !== end ) {
				// special case...
				if ( chunk === this$1.lastChunk ) { this$1.lastChunk = chunk.next; }

				this$1.byEnd[ chunk.end ] = chunk;
				this$1.byStart[ chunk.next.start ] = chunk.next;
			}

			if ( aborted ) { return this$1; }
			chunk = chunk.next;
		} while ( chunk );

		return this;
	}
};

var hasOwnProp = Object.prototype.hasOwnProperty;

function Bundle ( options ) {
	if ( options === void 0 ) options = {};

	this.intro = options.intro || '';
	this.separator = options.separator !== undefined ? options.separator : '\n';

	this.sources = [];

	this.uniqueSources = [];
	this.uniqueSourceIndexByFilename = {};
}

Bundle.prototype = {
	addSource: function addSource ( source ) {
		if ( source instanceof MagicString$1 ) {
			return this.addSource({
				content: source,
				filename: source.filename,
				separator: this.separator
			});
		}

		if ( !isObject( source ) || !source.content ) {
			throw new Error( 'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`' );
		}

		[ 'filename', 'indentExclusionRanges', 'separator' ].forEach( function (option) {
			if ( !hasOwnProp.call( source, option ) ) { source[ option ] = source.content[ option ]; }
		});

		if ( source.separator === undefined ) { // TODO there's a bunch of this sort of thing, needs cleaning up
			source.separator = this.separator;
		}

		if ( source.filename ) {
			if ( !hasOwnProp.call( this.uniqueSourceIndexByFilename, source.filename ) ) {
				this.uniqueSourceIndexByFilename[ source.filename ] = this.uniqueSources.length;
				this.uniqueSources.push({ filename: source.filename, content: source.content.original });
			} else {
				var uniqueSource = this.uniqueSources[ this.uniqueSourceIndexByFilename[ source.filename ] ];
				if ( source.content.original !== uniqueSource.content ) {
					throw new Error( ("Illegal source: same filename (" + (source.filename) + "), different contents") );
				}
			}
		}

		this.sources.push( source );
		return this;
	},

	append: function append ( str, options ) {
		this.addSource({
			content: new MagicString$1( str ),
			separator: ( options && options.separator ) || ''
		});

		return this;
	},

	clone: function clone () {
		var bundle = new Bundle({
			intro: this.intro,
			separator: this.separator
		});

		this.sources.forEach( function (source) {
			bundle.addSource({
				filename: source.filename,
				content: source.content.clone(),
				separator: source.separator
			});
		});

		return bundle;
	},

	generateMap: function generateMap ( options ) {
		var this$1 = this;
		if ( options === void 0 ) options = {};

		var names = [];
		this.sources.forEach( function (source) {
			Object.keys( source.content.storedNames ).forEach( function (name) {
				if ( !~names.indexOf( name ) ) { names.push( name ); }
			});
		});

		var mappings = new Mappings( options.hires );

		if ( this.intro ) {
			mappings.advance( this.intro );
		}

		this.sources.forEach( function ( source, i ) {
			if ( i > 0 ) {
				mappings.advance( this$1.separator );
			}

			var sourceIndex = source.filename ? this$1.uniqueSourceIndexByFilename[ source.filename ] : -1;
			var magicString = source.content;
			var locate = getLocator( magicString.original );

			if ( magicString.intro ) {
				mappings.advance( magicString.intro );
			}

			magicString.firstChunk.eachNext( function (chunk) {
				var loc = locate( chunk.start );

				if ( chunk.intro.length ) { mappings.advance( chunk.intro ); }

				if ( source.filename ) {
					if ( chunk.edited ) {
						mappings.addEdit( sourceIndex, chunk.content, chunk.original, loc, chunk.storeName ? names.indexOf( chunk.original ) : -1 );
					} else {
						mappings.addUneditedChunk( sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations );
					}
				}

				else {
					mappings.advance( chunk.content );
				}

				if ( chunk.outro.length ) { mappings.advance( chunk.outro ); }
			});

			if ( magicString.outro ) {
				mappings.advance( magicString.outro );
			}
		});

		return new SourceMap({
			file: ( options.file ? options.file.split( /[\/\\]/ ).pop() : null ),
			sources: this.uniqueSources.map( function (source) {
				return options.file ? getRelativePath( options.file, source.filename ) : source.filename;
			}),
			sourcesContent: this.uniqueSources.map( function (source) {
				return options.includeContent ? source.content : null;
			}),
			names: names,
			mappings: mappings.encode()
		});
	},

	getIndentString: function getIndentString () {
		var indentStringCounts = {};

		this.sources.forEach( function (source) {
			var indentStr = source.content.indentStr;

			if ( indentStr === null ) { return; }

			if ( !indentStringCounts[ indentStr ] ) { indentStringCounts[ indentStr ] = 0; }
			indentStringCounts[ indentStr ] += 1;
		});

		return ( Object.keys( indentStringCounts ).sort( function ( a, b ) {
			return indentStringCounts[a] - indentStringCounts[b];
		})[0] ) || '\t';
	},

	indent: function indent ( indentStr ) {
		var this$1 = this;

		if ( !arguments.length ) {
			indentStr = this.getIndentString();
		}

		if ( indentStr === '' ) { return this; } // noop

		var trailingNewline = !this.intro || this.intro.slice( -1 ) === '\n';

		this.sources.forEach( function ( source, i ) {
			var separator = source.separator !== undefined ? source.separator : this$1.separator;
			var indentStart = trailingNewline || ( i > 0 && /\r?\n$/.test( separator ) );

			source.content.indent( indentStr, {
				exclude: source.indentExclusionRanges,
				indentStart: indentStart//: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )
			});

			// TODO this is a very slow way to determine this
			trailingNewline = source.content.toString().slice( 0, -1 ) === '\n';
		});

		if ( this.intro ) {
			this.intro = indentStr + this.intro.replace( /^[^\n]/gm, function ( match, index ) {
				return index > 0 ? indentStr + match : match;
			});
		}

		return this;
	},

	prepend: function prepend ( str ) {
		this.intro = str + this.intro;
		return this;
	},

	toString: function toString () {
		var this$1 = this;

		var body = this.sources.map( function ( source, i ) {
			var separator = source.separator !== undefined ? source.separator : this$1.separator;
			var str = ( i > 0 ? separator : '' ) + source.content.toString();

			return str;
		}).join( '' );

		return this.intro + body;
	},

	trimLines: function trimLines () {
		return this.trim('[\\r\\n]');
	},

	trim: function trim ( charType ) {
		return this.trimStart( charType ).trimEnd( charType );
	},

	trimStart: function trimStart ( charType ) {
		var this$1 = this;

		var rx = new RegExp( '^' + ( charType || '\\s' ) + '+' );
		this.intro = this.intro.replace( rx, '' );

		if ( !this.intro ) {
			var source;
			var i = 0;

			do {
				source = this$1.sources[i];

				if ( !source ) {
					break;
				}

				source.content.trimStart( charType );
				i += 1;
			} while ( source.content.toString() === '' ); // TODO faster way to determine non-empty source?
		}

		return this;
	},

	trimEnd: function trimEnd ( charType ) {
		var this$1 = this;

		var rx = new RegExp( ( charType || '\\s' ) + '+$' );

		var source;
		var i = this.sources.length - 1;

		do {
			source = this$1.sources[i];

			if ( !source ) {
				this$1.intro = this$1.intro.replace( rx, '' );
				break;
			}

			source.content.trimEnd( charType );
			i -= 1;
		} while ( source.content.toString() === '' ); // TODO faster way to determine non-empty source?

		return this;
	}
};

MagicString$1.Bundle = Bundle;

module.exports = MagicString$1;


}).call(this,require('_process'),require("buffer").Buffer)
},{"_process":367,"buffer":65,"vlq":376}],3:[function(require,module,exports){
'use strict';
module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};

},{}],4:[function(require,module,exports){
'use strict';

function assembleStyles () {
	var styles = {
		modifiers: {
			reset: [0, 0],
			bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		colors: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			gray: [90, 39]
		},
		bgColors: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49]
		}
	};

	// fix humans
	styles.colors.grey = styles.colors.gray;

	Object.keys(styles).forEach(function (groupName) {
		var group = styles[groupName];

		Object.keys(group).forEach(function (styleName) {
			var style = group[styleName];

			styles[styleName] = group[styleName] = {
				open: '\u001b[' + style[0] + 'm',
				close: '\u001b[' + style[1] + 'm'
			};
		});

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	});

	return styles;
}

Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});

},{}],5:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('babel-traverse')) :
  typeof define === 'function' && define.amd ? define(['babel-traverse'], factory) :
  (global.ASI = factory(global._traverse));
}(this, function (_traverse) { 'use strict';

  _traverse = 'default' in _traverse ? _traverse['default'] : _traverse;

  function build(source, ast) {
    var insertions = [];
    var removals = [];
    var tokens = ast.tokens;

    return {
      ast: ast,
      insertions: insertions,
      removals: removals,

      traverse: function traverse(node, iterator) {
        _traverse(node, {
          enter: function enter(path) {
            iterator(path.node, path.parent);
          }
        });
      },
      firstTokenOfNode: function firstTokenOfNode(node) {
        for (var i = 0; i < tokens.length; i++) {
          var _token = tokens[i];
          if (_token.start === node.start) {
            return _token;
          }
        }
        throw new Error('cannot find first token for node ' + node.type + ' at ' + (node.loc.start.line + ':' + (node.loc.start.column + 1)));
      },
      lastTokenOfNode: function lastTokenOfNode(node) {
        for (var i = 0; i < tokens.length; i++) {
          var _token2 = tokens[i];
          if (_token2.end === node.end) {
            return _token2;
          }
        }
        throw new Error('cannot find last token for node ' + node.type + ' at ' + (node.loc.start.line + ':' + (node.loc.start.column + 1)));
      },
      tokenAfterToken: function tokenAfterToken(token) {
        var index = tokens.indexOf(token);
        if (index < 0) {
          throw new Error('cannot find token in tokens: ' + JSON.stringify(token));
        }
        return tokens[index + 1];
      },
      sourceOfToken: function sourceOfToken(token) {
        return source.slice(token.start, token.end);
      },
      insert: function insert(index, content) {
        insertions.push({ index: index, content: content });
      },
      remove: function remove(start, end) {
        removals.push({ start: start, end: end });
      },
      startOfNode: function startOfNode(node) {
        return node.start;
      },
      endOfNode: function endOfNode(node) {
        return node.end;
      },
      startOfToken: function startOfToken(token) {
        return token.start;
      },
      endOfToken: function endOfToken(token) {
        return token.end;
      }
    };
  }

  return build;

}));
},{"babel-traverse":25}],6:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.ASI = factory());
}(this, function () { 'use strict';

  function process(config) {
    var ast = config.ast;
    var traverse = config.traverse;
    var firstTokenOfNode = config.firstTokenOfNode;
    var lastTokenOfNode = config.lastTokenOfNode;
    var tokenAfterToken = config.tokenAfterToken;
    var sourceOfToken = config.sourceOfToken;
    var insert = config.insert;
    var remove = config.remove;
    var startOfToken = config.startOfToken;
    var endOfToken = config.endOfToken;
    var startOfNode = config.startOfNode;
    var endOfNode = config.endOfNode;


    traverse(ast, function (node, parent) {
      switch (node.type) {
        case 'VariableDeclaration':
          var isForInit = parent && parent.type === 'ForStatement' && parent.init === node || /^For(?:In|Of)Statement/.test(parent.type) && parent.left === node;

          if (!isForInit) {
            checkForSemicolon(node);
          }
          break;

        case 'ExpressionStatement':
        case 'ReturnStatement':
        case 'ThrowStatement':
        case 'DoWhileStatement':
        case 'DebuggerStatement':
        case 'BreakStatement':
        case 'ContinueStatement':
        case 'ImportDeclaration':
        case 'ExportAllDeclaration':
          checkForSemicolon(node);
          break;

        case 'ExportNamedDeclaration':
          if (!node.declaration) {
            checkForSemicolon(node);
          }
          break;

        case 'ExportDefaultDeclaration':
          if (/(?:Class|Function)Declaration/.test(node.declaration.type)) {
            if (!node.declaration.id) {
              checkForSemicolon(node);
            }
          } else {
            checkForSemicolon(node);
          }
          break;

        case 'EmptyStatement':
          switch (parent.type) {
            case 'ForStatement':
            case 'ForOfStatement':
            case 'ForInStatement':
            case 'WhileStatement':
            case 'DoWhileStatement':
              // These are allowed to have empty statement bodies, for example.
              break;

            default:
              remove(startOfNode(node), endOfNode(node));
              break;
          }
          break;

        case 'ClassBody':
          checkClassBodyForSemicolon(tokenAfterToken(firstTokenOfNode(node)));
          break;

        case 'ClassMethod':
        case 'MethodDefinition':
          checkClassBodyForSemicolon(tokenAfterToken(lastTokenOfNode(node)));
          break;
      }
    });

    /**
     * Checks a node to see if it's followed by a semicolon.
     */
    function checkForSemicolon(node) {
      var lastToken = lastTokenOfNode(node);

      if (sourceOfToken(lastToken) !== ';') {
        insert(endOfToken(lastToken), ';');
      }
    }

    /**
     * Class bodies don't need semicolons.
     */
    function checkClassBodyForSemicolon(token) {
      while (token) {
        var source = sourceOfToken(token);

        if (source === ';') {
          remove(startOfToken(token), endOfToken(token));
        } else {
          break;
        }

        token = tokenAfterToken(token);
      }
    }
  }

  return process;

}));
},{}],7:[function(require,module,exports){
"use strict";

exports.__esModule = true;

exports.default = function (rawLines, lineNumber, colNumber) {
  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  colNumber = Math.max(colNumber, 0);

  var highlighted = opts.highlightCode && _chalk2.default.supportsColor || opts.forceColor;
  var chalk = _chalk2.default;
  if (opts.forceColor) {
    chalk = new _chalk2.default.constructor({ enabled: true });
  }
  var maybeHighlight = function maybeHighlight(chalkFn, string) {
    return highlighted ? chalkFn(string) : string;
  };
  var defs = getDefs(chalk);
  if (highlighted) rawLines = highlight(defs, rawLines);

  var linesAbove = opts.linesAbove || 2;
  var linesBelow = opts.linesBelow || 3;

  var lines = rawLines.split(NEWLINE);
  var start = Math.max(lineNumber - (linesAbove + 1), 0);
  var end = Math.min(lines.length, lineNumber + linesBelow);

  if (!lineNumber && !colNumber) {
    start = 0;
    end = lines.length;
  }

  var numberMaxWidth = String(end).length;

  var frame = lines.slice(start, end).map(function (line, index) {
    var number = start + 1 + index;
    var paddedNumber = (" " + number).slice(-numberMaxWidth);
    var gutter = " " + paddedNumber + " | ";
    if (number === lineNumber) {
      var markerLine = "";
      if (colNumber) {
        var markerSpacing = line.slice(0, colNumber - 1).replace(/[^\t]/g, " ");
        markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), markerSpacing, maybeHighlight(defs.marker, "^")].join("");
      }
      return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line, markerLine].join("");
    } else {
      return " " + maybeHighlight(defs.gutter, gutter) + line;
    }
  }).join("\n");

  if (highlighted) {
    return chalk.reset(frame);
  } else {
    return frame;
  }
};

var _jsTokens = require("js-tokens");

var _jsTokens2 = _interopRequireDefault(_jsTokens);

var _esutils = require("esutils");

var _esutils2 = _interopRequireDefault(_esutils);

var _chalk = require("chalk");

var _chalk2 = _interopRequireDefault(_chalk);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getDefs(chalk) {
  return {
    keyword: chalk.cyan,
    capitalized: chalk.yellow,
    jsx_tag: chalk.yellow,
    punctuator: chalk.yellow,

    number: chalk.magenta,
    string: chalk.green,
    regex: chalk.magenta,
    comment: chalk.grey,
    invalid: chalk.white.bgRed.bold,
    gutter: chalk.grey,
    marker: chalk.red.bold
  };
}

var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;

var JSX_TAG = /^[a-z][\w-]*$/i;

var BRACKET = /^[()\[\]{}]$/;

function getTokenType(match) {
  var _match$slice = match.slice(-2),
      offset = _match$slice[0],
      text = _match$slice[1];

  var token = (0, _jsTokens.matchToToken)(match);

  if (token.type === "name") {
    if (_esutils2.default.keyword.isReservedWordES6(token.value)) {
      return "keyword";
    }

    if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")) {
      return "jsx_tag";
    }

    if (token.value[0] !== token.value[0].toLowerCase()) {
      return "capitalized";
    }
  }

  if (token.type === "punctuator" && BRACKET.test(token.value)) {
    return "bracket";
  }

  return token.type;
}

function highlight(defs, text) {
  return text.replace(_jsTokens2.default, function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var type = getTokenType(args);
    var colorize = defs[type];
    if (colorize) {
      return args[0].split(NEWLINE).map(function (str) {
        return colorize(str);
      }).join("\n");
    } else {
      return args[0];
    }
  });
}

module.exports = exports["default"];
},{"chalk":66,"esutils":197,"js-tokens":205}],8:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.MESSAGES = undefined;

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

exports.get = get;
exports.parseArgs = parseArgs;

var _util = require("util");

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MESSAGES = exports.MESSAGES = {
  tailCallReassignmentDeopt: "Function reference has been reassigned, so it will probably be dereferenced, therefore we can't optimise this with confidence",
  classesIllegalBareSuper: "Illegal use of bare super",
  classesIllegalSuperCall: "Direct super call is illegal in non-constructor, use super.$1() instead",
  scopeDuplicateDeclaration: "Duplicate declaration $1",
  settersNoRest: "Setters aren't allowed to have a rest",
  noAssignmentsInForHead: "No assignments allowed in for-in/of head",
  expectedMemberExpressionOrIdentifier: "Expected type MemberExpression or Identifier",
  invalidParentForThisNode: "We don't know how to handle this node within the current parent - please open an issue",
  readOnly: "$1 is read-only",
  unknownForHead: "Unknown node type $1 in ForStatement",
  didYouMean: "Did you mean $1?",
  codeGeneratorDeopt: "Note: The code generator has deoptimised the styling of $1 as it exceeds the max of $2.",
  missingTemplatesDirectory: "no templates directory - this is most likely the result of a broken `npm publish`. Please report to https://github.com/babel/babel/issues",
  unsupportedOutputType: "Unsupported output type $1",
  illegalMethodName: "Illegal method name $1",
  lostTrackNodePath: "We lost track of this node's position, likely because the AST was directly manipulated",

  modulesIllegalExportName: "Illegal export $1",
  modulesDuplicateDeclarations: "Duplicate module declarations with the same source but in different scopes",

  undeclaredVariable: "Reference to undeclared variable $1",
  undeclaredVariableType: "Referencing a type alias outside of a type annotation",
  undeclaredVariableSuggestion: "Reference to undeclared variable $1 - did you mean $2?",

  traverseNeedsParent: "You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a $1 node without passing scope and parentPath.",
  traverseVerifyRootFunction: "You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?",
  traverseVerifyVisitorProperty: "You passed `traverse()` a visitor object with the property $1 that has the invalid property $2",
  traverseVerifyNodeType: "You gave us a visitor for the node type $1 but it's not a valid type",

  pluginNotObject: "Plugin $2 specified in $1 was expected to return an object when invoked but returned $3",
  pluginNotFunction: "Plugin $2 specified in $1 was expected to return a function but returned $3",
  pluginUnknown: "Unknown plugin $1 specified in $2 at $3, attempted to resolve relative to $4",
  pluginInvalidProperty: "Plugin $2 specified in $1 provided an invalid property of $3"
};

function get(key) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var msg = MESSAGES[key];
  if (!msg) throw new ReferenceError("Unknown message " + (0, _stringify2.default)(key));

  args = parseArgs(args);

  return msg.replace(/\$(\d+)/g, function (str, i) {
    return args[i - 1];
  });
}

function parseArgs(args) {
  return args.map(function (val) {
    if (val != null && val.inspect) {
      return val.inspect();
    } else {
      try {
        return (0, _stringify2.default)(val) || val + "";
      } catch (e) {
        return util.inspect(val);
      }
    }
  });
}
},{"babel-runtime/core-js/json/stringify":10,"util":375}],9:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/get-iterator"), __esModule: true };
},{"core-js/library/fn/get-iterator":78}],10:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/json/stringify"), __esModule: true };
},{"core-js/library/fn/json/stringify":79}],11:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/map"), __esModule: true };
},{"core-js/library/fn/map":80}],12:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/number/max-safe-integer"), __esModule: true };
},{"core-js/library/fn/number/max-safe-integer":81}],13:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
},{"core-js/library/fn/object/create":82}],14:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-own-property-symbols"), __esModule: true };
},{"core-js/library/fn/object/get-own-property-symbols":83}],15:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/keys"), __esModule: true };
},{"core-js/library/fn/object/keys":84}],16:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":86}],17:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol/for"), __esModule: true };
},{"core-js/library/fn/symbol/for":85}],18:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol/iterator"), __esModule: true };
},{"core-js/library/fn/symbol/iterator":87}],19:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/weak-map"), __esModule: true };
},{"core-js/library/fn/weak-map":88}],20:[function(require,module,exports){
"use strict";

exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
},{}],21:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _iterator = require("../core-js/symbol/iterator");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = require("../core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};
},{"../core-js/symbol":16,"../core-js/symbol/iterator":18}],22:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.scope = exports.path = undefined;

var _weakMap = require("babel-runtime/core-js/weak-map");

var _weakMap2 = _interopRequireDefault(_weakMap);

exports.clear = clear;
exports.clearPath = clearPath;
exports.clearScope = clearScope;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var path = exports.path = new _weakMap2.default();
var scope = exports.scope = new _weakMap2.default();

function clear() {
  clearPath();
  clearScope();
}

function clearPath() {
  exports.path = path = new _weakMap2.default();
}

function clearScope() {
  exports.scope = scope = new _weakMap2.default();
}
},{"babel-runtime/core-js/weak-map":19}],23:[function(require,module,exports){
(function (process){
"use strict";

exports.__esModule = true;

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _path2 = require("./path");

var _path3 = _interopRequireDefault(_path2);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var testing = process.env.NODE_ENV === "test";

var TraversalContext = function () {
  function TraversalContext(scope, opts, state, parentPath) {
    (0, _classCallCheck3.default)(this, TraversalContext);
    this.queue = null;

    this.parentPath = parentPath;
    this.scope = scope;
    this.state = state;
    this.opts = opts;
  }

  TraversalContext.prototype.shouldVisit = function shouldVisit(node) {
    var opts = this.opts;
    if (opts.enter || opts.exit) return true;

    if (opts[node.type]) return true;

    var keys = t.VISITOR_KEYS[node.type];
    if (!keys || !keys.length) return false;

    for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var key = _ref;

      if (node[key]) return true;
    }

    return false;
  };

  TraversalContext.prototype.create = function create(node, obj, key, listKey) {
    return _path3.default.get({
      parentPath: this.parentPath,
      parent: node,
      container: obj,
      key: key,
      listKey: listKey
    });
  };

  TraversalContext.prototype.maybeQueue = function maybeQueue(path, notPriority) {
    if (this.trap) {
      throw new Error("Infinite cycle detected");
    }

    if (this.queue) {
      if (notPriority) {
        this.queue.push(path);
      } else {
        this.priorityQueue.push(path);
      }
    }
  };

  TraversalContext.prototype.visitMultiple = function visitMultiple(container, parent, listKey) {
    if (container.length === 0) return false;

    var queue = [];

    for (var key = 0; key < container.length; key++) {
      var node = container[key];
      if (node && this.shouldVisit(node)) {
        queue.push(this.create(parent, container, key, listKey));
      }
    }

    return this.visitQueue(queue);
  };

  TraversalContext.prototype.visitSingle = function visitSingle(node, key) {
    if (this.shouldVisit(node[key])) {
      return this.visitQueue([this.create(node, node, key)]);
    } else {
      return false;
    }
  };

  TraversalContext.prototype.visitQueue = function visitQueue(queue) {
    this.queue = queue;
    this.priorityQueue = [];

    var visited = [];
    var stop = false;

    for (var _iterator2 = queue, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var path = _ref2;

      path.resync();

      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
        path.pushContext(this);
      }

      if (path.key === null) continue;

      if (testing && queue.length >= 10000) {
        this.trap = true;
      }

      if (visited.indexOf(path.node) >= 0) continue;
      visited.push(path.node);

      if (path.visit()) {
        stop = true;
        break;
      }

      if (this.priorityQueue.length) {
        stop = this.visitQueue(this.priorityQueue);
        this.priorityQueue = [];
        this.queue = queue;
        if (stop) break;
      }
    }

    for (var _iterator3 = queue, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var _path = _ref3;

      _path.popContext();
    }

    this.queue = null;

    return stop;
  };

  TraversalContext.prototype.visit = function visit(node, key) {
    var nodes = node[key];
    if (!nodes) return false;

    if (Array.isArray(nodes)) {
      return this.visitMultiple(nodes, node, key);
    } else {
      return this.visitSingle(node, key);
    }
  };

  return TraversalContext;
}();

exports.default = TraversalContext;
module.exports = exports["default"];
}).call(this,require('_process'))
},{"./path":32,"_process":367,"babel-runtime/core-js/get-iterator":9,"babel-runtime/helpers/classCallCheck":20,"babel-types":58}],24:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Hub = function Hub(file, options) {
  (0, _classCallCheck3.default)(this, Hub);

  this.file = file;
  this.options = options;
};

exports.default = Hub;
module.exports = exports["default"];
},{"babel-runtime/helpers/classCallCheck":20}],25:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.visitors = exports.Hub = exports.Scope = exports.NodePath = undefined;

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _path = require("./path");

Object.defineProperty(exports, "NodePath", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_path).default;
  }
});

var _scope = require("./scope");

Object.defineProperty(exports, "Scope", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_scope).default;
  }
});

var _hub = require("./hub");

Object.defineProperty(exports, "Hub", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_hub).default;
  }
});
exports.default = traverse;

var _context = require("./context");

var _context2 = _interopRequireDefault(_context);

var _visitors = require("./visitors");

var visitors = _interopRequireWildcard(_visitors);

var _babelMessages = require("babel-messages");

var messages = _interopRequireWildcard(_babelMessages);

var _includes = require("lodash/includes");

var _includes2 = _interopRequireDefault(_includes);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _cache = require("./cache");

var cache = _interopRequireWildcard(_cache);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.visitors = visitors;
function traverse(parent, opts, scope, state, parentPath) {
  if (!parent) return;
  if (!opts) opts = {};

  if (!opts.noScope && !scope) {
    if (parent.type !== "Program" && parent.type !== "File") {
      throw new Error(messages.get("traverseNeedsParent", parent.type));
    }
  }

  visitors.explode(opts);

  traverse.node(parent, opts, scope, state, parentPath);
}

traverse.visitors = visitors;
traverse.verify = visitors.verify;
traverse.explode = visitors.explode;

traverse.NodePath = require("./path");
traverse.Scope = require("./scope");
traverse.Hub = require("./hub");

traverse.cheap = function (node, enter) {
  return t.traverseFast(node, enter);
};

traverse.node = function (node, opts, scope, state, parentPath, skipKeys) {
  var keys = t.VISITOR_KEYS[node.type];
  if (!keys) return;

  var context = new _context2.default(scope, opts, state, parentPath);
  for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var key = _ref;

    if (skipKeys && skipKeys[key]) continue;
    if (context.visit(node, key)) return;
  }
};

traverse.clearNode = function (node, opts) {
  t.removeProperties(node, opts);

  cache.path.delete(node);
};

traverse.removeProperties = function (tree, opts) {
  t.traverseFast(tree, traverse.clearNode, opts);
  return tree;
};

function hasBlacklistedType(path, state) {
  if (path.node.type === state.type) {
    state.has = true;
    path.stop();
  }
}

traverse.hasType = function (tree, scope, type, blacklistTypes) {
  if ((0, _includes2.default)(blacklistTypes, tree.type)) return false;

  if (tree.type === type) return true;

  var state = {
    has: false,
    type: type
  };

  traverse(tree, {
    blacklist: blacklistTypes,
    enter: hasBlacklistedType
  }, scope, state);

  return state.has;
};

traverse.clearCache = function () {
  cache.clear();
};

traverse.clearCache.clearPath = cache.clearPath;
traverse.clearCache.clearScope = cache.clearScope;

traverse.copyCache = function (source, destination) {
  if (cache.path.has(source)) {
    cache.path.set(destination, cache.path.get(source));
  }
};
},{"./cache":22,"./context":23,"./hub":24,"./path":32,"./scope":44,"./visitors":46,"babel-messages":8,"babel-runtime/core-js/get-iterator":9,"babel-types":58,"lodash/includes":336}],26:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.findParent = findParent;
exports.find = find;
exports.getFunctionParent = getFunctionParent;
exports.getStatementParent = getStatementParent;
exports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
exports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
exports.getAncestry = getAncestry;
exports.isAncestor = isAncestor;
exports.isDescendant = isDescendant;
exports.inType = inType;
exports.inShadow = inShadow;

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _index = require("./index");

var _index2 = _interopRequireDefault(_index);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function findParent(callback) {
  var path = this;
  while (path = path.parentPath) {
    if (callback(path)) return path;
  }
  return null;
}

function find(callback) {
  var path = this;
  do {
    if (callback(path)) return path;
  } while (path = path.parentPath);
  return null;
}

function getFunctionParent() {
  return this.findParent(function (path) {
    return path.isFunction() || path.isProgram();
  });
}

function getStatementParent() {
  var path = this;
  do {
    if (Array.isArray(path.container)) {
      return path;
    }
  } while (path = path.parentPath);
}

function getEarliestCommonAncestorFrom(paths) {
  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {
    var earliest = void 0;
    var keys = t.VISITOR_KEYS[deepest.type];

    for (var _iterator = ancestries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var ancestry = _ref;

      var path = ancestry[i + 1];

      if (!earliest) {
        earliest = path;
        continue;
      }

      if (path.listKey && earliest.listKey === path.listKey) {
        if (path.key < earliest.key) {
          earliest = path;
          continue;
        }
      }

      var earliestKeyIndex = keys.indexOf(earliest.parentKey);
      var currentKeyIndex = keys.indexOf(path.parentKey);
      if (earliestKeyIndex > currentKeyIndex) {
        earliest = path;
      }
    }

    return earliest;
  });
}

function getDeepestCommonAncestorFrom(paths, filter) {
  var _this = this;

  if (!paths.length) {
    return this;
  }

  if (paths.length === 1) {
    return paths[0];
  }

  var minDepth = Infinity;

  var lastCommonIndex = void 0,
      lastCommon = void 0;

  var ancestries = paths.map(function (path) {
    var ancestry = [];

    do {
      ancestry.unshift(path);
    } while ((path = path.parentPath) && path !== _this);

    if (ancestry.length < minDepth) {
      minDepth = ancestry.length;
    }

    return ancestry;
  });

  var first = ancestries[0];

  depthLoop: for (var i = 0; i < minDepth; i++) {
    var shouldMatch = first[i];

    for (var _iterator2 = ancestries, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var ancestry = _ref2;

      if (ancestry[i] !== shouldMatch) {
        break depthLoop;
      }
    }

    lastCommonIndex = i;
    lastCommon = shouldMatch;
  }

  if (lastCommon) {
    if (filter) {
      return filter(lastCommon, lastCommonIndex, ancestries);
    } else {
      return lastCommon;
    }
  } else {
    throw new Error("Couldn't find intersection");
  }
}

function getAncestry() {
  var path = this;
  var paths = [];
  do {
    paths.push(path);
  } while (path = path.parentPath);
  return paths;
}

function isAncestor(maybeDescendant) {
  return maybeDescendant.isDescendant(this);
}

function isDescendant(maybeAncestor) {
  return !!this.findParent(function (parent) {
    return parent === maybeAncestor;
  });
}

function inType() {
  var path = this;
  while (path) {
    for (var _iterator3 = arguments, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var type = _ref3;

      if (path.node.type === type) return true;
    }
    path = path.parentPath;
  }

  return false;
}

function inShadow(key) {
  var parentFn = this.isFunction() ? this : this.findParent(function (p) {
    return p.isFunction();
  });
  if (!parentFn) return;

  if (parentFn.isFunctionExpression() || parentFn.isFunctionDeclaration()) {
    var shadow = parentFn.node.shadow;

    if (shadow && (!key || shadow[key] !== false)) {
      return parentFn;
    }
  } else if (parentFn.isArrowFunctionExpression()) {
    return parentFn;
  }

  return null;
}
},{"./index":32,"babel-runtime/core-js/get-iterator":9,"babel-types":58}],27:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.shareCommentsWithSiblings = shareCommentsWithSiblings;
exports.addComment = addComment;
exports.addComments = addComments;
function shareCommentsWithSiblings() {
  if (typeof this.key === "string") return;

  var node = this.node;
  if (!node) return;

  var trailing = node.trailingComments;
  var leading = node.leadingComments;
  if (!trailing && !leading) return;

  var prev = this.getSibling(this.key - 1);
  var next = this.getSibling(this.key + 1);

  if (!prev.node) prev = next;
  if (!next.node) next = prev;

  prev.addComments("trailing", leading);
  next.addComments("leading", trailing);
}

function addComment(type, content, line) {
  this.addComments(type, [{
    type: line ? "CommentLine" : "CommentBlock",
    value: content
  }]);
}

function addComments(type, comments) {
  if (!comments) return;

  var node = this.node;
  if (!node) return;

  var key = type + "Comments";

  if (node[key]) {
    node[key] = node[key].concat(comments);
  } else {
    node[key] = comments;
  }
}
},{}],28:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.call = call;
exports._call = _call;
exports.isBlacklisted = isBlacklisted;
exports.visit = visit;
exports.skip = skip;
exports.skipKey = skipKey;
exports.stop = stop;
exports.setScope = setScope;
exports.setContext = setContext;
exports.resync = resync;
exports._resyncParent = _resyncParent;
exports._resyncKey = _resyncKey;
exports._resyncList = _resyncList;
exports._resyncRemoved = _resyncRemoved;
exports.popContext = popContext;
exports.pushContext = pushContext;
exports.setup = setup;
exports.setKey = setKey;
exports.requeue = requeue;
exports._getQueueContexts = _getQueueContexts;

var _index = require("../index");

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function call(key) {
  var opts = this.opts;

  this.debug(function () {
    return key;
  });

  if (this.node) {
    if (this._call(opts[key])) return true;
  }

  if (this.node) {
    return this._call(opts[this.node.type] && opts[this.node.type][key]);
  }

  return false;
}

function _call(fns) {
  if (!fns) return false;

  for (var _iterator = fns, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var fn = _ref;

    if (!fn) continue;

    var node = this.node;
    if (!node) return true;

    var ret = fn.call(this.state, this, this.state);
    if (ret) throw new Error("Unexpected return value from visitor method " + fn);

    if (this.node !== node) return true;

    if (this.shouldStop || this.shouldSkip || this.removed) return true;
  }

  return false;
}

function isBlacklisted() {
  var blacklist = this.opts.blacklist;
  return blacklist && blacklist.indexOf(this.node.type) > -1;
}

function visit() {
  if (!this.node) {
    return false;
  }

  if (this.isBlacklisted()) {
    return false;
  }

  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {
    return false;
  }

  if (this.call("enter") || this.shouldSkip) {
    this.debug(function () {
      return "Skip...";
    });
    return this.shouldStop;
  }

  this.debug(function () {
    return "Recursing into...";
  });
  _index2.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);

  this.call("exit");

  return this.shouldStop;
}

function skip() {
  this.shouldSkip = true;
}

function skipKey(key) {
  this.skipKeys[key] = true;
}

function stop() {
  this.shouldStop = true;
  this.shouldSkip = true;
}

function setScope() {
  if (this.opts && this.opts.noScope) return;

  var target = this.context && this.context.scope;

  if (!target) {
    var path = this.parentPath;
    while (path && !target) {
      if (path.opts && path.opts.noScope) return;

      target = path.scope;
      path = path.parentPath;
    }
  }

  this.scope = this.getScope(target);
  if (this.scope) this.scope.init();
}

function setContext(context) {
  this.shouldSkip = false;
  this.shouldStop = false;
  this.removed = false;
  this.skipKeys = {};

  if (context) {
    this.context = context;
    this.state = context.state;
    this.opts = context.opts;
  }

  this.setScope();

  return this;
}

function resync() {
  if (this.removed) return;

  this._resyncParent();
  this._resyncList();
  this._resyncKey();
}

function _resyncParent() {
  if (this.parentPath) {
    this.parent = this.parentPath.node;
  }
}

function _resyncKey() {
  if (!this.container) return;

  if (this.node === this.container[this.key]) return;

  if (Array.isArray(this.container)) {
    for (var i = 0; i < this.container.length; i++) {
      if (this.container[i] === this.node) {
        return this.setKey(i);
      }
    }
  } else {
    for (var key in this.container) {
      if (this.container[key] === this.node) {
        return this.setKey(key);
      }
    }
  }

  this.key = null;
}

function _resyncList() {
  if (!this.parent || !this.inList) return;

  var newContainer = this.parent[this.listKey];
  if (this.container === newContainer) return;

  this.container = newContainer || null;
}

function _resyncRemoved() {
  if (this.key == null || !this.container || this.container[this.key] !== this.node) {
    this._markRemoved();
  }
}

function popContext() {
  this.contexts.pop();
  this.setContext(this.contexts[this.contexts.length - 1]);
}

function pushContext(context) {
  this.contexts.push(context);
  this.setContext(context);
}

function setup(parentPath, container, listKey, key) {
  this.inList = !!listKey;
  this.listKey = listKey;
  this.parentKey = listKey || key;
  this.container = container;

  this.parentPath = parentPath || this.parentPath;
  this.setKey(key);
}

function setKey(key) {
  this.key = key;
  this.node = this.container[this.key];
  this.type = this.node && this.node.type;
}

function requeue() {
  var pathToQueue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;

  if (pathToQueue.removed) return;

  var contexts = this.contexts;

  for (var _iterator2 = contexts, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
    var _ref2;

    if (_isArray2) {
      if (_i2 >= _iterator2.length) break;
      _ref2 = _iterator2[_i2++];
    } else {
      _i2 = _iterator2.next();
      if (_i2.done) break;
      _ref2 = _i2.value;
    }

    var context = _ref2;

    context.maybeQueue(pathToQueue);
  }
}

function _getQueueContexts() {
  var path = this;
  var contexts = this.contexts;
  while (!contexts.length) {
    path = path.parentPath;
    contexts = path.contexts;
  }
  return contexts;
}
},{"../index":25,"babel-runtime/core-js/get-iterator":9}],29:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.toComputedKey = toComputedKey;
exports.ensureBlock = ensureBlock;
exports.arrowFunctionToShadowed = arrowFunctionToShadowed;

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function toComputedKey() {
  var node = this.node;

  var key = void 0;
  if (this.isMemberExpression()) {
    key = node.property;
  } else if (this.isProperty() || this.isMethod()) {
    key = node.key;
  } else {
    throw new ReferenceError("todo");
  }

  if (!node.computed) {
    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);
  }

  return key;
}

function ensureBlock() {
  return t.ensureBlock(this.node);
}

function arrowFunctionToShadowed() {
  if (!this.isArrowFunctionExpression()) return;

  this.ensureBlock();

  var node = this.node;

  node.expression = false;
  node.type = "FunctionExpression";
  node.shadow = node.shadow || true;
}
},{"babel-types":58}],30:[function(require,module,exports){
(function (global){
"use strict";

exports.__esModule = true;

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _map = require("babel-runtime/core-js/map");

var _map2 = _interopRequireDefault(_map);

exports.evaluateTruthy = evaluateTruthy;
exports.evaluate = evaluate;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var VALID_CALLEES = ["String", "Number", "Math"];
var INVALID_METHODS = ["random"];

function evaluateTruthy() {
  var res = this.evaluate();
  if (res.confident) return !!res.value;
}

function evaluate() {
  var confident = true;
  var deoptPath = void 0;
  var seen = new _map2.default();

  function deopt(path) {
    if (!confident) return;
    deoptPath = path;
    confident = false;
  }

  var value = evaluate(this);
  if (!confident) value = undefined;
  return {
    confident: confident,
    deopt: deoptPath,
    value: value
  };

  function evaluate(path) {
    var node = path.node;


    if (seen.has(node)) {
      var existing = seen.get(node);
      if (existing.resolved) {
        return existing.value;
      } else {
        deopt(path);
        return;
      }
    } else {
      var item = { resolved: false };
      seen.set(node, item);

      var val = _evaluate(path);
      if (confident) {
        item.resolved = true;
        item.value = val;
      }
      return val;
    }
  }

  function _evaluate(path) {
    if (!confident) return;

    var node = path.node;


    if (path.isSequenceExpression()) {
      var exprs = path.get("expressions");
      return evaluate(exprs[exprs.length - 1]);
    }

    if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
      return node.value;
    }

    if (path.isNullLiteral()) {
      return null;
    }

    if (path.isTemplateLiteral()) {
      var str = "";

      var i = 0;
      var _exprs = path.get("expressions");

      for (var _iterator = node.quasis, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var elem = _ref;

        if (!confident) break;

        str += elem.value.cooked;

        var expr = _exprs[i++];
        if (expr) str += String(evaluate(expr));
      }

      if (!confident) return;
      return str;
    }

    if (path.isConditionalExpression()) {
      var testResult = evaluate(path.get("test"));
      if (!confident) return;
      if (testResult) {
        return evaluate(path.get("consequent"));
      } else {
        return evaluate(path.get("alternate"));
      }
    }

    if (path.isExpressionWrapper()) {
      return evaluate(path.get("expression"));
    }

    if (path.isMemberExpression() && !path.parentPath.isCallExpression({ callee: node })) {
      var property = path.get("property");
      var object = path.get("object");

      if (object.isLiteral() && property.isIdentifier()) {
        var _value = object.node.value;
        var type = typeof _value === "undefined" ? "undefined" : (0, _typeof3.default)(_value);
        if (type === "number" || type === "string") {
          return _value[property.node.name];
        }
      }
    }

    if (path.isReferencedIdentifier()) {
      var binding = path.scope.getBinding(node.name);

      if (binding && binding.constantViolations.length > 0) {
        return deopt(binding.path);
      }

      if (binding && path.node.start < binding.path.node.end) {
        return deopt(binding.path);
      }

      if (binding && binding.hasValue) {
        return binding.value;
      } else {
        if (node.name === "undefined") {
          return binding ? deopt(binding.path) : undefined;
        } else if (node.name === "Infinity") {
          return binding ? deopt(binding.path) : Infinity;
        } else if (node.name === "NaN") {
          return binding ? deopt(binding.path) : NaN;
        }

        var resolved = path.resolve();
        if (resolved === path) {
          return deopt(path);
        } else {
          return evaluate(resolved);
        }
      }
    }

    if (path.isUnaryExpression({ prefix: true })) {
      if (node.operator === "void") {
        return undefined;
      }

      var argument = path.get("argument");
      if (node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
        return "function";
      }

      var arg = evaluate(argument);
      if (!confident) return;
      switch (node.operator) {
        case "!":
          return !arg;
        case "+":
          return +arg;
        case "-":
          return -arg;
        case "~":
          return ~arg;
        case "typeof":
          return typeof arg === "undefined" ? "undefined" : (0, _typeof3.default)(arg);
      }
    }

    if (path.isArrayExpression()) {
      var arr = [];
      var elems = path.get("elements");
      for (var _iterator2 = elems, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var _elem = _ref2;

        _elem = _elem.evaluate();

        if (_elem.confident) {
          arr.push(_elem.value);
        } else {
          return deopt(_elem);
        }
      }
      return arr;
    }

    if (path.isObjectExpression()) {
      var obj = {};
      var props = path.get("properties");
      for (var _iterator3 = props, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
        var _ref3;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref3 = _i3.value;
        }

        var prop = _ref3;

        if (prop.isObjectMethod() || prop.isSpreadProperty()) {
          return deopt(prop);
        }
        var keyPath = prop.get("key");
        var key = keyPath;
        if (prop.node.computed) {
          key = key.evaluate();
          if (!key.confident) {
            return deopt(keyPath);
          }
          key = key.value;
        } else if (key.isIdentifier()) {
          key = key.node.name;
        } else {
          key = key.node.value;
        }
        var valuePath = prop.get("value");
        var _value2 = valuePath.evaluate();
        if (!_value2.confident) {
          return deopt(valuePath);
        }
        _value2 = _value2.value;
        obj[key] = _value2;
      }
      return obj;
    }

    if (path.isLogicalExpression()) {
      var wasConfident = confident;
      var left = evaluate(path.get("left"));
      var leftConfident = confident;
      confident = wasConfident;
      var right = evaluate(path.get("right"));
      var rightConfident = confident;
      confident = leftConfident && rightConfident;

      switch (node.operator) {
        case "||":
          if (left && leftConfident) {
            confident = true;
            return left;
          }

          if (!confident) return;

          return left || right;
        case "&&":
          if (!left && leftConfident || !right && rightConfident) {
            confident = true;
          }

          if (!confident) return;

          return left && right;
      }
    }

    if (path.isBinaryExpression()) {
      var _left = evaluate(path.get("left"));
      if (!confident) return;
      var _right = evaluate(path.get("right"));
      if (!confident) return;

      switch (node.operator) {
        case "-":
          return _left - _right;
        case "+":
          return _left + _right;
        case "/":
          return _left / _right;
        case "*":
          return _left * _right;
        case "%":
          return _left % _right;
        case "**":
          return Math.pow(_left, _right);
        case "<":
          return _left < _right;
        case ">":
          return _left > _right;
        case "<=":
          return _left <= _right;
        case ">=":
          return _left >= _right;
        case "==":
          return _left == _right;
        case "!=":
          return _left != _right;
        case "===":
          return _left === _right;
        case "!==":
          return _left !== _right;
        case "|":
          return _left | _right;
        case "&":
          return _left & _right;
        case "^":
          return _left ^ _right;
        case "<<":
          return _left << _right;
        case ">>":
          return _left >> _right;
        case ">>>":
          return _left >>> _right;
      }
    }

    if (path.isCallExpression()) {
      var callee = path.get("callee");
      var context = void 0;
      var func = void 0;

      if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name, true) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {
        func = global[node.callee.name];
      }

      if (callee.isMemberExpression()) {
        var _object = callee.get("object");
        var _property = callee.get("property");

        if (_object.isIdentifier() && _property.isIdentifier() && VALID_CALLEES.indexOf(_object.node.name) >= 0 && INVALID_METHODS.indexOf(_property.node.name) < 0) {
          context = global[_object.node.name];
          func = context[_property.node.name];
        }

        if (_object.isLiteral() && _property.isIdentifier()) {
          var _type = (0, _typeof3.default)(_object.node.value);
          if (_type === "string" || _type === "number") {
            context = _object.node.value;
            func = context[_property.node.name];
          }
        }
      }

      if (func) {
        var args = path.get("arguments").map(evaluate);
        if (!confident) return;

        return func.apply(context, args);
      }
    }

    deopt(path);
  }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"babel-runtime/core-js/get-iterator":9,"babel-runtime/core-js/map":11,"babel-runtime/helpers/typeof":21}],31:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _create = require("babel-runtime/core-js/object/create");

var _create2 = _interopRequireDefault(_create);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.getStatementParent = getStatementParent;
exports.getOpposite = getOpposite;
exports.getCompletionRecords = getCompletionRecords;
exports.getSibling = getSibling;
exports.getPrevSibling = getPrevSibling;
exports.getNextSibling = getNextSibling;
exports.getAllNextSiblings = getAllNextSiblings;
exports.getAllPrevSiblings = getAllPrevSiblings;
exports.get = get;
exports._getKey = _getKey;
exports._getPattern = _getPattern;
exports.getBindingIdentifiers = getBindingIdentifiers;
exports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
exports.getBindingIdentifierPaths = getBindingIdentifierPaths;
exports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;

var _index = require("./index");

var _index2 = _interopRequireDefault(_index);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getStatementParent() {
  var path = this;

  do {
    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
      break;
    } else {
      path = path.parentPath;
    }
  } while (path);

  if (path && (path.isProgram() || path.isFile())) {
    throw new Error("File/Program node, we can't possibly find a statement parent to this");
  }

  return path;
}

function getOpposite() {
  if (this.key === "left") {
    return this.getSibling("right");
  } else if (this.key === "right") {
    return this.getSibling("left");
  }
}

function getCompletionRecords() {
  var paths = [];

  var add = function add(path) {
    if (path) paths = paths.concat(path.getCompletionRecords());
  };

  if (this.isIfStatement()) {
    add(this.get("consequent"));
    add(this.get("alternate"));
  } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {
    add(this.get("body"));
  } else if (this.isProgram() || this.isBlockStatement()) {
    add(this.get("body").pop());
  } else if (this.isFunction()) {
    return this.get("body").getCompletionRecords();
  } else if (this.isTryStatement()) {
    add(this.get("block"));
    add(this.get("handler"));
    add(this.get("finalizer"));
  } else {
    paths.push(this);
  }

  return paths;
}

function getSibling(key) {
  return _index2.default.get({
    parentPath: this.parentPath,
    parent: this.parent,
    container: this.container,
    listKey: this.listKey,
    key: key
  });
}

function getPrevSibling() {
  return this.getSibling(this.key - 1);
}

function getNextSibling() {
  return this.getSibling(this.key + 1);
}

function getAllNextSiblings() {
  var _key = this.key;
  var sibling = this.getSibling(++_key);
  var siblings = [];
  while (sibling.node) {
    siblings.push(sibling);
    sibling = this.getSibling(++_key);
  }
  return siblings;
}

function getAllPrevSiblings() {
  var _key = this.key;
  var sibling = this.getSibling(--_key);
  var siblings = [];
  while (sibling.node) {
    siblings.push(sibling);
    sibling = this.getSibling(--_key);
  }
  return siblings;
}

function get(key, context) {
  if (context === true) context = this.context;
  var parts = key.split(".");
  if (parts.length === 1) {
    return this._getKey(key, context);
  } else {
    return this._getPattern(parts, context);
  }
}

function _getKey(key, context) {
  var _this = this;

  var node = this.node;
  var container = node[key];

  if (Array.isArray(container)) {
    return container.map(function (_, i) {
      return _index2.default.get({
        listKey: key,
        parentPath: _this,
        parent: node,
        container: container,
        key: i
      }).setContext(context);
    });
  } else {
    return _index2.default.get({
      parentPath: this,
      parent: node,
      container: node,
      key: key
    }).setContext(context);
  }
}

function _getPattern(parts, context) {
  var path = this;
  for (var _iterator = parts, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var part = _ref;

    if (part === ".") {
      path = path.parentPath;
    } else {
      if (Array.isArray(path)) {
        path = path[part];
      } else {
        path = path.get(part, context);
      }
    }
  }
  return path;
}

function getBindingIdentifiers(duplicates) {
  return t.getBindingIdentifiers(this.node, duplicates);
}

function getOuterBindingIdentifiers(duplicates) {
  return t.getOuterBindingIdentifiers(this.node, duplicates);
}

function getBindingIdentifierPaths() {
  var duplicates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var outerOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var path = this;
  var search = [].concat(path);
  var ids = (0, _create2.default)(null);

  while (search.length) {
    var id = search.shift();
    if (!id) continue;
    if (!id.node) continue;

    var keys = t.getBindingIdentifiers.keys[id.node.type];

    if (id.isIdentifier()) {
      if (duplicates) {
        var _ids = ids[id.node.name] = ids[id.node.name] || [];
        _ids.push(id);
      } else {
        ids[id.node.name] = id;
      }
      continue;
    }

    if (id.isExportDeclaration()) {
      var declaration = id.get("declaration");
      if (declaration.isDeclaration()) {
        search.push(declaration);
      }
      continue;
    }

    if (outerOnly) {
      if (id.isFunctionDeclaration()) {
        search.push(id.get("id"));
        continue;
      }
      if (id.isFunctionExpression()) {
        continue;
      }
    }

    if (keys) {
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var child = id.get(key);
        if (Array.isArray(child) || child.node) {
          search = search.concat(child);
        }
      }
    }
  }

  return ids;
}

function getOuterBindingIdentifierPaths(duplicates) {
  return this.getBindingIdentifierPaths(duplicates, true);
}
},{"./index":32,"babel-runtime/core-js/get-iterator":9,"babel-runtime/core-js/object/create":13,"babel-types":58}],32:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _virtualTypes = require("./lib/virtual-types");

var virtualTypes = _interopRequireWildcard(_virtualTypes);

var _debug2 = require("debug");

var _debug3 = _interopRequireDefault(_debug2);

var _invariant = require("invariant");

var _invariant2 = _interopRequireDefault(_invariant);

var _index = require("../index");

var _index2 = _interopRequireDefault(_index);

var _assign = require("lodash/assign");

var _assign2 = _interopRequireDefault(_assign);

var _scope = require("../scope");

var _scope2 = _interopRequireDefault(_scope);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _cache = require("../cache");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _debug = (0, _debug3.default)("babel");

var NodePath = function () {
  function NodePath(hub, parent) {
    (0, _classCallCheck3.default)(this, NodePath);

    this.parent = parent;
    this.hub = hub;
    this.contexts = [];
    this.data = {};
    this.shouldSkip = false;
    this.shouldStop = false;
    this.removed = false;
    this.state = null;
    this.opts = null;
    this.skipKeys = null;
    this.parentPath = null;
    this.context = null;
    this.container = null;
    this.listKey = null;
    this.inList = false;
    this.parentKey = null;
    this.key = null;
    this.node = null;
    this.scope = null;
    this.type = null;
    this.typeAnnotation = null;
  }

  NodePath.get = function get(_ref) {
    var hub = _ref.hub,
        parentPath = _ref.parentPath,
        parent = _ref.parent,
        container = _ref.container,
        listKey = _ref.listKey,
        key = _ref.key;

    if (!hub && parentPath) {
      hub = parentPath.hub;
    }

    (0, _invariant2.default)(parent, "To get a node path the parent needs to exist");

    var targetNode = container[key];

    var paths = _cache.path.get(parent) || [];
    if (!_cache.path.has(parent)) {
      _cache.path.set(parent, paths);
    }

    var path = void 0;

    for (var i = 0; i < paths.length; i++) {
      var pathCheck = paths[i];
      if (pathCheck.node === targetNode) {
        path = pathCheck;
        break;
      }
    }

    if (!path) {
      path = new NodePath(hub, parent);
      paths.push(path);
    }

    path.setup(parentPath, container, listKey, key);

    return path;
  };

  NodePath.prototype.getScope = function getScope(scope) {
    var ourScope = scope;

    if (this.isScope()) {
      ourScope = new _scope2.default(this, scope);
    }

    return ourScope;
  };

  NodePath.prototype.setData = function setData(key, val) {
    return this.data[key] = val;
  };

  NodePath.prototype.getData = function getData(key, def) {
    var val = this.data[key];
    if (!val && def) val = this.data[key] = def;
    return val;
  };

  NodePath.prototype.buildCodeFrameError = function buildCodeFrameError(msg) {
    var Error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SyntaxError;

    return this.hub.file.buildCodeFrameError(this.node, msg, Error);
  };

  NodePath.prototype.traverse = function traverse(visitor, state) {
    (0, _index2.default)(this.node, visitor, this.scope, state, this);
  };

  NodePath.prototype.mark = function mark(type, message) {
    this.hub.file.metadata.marked.push({
      type: type,
      message: message,
      loc: this.node.loc
    });
  };

  NodePath.prototype.set = function set(key, node) {
    t.validate(this.node, key, node);
    this.node[key] = node;
  };

  NodePath.prototype.getPathLocation = function getPathLocation() {
    var parts = [];
    var path = this;
    do {
      var key = path.key;
      if (path.inList) key = path.listKey + "[" + key + "]";
      parts.unshift(key);
    } while (path = path.parentPath);
    return parts.join(".");
  };

  NodePath.prototype.debug = function debug(buildMessage) {
    if (!_debug.enabled) return;
    _debug(this.getPathLocation() + " " + this.type + ": " + buildMessage());
  };

  return NodePath;
}();

exports.default = NodePath;


(0, _assign2.default)(NodePath.prototype, require("./ancestry"));
(0, _assign2.default)(NodePath.prototype, require("./inference"));
(0, _assign2.default)(NodePath.prototype, require("./replacement"));
(0, _assign2.default)(NodePath.prototype, require("./evaluation"));
(0, _assign2.default)(NodePath.prototype, require("./conversion"));
(0, _assign2.default)(NodePath.prototype, require("./introspection"));
(0, _assign2.default)(NodePath.prototype, require("./context"));
(0, _assign2.default)(NodePath.prototype, require("./removal"));
(0, _assign2.default)(NodePath.prototype, require("./modification"));
(0, _assign2.default)(NodePath.prototype, require("./family"));
(0, _assign2.default)(NodePath.prototype, require("./comments"));

var _loop2 = function _loop2() {
  if (_isArray) {
    if (_i >= _iterator.length) return "break";
    _ref2 = _iterator[_i++];
  } else {
    _i = _iterator.next();
    if (_i.done) return "break";
    _ref2 = _i.value;
  }

  var type = _ref2;

  var typeKey = "is" + type;
  NodePath.prototype[typeKey] = function (opts) {
    return t[typeKey](this.node, opts);
  };

  NodePath.prototype["assert" + type] = function (opts) {
    if (!this[typeKey](opts)) {
      throw new TypeError("Expected node path of type " + type);
    }
  };
};

for (var _iterator = t.TYPES, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
  var _ref2;

  var _ret2 = _loop2();

  if (_ret2 === "break") break;
}

var _loop = function _loop(type) {
  if (type[0] === "_") return "continue";
  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);

  var virtualType = virtualTypes[type];

  NodePath.prototype["is" + type] = function (opts) {
    return virtualType.checkPath(this, opts);
  };
};

for (var type in virtualTypes) {
  var _ret = _loop(type);

  if (_ret === "continue") continue;
}
module.exports = exports["default"];
},{"../cache":22,"../index":25,"../scope":44,"./ancestry":26,"./comments":27,"./context":28,"./conversion":29,"./evaluation":30,"./family":31,"./inference":33,"./introspection":36,"./lib/virtual-types":39,"./modification":40,"./removal":41,"./replacement":42,"babel-runtime/core-js/get-iterator":9,"babel-runtime/helpers/classCallCheck":20,"babel-types":58,"debug":177,"invariant":203,"lodash/assign":329}],33:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.getTypeAnnotation = getTypeAnnotation;
exports._getTypeAnnotation = _getTypeAnnotation;
exports.isBaseType = isBaseType;
exports.couldBeBaseType = couldBeBaseType;
exports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
exports.isGenericType = isGenericType;

var _inferers = require("./inferers");

var inferers = _interopRequireWildcard(_inferers);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getTypeAnnotation() {
  if (this.typeAnnotation) return this.typeAnnotation;

  var type = this._getTypeAnnotation() || t.anyTypeAnnotation();
  if (t.isTypeAnnotation(type)) type = type.typeAnnotation;
  return this.typeAnnotation = type;
}

function _getTypeAnnotation() {
  var node = this.node;

  if (!node) {
    if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
      var declar = this.parentPath.parentPath;
      var declarParent = declar.parentPath;

      if (declar.key === "left" && declarParent.isForInStatement()) {
        return t.stringTypeAnnotation();
      }

      if (declar.key === "left" && declarParent.isForOfStatement()) {
        return t.anyTypeAnnotation();
      }

      return t.voidTypeAnnotation();
    } else {
      return;
    }
  }

  if (node.typeAnnotation) {
    return node.typeAnnotation;
  }

  var inferer = inferers[node.type];
  if (inferer) {
    return inferer.call(this, node);
  }

  inferer = inferers[this.parentPath.type];
  if (inferer && inferer.validParent) {
    return this.parentPath.getTypeAnnotation();
  }
}

function isBaseType(baseName, soft) {
  return _isBaseType(baseName, this.getTypeAnnotation(), soft);
}

function _isBaseType(baseName, type, soft) {
  if (baseName === "string") {
    return t.isStringTypeAnnotation(type);
  } else if (baseName === "number") {
    return t.isNumberTypeAnnotation(type);
  } else if (baseName === "boolean") {
    return t.isBooleanTypeAnnotation(type);
  } else if (baseName === "any") {
    return t.isAnyTypeAnnotation(type);
  } else if (baseName === "mixed") {
    return t.isMixedTypeAnnotation(type);
  } else if (baseName === "empty") {
    return t.isEmptyTypeAnnotation(type);
  } else if (baseName === "void") {
    return t.isVoidTypeAnnotation(type);
  } else {
    if (soft) {
      return false;
    } else {
      throw new Error("Unknown base type " + baseName);
    }
  }
}

function couldBeBaseType(name) {
  var type = this.getTypeAnnotation();
  if (t.isAnyTypeAnnotation(type)) return true;

  if (t.isUnionTypeAnnotation(type)) {
    for (var _iterator = type.types, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var type2 = _ref;

      if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
        return true;
      }
    }
    return false;
  } else {
    return _isBaseType(name, type, true);
  }
}

function baseTypeStrictlyMatches(right) {
  var left = this.getTypeAnnotation();
  right = right.getTypeAnnotation();

  if (!t.isAnyTypeAnnotation(left) && t.isFlowBaseAnnotation(left)) {
    return right.type === left.type;
  }
}

function isGenericType(genericName) {
  var type = this.getTypeAnnotation();
  return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, { name: genericName });
}
},{"./inferers":35,"babel-runtime/core-js/get-iterator":9,"babel-types":58}],34:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.default = function (node) {
  if (!this.isReferenced()) return;

  var binding = this.scope.getBinding(node.name);
  if (binding) {
    if (binding.identifier.typeAnnotation) {
      return binding.identifier.typeAnnotation;
    } else {
      return getTypeAnnotationBindingConstantViolations(this, node.name);
    }
  }

  if (node.name === "undefined") {
    return t.voidTypeAnnotation();
  } else if (node.name === "NaN" || node.name === "Infinity") {
    return t.numberTypeAnnotation();
  } else if (node.name === "arguments") {}
};

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getTypeAnnotationBindingConstantViolations(path, name) {
  var binding = path.scope.getBinding(name);

  var types = [];
  path.typeAnnotation = t.unionTypeAnnotation(types);

  var functionConstantViolations = [];
  var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);

  var testType = getConditionalAnnotation(path, name);
  if (testType) {
    var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);

    constantViolations = constantViolations.filter(function (path) {
      return testConstantViolations.indexOf(path) < 0;
    });

    types.push(testType.typeAnnotation);
  }

  if (constantViolations.length) {
    constantViolations = constantViolations.concat(functionConstantViolations);

    for (var _iterator = constantViolations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var violation = _ref;

      types.push(violation.getTypeAnnotation());
    }
  }

  if (types.length) {
    return t.createUnionTypeAnnotation(types);
  }
}

function getConstantViolationsBefore(binding, path, functions) {
  var violations = binding.constantViolations.slice();
  violations.unshift(binding.path);
  return violations.filter(function (violation) {
    violation = violation.resolve();
    var status = violation._guessExecutionStatusRelativeTo(path);
    if (functions && status === "function") functions.push(violation);
    return status === "before";
  });
}

function inferAnnotationFromBinaryExpression(name, path) {
  var operator = path.node.operator;

  var right = path.get("right").resolve();
  var left = path.get("left").resolve();

  var target = void 0;
  if (left.isIdentifier({ name: name })) {
    target = right;
  } else if (right.isIdentifier({ name: name })) {
    target = left;
  }
  if (target) {
    if (operator === "===") {
      return target.getTypeAnnotation();
    } else if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
      return t.numberTypeAnnotation();
    } else {
      return;
    }
  } else {
    if (operator !== "===") return;
  }

  var typeofPath = void 0;
  var typePath = void 0;
  if (left.isUnaryExpression({ operator: "typeof" })) {
    typeofPath = left;
    typePath = right;
  } else if (right.isUnaryExpression({ operator: "typeof" })) {
    typeofPath = right;
    typePath = left;
  }
  if (!typePath && !typeofPath) return;

  typePath = typePath.resolve();
  if (!typePath.isLiteral()) return;

  var typeValue = typePath.node.value;
  if (typeof typeValue !== "string") return;

  if (!typeofPath.get("argument").isIdentifier({ name: name })) return;

  return t.createTypeAnnotationBasedOnTypeof(typePath.node.value);
}

function getParentConditionalPath(path) {
  var parentPath = void 0;
  while (parentPath = path.parentPath) {
    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
      if (path.key === "test") {
        return;
      } else {
        return parentPath;
      }
    } else {
      path = parentPath;
    }
  }
}

function getConditionalAnnotation(path, name) {
  var ifStatement = getParentConditionalPath(path);
  if (!ifStatement) return;

  var test = ifStatement.get("test");
  var paths = [test];
  var types = [];

  do {
    var _path = paths.shift().resolve();

    if (_path.isLogicalExpression()) {
      paths.push(_path.get("left"));
      paths.push(_path.get("right"));
    }

    if (_path.isBinaryExpression()) {
      var type = inferAnnotationFromBinaryExpression(name, _path);
      if (type) types.push(type);
    }
  } while (paths.length);

  if (types.length) {
    return {
      typeAnnotation: t.createUnionTypeAnnotation(types),
      ifStatement: ifStatement
    };
  } else {
    return getConditionalAnnotation(ifStatement, name);
  }
}
module.exports = exports["default"];
},{"babel-runtime/core-js/get-iterator":9,"babel-types":58}],35:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = exports.Identifier = undefined;

var _infererReference = require("./inferer-reference");

Object.defineProperty(exports, "Identifier", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_infererReference).default;
  }
});
exports.VariableDeclarator = VariableDeclarator;
exports.TypeCastExpression = TypeCastExpression;
exports.NewExpression = NewExpression;
exports.TemplateLiteral = TemplateLiteral;
exports.UnaryExpression = UnaryExpression;
exports.BinaryExpression = BinaryExpression;
exports.LogicalExpression = LogicalExpression;
exports.ConditionalExpression = ConditionalExpression;
exports.SequenceExpression = SequenceExpression;
exports.AssignmentExpression = AssignmentExpression;
exports.UpdateExpression = UpdateExpression;
exports.StringLiteral = StringLiteral;
exports.NumericLiteral = NumericLiteral;
exports.BooleanLiteral = BooleanLiteral;
exports.NullLiteral = NullLiteral;
exports.RegExpLiteral = RegExpLiteral;
exports.ObjectExpression = ObjectExpression;
exports.ArrayExpression = ArrayExpression;
exports.RestElement = RestElement;
exports.CallExpression = CallExpression;
exports.TaggedTemplateExpression = TaggedTemplateExpression;

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function VariableDeclarator() {
  var id = this.get("id");

  if (id.isIdentifier()) {
    return this.get("init").getTypeAnnotation();
  } else {
    return;
  }
}

function TypeCastExpression(node) {
  return node.typeAnnotation;
}

TypeCastExpression.validParent = true;

function NewExpression(node) {
  if (this.get("callee").isIdentifier()) {
    return t.genericTypeAnnotation(node.callee);
  }
}

function TemplateLiteral() {
  return t.stringTypeAnnotation();
}

function UnaryExpression(node) {
  var operator = node.operator;

  if (operator === "void") {
    return t.voidTypeAnnotation();
  } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
    return t.numberTypeAnnotation();
  } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
    return t.stringTypeAnnotation();
  } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
    return t.booleanTypeAnnotation();
  }
}

function BinaryExpression(node) {
  var operator = node.operator;

  if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
    return t.numberTypeAnnotation();
  } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
    return t.booleanTypeAnnotation();
  } else if (operator === "+") {
    var right = this.get("right");
    var left = this.get("left");

    if (left.isBaseType("number") && right.isBaseType("number")) {
      return t.numberTypeAnnotation();
    } else if (left.isBaseType("string") || right.isBaseType("string")) {
      return t.stringTypeAnnotation();
    }

    return t.unionTypeAnnotation([t.stringTypeAnnotation(), t.numberTypeAnnotation()]);
  }
}

function LogicalExpression() {
  return t.createUnionTypeAnnotation([this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()]);
}

function ConditionalExpression() {
  return t.createUnionTypeAnnotation([this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()]);
}

function SequenceExpression() {
  return this.get("expressions").pop().getTypeAnnotation();
}

function AssignmentExpression() {
  return this.get("right").getTypeAnnotation();
}

function UpdateExpression(node) {
  var operator = node.operator;
  if (operator === "++" || operator === "--") {
    return t.numberTypeAnnotation();
  }
}

function StringLiteral() {
  return t.stringTypeAnnotation();
}

function NumericLiteral() {
  return t.numberTypeAnnotation();
}

function BooleanLiteral() {
  return t.booleanTypeAnnotation();
}

function NullLiteral() {
  return t.nullLiteralTypeAnnotation();
}

function RegExpLiteral() {
  return t.genericTypeAnnotation(t.identifier("RegExp"));
}

function ObjectExpression() {
  return t.genericTypeAnnotation(t.identifier("Object"));
}

function ArrayExpression() {
  return t.genericTypeAnnotation(t.identifier("Array"));
}

function RestElement() {
  return ArrayExpression();
}

RestElement.validParent = true;

function Func() {
  return t.genericTypeAnnotation(t.identifier("Function"));
}

exports.FunctionExpression = Func;
exports.ArrowFunctionExpression = Func;
exports.FunctionDeclaration = Func;
exports.ClassExpression = Func;
exports.ClassDeclaration = Func;
function CallExpression() {
  return resolveCall(this.get("callee"));
}

function TaggedTemplateExpression() {
  return resolveCall(this.get("tag"));
}

function resolveCall(callee) {
  callee = callee.resolve();

  if (callee.isFunction()) {
    if (callee.is("async")) {
      if (callee.is("generator")) {
        return t.genericTypeAnnotation(t.identifier("AsyncIterator"));
      } else {
        return t.genericTypeAnnotation(t.identifier("Promise"));
      }
    } else {
      if (callee.node.returnType) {
        return callee.node.returnType;
      } else {}
    }
  }
}
},{"./inferer-reference":34,"babel-types":58}],36:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.is = undefined;

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.matchesPattern = matchesPattern;
exports.has = has;
exports.isStatic = isStatic;
exports.isnt = isnt;
exports.equals = equals;
exports.isNodeType = isNodeType;
exports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
exports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
exports.isCompletionRecord = isCompletionRecord;
exports.isStatementOrBlock = isStatementOrBlock;
exports.referencesImport = referencesImport;
exports.getSource = getSource;
exports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
exports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
exports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;
exports.resolve = resolve;
exports._resolve = _resolve;

var _includes = require("lodash/includes");

var _includes2 = _interopRequireDefault(_includes);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function matchesPattern(pattern, allowPartial) {
  if (!this.isMemberExpression()) return false;

  var parts = pattern.split(".");
  var search = [this.node];
  var i = 0;

  function matches(name) {
    var part = parts[i];
    return part === "*" || name === part;
  }

  while (search.length) {
    var node = search.shift();

    if (allowPartial && i === parts.length) {
      return true;
    }

    if (t.isIdentifier(node)) {
      if (!matches(node.name)) return false;
    } else if (t.isLiteral(node)) {
      if (!matches(node.value)) return false;
    } else if (t.isMemberExpression(node)) {
      if (node.computed && !t.isLiteral(node.property)) {
        return false;
      } else {
        search.unshift(node.property);
        search.unshift(node.object);
        continue;
      }
    } else if (t.isThisExpression(node)) {
      if (!matches("this")) return false;
    } else {
      return false;
    }

    if (++i > parts.length) {
      return false;
    }
  }

  return i === parts.length;
}

function has(key) {
  var val = this.node && this.node[key];
  if (val && Array.isArray(val)) {
    return !!val.length;
  } else {
    return !!val;
  }
}

function isStatic() {
  return this.scope.isStatic(this.node);
}

var is = exports.is = has;

function isnt(key) {
  return !this.has(key);
}

function equals(key, value) {
  return this.node[key] === value;
}

function isNodeType(type) {
  return t.isType(this.type, type);
}

function canHaveVariableDeclarationOrExpression() {
  return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
}

function canSwapBetweenExpressionAndStatement(replacement) {
  if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
    return false;
  }

  if (this.isExpression()) {
    return t.isBlockStatement(replacement);
  } else if (this.isBlockStatement()) {
    return t.isExpression(replacement);
  }

  return false;
}

function isCompletionRecord(allowInsideFunction) {
  var path = this;
  var first = true;

  do {
    var container = path.container;

    if (path.isFunction() && !first) {
      return !!allowInsideFunction;
    }

    first = false;

    if (Array.isArray(container) && path.key !== container.length - 1) {
      return false;
    }
  } while ((path = path.parentPath) && !path.isProgram());

  return true;
}

function isStatementOrBlock() {
  if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {
    return false;
  } else {
    return (0, _includes2.default)(t.STATEMENT_OR_BLOCK_KEYS, this.key);
  }
}

function referencesImport(moduleSource, importName) {
  if (!this.isReferencedIdentifier()) return false;

  var binding = this.scope.getBinding(this.node.name);
  if (!binding || binding.kind !== "module") return false;

  var path = binding.path;
  var parent = path.parentPath;
  if (!parent.isImportDeclaration()) return false;

  if (parent.node.source.value === moduleSource) {
    if (!importName) return true;
  } else {
    return false;
  }

  if (path.isImportDefaultSpecifier() && importName === "default") {
    return true;
  }

  if (path.isImportNamespaceSpecifier() && importName === "*") {
    return true;
  }

  if (path.isImportSpecifier() && path.node.imported.name === importName) {
    return true;
  }

  return false;
}

function getSource() {
  var node = this.node;
  if (node.end) {
    return this.hub.file.code.slice(node.start, node.end);
  } else {
    return "";
  }
}

function willIMaybeExecuteBefore(target) {
  return this._guessExecutionStatusRelativeTo(target) !== "after";
}

function _guessExecutionStatusRelativeTo(target) {
  var targetFuncParent = target.scope.getFunctionParent();
  var selfFuncParent = this.scope.getFunctionParent();

  if (targetFuncParent.node !== selfFuncParent.node) {
    var status = this._guessExecutionStatusRelativeToDifferentFunctions(targetFuncParent);
    if (status) {
      return status;
    } else {
      target = targetFuncParent.path;
    }
  }

  var targetPaths = target.getAncestry();
  if (targetPaths.indexOf(this) >= 0) return "after";

  var selfPaths = this.getAncestry();

  var commonPath = void 0;
  var targetIndex = void 0;
  var selfIndex = void 0;
  for (selfIndex = 0; selfIndex < selfPaths.length; selfIndex++) {
    var selfPath = selfPaths[selfIndex];
    targetIndex = targetPaths.indexOf(selfPath);
    if (targetIndex >= 0) {
      commonPath = selfPath;
      break;
    }
  }
  if (!commonPath) {
    return "before";
  }

  var targetRelationship = targetPaths[targetIndex - 1];
  var selfRelationship = selfPaths[selfIndex - 1];
  if (!targetRelationship || !selfRelationship) {
    return "before";
  }

  if (targetRelationship.listKey && targetRelationship.container === selfRelationship.container) {
    return targetRelationship.key > selfRelationship.key ? "before" : "after";
  }

  var targetKeyPosition = t.VISITOR_KEYS[targetRelationship.type].indexOf(targetRelationship.key);
  var selfKeyPosition = t.VISITOR_KEYS[selfRelationship.type].indexOf(selfRelationship.key);
  return targetKeyPosition > selfKeyPosition ? "before" : "after";
}

function _guessExecutionStatusRelativeToDifferentFunctions(targetFuncParent) {
  var targetFuncPath = targetFuncParent.path;
  if (!targetFuncPath.isFunctionDeclaration()) return;

  var binding = targetFuncPath.scope.getBinding(targetFuncPath.node.id.name);

  if (!binding.references) return "before";

  var referencePaths = binding.referencePaths;

  for (var _iterator = referencePaths, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var path = _ref;

    if (path.key !== "callee" || !path.parentPath.isCallExpression()) {
      return;
    }
  }

  var allStatus = void 0;

  for (var _iterator2 = referencePaths, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
    var _ref2;

    if (_isArray2) {
      if (_i2 >= _iterator2.length) break;
      _ref2 = _iterator2[_i2++];
    } else {
      _i2 = _iterator2.next();
      if (_i2.done) break;
      _ref2 = _i2.value;
    }

    var _path = _ref2;

    var childOfFunction = !!_path.find(function (path) {
      return path.node === targetFuncPath.node;
    });
    if (childOfFunction) continue;

    var status = this._guessExecutionStatusRelativeTo(_path);

    if (allStatus) {
      if (allStatus !== status) return;
    } else {
      allStatus = status;
    }
  }

  return allStatus;
}

function resolve(dangerous, resolved) {
  return this._resolve(dangerous, resolved) || this;
}

function _resolve(dangerous, resolved) {
  if (resolved && resolved.indexOf(this) >= 0) return;

  resolved = resolved || [];
  resolved.push(this);

  if (this.isVariableDeclarator()) {
    if (this.get("id").isIdentifier()) {
      return this.get("init").resolve(dangerous, resolved);
    } else {}
  } else if (this.isReferencedIdentifier()) {
    var binding = this.scope.getBinding(this.node.name);
    if (!binding) return;

    if (!binding.constant) return;

    if (binding.kind === "module") return;

    if (binding.path !== this) {
      var ret = binding.path.resolve(dangerous, resolved);

      if (this.find(function (parent) {
        return parent.node === ret.node;
      })) return;
      return ret;
    }
  } else if (this.isTypeCastExpression()) {
    return this.get("expression").resolve(dangerous, resolved);
  } else if (dangerous && this.isMemberExpression()) {

    var targetKey = this.toComputedKey();
    if (!t.isLiteral(targetKey)) return;

    var targetName = targetKey.value;

    var target = this.get("object").resolve(dangerous, resolved);

    if (target.isObjectExpression()) {
      var props = target.get("properties");
      for (var _iterator3 = props, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
        var _ref3;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref3 = _i3.value;
        }

        var prop = _ref3;

        if (!prop.isProperty()) continue;

        var key = prop.get("key");

        var match = prop.isnt("computed") && key.isIdentifier({ name: targetName });

        match = match || key.isLiteral({ value: targetName });

        if (match) return prop.get("value").resolve(dangerous, resolved);
      }
    } else if (target.isArrayExpression() && !isNaN(+targetName)) {
      var elems = target.get("elements");
      var elem = elems[targetName];
      if (elem) return elem.resolve(dangerous, resolved);
    }
  }
}
},{"babel-runtime/core-js/get-iterator":9,"babel-types":58,"lodash/includes":336}],37:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var referenceVisitor = {
  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
    if (path.isJSXIdentifier() && _babelTypes.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {
      return;
    }

    if (path.node.name === "this") {
      var scope = path.scope;
      do {
        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) break;
      } while (scope = scope.parent);
      if (scope) state.breakOnScopePaths.push(scope.path);
    }

    var binding = path.scope.getBinding(path.node.name);
    if (!binding) return;

    if (binding !== state.scope.getBinding(path.node.name)) return;

    state.bindings[path.node.name] = binding;
  }
};

var PathHoister = function () {
  function PathHoister(path, scope) {
    (0, _classCallCheck3.default)(this, PathHoister);

    this.breakOnScopePaths = [];

    this.bindings = {};

    this.scopes = [];

    this.scope = scope;
    this.path = path;

    this.attachAfter = false;
  }

  PathHoister.prototype.isCompatibleScope = function isCompatibleScope(scope) {
    for (var key in this.bindings) {
      var binding = this.bindings[key];
      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
        return false;
      }
    }

    return true;
  };

  PathHoister.prototype.getCompatibleScopes = function getCompatibleScopes() {
    var scope = this.path.scope;
    do {
      if (this.isCompatibleScope(scope)) {
        this.scopes.push(scope);
      } else {
        break;
      }

      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
        break;
      }
    } while (scope = scope.parent);
  };

  PathHoister.prototype.getAttachmentPath = function getAttachmentPath() {
    var path = this._getAttachmentPath();
    if (!path) return;

    var targetScope = path.scope;

    if (targetScope.path === path) {
      targetScope = path.scope.parent;
    }

    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
      for (var name in this.bindings) {
        if (!targetScope.hasOwnBinding(name)) continue;

        var binding = this.bindings[name];

        if (binding.kind === "param") continue;

        if (this.getAttachmentParentForPath(binding.path).key > path.key) {
          this.attachAfter = true;
          path = binding.path;

          for (var _iterator = binding.constantViolations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
            var _ref;

            if (_isArray) {
              if (_i >= _iterator.length) break;
              _ref = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done) break;
              _ref = _i.value;
            }

            var violationPath = _ref;

            if (this.getAttachmentParentForPath(violationPath).key > path.key) {
              path = violationPath;
            }
          }
        }
      }
    }

    return path;
  };

  PathHoister.prototype._getAttachmentPath = function _getAttachmentPath() {
    var scopes = this.scopes;

    var scope = scopes.pop();

    if (!scope) return;

    if (scope.path.isFunction()) {
      if (this.hasOwnParamBindings(scope)) {
        if (this.scope === scope) return;

        return scope.path.get("body").get("body")[0];
      } else {
        return this.getNextScopeAttachmentParent();
      }
    } else if (scope.path.isProgram()) {
      return this.getNextScopeAttachmentParent();
    }
  };

  PathHoister.prototype.getNextScopeAttachmentParent = function getNextScopeAttachmentParent() {
    var scope = this.scopes.pop();
    if (scope) return this.getAttachmentParentForPath(scope.path);
  };

  PathHoister.prototype.getAttachmentParentForPath = function getAttachmentParentForPath(path) {
    do {
      if (!path.parentPath || Array.isArray(path.container) && path.isStatement() || path.isVariableDeclarator() && path.parentPath.node !== null && path.parentPath.node.declarations.length > 1) return path;
    } while (path = path.parentPath);
  };

  PathHoister.prototype.hasOwnParamBindings = function hasOwnParamBindings(scope) {
    for (var name in this.bindings) {
      if (!scope.hasOwnBinding(name)) continue;

      var binding = this.bindings[name];

      if (binding.kind === "param" && binding.constant) return true;
    }
    return false;
  };

  PathHoister.prototype.run = function run() {
    var node = this.path.node;
    if (node._hoisted) return;
    node._hoisted = true;

    this.path.traverse(referenceVisitor, this);

    this.getCompatibleScopes();

    var attachTo = this.getAttachmentPath();
    if (!attachTo) return;

    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;

    var uid = attachTo.scope.generateUidIdentifier("ref");
    var declarator = t.variableDeclarator(uid, this.path.node);

    var insertFn = this.attachAfter ? "insertAfter" : "insertBefore";
    attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration("var", [declarator])]);

    var parent = this.path.parentPath;
    if (parent.isJSXElement() && this.path.container === parent.node.children) {
      uid = t.JSXExpressionContainer(uid);
    }

    this.path.replaceWith(uid);
  };

  return PathHoister;
}();

exports.default = PathHoister;
module.exports = exports["default"];
},{"babel-runtime/core-js/get-iterator":9,"babel-runtime/helpers/classCallCheck":20,"babel-types":58}],38:[function(require,module,exports){
"use strict";

exports.__esModule = true;
var hooks = exports.hooks = [function (self, parent) {
  var removeParent = self.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self.key === "declaration" && parent.isExportDeclaration() || self.key === "body" && parent.isLabeledStatement() || self.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === "expression" && parent.isExpressionStatement();

  if (removeParent) {
    parent.remove();
    return true;
  }
}, function (self, parent) {
  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
    parent.replaceWith(parent.node.expressions[0]);
    return true;
  }
}, function (self, parent) {
  if (parent.isBinary()) {
    if (self.key === "left") {
      parent.replaceWith(parent.node.right);
    } else {
      parent.replaceWith(parent.node.left);
    }
    return true;
  }
}, function (self, parent) {
  if (parent.isIfStatement() && (self.key === "consequent" || self.key === "alternate") || self.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
    self.replaceWith({
      type: "BlockStatement",
      body: []
    });
    return true;
  }
}];
},{}],39:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = undefined;

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var ReferencedIdentifier = exports.ReferencedIdentifier = {
  types: ["Identifier", "JSXIdentifier"],
  checkPath: function checkPath(_ref, opts) {
    var node = _ref.node,
        parent = _ref.parent;

    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {
      if (t.isJSXIdentifier(node, opts)) {
        if (_babelTypes.react.isCompatTag(node.name)) return false;
      } else {
        return false;
      }
    }

    return t.isReferenced(node, parent);
  }
};

var ReferencedMemberExpression = exports.ReferencedMemberExpression = {
  types: ["MemberExpression"],
  checkPath: function checkPath(_ref2) {
    var node = _ref2.node,
        parent = _ref2.parent;

    return t.isMemberExpression(node) && t.isReferenced(node, parent);
  }
};

var BindingIdentifier = exports.BindingIdentifier = {
  types: ["Identifier"],
  checkPath: function checkPath(_ref3) {
    var node = _ref3.node,
        parent = _ref3.parent;

    return t.isIdentifier(node) && t.isBinding(node, parent);
  }
};

var Statement = exports.Statement = {
  types: ["Statement"],
  checkPath: function checkPath(_ref4) {
    var node = _ref4.node,
        parent = _ref4.parent;

    if (t.isStatement(node)) {
      if (t.isVariableDeclaration(node)) {
        if (t.isForXStatement(parent, { left: node })) return false;
        if (t.isForStatement(parent, { init: node })) return false;
      }

      return true;
    } else {
      return false;
    }
  }
};

var Expression = exports.Expression = {
  types: ["Expression"],
  checkPath: function checkPath(path) {
    if (path.isIdentifier()) {
      return path.isReferencedIdentifier();
    } else {
      return t.isExpression(path.node);
    }
  }
};

var Scope = exports.Scope = {
  types: ["Scopable"],
  checkPath: function checkPath(path) {
    return t.isScope(path.node, path.parent);
  }
};

var Referenced = exports.Referenced = {
  checkPath: function checkPath(path) {
    return t.isReferenced(path.node, path.parent);
  }
};

var BlockScoped = exports.BlockScoped = {
  checkPath: function checkPath(path) {
    return t.isBlockScoped(path.node);
  }
};

var Var = exports.Var = {
  types: ["VariableDeclaration"],
  checkPath: function checkPath(path) {
    return t.isVar(path.node);
  }
};

var User = exports.User = {
  checkPath: function checkPath(path) {
    return path.node && !!path.node.loc;
  }
};

var Generated = exports.Generated = {
  checkPath: function checkPath(path) {
    return !path.isUser();
  }
};

var Pure = exports.Pure = {
  checkPath: function checkPath(path, opts) {
    return path.scope.isPure(path.node, opts);
  }
};

var Flow = exports.Flow = {
  types: ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"],
  checkPath: function checkPath(_ref5) {
    var node = _ref5.node;

    if (t.isFlow(node)) {
      return true;
    } else if (t.isImportDeclaration(node)) {
      return node.importKind === "type" || node.importKind === "typeof";
    } else if (t.isExportDeclaration(node)) {
      return node.exportKind === "type";
    } else if (t.isImportSpecifier(node)) {
      return node.importKind === "type" || node.importKind === "typeof";
    } else {
      return false;
    }
  }
};
},{"babel-types":58}],40:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.insertBefore = insertBefore;
exports._containerInsert = _containerInsert;
exports._containerInsertBefore = _containerInsertBefore;
exports._containerInsertAfter = _containerInsertAfter;
exports._maybePopFromStatements = _maybePopFromStatements;
exports.insertAfter = insertAfter;
exports.updateSiblingKeys = updateSiblingKeys;
exports._verifyNodeList = _verifyNodeList;
exports.unshiftContainer = unshiftContainer;
exports.pushContainer = pushContainer;
exports.hoist = hoist;

var _cache = require("../cache");

var _hoister = require("./lib/hoister");

var _hoister2 = _interopRequireDefault(_hoister);

var _index = require("./index");

var _index2 = _interopRequireDefault(_index);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function insertBefore(nodes) {
  this._assertUnremoved();

  nodes = this._verifyNodeList(nodes);

  if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {
    return this.parentPath.insertBefore(nodes);
  } else if (this.isNodeType("Expression") || this.parentPath.isForStatement() && this.key === "init") {
    if (this.node) nodes.push(this.node);
    this.replaceExpressionWithStatements(nodes);
  } else {
    this._maybePopFromStatements(nodes);
    if (Array.isArray(this.container)) {
      return this._containerInsertBefore(nodes);
    } else if (this.isStatementOrBlock()) {
      if (this.node) nodes.push(this.node);
      this._replaceWith(t.blockStatement(nodes));
    } else {
      throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
    }
  }

  return [this];
}

function _containerInsert(from, nodes) {
  this.updateSiblingKeys(from, nodes.length);

  var paths = [];

  for (var i = 0; i < nodes.length; i++) {
    var to = from + i;
    var node = nodes[i];
    this.container.splice(to, 0, node);

    if (this.context) {
      var path = this.context.create(this.parent, this.container, to, this.listKey);

      if (this.context.queue) path.pushContext(this.context);
      paths.push(path);
    } else {
      paths.push(_index2.default.get({
        parentPath: this.parentPath,
        parent: this.parent,
        container: this.container,
        listKey: this.listKey,
        key: to
      }));
    }
  }

  var contexts = this._getQueueContexts();

  for (var _iterator = paths, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var _path = _ref;

    _path.setScope();
    _path.debug(function () {
      return "Inserted.";
    });

    for (var _iterator2 = contexts, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var context = _ref2;

      context.maybeQueue(_path, true);
    }
  }

  return paths;
}

function _containerInsertBefore(nodes) {
  return this._containerInsert(this.key, nodes);
}

function _containerInsertAfter(nodes) {
  return this._containerInsert(this.key + 1, nodes);
}

function _maybePopFromStatements(nodes) {
  var last = nodes[nodes.length - 1];
  var isIdentifier = t.isIdentifier(last) || t.isExpressionStatement(last) && t.isIdentifier(last.expression);

  if (isIdentifier && !this.isCompletionRecord()) {
    nodes.pop();
  }
}

function insertAfter(nodes) {
  this._assertUnremoved();

  nodes = this._verifyNodeList(nodes);

  if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {
    return this.parentPath.insertAfter(nodes);
  } else if (this.isNodeType("Expression") || this.parentPath.isForStatement() && this.key === "init") {
    if (this.node) {
      var temp = this.scope.generateDeclaredUidIdentifier();
      nodes.unshift(t.expressionStatement(t.assignmentExpression("=", temp, this.node)));
      nodes.push(t.expressionStatement(temp));
    }
    this.replaceExpressionWithStatements(nodes);
  } else {
    this._maybePopFromStatements(nodes);
    if (Array.isArray(this.container)) {
      return this._containerInsertAfter(nodes);
    } else if (this.isStatementOrBlock()) {
      if (this.node) nodes.unshift(this.node);
      this._replaceWith(t.blockStatement(nodes));
    } else {
      throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
    }
  }

  return [this];
}

function updateSiblingKeys(fromIndex, incrementBy) {
  if (!this.parent) return;

  var paths = _cache.path.get(this.parent);
  for (var i = 0; i < paths.length; i++) {
    var path = paths[i];
    if (path.key >= fromIndex) {
      path.key += incrementBy;
    }
  }
}

function _verifyNodeList(nodes) {
  if (!nodes) {
    return [];
  }

  if (nodes.constructor !== Array) {
    nodes = [nodes];
  }

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    var msg = void 0;

    if (!node) {
      msg = "has falsy node";
    } else if ((typeof node === "undefined" ? "undefined" : (0, _typeof3.default)(node)) !== "object") {
      msg = "contains a non-object node";
    } else if (!node.type) {
      msg = "without a type";
    } else if (node instanceof _index2.default) {
      msg = "has a NodePath when it expected a raw object";
    }

    if (msg) {
      var type = Array.isArray(node) ? "array" : typeof node === "undefined" ? "undefined" : (0, _typeof3.default)(node);
      throw new Error("Node list " + msg + " with the index of " + i + " and type of " + type);
    }
  }

  return nodes;
}

function unshiftContainer(listKey, nodes) {
  this._assertUnremoved();

  nodes = this._verifyNodeList(nodes);

  var path = _index2.default.get({
    parentPath: this,
    parent: this.node,
    container: this.node[listKey],
    listKey: listKey,
    key: 0
  });

  return path.insertBefore(nodes);
}

function pushContainer(listKey, nodes) {
  this._assertUnremoved();

  nodes = this._verifyNodeList(nodes);

  var container = this.node[listKey];
  var path = _index2.default.get({
    parentPath: this,
    parent: this.node,
    container: container,
    listKey: listKey,
    key: container.length
  });

  return path.replaceWithMultiple(nodes);
}

function hoist() {
  var scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.scope;

  var hoister = new _hoister2.default(this, scope);
  return hoister.run();
}
},{"../cache":22,"./index":32,"./lib/hoister":37,"babel-runtime/core-js/get-iterator":9,"babel-runtime/helpers/typeof":21,"babel-types":58}],41:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.remove = remove;
exports._callRemovalHooks = _callRemovalHooks;
exports._remove = _remove;
exports._markRemoved = _markRemoved;
exports._assertUnremoved = _assertUnremoved;

var _removalHooks = require("./lib/removal-hooks");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function remove() {
  this._assertUnremoved();

  this.resync();

  if (this._callRemovalHooks()) {
    this._markRemoved();
    return;
  }

  this.shareCommentsWithSiblings();
  this._remove();
  this._markRemoved();
}

function _callRemovalHooks() {
  for (var _iterator = _removalHooks.hooks, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var fn = _ref;

    if (fn(this, this.parentPath)) return true;
  }
}

function _remove() {
  if (Array.isArray(this.container)) {
    this.container.splice(this.key, 1);
    this.updateSiblingKeys(this.key, -1);
  } else {
    this._replaceWith(null);
  }
}

function _markRemoved() {
  this.shouldSkip = true;
  this.removed = true;
  this.node = null;
}

function _assertUnremoved() {
  if (this.removed) {
    throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }
}
},{"./lib/removal-hooks":38,"babel-runtime/core-js/get-iterator":9}],42:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.replaceWithMultiple = replaceWithMultiple;
exports.replaceWithSourceString = replaceWithSourceString;
exports.replaceWith = replaceWith;
exports._replaceWith = _replaceWith;
exports.replaceExpressionWithStatements = replaceExpressionWithStatements;
exports.replaceInline = replaceInline;

var _babelCodeFrame = require("babel-code-frame");

var _babelCodeFrame2 = _interopRequireDefault(_babelCodeFrame);

var _index = require("../index");

var _index2 = _interopRequireDefault(_index);

var _index3 = require("./index");

var _index4 = _interopRequireDefault(_index3);

var _babylon = require("babylon");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hoistVariablesVisitor = {
  Function: function Function(path) {
    path.skip();
  },
  VariableDeclaration: function VariableDeclaration(path) {
    if (path.node.kind !== "var") return;

    var bindings = path.getBindingIdentifiers();
    for (var key in bindings) {
      path.scope.push({ id: bindings[key] });
    }

    var exprs = [];

    for (var _iterator = path.node.declarations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var declar = _ref;

      if (declar.init) {
        exprs.push(t.expressionStatement(t.assignmentExpression("=", declar.id, declar.init)));
      }
    }

    path.replaceWithMultiple(exprs);
  }
};

function replaceWithMultiple(nodes) {
  this.resync();

  nodes = this._verifyNodeList(nodes);
  t.inheritLeadingComments(nodes[0], this.node);
  t.inheritTrailingComments(nodes[nodes.length - 1], this.node);
  this.node = this.container[this.key] = null;
  this.insertAfter(nodes);

  if (this.node) {
    this.requeue();
  } else {
    this.remove();
  }
}

function replaceWithSourceString(replacement) {
  this.resync();

  try {
    replacement = "(" + replacement + ")";
    replacement = (0, _babylon.parse)(replacement);
  } catch (err) {
    var loc = err.loc;
    if (loc) {
      err.message += " - make sure this is an expression.";
      err.message += "\n" + (0, _babelCodeFrame2.default)(replacement, loc.line, loc.column + 1);
    }
    throw err;
  }

  replacement = replacement.program.body[0].expression;
  _index2.default.removeProperties(replacement);
  return this.replaceWith(replacement);
}

function replaceWith(replacement) {
  this.resync();

  if (this.removed) {
    throw new Error("You can't replace this node, we've already removed it");
  }

  if (replacement instanceof _index4.default) {
    replacement = replacement.node;
  }

  if (!replacement) {
    throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
  }

  if (this.node === replacement) {
    return;
  }

  if (this.isProgram() && !t.isProgram(replacement)) {
    throw new Error("You can only replace a Program root node with another Program node");
  }

  if (Array.isArray(replacement)) {
    throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
  }

  if (typeof replacement === "string") {
    throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
  }

  if (this.isNodeType("Statement") && t.isExpression(replacement)) {
    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
      replacement = t.expressionStatement(replacement);
    }
  }

  if (this.isNodeType("Expression") && t.isStatement(replacement)) {
    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
      return this.replaceExpressionWithStatements([replacement]);
    }
  }

  var oldNode = this.node;
  if (oldNode) {
    t.inheritsComments(replacement, oldNode);
    t.removeComments(oldNode);
  }

  this._replaceWith(replacement);
  this.type = replacement.type;

  this.setScope();

  this.requeue();
}

function _replaceWith(node) {
  if (!this.container) {
    throw new ReferenceError("Container is falsy");
  }

  if (this.inList) {
    t.validate(this.parent, this.key, [node]);
  } else {
    t.validate(this.parent, this.key, node);
  }

  this.debug(function () {
    return "Replace with " + (node && node.type);
  });

  this.node = this.container[this.key] = node;
}

function replaceExpressionWithStatements(nodes) {
  this.resync();

  var toSequenceExpression = t.toSequenceExpression(nodes, this.scope);

  if (t.isSequenceExpression(toSequenceExpression)) {
    var exprs = toSequenceExpression.expressions;

    if (exprs.length >= 2 && this.parentPath.isExpressionStatement()) {
      this._maybePopFromStatements(exprs);
    }

    if (exprs.length === 1) {
      this.replaceWith(exprs[0]);
    } else {
      this.replaceWith(toSequenceExpression);
    }
  } else if (toSequenceExpression) {
    this.replaceWith(toSequenceExpression);
  } else {
    var container = t.functionExpression(null, [], t.blockStatement(nodes));
    container.shadow = true;

    this.replaceWith(t.callExpression(container, []));
    this.traverse(hoistVariablesVisitor);

    var completionRecords = this.get("callee").getCompletionRecords();
    for (var _iterator2 = completionRecords, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var path = _ref2;

      if (!path.isExpressionStatement()) continue;

      var loop = path.findParent(function (path) {
        return path.isLoop();
      });
      if (loop) {
        var uid = loop.getData("expressionReplacementReturnUid");

        if (!uid) {
          var callee = this.get("callee");
          uid = callee.scope.generateDeclaredUidIdentifier("ret");
          callee.get("body").pushContainer("body", t.returnStatement(uid));
          loop.setData("expressionReplacementReturnUid", uid);
        } else {
          uid = t.identifier(uid.name);
        }

        path.get("expression").replaceWith(t.assignmentExpression("=", uid, path.node.expression));
      } else {
        path.replaceWith(t.returnStatement(path.node.expression));
      }
    }

    return this.node;
  }
}

function replaceInline(nodes) {
  this.resync();

  if (Array.isArray(nodes)) {
    if (Array.isArray(this.container)) {
      nodes = this._verifyNodeList(nodes);
      this._containerInsertAfter(nodes);
      return this.remove();
    } else {
      return this.replaceWithMultiple(nodes);
    }
  } else {
    return this.replaceWith(nodes);
  }
}
},{"../index":25,"./index":32,"babel-code-frame":7,"babel-runtime/core-js/get-iterator":9,"babel-types":58,"babylon":62}],43:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Binding = function () {
  function Binding(_ref) {
    var existing = _ref.existing,
        identifier = _ref.identifier,
        scope = _ref.scope,
        path = _ref.path,
        kind = _ref.kind;
    (0, _classCallCheck3.default)(this, Binding);

    this.identifier = identifier;
    this.scope = scope;
    this.path = path;
    this.kind = kind;

    this.constantViolations = [];
    this.constant = true;

    this.referencePaths = [];
    this.referenced = false;
    this.references = 0;

    this.clearValue();

    if (existing) {
      this.constantViolations = [].concat(existing.path, existing.constantViolations, this.constantViolations);
    }
  }

  Binding.prototype.deoptValue = function deoptValue() {
    this.clearValue();
    this.hasDeoptedValue = true;
  };

  Binding.prototype.setValue = function setValue(value) {
    if (this.hasDeoptedValue) return;
    this.hasValue = true;
    this.value = value;
  };

  Binding.prototype.clearValue = function clearValue() {
    this.hasDeoptedValue = false;
    this.hasValue = false;
    this.value = null;
  };

  Binding.prototype.reassign = function reassign(path) {
    this.constant = false;
    if (this.constantViolations.indexOf(path) !== -1) {
      return;
    }
    this.constantViolations.push(path);
  };

  Binding.prototype.reference = function reference(path) {
    if (this.referencePaths.indexOf(path) !== -1) {
      return;
    }
    this.referenced = true;
    this.references++;
    this.referencePaths.push(path);
  };

  Binding.prototype.dereference = function dereference() {
    this.references--;
    this.referenced = !!this.references;
  };

  return Binding;
}();

exports.default = Binding;
module.exports = exports["default"];
},{"babel-runtime/helpers/classCallCheck":20}],44:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _create = require("babel-runtime/core-js/object/create");

var _create2 = _interopRequireDefault(_create);

var _map = require("babel-runtime/core-js/map");

var _map2 = _interopRequireDefault(_map);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _includes = require("lodash/includes");

var _includes2 = _interopRequireDefault(_includes);

var _repeat = require("lodash/repeat");

var _repeat2 = _interopRequireDefault(_repeat);

var _renamer = require("./lib/renamer");

var _renamer2 = _interopRequireDefault(_renamer);

var _index = require("../index");

var _index2 = _interopRequireDefault(_index);

var _defaults = require("lodash/defaults");

var _defaults2 = _interopRequireDefault(_defaults);

var _babelMessages = require("babel-messages");

var messages = _interopRequireWildcard(_babelMessages);

var _binding2 = require("./binding");

var _binding3 = _interopRequireDefault(_binding2);

var _globals = require("globals");

var _globals2 = _interopRequireDefault(_globals);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _cache = require("../cache");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _crawlCallsCount = 0;

function getCache(path, parentScope, self) {
  var scopes = _cache.scope.get(path.node) || [];

  for (var _iterator = scopes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var scope = _ref;

    if (scope.parent === parentScope && scope.path === path) return scope;
  }

  scopes.push(self);

  if (!_cache.scope.has(path.node)) {
    _cache.scope.set(path.node, scopes);
  }
}

function gatherNodeParts(node, parts) {
  if (t.isModuleDeclaration(node)) {
    if (node.source) {
      gatherNodeParts(node.source, parts);
    } else if (node.specifiers && node.specifiers.length) {
      for (var _iterator2 = node.specifiers, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var specifier = _ref2;

        gatherNodeParts(specifier, parts);
      }
    } else if (node.declaration) {
      gatherNodeParts(node.declaration, parts);
    }
  } else if (t.isModuleSpecifier(node)) {
    gatherNodeParts(node.local, parts);
  } else if (t.isMemberExpression(node)) {
    gatherNodeParts(node.object, parts);
    gatherNodeParts(node.property, parts);
  } else if (t.isIdentifier(node)) {
    parts.push(node.name);
  } else if (t.isLiteral(node)) {
    parts.push(node.value);
  } else if (t.isCallExpression(node)) {
    gatherNodeParts(node.callee, parts);
  } else if (t.isObjectExpression(node) || t.isObjectPattern(node)) {
    for (var _iterator3 = node.properties, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var prop = _ref3;

      gatherNodeParts(prop.key || prop.argument, parts);
    }
  }
}

var collectorVisitor = {
  For: function For(path) {
    for (var _iterator4 = t.FOR_INIT_KEYS, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {
      var _ref4;

      if (_isArray4) {
        if (_i4 >= _iterator4.length) break;
        _ref4 = _iterator4[_i4++];
      } else {
        _i4 = _iterator4.next();
        if (_i4.done) break;
        _ref4 = _i4.value;
      }

      var key = _ref4;

      var declar = path.get(key);
      if (declar.isVar()) path.scope.getFunctionParent().registerBinding("var", declar);
    }
  },
  Declaration: function Declaration(path) {
    if (path.isBlockScoped()) return;

    if (path.isExportDeclaration() && path.get("declaration").isDeclaration()) return;

    path.scope.getFunctionParent().registerDeclaration(path);
  },
  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
    state.references.push(path);
  },
  ForXStatement: function ForXStatement(path, state) {
    var left = path.get("left");
    if (left.isPattern() || left.isIdentifier()) {
      state.constantViolations.push(left);
    }
  },


  ExportDeclaration: {
    exit: function exit(path) {
      var node = path.node,
          scope = path.scope;

      var declar = node.declaration;
      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {
        var _id = declar.id;
        if (!_id) return;

        var binding = scope.getBinding(_id.name);
        if (binding) binding.reference(path);
      } else if (t.isVariableDeclaration(declar)) {
        for (var _iterator5 = declar.declarations, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);;) {
          var _ref5;

          if (_isArray5) {
            if (_i5 >= _iterator5.length) break;
            _ref5 = _iterator5[_i5++];
          } else {
            _i5 = _iterator5.next();
            if (_i5.done) break;
            _ref5 = _i5.value;
          }

          var decl = _ref5;

          var ids = t.getBindingIdentifiers(decl);
          for (var name in ids) {
            var _binding = scope.getBinding(name);
            if (_binding) _binding.reference(path);
          }
        }
      }
    }
  },

  LabeledStatement: function LabeledStatement(path) {
    path.scope.getProgramParent().addGlobal(path.node);
    path.scope.getBlockParent().registerDeclaration(path);
  },
  AssignmentExpression: function AssignmentExpression(path, state) {
    state.assignments.push(path);
  },
  UpdateExpression: function UpdateExpression(path, state) {
    state.constantViolations.push(path.get("argument"));
  },
  UnaryExpression: function UnaryExpression(path, state) {
    if (path.node.operator === "delete") {
      state.constantViolations.push(path.get("argument"));
    }
  },
  BlockScoped: function BlockScoped(path) {
    var scope = path.scope;
    if (scope.path === path) scope = scope.parent;
    scope.getBlockParent().registerDeclaration(path);
  },
  ClassDeclaration: function ClassDeclaration(path) {
    var id = path.node.id;
    if (!id) return;

    var name = id.name;
    path.scope.bindings[name] = path.scope.getBinding(name);
  },
  Block: function Block(path) {
    var paths = path.get("body");
    for (var _iterator6 = paths, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : (0, _getIterator3.default)(_iterator6);;) {
      var _ref6;

      if (_isArray6) {
        if (_i6 >= _iterator6.length) break;
        _ref6 = _iterator6[_i6++];
      } else {
        _i6 = _iterator6.next();
        if (_i6.done) break;
        _ref6 = _i6.value;
      }

      var bodyPath = _ref6;

      if (bodyPath.isFunctionDeclaration()) {
        path.scope.getBlockParent().registerDeclaration(bodyPath);
      }
    }
  }
};

var uid = 0;

var Scope = function () {
  function Scope(path, parentScope) {
    (0, _classCallCheck3.default)(this, Scope);

    if (parentScope && parentScope.block === path.node) {
      return parentScope;
    }

    var cached = getCache(path, parentScope, this);
    if (cached) return cached;

    this.uid = uid++;
    this.parent = parentScope;
    this.hub = path.hub;

    this.parentBlock = path.parent;
    this.block = path.node;
    this.path = path;

    this.labels = new _map2.default();
  }

  Scope.prototype.traverse = function traverse(node, opts, state) {
    (0, _index2.default)(node, opts, this, state, this.path);
  };

  Scope.prototype.generateDeclaredUidIdentifier = function generateDeclaredUidIdentifier() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "temp";

    var id = this.generateUidIdentifier(name);
    this.push({ id: id });
    return id;
  };

  Scope.prototype.generateUidIdentifier = function generateUidIdentifier() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "temp";

    return t.identifier(this.generateUid(name));
  };

  Scope.prototype.generateUid = function generateUid() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "temp";

    name = t.toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, "");

    var uid = void 0;
    var i = 0;
    do {
      uid = this._generateUid(name, i);
      i++;
    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));

    var program = this.getProgramParent();
    program.references[uid] = true;
    program.uids[uid] = true;

    return uid;
  };

  Scope.prototype._generateUid = function _generateUid(name, i) {
    var id = name;
    if (i > 1) id += i;
    return "_" + id;
  };

  Scope.prototype.generateUidIdentifierBasedOnNode = function generateUidIdentifierBasedOnNode(parent, defaultName) {
    var node = parent;

    if (t.isAssignmentExpression(parent)) {
      node = parent.left;
    } else if (t.isVariableDeclarator(parent)) {
      node = parent.id;
    } else if (t.isObjectProperty(node) || t.isObjectMethod(node)) {
      node = node.key;
    }

    var parts = [];
    gatherNodeParts(node, parts);

    var id = parts.join("$");
    id = id.replace(/^_/, "") || defaultName || "ref";

    return this.generateUidIdentifier(id.slice(0, 20));
  };

  Scope.prototype.isStatic = function isStatic(node) {
    if (t.isThisExpression(node) || t.isSuper(node)) {
      return true;
    }

    if (t.isIdentifier(node)) {
      var binding = this.getBinding(node.name);
      if (binding) {
        return binding.constant;
      } else {
        return this.hasBinding(node.name);
      }
    }

    return false;
  };

  Scope.prototype.maybeGenerateMemoised = function maybeGenerateMemoised(node, dontPush) {
    if (this.isStatic(node)) {
      return null;
    } else {
      var _id2 = this.generateUidIdentifierBasedOnNode(node);
      if (!dontPush) this.push({ id: _id2 });
      return _id2;
    }
  };

  Scope.prototype.checkBlockScopedCollisions = function checkBlockScopedCollisions(local, kind, name, id) {
    if (kind === "param") return;

    if (kind === "hoisted" && local.kind === "let") return;

    var duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && (kind === "let" || kind === "const");

    if (duplicate) {
      throw this.hub.file.buildCodeFrameError(id, messages.get("scopeDuplicateDeclaration", name), TypeError);
    }
  };

  Scope.prototype.rename = function rename(oldName, newName, block) {
    var binding = this.getBinding(oldName);
    if (binding) {
      newName = newName || this.generateUidIdentifier(oldName).name;
      return new _renamer2.default(binding, oldName, newName).rename(block);
    }
  };

  Scope.prototype._renameFromMap = function _renameFromMap(map, oldName, newName, value) {
    if (map[oldName]) {
      map[newName] = value;
      map[oldName] = null;
    }
  };

  Scope.prototype.dump = function dump() {
    var sep = (0, _repeat2.default)("-", 60);
    console.log(sep);
    var scope = this;
    do {
      console.log("#", scope.block.type);
      for (var name in scope.bindings) {
        var binding = scope.bindings[name];
        console.log(" -", name, {
          constant: binding.constant,
          references: binding.references,
          violations: binding.constantViolations.length,
          kind: binding.kind
        });
      }
    } while (scope = scope.parent);
    console.log(sep);
  };

  Scope.prototype.toArray = function toArray(node, i) {
    var file = this.hub.file;

    if (t.isIdentifier(node)) {
      var binding = this.getBinding(node.name);
      if (binding && binding.constant && binding.path.isGenericType("Array")) return node;
    }

    if (t.isArrayExpression(node)) {
      return node;
    }

    if (t.isIdentifier(node, { name: "arguments" })) {
      return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier("Array"), t.identifier("prototype")), t.identifier("slice")), t.identifier("call")), [node]);
    }

    var helperName = "toArray";
    var args = [node];
    if (i === true) {
      helperName = "toConsumableArray";
    } else if (i) {
      args.push(t.numericLiteral(i));
      helperName = "slicedToArray";
    }
    return t.callExpression(file.addHelper(helperName), args);
  };

  Scope.prototype.hasLabel = function hasLabel(name) {
    return !!this.getLabel(name);
  };

  Scope.prototype.getLabel = function getLabel(name) {
    return this.labels.get(name);
  };

  Scope.prototype.registerLabel = function registerLabel(path) {
    this.labels.set(path.node.label.name, path);
  };

  Scope.prototype.registerDeclaration = function registerDeclaration(path) {
    if (path.isLabeledStatement()) {
      this.registerLabel(path);
    } else if (path.isFunctionDeclaration()) {
      this.registerBinding("hoisted", path.get("id"), path);
    } else if (path.isVariableDeclaration()) {
      var declarations = path.get("declarations");
      for (var _iterator7 = declarations, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : (0, _getIterator3.default)(_iterator7);;) {
        var _ref7;

        if (_isArray7) {
          if (_i7 >= _iterator7.length) break;
          _ref7 = _iterator7[_i7++];
        } else {
          _i7 = _iterator7.next();
          if (_i7.done) break;
          _ref7 = _i7.value;
        }

        var declar = _ref7;

        this.registerBinding(path.node.kind, declar);
      }
    } else if (path.isClassDeclaration()) {
      this.registerBinding("let", path);
    } else if (path.isImportDeclaration()) {
      var specifiers = path.get("specifiers");
      for (var _iterator8 = specifiers, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : (0, _getIterator3.default)(_iterator8);;) {
        var _ref8;

        if (_isArray8) {
          if (_i8 >= _iterator8.length) break;
          _ref8 = _iterator8[_i8++];
        } else {
          _i8 = _iterator8.next();
          if (_i8.done) break;
          _ref8 = _i8.value;
        }

        var specifier = _ref8;

        this.registerBinding("module", specifier);
      }
    } else if (path.isExportDeclaration()) {
      var _declar = path.get("declaration");
      if (_declar.isClassDeclaration() || _declar.isFunctionDeclaration() || _declar.isVariableDeclaration()) {
        this.registerDeclaration(_declar);
      }
    } else {
      this.registerBinding("unknown", path);
    }
  };

  Scope.prototype.buildUndefinedNode = function buildUndefinedNode() {
    if (this.hasBinding("undefined")) {
      return t.unaryExpression("void", t.numericLiteral(0), true);
    } else {
      return t.identifier("undefined");
    }
  };

  Scope.prototype.registerConstantViolation = function registerConstantViolation(path) {
    var ids = path.getBindingIdentifiers();
    for (var name in ids) {
      var binding = this.getBinding(name);
      if (binding) binding.reassign(path);
    }
  };

  Scope.prototype.registerBinding = function registerBinding(kind, path) {
    var bindingPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path;

    if (!kind) throw new ReferenceError("no `kind`");

    if (path.isVariableDeclaration()) {
      var declarators = path.get("declarations");
      for (var _iterator9 = declarators, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : (0, _getIterator3.default)(_iterator9);;) {
        var _ref9;

        if (_isArray9) {
          if (_i9 >= _iterator9.length) break;
          _ref9 = _iterator9[_i9++];
        } else {
          _i9 = _iterator9.next();
          if (_i9.done) break;
          _ref9 = _i9.value;
        }

        var declar = _ref9;

        this.registerBinding(kind, declar);
      }
      return;
    }

    var parent = this.getProgramParent();
    var ids = path.getBindingIdentifiers(true);

    for (var name in ids) {
      for (var _iterator10 = ids[name], _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : (0, _getIterator3.default)(_iterator10);;) {
        var _ref10;

        if (_isArray10) {
          if (_i10 >= _iterator10.length) break;
          _ref10 = _iterator10[_i10++];
        } else {
          _i10 = _iterator10.next();
          if (_i10.done) break;
          _ref10 = _i10.value;
        }

        var _id3 = _ref10;

        var local = this.getOwnBinding(name);
        if (local) {
          if (local.identifier === _id3) continue;

          this.checkBlockScopedCollisions(local, kind, name, _id3);
        }

        if (local && local.path.isFlow()) local = null;

        parent.references[name] = true;

        this.bindings[name] = new _binding3.default({
          identifier: _id3,
          existing: local,
          scope: this,
          path: bindingPath,
          kind: kind
        });
      }
    }
  };

  Scope.prototype.addGlobal = function addGlobal(node) {
    this.globals[node.name] = node;
  };

  Scope.prototype.hasUid = function hasUid(name) {
    var scope = this;

    do {
      if (scope.uids[name]) return true;
    } while (scope = scope.parent);

    return false;
  };

  Scope.prototype.hasGlobal = function hasGlobal(name) {
    var scope = this;

    do {
      if (scope.globals[name]) return true;
    } while (scope = scope.parent);

    return false;
  };

  Scope.prototype.hasReference = function hasReference(name) {
    var scope = this;

    do {
      if (scope.references[name]) return true;
    } while (scope = scope.parent);

    return false;
  };

  Scope.prototype.isPure = function isPure(node, constantsOnly) {
    if (t.isIdentifier(node)) {
      var binding = this.getBinding(node.name);
      if (!binding) return false;
      if (constantsOnly) return binding.constant;
      return true;
    } else if (t.isClass(node)) {
      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) return false;
      return this.isPure(node.body, constantsOnly);
    } else if (t.isClassBody(node)) {
      for (var _iterator11 = node.body, _isArray11 = Array.isArray(_iterator11), _i11 = 0, _iterator11 = _isArray11 ? _iterator11 : (0, _getIterator3.default)(_iterator11);;) {
        var _ref11;

        if (_isArray11) {
          if (_i11 >= _iterator11.length) break;
          _ref11 = _iterator11[_i11++];
        } else {
          _i11 = _iterator11.next();
          if (_i11.done) break;
          _ref11 = _i11.value;
        }

        var method = _ref11;

        if (!this.isPure(method, constantsOnly)) return false;
      }
      return true;
    } else if (t.isBinary(node)) {
      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
    } else if (t.isArrayExpression(node)) {
      for (var _iterator12 = node.elements, _isArray12 = Array.isArray(_iterator12), _i12 = 0, _iterator12 = _isArray12 ? _iterator12 : (0, _getIterator3.default)(_iterator12);;) {
        var _ref12;

        if (_isArray12) {
          if (_i12 >= _iterator12.length) break;
          _ref12 = _iterator12[_i12++];
        } else {
          _i12 = _iterator12.next();
          if (_i12.done) break;
          _ref12 = _i12.value;
        }

        var elem = _ref12;

        if (!this.isPure(elem, constantsOnly)) return false;
      }
      return true;
    } else if (t.isObjectExpression(node)) {
      for (var _iterator13 = node.properties, _isArray13 = Array.isArray(_iterator13), _i13 = 0, _iterator13 = _isArray13 ? _iterator13 : (0, _getIterator3.default)(_iterator13);;) {
        var _ref13;

        if (_isArray13) {
          if (_i13 >= _iterator13.length) break;
          _ref13 = _iterator13[_i13++];
        } else {
          _i13 = _iterator13.next();
          if (_i13.done) break;
          _ref13 = _i13.value;
        }

        var prop = _ref13;

        if (!this.isPure(prop, constantsOnly)) return false;
      }
      return true;
    } else if (t.isClassMethod(node)) {
      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
      if (node.kind === "get" || node.kind === "set") return false;
      return true;
    } else if (t.isClassProperty(node) || t.isObjectProperty(node)) {
      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
      return this.isPure(node.value, constantsOnly);
    } else if (t.isUnaryExpression(node)) {
      return this.isPure(node.argument, constantsOnly);
    } else {
      return t.isPureish(node);
    }
  };

  Scope.prototype.setData = function setData(key, val) {
    return this.data[key] = val;
  };

  Scope.prototype.getData = function getData(key) {
    var scope = this;
    do {
      var data = scope.data[key];
      if (data != null) return data;
    } while (scope = scope.parent);
  };

  Scope.prototype.removeData = function removeData(key) {
    var scope = this;
    do {
      var data = scope.data[key];
      if (data != null) scope.data[key] = null;
    } while (scope = scope.parent);
  };

  Scope.prototype.init = function init() {
    if (!this.references) this.crawl();
  };

  Scope.prototype.crawl = function crawl() {
    _crawlCallsCount++;
    this._crawl();
    _crawlCallsCount--;
  };

  Scope.prototype._crawl = function _crawl() {
    var path = this.path;

    this.references = (0, _create2.default)(null);
    this.bindings = (0, _create2.default)(null);
    this.globals = (0, _create2.default)(null);
    this.uids = (0, _create2.default)(null);
    this.data = (0, _create2.default)(null);

    if (path.isLoop()) {
      for (var _iterator14 = t.FOR_INIT_KEYS, _isArray14 = Array.isArray(_iterator14), _i14 = 0, _iterator14 = _isArray14 ? _iterator14 : (0, _getIterator3.default)(_iterator14);;) {
        var _ref14;

        if (_isArray14) {
          if (_i14 >= _iterator14.length) break;
          _ref14 = _iterator14[_i14++];
        } else {
          _i14 = _iterator14.next();
          if (_i14.done) break;
          _ref14 = _i14.value;
        }

        var key = _ref14;

        var node = path.get(key);
        if (node.isBlockScoped()) this.registerBinding(node.node.kind, node);
      }
    }

    if (path.isFunctionExpression() && path.has("id")) {
      if (!path.get("id").node[t.NOT_LOCAL_BINDING]) {
        this.registerBinding("local", path.get("id"), path);
      }
    }

    if (path.isClassExpression() && path.has("id")) {
      if (!path.get("id").node[t.NOT_LOCAL_BINDING]) {
        this.registerBinding("local", path);
      }
    }

    if (path.isFunction()) {
      var params = path.get("params");
      for (var _iterator15 = params, _isArray15 = Array.isArray(_iterator15), _i15 = 0, _iterator15 = _isArray15 ? _iterator15 : (0, _getIterator3.default)(_iterator15);;) {
        var _ref15;

        if (_isArray15) {
          if (_i15 >= _iterator15.length) break;
          _ref15 = _iterator15[_i15++];
        } else {
          _i15 = _iterator15.next();
          if (_i15.done) break;
          _ref15 = _i15.value;
        }

        var param = _ref15;

        this.registerBinding("param", param);
      }
    }

    if (path.isCatchClause()) {
      this.registerBinding("let", path);
    }

    var parent = this.getProgramParent();
    if (parent.crawling) return;

    var state = {
      references: [],
      constantViolations: [],
      assignments: []
    };

    this.crawling = true;
    path.traverse(collectorVisitor, state);
    this.crawling = false;

    for (var _iterator16 = state.assignments, _isArray16 = Array.isArray(_iterator16), _i16 = 0, _iterator16 = _isArray16 ? _iterator16 : (0, _getIterator3.default)(_iterator16);;) {
      var _ref16;

      if (_isArray16) {
        if (_i16 >= _iterator16.length) break;
        _ref16 = _iterator16[_i16++];
      } else {
        _i16 = _iterator16.next();
        if (_i16.done) break;
        _ref16 = _i16.value;
      }

      var _path = _ref16;

      var ids = _path.getBindingIdentifiers();
      var programParent = void 0;
      for (var name in ids) {
        if (_path.scope.getBinding(name)) continue;

        programParent = programParent || _path.scope.getProgramParent();
        programParent.addGlobal(ids[name]);
      }

      _path.scope.registerConstantViolation(_path);
    }

    for (var _iterator17 = state.references, _isArray17 = Array.isArray(_iterator17), _i17 = 0, _iterator17 = _isArray17 ? _iterator17 : (0, _getIterator3.default)(_iterator17);;) {
      var _ref17;

      if (_isArray17) {
        if (_i17 >= _iterator17.length) break;
        _ref17 = _iterator17[_i17++];
      } else {
        _i17 = _iterator17.next();
        if (_i17.done) break;
        _ref17 = _i17.value;
      }

      var ref = _ref17;

      var binding = ref.scope.getBinding(ref.node.name);
      if (binding) {
        binding.reference(ref);
      } else {
        ref.scope.getProgramParent().addGlobal(ref.node);
      }
    }

    for (var _iterator18 = state.constantViolations, _isArray18 = Array.isArray(_iterator18), _i18 = 0, _iterator18 = _isArray18 ? _iterator18 : (0, _getIterator3.default)(_iterator18);;) {
      var _ref18;

      if (_isArray18) {
        if (_i18 >= _iterator18.length) break;
        _ref18 = _iterator18[_i18++];
      } else {
        _i18 = _iterator18.next();
        if (_i18.done) break;
        _ref18 = _i18.value;
      }

      var _path2 = _ref18;

      _path2.scope.registerConstantViolation(_path2);
    }
  };

  Scope.prototype.push = function push(opts) {
    var path = this.path;

    if (!path.isBlockStatement() && !path.isProgram()) {
      path = this.getBlockParent().path;
    }

    if (path.isSwitchStatement()) {
      path = this.getFunctionParent().path;
    }

    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
      t.ensureBlock(path.node);
      path = path.get("body");
    }

    var unique = opts.unique;
    var kind = opts.kind || "var";
    var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;

    var dataKey = "declaration:" + kind + ":" + blockHoist;
    var declarPath = !unique && path.getData(dataKey);

    if (!declarPath) {
      var declar = t.variableDeclaration(kind, []);
      declar._generated = true;
      declar._blockHoist = blockHoist;

      var _path$unshiftContaine = path.unshiftContainer("body", [declar]);

      declarPath = _path$unshiftContaine[0];

      if (!unique) path.setData(dataKey, declarPath);
    }

    var declarator = t.variableDeclarator(opts.id, opts.init);
    declarPath.node.declarations.push(declarator);
    this.registerBinding(kind, declarPath.get("declarations").pop());
  };

  Scope.prototype.getProgramParent = function getProgramParent() {
    var scope = this;
    do {
      if (scope.path.isProgram()) {
        return scope;
      }
    } while (scope = scope.parent);
    throw new Error("We couldn't find a Function or Program...");
  };

  Scope.prototype.getFunctionParent = function getFunctionParent() {
    var scope = this;
    do {
      if (scope.path.isFunctionParent()) {
        return scope;
      }
    } while (scope = scope.parent);
    throw new Error("We couldn't find a Function or Program...");
  };

  Scope.prototype.getBlockParent = function getBlockParent() {
    var scope = this;
    do {
      if (scope.path.isBlockParent()) {
        return scope;
      }
    } while (scope = scope.parent);
    throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
  };

  Scope.prototype.getAllBindings = function getAllBindings() {
    var ids = (0, _create2.default)(null);

    var scope = this;
    do {
      (0, _defaults2.default)(ids, scope.bindings);
      scope = scope.parent;
    } while (scope);

    return ids;
  };

  Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind() {
    var ids = (0, _create2.default)(null);

    for (var _iterator19 = arguments, _isArray19 = Array.isArray(_iterator19), _i19 = 0, _iterator19 = _isArray19 ? _iterator19 : (0, _getIterator3.default)(_iterator19);;) {
      var _ref19;

      if (_isArray19) {
        if (_i19 >= _iterator19.length) break;
        _ref19 = _iterator19[_i19++];
      } else {
        _i19 = _iterator19.next();
        if (_i19.done) break;
        _ref19 = _i19.value;
      }

      var kind = _ref19;

      var scope = this;
      do {
        for (var name in scope.bindings) {
          var binding = scope.bindings[name];
          if (binding.kind === kind) ids[name] = binding;
        }
        scope = scope.parent;
      } while (scope);
    }

    return ids;
  };

  Scope.prototype.bindingIdentifierEquals = function bindingIdentifierEquals(name, node) {
    return this.getBindingIdentifier(name) === node;
  };

  Scope.prototype.warnOnFlowBinding = function warnOnFlowBinding(binding) {
    if (_crawlCallsCount === 0 && binding && binding.path.isFlow()) {
      console.warn("\n        You or one of the Babel plugins you are using are using Flow declarations as bindings.\n        Support for this will be removed in version 6.8. To find out the caller, grep for this\n        message and change it to a `console.trace()`.\n      ");
    }
    return binding;
  };

  Scope.prototype.getBinding = function getBinding(name) {
    var scope = this;

    do {
      var binding = scope.getOwnBinding(name);
      if (binding) return this.warnOnFlowBinding(binding);
    } while (scope = scope.parent);
  };

  Scope.prototype.getOwnBinding = function getOwnBinding(name) {
    return this.warnOnFlowBinding(this.bindings[name]);
  };

  Scope.prototype.getBindingIdentifier = function getBindingIdentifier(name) {
    var info = this.getBinding(name);
    return info && info.identifier;
  };

  Scope.prototype.getOwnBindingIdentifier = function getOwnBindingIdentifier(name) {
    var binding = this.bindings[name];
    return binding && binding.identifier;
  };

  Scope.prototype.hasOwnBinding = function hasOwnBinding(name) {
    return !!this.getOwnBinding(name);
  };

  Scope.prototype.hasBinding = function hasBinding(name, noGlobals) {
    if (!name) return false;
    if (this.hasOwnBinding(name)) return true;
    if (this.parentHasBinding(name, noGlobals)) return true;
    if (this.hasUid(name)) return true;
    if (!noGlobals && (0, _includes2.default)(Scope.globals, name)) return true;
    if (!noGlobals && (0, _includes2.default)(Scope.contextVariables, name)) return true;
    return false;
  };

  Scope.prototype.parentHasBinding = function parentHasBinding(name, noGlobals) {
    return this.parent && this.parent.hasBinding(name, noGlobals);
  };

  Scope.prototype.moveBindingTo = function moveBindingTo(name, scope) {
    var info = this.getBinding(name);
    if (info) {
      info.scope.removeOwnBinding(name);
      info.scope = scope;
      scope.bindings[name] = info;
    }
  };

  Scope.prototype.removeOwnBinding = function removeOwnBinding(name) {
    delete this.bindings[name];
  };

  Scope.prototype.removeBinding = function removeBinding(name) {
    var info = this.getBinding(name);
    if (info) {
      info.scope.removeOwnBinding(name);
    }

    var scope = this;
    do {
      if (scope.uids[name]) {
        scope.uids[name] = false;
      }
    } while (scope = scope.parent);
  };

  return Scope;
}();

Scope.globals = (0, _keys2.default)(_globals2.default.builtin);
Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
exports.default = Scope;
module.exports = exports["default"];
},{"../cache":22,"../index":25,"./binding":43,"./lib/renamer":45,"babel-messages":8,"babel-runtime/core-js/get-iterator":9,"babel-runtime/core-js/map":11,"babel-runtime/core-js/object/create":13,"babel-runtime/core-js/object/keys":15,"babel-runtime/helpers/classCallCheck":20,"babel-types":58,"globals":199,"lodash/defaults":333,"lodash/includes":336,"lodash/repeat":353}],45:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _binding = require("../binding");

var _binding2 = _interopRequireDefault(_binding);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var renameVisitor = {
  ReferencedIdentifier: function ReferencedIdentifier(_ref, state) {
    var node = _ref.node;

    if (node.name === state.oldName) {
      node.name = state.newName;
    }
  },
  Scope: function Scope(path, state) {
    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
      path.skip();
    }
  },
  "AssignmentExpression|Declaration": function AssignmentExpressionDeclaration(path, state) {
    var ids = path.getOuterBindingIdentifiers();

    for (var name in ids) {
      if (name === state.oldName) ids[name].name = state.newName;
    }
  }
};

var Renamer = function () {
  function Renamer(binding, oldName, newName) {
    (0, _classCallCheck3.default)(this, Renamer);

    this.newName = newName;
    this.oldName = oldName;
    this.binding = binding;
  }

  Renamer.prototype.maybeConvertFromExportDeclaration = function maybeConvertFromExportDeclaration(parentDeclar) {
    var exportDeclar = parentDeclar.parentPath.isExportDeclaration() && parentDeclar.parentPath;
    if (!exportDeclar) return;

    var isDefault = exportDeclar.isExportDefaultDeclaration();

    if (isDefault && (parentDeclar.isFunctionDeclaration() || parentDeclar.isClassDeclaration()) && !parentDeclar.node.id) {
      parentDeclar.node.id = parentDeclar.scope.generateUidIdentifier("default");
    }

    var bindingIdentifiers = parentDeclar.getOuterBindingIdentifiers();
    var specifiers = [];

    for (var name in bindingIdentifiers) {
      var localName = name === this.oldName ? this.newName : name;
      var exportedName = isDefault ? "default" : name;
      specifiers.push(t.exportSpecifier(t.identifier(localName), t.identifier(exportedName)));
    }

    if (specifiers.length) {
      var aliasDeclar = t.exportNamedDeclaration(null, specifiers);

      if (parentDeclar.isFunctionDeclaration()) {
        aliasDeclar._blockHoist = 3;
      }

      exportDeclar.insertAfter(aliasDeclar);
      exportDeclar.replaceWith(parentDeclar.node);
    }
  };

  Renamer.prototype.maybeConvertFromClassFunctionDeclaration = function maybeConvertFromClassFunctionDeclaration(path) {
    return;

    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;
    if (this.binding.kind !== "hoisted") return;

    path.node.id = t.identifier(this.oldName);
    path.node._blockHoist = 3;

    path.replaceWith(t.variableDeclaration("let", [t.variableDeclarator(t.identifier(this.newName), t.toExpression(path.node))]));
  };

  Renamer.prototype.maybeConvertFromClassFunctionExpression = function maybeConvertFromClassFunctionExpression(path) {
    return;

    if (!path.isFunctionExpression() && !path.isClassExpression()) return;
    if (this.binding.kind !== "local") return;

    path.node.id = t.identifier(this.oldName);

    this.binding.scope.parent.push({
      id: t.identifier(this.newName)
    });

    path.replaceWith(t.assignmentExpression("=", t.identifier(this.newName), path.node));
  };

  Renamer.prototype.rename = function rename(block) {
    var binding = this.binding,
        oldName = this.oldName,
        newName = this.newName;
    var scope = binding.scope,
        path = binding.path;


    var parentDeclar = path.find(function (path) {
      return path.isDeclaration() || path.isFunctionExpression();
    });
    if (parentDeclar) {
      this.maybeConvertFromExportDeclaration(parentDeclar);
    }

    scope.traverse(block || scope.block, renameVisitor, this);

    if (!block) {
      scope.removeOwnBinding(oldName);
      scope.bindings[newName] = binding;
      this.binding.identifier.name = newName;
    }

    if (binding.type === "hoisted") {}

    if (parentDeclar) {
      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);
      this.maybeConvertFromClassFunctionExpression(parentDeclar);
    }
  };

  return Renamer;
}();

exports.default = Renamer;
module.exports = exports["default"];
},{"../binding":43,"babel-runtime/helpers/classCallCheck":20,"babel-types":58}],46:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.explode = explode;
exports.verify = verify;
exports.merge = merge;

var _virtualTypes = require("./path/lib/virtual-types");

var virtualTypes = _interopRequireWildcard(_virtualTypes);

var _babelMessages = require("babel-messages");

var messages = _interopRequireWildcard(_babelMessages);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _clone = require("lodash/clone");

var _clone2 = _interopRequireDefault(_clone);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function explode(visitor) {
  if (visitor._exploded) return visitor;
  visitor._exploded = true;

  for (var nodeType in visitor) {
    if (shouldIgnoreKey(nodeType)) continue;

    var parts = nodeType.split("|");
    if (parts.length === 1) continue;

    var fns = visitor[nodeType];
    delete visitor[nodeType];

    for (var _iterator = parts, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var part = _ref;

      visitor[part] = fns;
    }
  }

  verify(visitor);

  delete visitor.__esModule;

  ensureEntranceObjects(visitor);

  ensureCallbackArrays(visitor);

  for (var _iterator2 = (0, _keys2.default)(visitor), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
    var _ref2;

    if (_isArray2) {
      if (_i2 >= _iterator2.length) break;
      _ref2 = _iterator2[_i2++];
    } else {
      _i2 = _iterator2.next();
      if (_i2.done) break;
      _ref2 = _i2.value;
    }

    var _nodeType3 = _ref2;

    if (shouldIgnoreKey(_nodeType3)) continue;

    var wrapper = virtualTypes[_nodeType3];
    if (!wrapper) continue;

    var _fns2 = visitor[_nodeType3];
    for (var type in _fns2) {
      _fns2[type] = wrapCheck(wrapper, _fns2[type]);
    }

    delete visitor[_nodeType3];

    if (wrapper.types) {
      for (var _iterator4 = wrapper.types, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {
        var _ref4;

        if (_isArray4) {
          if (_i4 >= _iterator4.length) break;
          _ref4 = _iterator4[_i4++];
        } else {
          _i4 = _iterator4.next();
          if (_i4.done) break;
          _ref4 = _i4.value;
        }

        var _type = _ref4;

        if (visitor[_type]) {
          mergePair(visitor[_type], _fns2);
        } else {
          visitor[_type] = _fns2;
        }
      }
    } else {
      mergePair(visitor, _fns2);
    }
  }

  for (var _nodeType in visitor) {
    if (shouldIgnoreKey(_nodeType)) continue;

    var _fns = visitor[_nodeType];

    var aliases = t.FLIPPED_ALIAS_KEYS[_nodeType];

    var deprecratedKey = t.DEPRECATED_KEYS[_nodeType];
    if (deprecratedKey) {
      console.trace("Visitor defined for " + _nodeType + " but it has been renamed to " + deprecratedKey);
      aliases = [deprecratedKey];
    }

    if (!aliases) continue;

    delete visitor[_nodeType];

    for (var _iterator3 = aliases, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var alias = _ref3;

      var existing = visitor[alias];
      if (existing) {
        mergePair(existing, _fns);
      } else {
        visitor[alias] = (0, _clone2.default)(_fns);
      }
    }
  }

  for (var _nodeType2 in visitor) {
    if (shouldIgnoreKey(_nodeType2)) continue;

    ensureCallbackArrays(visitor[_nodeType2]);
  }

  return visitor;
}

function verify(visitor) {
  if (visitor._verified) return;

  if (typeof visitor === "function") {
    throw new Error(messages.get("traverseVerifyRootFunction"));
  }

  for (var nodeType in visitor) {
    if (nodeType === "enter" || nodeType === "exit") {
      validateVisitorMethods(nodeType, visitor[nodeType]);
    }

    if (shouldIgnoreKey(nodeType)) continue;

    if (t.TYPES.indexOf(nodeType) < 0) {
      throw new Error(messages.get("traverseVerifyNodeType", nodeType));
    }

    var visitors = visitor[nodeType];
    if ((typeof visitors === "undefined" ? "undefined" : (0, _typeof3.default)(visitors)) === "object") {
      for (var visitorKey in visitors) {
        if (visitorKey === "enter" || visitorKey === "exit") {
          validateVisitorMethods(nodeType + "." + visitorKey, visitors[visitorKey]);
        } else {
          throw new Error(messages.get("traverseVerifyVisitorProperty", nodeType, visitorKey));
        }
      }
    }
  }

  visitor._verified = true;
}

function validateVisitorMethods(path, val) {
  var fns = [].concat(val);
  for (var _iterator5 = fns, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);;) {
    var _ref5;

    if (_isArray5) {
      if (_i5 >= _iterator5.length) break;
      _ref5 = _iterator5[_i5++];
    } else {
      _i5 = _iterator5.next();
      if (_i5.done) break;
      _ref5 = _i5.value;
    }

    var fn = _ref5;

    if (typeof fn !== "function") {
      throw new TypeError("Non-function found defined in " + path + " with type " + (typeof fn === "undefined" ? "undefined" : (0, _typeof3.default)(fn)));
    }
  }
}

function merge(visitors) {
  var states = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var wrapper = arguments[2];

  var rootVisitor = {};

  for (var i = 0; i < visitors.length; i++) {
    var visitor = visitors[i];
    var state = states[i];

    explode(visitor);

    for (var type in visitor) {
      var visitorType = visitor[type];

      if (state || wrapper) {
        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);
      }

      var nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};
      mergePair(nodeVisitor, visitorType);
    }
  }

  return rootVisitor;
}

function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
  var newVisitor = {};

  var _loop = function _loop(key) {
    var fns = oldVisitor[key];

    if (!Array.isArray(fns)) return "continue";

    fns = fns.map(function (fn) {
      var newFn = fn;

      if (state) {
        newFn = function newFn(path) {
          return fn.call(state, path, state);
        };
      }

      if (wrapper) {
        newFn = wrapper(state.key, key, newFn);
      }

      return newFn;
    });

    newVisitor[key] = fns;
  };

  for (var key in oldVisitor) {
    var _ret = _loop(key);

    if (_ret === "continue") continue;
  }

  return newVisitor;
}

function ensureEntranceObjects(obj) {
  for (var key in obj) {
    if (shouldIgnoreKey(key)) continue;

    var fns = obj[key];
    if (typeof fns === "function") {
      obj[key] = { enter: fns };
    }
  }
}

function ensureCallbackArrays(obj) {
  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
}

function wrapCheck(wrapper, fn) {
  var newFn = function newFn(path) {
    if (wrapper.checkPath(path)) {
      return fn.apply(this, arguments);
    }
  };
  newFn.toString = function () {
    return fn.toString();
  };
  return newFn;
}

function shouldIgnoreKey(key) {
  if (key[0] === "_") return true;

  if (key === "enter" || key === "exit" || key === "shouldSkip") return true;

  if (key === "blacklist" || key === "noScope" || key === "skipKeys") return true;

  return false;
}

function mergePair(dest, src) {
  for (var key in src) {
    dest[key] = [].concat(dest[key] || [], src[key]);
  }
}
},{"./path/lib/virtual-types":39,"babel-messages":8,"babel-runtime/core-js/get-iterator":9,"babel-runtime/core-js/object/keys":15,"babel-runtime/helpers/typeof":21,"babel-types":58,"lodash/clone":331}],47:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = undefined;

var _for = require("babel-runtime/core-js/symbol/for");

var _for2 = _interopRequireDefault(_for);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var STATEMENT_OR_BLOCK_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
var FLATTENABLE_KEYS = exports.FLATTENABLE_KEYS = ["body", "expressions"];
var FOR_INIT_KEYS = exports.FOR_INIT_KEYS = ["left", "init"];
var COMMENT_KEYS = exports.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];

var LOGICAL_OPERATORS = exports.LOGICAL_OPERATORS = ["||", "&&"];
var UPDATE_OPERATORS = exports.UPDATE_OPERATORS = ["++", "--"];

var BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
var EQUALITY_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
var COMPARISON_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = [].concat(EQUALITY_BINARY_OPERATORS, ["in", "instanceof"]);
var BOOLEAN_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = [].concat(COMPARISON_BINARY_OPERATORS, BOOLEAN_NUMBER_BINARY_OPERATORS);
var NUMBER_BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
var BINARY_OPERATORS = exports.BINARY_OPERATORS = ["+"].concat(NUMBER_BINARY_OPERATORS, BOOLEAN_BINARY_OPERATORS);

var BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
var NUMBER_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = ["+", "-", "++", "--", "~"];
var STRING_UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = ["typeof"];
var UNARY_OPERATORS = exports.UNARY_OPERATORS = ["void"].concat(BOOLEAN_UNARY_OPERATORS, NUMBER_UNARY_OPERATORS, STRING_UNARY_OPERATORS);

var INHERIT_KEYS = exports.INHERIT_KEYS = {
  optional: ["typeAnnotation", "typeParameters", "returnType"],
  force: ["start", "loc", "end"]
};

var BLOCK_SCOPED_SYMBOL = exports.BLOCK_SCOPED_SYMBOL = (0, _for2.default)("var used to be block scoped");
var NOT_LOCAL_BINDING = exports.NOT_LOCAL_BINDING = (0, _for2.default)("should not be considered a local binding");
},{"babel-runtime/core-js/symbol/for":17}],48:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _maxSafeInteger = require("babel-runtime/core-js/number/max-safe-integer");

var _maxSafeInteger2 = _interopRequireDefault(_maxSafeInteger);

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.toComputedKey = toComputedKey;
exports.toSequenceExpression = toSequenceExpression;
exports.toKeyAlias = toKeyAlias;
exports.toIdentifier = toIdentifier;
exports.toBindingIdentifierName = toBindingIdentifierName;
exports.toStatement = toStatement;
exports.toExpression = toExpression;
exports.toBlock = toBlock;
exports.valueToNode = valueToNode;

var _isPlainObject = require("lodash/isPlainObject");

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _isRegExp = require("lodash/isRegExp");

var _isRegExp2 = _interopRequireDefault(_isRegExp);

var _index = require("./index");

var t = _interopRequireWildcard(_index);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toComputedKey(node) {
  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node.key || node.property;

  if (!node.computed) {
    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);
  }
  return key;
}

function toSequenceExpression(nodes, scope) {
  if (!nodes || !nodes.length) return;

  var declars = [];
  var bailed = false;

  var result = convert(nodes);
  if (bailed) return;

  for (var i = 0; i < declars.length; i++) {
    scope.push(declars[i]);
  }

  return result;

  function convert(nodes) {
    var ensureLastUndefined = false;
    var exprs = [];

    for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var node = _ref;

      if (t.isExpression(node)) {
        exprs.push(node);
      } else if (t.isExpressionStatement(node)) {
        exprs.push(node.expression);
      } else if (t.isVariableDeclaration(node)) {
        if (node.kind !== "var") return bailed = true;

        for (var _iterator2 = node.declarations, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
          var _ref2;

          if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref2 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref2 = _i2.value;
          }

          var declar = _ref2;

          var bindings = t.getBindingIdentifiers(declar);
          for (var key in bindings) {
            declars.push({
              kind: node.kind,
              id: bindings[key]
            });
          }

          if (declar.init) {
            exprs.push(t.assignmentExpression("=", declar.id, declar.init));
          }
        }

        ensureLastUndefined = true;
        continue;
      } else if (t.isIfStatement(node)) {
        var consequent = node.consequent ? convert([node.consequent]) : scope.buildUndefinedNode();
        var alternate = node.alternate ? convert([node.alternate]) : scope.buildUndefinedNode();
        if (!consequent || !alternate) return bailed = true;

        exprs.push(t.conditionalExpression(node.test, consequent, alternate));
      } else if (t.isBlockStatement(node)) {
        exprs.push(convert(node.body));
      } else if (t.isEmptyStatement(node)) {
        ensureLastUndefined = true;
        continue;
      } else {
        return bailed = true;
      }

      ensureLastUndefined = false;
    }

    if (ensureLastUndefined || exprs.length === 0) {
      exprs.push(scope.buildUndefinedNode());
    }

    if (exprs.length === 1) {
      return exprs[0];
    } else {
      return t.sequenceExpression(exprs);
    }
  }
}

function toKeyAlias(node) {
  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node.key;

  var alias = void 0;

  if (node.kind === "method") {
    return toKeyAlias.increment() + "";
  } else if (t.isIdentifier(key)) {
    alias = key.name;
  } else if (t.isStringLiteral(key)) {
    alias = (0, _stringify2.default)(key.value);
  } else {
    alias = (0, _stringify2.default)(t.removePropertiesDeep(t.cloneDeep(key)));
  }

  if (node.computed) {
    alias = "[" + alias + "]";
  }

  if (node.static) {
    alias = "static:" + alias;
  }

  return alias;
}

toKeyAlias.uid = 0;

toKeyAlias.increment = function () {
  if (toKeyAlias.uid >= _maxSafeInteger2.default) {
    return toKeyAlias.uid = 0;
  } else {
    return toKeyAlias.uid++;
  }
};

function toIdentifier(name) {
  name = name + "";

  name = name.replace(/[^a-zA-Z0-9$_]/g, "-");

  name = name.replace(/^[-0-9]+/, "");

  name = name.replace(/[-\s]+(.)?/g, function (match, c) {
    return c ? c.toUpperCase() : "";
  });

  if (!t.isValidIdentifier(name)) {
    name = "_" + name;
  }

  return name || "_";
}

function toBindingIdentifierName(name) {
  name = toIdentifier(name);
  if (name === "eval" || name === "arguments") name = "_" + name;
  return name;
}

function toStatement(node, ignore) {
  if (t.isStatement(node)) {
    return node;
  }

  var mustHaveId = false;
  var newType = void 0;

  if (t.isClass(node)) {
    mustHaveId = true;
    newType = "ClassDeclaration";
  } else if (t.isFunction(node)) {
    mustHaveId = true;
    newType = "FunctionDeclaration";
  } else if (t.isAssignmentExpression(node)) {
    return t.expressionStatement(node);
  }

  if (mustHaveId && !node.id) {
    newType = false;
  }

  if (!newType) {
    if (ignore) {
      return false;
    } else {
      throw new Error("cannot turn " + node.type + " to a statement");
    }
  }

  node.type = newType;

  return node;
}

function toExpression(node) {
  if (t.isExpressionStatement(node)) {
    node = node.expression;
  }

  if (t.isExpression(node)) {
    return node;
  }

  if (t.isClass(node)) {
    node.type = "ClassExpression";
  } else if (t.isFunction(node)) {
    node.type = "FunctionExpression";
  }

  if (!t.isExpression(node)) {
    throw new Error("cannot turn " + node.type + " to an expression");
  }

  return node;
}

function toBlock(node, parent) {
  if (t.isBlockStatement(node)) {
    return node;
  }

  if (t.isEmptyStatement(node)) {
    node = [];
  }

  if (!Array.isArray(node)) {
    if (!t.isStatement(node)) {
      if (t.isFunction(parent)) {
        node = t.returnStatement(node);
      } else {
        node = t.expressionStatement(node);
      }
    }

    node = [node];
  }

  return t.blockStatement(node);
}

function valueToNode(value) {
  if (value === undefined) {
    return t.identifier("undefined");
  }

  if (value === true || value === false) {
    return t.booleanLiteral(value);
  }

  if (value === null) {
    return t.nullLiteral();
  }

  if (typeof value === "string") {
    return t.stringLiteral(value);
  }

  if (typeof value === "number") {
    return t.numericLiteral(value);
  }

  if ((0, _isRegExp2.default)(value)) {
    var pattern = value.source;
    var flags = value.toString().match(/\/([a-z]+|)$/)[1];
    return t.regExpLiteral(pattern, flags);
  }

  if (Array.isArray(value)) {
    return t.arrayExpression(value.map(t.valueToNode));
  }

  if ((0, _isPlainObject2.default)(value)) {
    var props = [];
    for (var key in value) {
      var nodeKey = void 0;
      if (t.isValidIdentifier(key)) {
        nodeKey = t.identifier(key);
      } else {
        nodeKey = t.stringLiteral(key);
      }
      props.push(t.objectProperty(nodeKey, t.valueToNode(value[key])));
    }
    return t.objectExpression(props);
  }

  throw new Error("don't know how to turn this value into a node");
}
},{"./index":58,"babel-runtime/core-js/get-iterator":9,"babel-runtime/core-js/json/stringify":10,"babel-runtime/core-js/number/max-safe-integer":12,"lodash/isPlainObject":345,"lodash/isRegExp":346}],49:[function(require,module,exports){
"use strict";

var _index = require("../index");

var t = _interopRequireWildcard(_index);

var _constants = require("../constants");

var _index2 = require("./index");

var _index3 = _interopRequireDefault(_index2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

(0, _index3.default)("ArrayExpression", {
  fields: {
    elements: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
      default: []
    }
  },
  visitor: ["elements"],
  aliases: ["Expression"]
});

(0, _index3.default)("AssignmentExpression", {
  fields: {
    operator: {
      validate: (0, _index2.assertValueType)("string")
    },
    left: {
      validate: (0, _index2.assertNodeType)("LVal")
    },
    right: {
      validate: (0, _index2.assertNodeType)("Expression")
    }
  },
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Expression"]
});

(0, _index3.default)("BinaryExpression", {
  builder: ["operator", "left", "right"],
  fields: {
    operator: {
      validate: _index2.assertOneOf.apply(undefined, _constants.BINARY_OPERATORS)
    },
    left: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    right: {
      validate: (0, _index2.assertNodeType)("Expression")
    }
  },
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"]
});

(0, _index3.default)("Directive", {
  visitor: ["value"],
  fields: {
    value: {
      validate: (0, _index2.assertNodeType)("DirectiveLiteral")
    }
  }
});

(0, _index3.default)("DirectiveLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _index2.assertValueType)("string")
    }
  }
});

(0, _index3.default)("BlockStatement", {
  builder: ["body", "directives"],
  visitor: ["directives", "body"],
  fields: {
    directives: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Directive"))),
      default: []
    },
    body: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Statement")))
    }
  },
  aliases: ["Scopable", "BlockParent", "Block", "Statement"]
});

(0, _index3.default)("BreakStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: (0, _index2.assertNodeType)("Identifier"),
      optional: true
    }
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
});

(0, _index3.default)("CallExpression", {
  visitor: ["callee", "arguments"],
  fields: {
    callee: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    arguments: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Expression", "SpreadElement")))
    }
  },
  aliases: ["Expression"]
});

(0, _index3.default)("CatchClause", {
  visitor: ["param", "body"],
  fields: {
    param: {
      validate: (0, _index2.assertNodeType)("Identifier")
    },
    body: {
      validate: (0, _index2.assertNodeType)("BlockStatement")
    }
  },
  aliases: ["Scopable"]
});

(0, _index3.default)("ConditionalExpression", {
  visitor: ["test", "consequent", "alternate"],
  fields: {
    test: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    consequent: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    alternate: {
      validate: (0, _index2.assertNodeType)("Expression")
    }
  },
  aliases: ["Expression", "Conditional"]
});

(0, _index3.default)("ContinueStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: (0, _index2.assertNodeType)("Identifier"),
      optional: true
    }
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
});

(0, _index3.default)("DebuggerStatement", {
  aliases: ["Statement"]
});

(0, _index3.default)("DoWhileStatement", {
  visitor: ["test", "body"],
  fields: {
    test: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _index2.assertNodeType)("Statement")
    }
  },
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
});

(0, _index3.default)("EmptyStatement", {
  aliases: ["Statement"]
});

(0, _index3.default)("ExpressionStatement", {
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, _index2.assertNodeType)("Expression")
    }
  },
  aliases: ["Statement", "ExpressionWrapper"]
});

(0, _index3.default)("File", {
  builder: ["program", "comments", "tokens"],
  visitor: ["program"],
  fields: {
    program: {
      validate: (0, _index2.assertNodeType)("Program")
    }
  }
});

(0, _index3.default)("ForInStatement", {
  visitor: ["left", "right", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: (0, _index2.assertNodeType)("VariableDeclaration", "LVal")
    },
    right: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _index2.assertNodeType)("Statement")
    }
  }
});

(0, _index3.default)("ForStatement", {
  visitor: ["init", "test", "update", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
  fields: {
    init: {
      validate: (0, _index2.assertNodeType)("VariableDeclaration", "Expression"),
      optional: true
    },
    test: {
      validate: (0, _index2.assertNodeType)("Expression"),
      optional: true
    },
    update: {
      validate: (0, _index2.assertNodeType)("Expression"),
      optional: true
    },
    body: {
      validate: (0, _index2.assertNodeType)("Statement")
    }
  }
});

(0, _index3.default)("FunctionDeclaration", {
  builder: ["id", "params", "body", "generator", "async"],
  visitor: ["id", "params", "body", "returnType", "typeParameters"],
  fields: {
    id: {
      validate: (0, _index2.assertNodeType)("Identifier")
    },
    params: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("LVal")))
    },
    body: {
      validate: (0, _index2.assertNodeType)("BlockStatement")
    },
    generator: {
      default: false,
      validate: (0, _index2.assertValueType)("boolean")
    },
    async: {
      default: false,
      validate: (0, _index2.assertValueType)("boolean")
    }
  },
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"]
});

(0, _index3.default)("FunctionExpression", {
  inherits: "FunctionDeclaration",
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
  fields: {
    id: {
      validate: (0, _index2.assertNodeType)("Identifier"),
      optional: true
    },
    params: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("LVal")))
    },
    body: {
      validate: (0, _index2.assertNodeType)("BlockStatement")
    },
    generator: {
      default: false,
      validate: (0, _index2.assertValueType)("boolean")
    },
    async: {
      default: false,
      validate: (0, _index2.assertValueType)("boolean")
    }
  }
});

(0, _index3.default)("Identifier", {
  builder: ["name"],
  visitor: ["typeAnnotation"],
  aliases: ["Expression", "LVal"],
  fields: {
    name: {
      validate: function validate(node, key, val) {
        if (!t.isValidIdentifier(val)) {}
      }
    },
    decorators: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Decorator")))
    }
  }
});

(0, _index3.default)("IfStatement", {
  visitor: ["test", "consequent", "alternate"],
  aliases: ["Statement", "Conditional"],
  fields: {
    test: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    consequent: {
      validate: (0, _index2.assertNodeType)("Statement")
    },
    alternate: {
      optional: true,
      validate: (0, _index2.assertNodeType)("Statement")
    }
  }
});

(0, _index3.default)("LabeledStatement", {
  visitor: ["label", "body"],
  aliases: ["Statement"],
  fields: {
    label: {
      validate: (0, _index2.assertNodeType)("Identifier")
    },
    body: {
      validate: (0, _index2.assertNodeType)("Statement")
    }
  }
});

(0, _index3.default)("StringLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _index2.assertValueType)("string")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});

(0, _index3.default)("NumericLiteral", {
  builder: ["value"],
  deprecatedAlias: "NumberLiteral",
  fields: {
    value: {
      validate: (0, _index2.assertValueType)("number")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});

(0, _index3.default)("NullLiteral", {
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});

(0, _index3.default)("BooleanLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _index2.assertValueType)("boolean")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});

(0, _index3.default)("RegExpLiteral", {
  builder: ["pattern", "flags"],
  deprecatedAlias: "RegexLiteral",
  aliases: ["Expression", "Literal"],
  fields: {
    pattern: {
      validate: (0, _index2.assertValueType)("string")
    },
    flags: {
      validate: (0, _index2.assertValueType)("string"),
      default: ""
    }
  }
});

(0, _index3.default)("LogicalExpression", {
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"],
  fields: {
    operator: {
      validate: _index2.assertOneOf.apply(undefined, _constants.LOGICAL_OPERATORS)
    },
    left: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    right: {
      validate: (0, _index2.assertNodeType)("Expression")
    }
  }
});

(0, _index3.default)("MemberExpression", {
  builder: ["object", "property", "computed"],
  visitor: ["object", "property"],
  aliases: ["Expression", "LVal"],
  fields: {
    object: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    property: {
      validate: function validate(node, key, val) {
        var expectedType = node.computed ? "Expression" : "Identifier";
        (0, _index2.assertNodeType)(expectedType)(node, key, val);
      }
    },
    computed: {
      default: false
    }
  }
});

(0, _index3.default)("NewExpression", {
  visitor: ["callee", "arguments"],
  aliases: ["Expression"],
  fields: {
    callee: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    arguments: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Expression", "SpreadElement")))
    }
  }
});

(0, _index3.default)("Program", {
  visitor: ["directives", "body"],
  builder: ["body", "directives"],
  fields: {
    directives: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Directive"))),
      default: []
    },
    body: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Statement")))
    }
  },
  aliases: ["Scopable", "BlockParent", "Block", "FunctionParent"]
});

(0, _index3.default)("ObjectExpression", {
  visitor: ["properties"],
  aliases: ["Expression"],
  fields: {
    properties: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadProperty")))
    }
  }
});

(0, _index3.default)("ObjectMethod", {
  builder: ["kind", "key", "params", "body", "computed"],
  fields: {
    kind: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("string"), (0, _index2.assertOneOf)("method", "get", "set")),
      default: "method"
    },
    computed: {
      validate: (0, _index2.assertValueType)("boolean"),
      default: false
    },
    key: {
      validate: function validate(node, key, val) {
        var expectedTypes = node.computed ? ["Expression"] : ["Identifier", "StringLiteral", "NumericLiteral"];
        _index2.assertNodeType.apply(undefined, expectedTypes)(node, key, val);
      }
    },
    decorators: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Decorator")))
    },
    body: {
      validate: (0, _index2.assertNodeType)("BlockStatement")
    },
    generator: {
      default: false,
      validate: (0, _index2.assertValueType)("boolean")
    },
    async: {
      default: false,
      validate: (0, _index2.assertValueType)("boolean")
    }
  },
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
});

(0, _index3.default)("ObjectProperty", {
  builder: ["key", "value", "computed", "shorthand", "decorators"],
  fields: {
    computed: {
      validate: (0, _index2.assertValueType)("boolean"),
      default: false
    },
    key: {
      validate: function validate(node, key, val) {
        var expectedTypes = node.computed ? ["Expression"] : ["Identifier", "StringLiteral", "NumericLiteral"];
        _index2.assertNodeType.apply(undefined, expectedTypes)(node, key, val);
      }
    },
    value: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    shorthand: {
      validate: (0, _index2.assertValueType)("boolean"),
      default: false
    },
    decorators: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Decorator"))),
      optional: true
    }
  },
  visitor: ["key", "value", "decorators"],
  aliases: ["UserWhitespacable", "Property", "ObjectMember"]
});

(0, _index3.default)("RestElement", {
  visitor: ["argument", "typeAnnotation"],
  aliases: ["LVal"],
  fields: {
    argument: {
      validate: (0, _index2.assertNodeType)("LVal")
    },
    decorators: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Decorator")))
    }
  }
});

(0, _index3.default)("ReturnStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: (0, _index2.assertNodeType)("Expression"),
      optional: true
    }
  }
});

(0, _index3.default)("SequenceExpression", {
  visitor: ["expressions"],
  fields: {
    expressions: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Expression")))
    }
  },
  aliases: ["Expression"]
});

(0, _index3.default)("SwitchCase", {
  visitor: ["test", "consequent"],
  fields: {
    test: {
      validate: (0, _index2.assertNodeType)("Expression"),
      optional: true
    },
    consequent: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Statement")))
    }
  }
});

(0, _index3.default)("SwitchStatement", {
  visitor: ["discriminant", "cases"],
  aliases: ["Statement", "BlockParent", "Scopable"],
  fields: {
    discriminant: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    cases: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("SwitchCase")))
    }
  }
});

(0, _index3.default)("ThisExpression", {
  aliases: ["Expression"]
});

(0, _index3.default)("ThrowStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: (0, _index2.assertNodeType)("Expression")
    }
  }
});

(0, _index3.default)("TryStatement", {
  visitor: ["block", "handler", "finalizer"],
  aliases: ["Statement"],
  fields: {
    body: {
      validate: (0, _index2.assertNodeType)("BlockStatement")
    },
    handler: {
      optional: true,
      handler: (0, _index2.assertNodeType)("BlockStatement")
    },
    finalizer: {
      optional: true,
      validate: (0, _index2.assertNodeType)("BlockStatement")
    }
  }
});

(0, _index3.default)("UnaryExpression", {
  builder: ["operator", "argument", "prefix"],
  fields: {
    prefix: {
      default: true
    },
    argument: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    operator: {
      validate: _index2.assertOneOf.apply(undefined, _constants.UNARY_OPERATORS)
    }
  },
  visitor: ["argument"],
  aliases: ["UnaryLike", "Expression"]
});

(0, _index3.default)("UpdateExpression", {
  builder: ["operator", "argument", "prefix"],
  fields: {
    prefix: {
      default: false
    },
    argument: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    operator: {
      validate: _index2.assertOneOf.apply(undefined, _constants.UPDATE_OPERATORS)
    }
  },
  visitor: ["argument"],
  aliases: ["Expression"]
});

(0, _index3.default)("VariableDeclaration", {
  builder: ["kind", "declarations"],
  visitor: ["declarations"],
  aliases: ["Statement", "Declaration"],
  fields: {
    kind: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("string"), (0, _index2.assertOneOf)("var", "let", "const"))
    },
    declarations: {
      validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("VariableDeclarator")))
    }
  }
});

(0, _index3.default)("VariableDeclarator", {
  visitor: ["id", "init"],
  fields: {
    id: {
      validate: (0, _index2.assertNodeType)("LVal")
    },
    init: {
      optional: true,
      validate: (0, _index2.assertNodeType)("Expression")
    }
  }
});

(0, _index3.default)("WhileStatement", {
  visitor: ["test", "body"],
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
  fields: {
    test: {
      validate: (0, _index2.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _index2.assertNodeType)("BlockStatement", "Statement")
    }
  }
});

(0, _index3.default)("WithStatement", {
  visitor: ["object", "body"],
  aliases: ["Statement"],
  fields: {
    object: {
      object: (0, _index2.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _index2.assertNodeType)("BlockStatement", "Statement")
    }
  }
});
},{"../constants":47,"../index":58,"./index":53}],50:[function(require,module,exports){
"use strict";

var _index = require("./index");

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _index2.default)("AssignmentPattern", {
  visitor: ["left", "right"],
  aliases: ["Pattern", "LVal"],
  fields: {
    left: {
      validate: (0, _index.assertNodeType)("Identifier")
    },
    right: {
      validate: (0, _index.assertNodeType)("Expression")
    },
    decorators: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Decorator")))
    }
  }
});

(0, _index2.default)("ArrayPattern", {
  visitor: ["elements", "typeAnnotation"],
  aliases: ["Pattern", "LVal"],
  fields: {
    elements: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Expression")))
    },
    decorators: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Decorator")))
    }
  }
});

(0, _index2.default)("ArrowFunctionExpression", {
  builder: ["params", "body", "async"],
  visitor: ["params", "body", "returnType", "typeParameters"],
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
  fields: {
    params: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("LVal")))
    },
    body: {
      validate: (0, _index.assertNodeType)("BlockStatement", "Expression")
    },
    async: {
      validate: (0, _index.assertValueType)("boolean"),
      default: false
    }
  }
});

(0, _index2.default)("ClassBody", {
  visitor: ["body"],
  fields: {
    body: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("ClassMethod", "ClassProperty")))
    }
  }
});

(0, _index2.default)("ClassDeclaration", {
  builder: ["id", "superClass", "body", "decorators"],
  visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
  aliases: ["Scopable", "Class", "Statement", "Declaration", "Pureish"],
  fields: {
    id: {
      validate: (0, _index.assertNodeType)("Identifier")
    },
    body: {
      validate: (0, _index.assertNodeType)("ClassBody")
    },
    superClass: {
      optional: true,
      validate: (0, _index.assertNodeType)("Expression")
    },
    decorators: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Decorator")))
    }
  }
});

(0, _index2.default)("ClassExpression", {
  inherits: "ClassDeclaration",
  aliases: ["Scopable", "Class", "Expression", "Pureish"],
  fields: {
    id: {
      optional: true,
      validate: (0, _index.assertNodeType)("Identifier")
    },
    body: {
      validate: (0, _index.assertNodeType)("ClassBody")
    },
    superClass: {
      optional: true,
      validate: (0, _index.assertNodeType)("Expression")
    },
    decorators: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Decorator")))
    }
  }
});

(0, _index2.default)("ExportAllDeclaration", {
  visitor: ["source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    source: {
      validate: (0, _index.assertNodeType)("StringLiteral")
    }
  }
});

(0, _index2.default)("ExportDefaultDeclaration", {
  visitor: ["declaration"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    declaration: {
      validate: (0, _index.assertNodeType)("FunctionDeclaration", "ClassDeclaration", "Expression")
    }
  }
});

(0, _index2.default)("ExportNamedDeclaration", {
  visitor: ["declaration", "specifiers", "source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    declaration: {
      validate: (0, _index.assertNodeType)("Declaration"),
      optional: true
    },
    specifiers: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("ExportSpecifier")))
    },
    source: {
      validate: (0, _index.assertNodeType)("StringLiteral"),
      optional: true
    }
  }
});

(0, _index2.default)("ExportSpecifier", {
  visitor: ["local", "exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _index.assertNodeType)("Identifier")
    },
    exported: {
      validate: (0, _index.assertNodeType)("Identifier")
    }
  }
});

(0, _index2.default)("ForOfStatement", {
  visitor: ["left", "right", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: (0, _index.assertNodeType)("VariableDeclaration", "LVal")
    },
    right: {
      validate: (0, _index.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _index.assertNodeType)("Statement")
    }
  }
});

(0, _index2.default)("ImportDeclaration", {
  visitor: ["specifiers", "source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration"],
  fields: {
    specifiers: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
    },
    source: {
      validate: (0, _index.assertNodeType)("StringLiteral")
    }
  }
});

(0, _index2.default)("ImportDefaultSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _index.assertNodeType)("Identifier")
    }
  }
});

(0, _index2.default)("ImportNamespaceSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _index.assertNodeType)("Identifier")
    }
  }
});

(0, _index2.default)("ImportSpecifier", {
  visitor: ["local", "imported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _index.assertNodeType)("Identifier")
    },
    imported: {
      validate: (0, _index.assertNodeType)("Identifier")
    },
    importKind: {
      validate: (0, _index.assertOneOf)(null, "type", "typeof")
    }
  }
});

(0, _index2.default)("MetaProperty", {
  visitor: ["meta", "property"],
  aliases: ["Expression"],
  fields: {
    meta: {
      validate: (0, _index.assertValueType)("string")
    },
    property: {
      validate: (0, _index.assertValueType)("string")
    }
  }
});

(0, _index2.default)("ClassMethod", {
  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
  builder: ["kind", "key", "params", "body", "computed", "static"],
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  fields: {
    kind: {
      validate: (0, _index.chain)((0, _index.assertValueType)("string"), (0, _index.assertOneOf)("get", "set", "method", "constructor")),
      default: "method"
    },
    computed: {
      default: false,
      validate: (0, _index.assertValueType)("boolean")
    },
    static: {
      default: false,
      validate: (0, _index.assertValueType)("boolean")
    },
    key: {
      validate: function validate(node, key, val) {
        var expectedTypes = node.computed ? ["Expression"] : ["Identifier", "StringLiteral", "NumericLiteral"];
        _index.assertNodeType.apply(undefined, expectedTypes)(node, key, val);
      }
    },
    params: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("LVal")))
    },
    body: {
      validate: (0, _index.assertNodeType)("BlockStatement")
    },
    generator: {
      default: false,
      validate: (0, _index.assertValueType)("boolean")
    },
    async: {
      default: false,
      validate: (0, _index.assertValueType)("boolean")
    }
  }
});

(0, _index2.default)("ObjectPattern", {
  visitor: ["properties", "typeAnnotation"],
  aliases: ["Pattern", "LVal"],
  fields: {
    properties: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("RestProperty", "Property")))
    },
    decorators: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Decorator")))
    }
  }
});

(0, _index2.default)("SpreadElement", {
  visitor: ["argument"],
  aliases: ["UnaryLike"],
  fields: {
    argument: {
      validate: (0, _index.assertNodeType)("Expression")
    }
  }
});

(0, _index2.default)("Super", {
  aliases: ["Expression"]
});

(0, _index2.default)("TaggedTemplateExpression", {
  visitor: ["tag", "quasi"],
  aliases: ["Expression"],
  fields: {
    tag: {
      validate: (0, _index.assertNodeType)("Expression")
    },
    quasi: {
      validate: (0, _index.assertNodeType)("TemplateLiteral")
    }
  }
});

(0, _index2.default)("TemplateElement", {
  builder: ["value", "tail"],
  fields: {
    value: {},
    tail: {
      validate: (0, _index.assertValueType)("boolean"),
      default: false
    }
  }
});

(0, _index2.default)("TemplateLiteral", {
  visitor: ["quasis", "expressions"],
  aliases: ["Expression", "Literal"],
  fields: {
    quasis: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("TemplateElement")))
    },
    expressions: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Expression")))
    }
  }
});

(0, _index2.default)("YieldExpression", {
  builder: ["argument", "delegate"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: {
    delegate: {
      validate: (0, _index.assertValueType)("boolean"),
      default: false
    },
    argument: {
      optional: true,
      validate: (0, _index.assertNodeType)("Expression")
    }
  }
});
},{"./index":53}],51:[function(require,module,exports){
"use strict";

var _index = require("./index");

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _index2.default)("AwaitExpression", {
  builder: ["argument"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: {
    argument: {
      validate: (0, _index.assertNodeType)("Expression")
    }
  }
});

(0, _index2.default)("ForAwaitStatement", {
  visitor: ["left", "right", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: (0, _index.assertNodeType)("VariableDeclaration", "LVal")
    },
    right: {
      validate: (0, _index.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _index.assertNodeType)("Statement")
    }
  }
});

(0, _index2.default)("BindExpression", {
  visitor: ["object", "callee"],
  aliases: ["Expression"],
  fields: {}
});

(0, _index2.default)("Import", {
  aliases: ["Expression"]
});

(0, _index2.default)("Decorator", {
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, _index.assertNodeType)("Expression")
    }
  }
});

(0, _index2.default)("DoExpression", {
  visitor: ["body"],
  aliases: ["Expression"],
  fields: {
    body: {
      validate: (0, _index.assertNodeType)("BlockStatement")
    }
  }
});

(0, _index2.default)("ExportDefaultSpecifier", {
  visitor: ["exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    exported: {
      validate: (0, _index.assertNodeType)("Identifier")
    }
  }
});

(0, _index2.default)("ExportNamespaceSpecifier", {
  visitor: ["exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    exported: {
      validate: (0, _index.assertNodeType)("Identifier")
    }
  }
});

(0, _index2.default)("RestProperty", {
  visitor: ["argument"],
  aliases: ["UnaryLike"],
  fields: {
    argument: {
      validate: (0, _index.assertNodeType)("LVal")
    }
  }
});

(0, _index2.default)("SpreadProperty", {
  visitor: ["argument"],
  aliases: ["UnaryLike"],
  fields: {
    argument: {
      validate: (0, _index.assertNodeType)("Expression")
    }
  }
});
},{"./index":53}],52:[function(require,module,exports){
"use strict";

var _index = require("./index");

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _index2.default)("AnyTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"],
  fields: {}
});

(0, _index2.default)("ArrayTypeAnnotation", {
  visitor: ["elementType"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("BooleanTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"],
  fields: {}
});

(0, _index2.default)("BooleanLiteralTypeAnnotation", {
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("NullLiteralTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"],
  fields: {}
});

(0, _index2.default)("ClassImplements", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("ClassProperty", {
  visitor: ["key", "value", "typeAnnotation", "decorators"],
  builder: ["key", "value", "typeAnnotation", "decorators", "computed"],
  aliases: ["Property"],
  fields: {
    computed: {
      validate: (0, _index.assertValueType)("boolean"),
      default: false
    }
  }
});

(0, _index2.default)("DeclareClass", {
  visitor: ["id", "typeParameters", "extends", "body"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _index2.default)("DeclareFunction", {
  visitor: ["id"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _index2.default)("DeclareInterface", {
  visitor: ["id", "typeParameters", "extends", "body"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _index2.default)("DeclareModule", {
  visitor: ["id", "body"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _index2.default)("DeclareModuleExports", {
  visitor: ["typeAnnotation"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _index2.default)("DeclareTypeAlias", {
  visitor: ["id", "typeParameters", "right"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _index2.default)("DeclareVariable", {
  visitor: ["id"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _index2.default)("ExistentialTypeParam", {
  aliases: ["Flow"]
});

(0, _index2.default)("FunctionTypeAnnotation", {
  visitor: ["typeParameters", "params", "rest", "returnType"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("FunctionTypeParam", {
  visitor: ["name", "typeAnnotation"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("GenericTypeAnnotation", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("InterfaceExtends", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("InterfaceDeclaration", {
  visitor: ["id", "typeParameters", "extends", "body"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _index2.default)("IntersectionTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("MixedTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"]
});

(0, _index2.default)("EmptyTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"]
});

(0, _index2.default)("NullableTypeAnnotation", {
  visitor: ["typeAnnotation"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("NumericLiteralTypeAnnotation", {
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("NumberTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"],
  fields: {}
});

(0, _index2.default)("StringLiteralTypeAnnotation", {
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("StringTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"],
  fields: {}
});

(0, _index2.default)("ThisTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"],
  fields: {}
});

(0, _index2.default)("TupleTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("TypeofTypeAnnotation", {
  visitor: ["argument"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("TypeAlias", {
  visitor: ["id", "typeParameters", "right"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {}
});

(0, _index2.default)("TypeAnnotation", {
  visitor: ["typeAnnotation"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("TypeCastExpression", {
  visitor: ["expression", "typeAnnotation"],
  aliases: ["Flow", "ExpressionWrapper", "Expression"],
  fields: {}
});

(0, _index2.default)("TypeParameter", {
  visitor: ["bound"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("TypeParameterDeclaration", {
  visitor: ["params"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("TypeParameterInstantiation", {
  visitor: ["params"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("ObjectTypeAnnotation", {
  visitor: ["properties", "indexers", "callProperties"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("ObjectTypeCallProperty", {
  visitor: ["value"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {}
});

(0, _index2.default)("ObjectTypeIndexer", {
  visitor: ["id", "key", "value"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {}
});

(0, _index2.default)("ObjectTypeProperty", {
  visitor: ["key", "value"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {}
});

(0, _index2.default)("QualifiedTypeIdentifier", {
  visitor: ["id", "qualification"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("UnionTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow"],
  fields: {}
});

(0, _index2.default)("VoidTypeAnnotation", {
  aliases: ["Flow", "FlowBaseAnnotation"],
  fields: {}
});
},{"./index":53}],53:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = undefined;

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

exports.assertEach = assertEach;
exports.assertOneOf = assertOneOf;
exports.assertNodeType = assertNodeType;
exports.assertNodeOrValueType = assertNodeOrValueType;
exports.assertValueType = assertValueType;
exports.chain = chain;
exports.default = defineType;

var _index = require("../index");

var t = _interopRequireWildcard(_index);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var VISITOR_KEYS = exports.VISITOR_KEYS = {};
var ALIAS_KEYS = exports.ALIAS_KEYS = {};
var NODE_FIELDS = exports.NODE_FIELDS = {};
var BUILDER_KEYS = exports.BUILDER_KEYS = {};
var DEPRECATED_KEYS = exports.DEPRECATED_KEYS = {};

function getType(val) {
  if (Array.isArray(val)) {
    return "array";
  } else if (val === null) {
    return "null";
  } else if (val === undefined) {
    return "undefined";
  } else {
    return typeof val === "undefined" ? "undefined" : (0, _typeof3.default)(val);
  }
}

function assertEach(callback) {
  function validator(node, key, val) {
    if (!Array.isArray(val)) return;

    for (var i = 0; i < val.length; i++) {
      callback(node, key + "[" + i + "]", val[i]);
    }
  }
  validator.each = callback;
  return validator;
}

function assertOneOf() {
  for (var _len = arguments.length, vals = Array(_len), _key = 0; _key < _len; _key++) {
    vals[_key] = arguments[_key];
  }

  function validate(node, key, val) {
    if (vals.indexOf(val) < 0) {
      throw new TypeError("Property " + key + " expected value to be one of " + (0, _stringify2.default)(vals) + " but got " + (0, _stringify2.default)(val));
    }
  }

  validate.oneOf = vals;

  return validate;
}

function assertNodeType() {
  for (var _len2 = arguments.length, types = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    types[_key2] = arguments[_key2];
  }

  function validate(node, key, val) {
    var valid = false;

    for (var _iterator = types, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var type = _ref;

      if (t.is(type, val)) {
        valid = true;
        break;
      }
    }

    if (!valid) {
      throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + (0, _stringify2.default)(types) + " " + ("but instead got " + (0, _stringify2.default)(val && val.type)));
    }
  }

  validate.oneOfNodeTypes = types;

  return validate;
}

function assertNodeOrValueType() {
  for (var _len3 = arguments.length, types = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    types[_key3] = arguments[_key3];
  }

  function validate(node, key, val) {
    var valid = false;

    for (var _iterator2 = types, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var type = _ref2;

      if (getType(val) === type || t.is(type, val)) {
        valid = true;
        break;
      }
    }

    if (!valid) {
      throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + (0, _stringify2.default)(types) + " " + ("but instead got " + (0, _stringify2.default)(val && val.type)));
    }
  }

  validate.oneOfNodeOrValueTypes = types;

  return validate;
}

function assertValueType(type) {
  function validate(node, key, val) {
    var valid = getType(val) === type;

    if (!valid) {
      throw new TypeError("Property " + key + " expected type of " + type + " but got " + getType(val));
    }
  }

  validate.type = type;

  return validate;
}

function chain() {
  for (var _len4 = arguments.length, fns = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    fns[_key4] = arguments[_key4];
  }

  function validate() {
    for (var _iterator3 = fns, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var fn = _ref3;

      fn.apply(undefined, arguments);
    }
  }
  validate.chainOf = fns;
  return validate;
}

function defineType(type) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var inherits = opts.inherits && store[opts.inherits] || {};

  opts.fields = opts.fields || inherits.fields || {};
  opts.visitor = opts.visitor || inherits.visitor || [];
  opts.aliases = opts.aliases || inherits.aliases || [];
  opts.builder = opts.builder || inherits.builder || opts.visitor || [];

  if (opts.deprecatedAlias) {
    DEPRECATED_KEYS[opts.deprecatedAlias] = type;
  }

  for (var _iterator4 = opts.visitor.concat(opts.builder), _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {
    var _ref4;

    if (_isArray4) {
      if (_i4 >= _iterator4.length) break;
      _ref4 = _iterator4[_i4++];
    } else {
      _i4 = _iterator4.next();
      if (_i4.done) break;
      _ref4 = _i4.value;
    }

    var _key5 = _ref4;

    opts.fields[_key5] = opts.fields[_key5] || {};
  }

  for (var key in opts.fields) {
    var field = opts.fields[key];

    if (opts.builder.indexOf(key) === -1) {
      field.optional = true;
    }
    if (field.default === undefined) {
      field.default = null;
    } else if (!field.validate) {
      field.validate = assertValueType(getType(field.default));
    }
  }

  VISITOR_KEYS[type] = opts.visitor;
  BUILDER_KEYS[type] = opts.builder;
  NODE_FIELDS[type] = opts.fields;
  ALIAS_KEYS[type] = opts.aliases;

  store[type] = opts;
}

var store = {};
},{"../index":58,"babel-runtime/core-js/get-iterator":9,"babel-runtime/core-js/json/stringify":10,"babel-runtime/helpers/typeof":21}],54:[function(require,module,exports){
"use strict";

require("./index");

require("./core");

require("./es2015");

require("./flow");

require("./jsx");

require("./misc");

require("./experimental");
},{"./core":49,"./es2015":50,"./experimental":51,"./flow":52,"./index":53,"./jsx":55,"./misc":56}],55:[function(require,module,exports){
"use strict";

var _index = require("./index");

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _index2.default)("JSXAttribute", {
  visitor: ["name", "value"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _index.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
    },
    value: {
      optional: true,
      validate: (0, _index.assertNodeType)("JSXElement", "StringLiteral", "JSXExpressionContainer")
    }
  }
});

(0, _index2.default)("JSXClosingElement", {
  visitor: ["name"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _index.assertNodeType)("JSXIdentifier", "JSXMemberExpression")
    }
  }
});

(0, _index2.default)("JSXElement", {
  builder: ["openingElement", "closingElement", "children", "selfClosing"],
  visitor: ["openingElement", "children", "closingElement"],
  aliases: ["JSX", "Immutable", "Expression"],
  fields: {
    openingElement: {
      validate: (0, _index.assertNodeType)("JSXOpeningElement")
    },
    closingElement: {
      optional: true,
      validate: (0, _index.assertNodeType)("JSXClosingElement")
    },
    children: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement")))
    }
  }
});

(0, _index2.default)("JSXEmptyExpression", {
  aliases: ["JSX", "Expression"]
});

(0, _index2.default)("JSXExpressionContainer", {
  visitor: ["expression"],
  aliases: ["JSX", "Immutable"],
  fields: {
    expression: {
      validate: (0, _index.assertNodeType)("Expression")
    }
  }
});

(0, _index2.default)("JSXSpreadChild", {
  visitor: ["expression"],
  aliases: ["JSX", "Immutable"],
  fields: {
    expression: {
      validate: (0, _index.assertNodeType)("Expression")
    }
  }
});

(0, _index2.default)("JSXIdentifier", {
  builder: ["name"],
  aliases: ["JSX", "Expression"],
  fields: {
    name: {
      validate: (0, _index.assertValueType)("string")
    }
  }
});

(0, _index2.default)("JSXMemberExpression", {
  visitor: ["object", "property"],
  aliases: ["JSX", "Expression"],
  fields: {
    object: {
      validate: (0, _index.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
    },
    property: {
      validate: (0, _index.assertNodeType)("JSXIdentifier")
    }
  }
});

(0, _index2.default)("JSXNamespacedName", {
  visitor: ["namespace", "name"],
  aliases: ["JSX"],
  fields: {
    namespace: {
      validate: (0, _index.assertNodeType)("JSXIdentifier")
    },
    name: {
      validate: (0, _index.assertNodeType)("JSXIdentifier")
    }
  }
});

(0, _index2.default)("JSXOpeningElement", {
  builder: ["name", "attributes", "selfClosing"],
  visitor: ["name", "attributes"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _index.assertNodeType)("JSXIdentifier", "JSXMemberExpression")
    },
    selfClosing: {
      default: false,
      validate: (0, _index.assertValueType)("boolean")
    },
    attributes: {
      validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
    }
  }
});

(0, _index2.default)("JSXSpreadAttribute", {
  visitor: ["argument"],
  aliases: ["JSX"],
  fields: {
    argument: {
      validate: (0, _index.assertNodeType)("Expression")
    }
  }
});

(0, _index2.default)("JSXText", {
  aliases: ["JSX", "Immutable"],
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _index.assertValueType)("string")
    }
  }
});
},{"./index":53}],56:[function(require,module,exports){
"use strict";

var _index = require("./index");

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _index2.default)("Noop", {
  visitor: []
});

(0, _index2.default)("ParenthesizedExpression", {
  visitor: ["expression"],
  aliases: ["Expression", "ExpressionWrapper"],
  fields: {
    expression: {
      validate: (0, _index.assertNodeType)("Expression")
    }
  }
});
},{"./index":53}],57:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.createUnionTypeAnnotation = createUnionTypeAnnotation;
exports.removeTypeDuplicates = removeTypeDuplicates;
exports.createTypeAnnotationBasedOnTypeof = createTypeAnnotationBasedOnTypeof;

var _index = require("./index");

var t = _interopRequireWildcard(_index);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function createUnionTypeAnnotation(types) {
  var flattened = removeTypeDuplicates(types);

  if (flattened.length === 1) {
    return flattened[0];
  } else {
    return t.unionTypeAnnotation(flattened);
  }
}

function removeTypeDuplicates(nodes) {
  var generics = {};
  var bases = {};

  var typeGroups = [];

  var types = [];

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    if (!node) continue;

    if (types.indexOf(node) >= 0) {
      continue;
    }

    if (t.isAnyTypeAnnotation(node)) {
      return [node];
    }

    if (t.isFlowBaseAnnotation(node)) {
      bases[node.type] = node;
      continue;
    }

    if (t.isUnionTypeAnnotation(node)) {
      if (typeGroups.indexOf(node.types) < 0) {
        nodes = nodes.concat(node.types);
        typeGroups.push(node.types);
      }
      continue;
    }

    if (t.isGenericTypeAnnotation(node)) {
      var name = node.id.name;

      if (generics[name]) {
        var existing = generics[name];
        if (existing.typeParameters) {
          if (node.typeParameters) {
            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
          }
        } else {
          existing = node.typeParameters;
        }
      } else {
        generics[name] = node;
      }

      continue;
    }

    types.push(node);
  }

  for (var type in bases) {
    types.push(bases[type]);
  }

  for (var _name in generics) {
    types.push(generics[_name]);
  }

  return types;
}

function createTypeAnnotationBasedOnTypeof(type) {
  if (type === "string") {
    return t.stringTypeAnnotation();
  } else if (type === "number") {
    return t.numberTypeAnnotation();
  } else if (type === "undefined") {
    return t.voidTypeAnnotation();
  } else if (type === "boolean") {
    return t.booleanTypeAnnotation();
  } else if (type === "function") {
    return t.genericTypeAnnotation(t.identifier("Function"));
  } else if (type === "object") {
    return t.genericTypeAnnotation(t.identifier("Object"));
  } else if (type === "symbol") {
    return t.genericTypeAnnotation(t.identifier("Symbol"));
  } else {
    throw new Error("Invalid typeof value");
  }
}
},{"./index":58}],58:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.createTypeAnnotationBasedOnTypeof = exports.removeTypeDuplicates = exports.createUnionTypeAnnotation = exports.valueToNode = exports.toBlock = exports.toExpression = exports.toStatement = exports.toBindingIdentifierName = exports.toIdentifier = exports.toKeyAlias = exports.toSequenceExpression = exports.toComputedKey = exports.isNodesEquivalent = exports.isImmutable = exports.isScope = exports.isSpecifierDefault = exports.isVar = exports.isBlockScoped = exports.isLet = exports.isValidIdentifier = exports.isReferenced = exports.isBinding = exports.getOuterBindingIdentifiers = exports.getBindingIdentifiers = exports.TYPES = exports.react = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = exports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = undefined;

var _getOwnPropertySymbols = require("babel-runtime/core-js/object/get-own-property-symbols");

var _getOwnPropertySymbols2 = _interopRequireDefault(_getOwnPropertySymbols);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _constants = require("./constants");

Object.defineProperty(exports, "STATEMENT_OR_BLOCK_KEYS", {
  enumerable: true,
  get: function get() {
    return _constants.STATEMENT_OR_BLOCK_KEYS;
  }
});
Object.defineProperty(exports, "FLATTENABLE_KEYS", {
  enumerable: true,
  get: function get() {
    return _constants.FLATTENABLE_KEYS;
  }
});
Object.defineProperty(exports, "FOR_INIT_KEYS", {
  enumerable: true,
  get: function get() {
    return _constants.FOR_INIT_KEYS;
  }
});
Object.defineProperty(exports, "COMMENT_KEYS", {
  enumerable: true,
  get: function get() {
    return _constants.COMMENT_KEYS;
  }
});
Object.defineProperty(exports, "LOGICAL_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.LOGICAL_OPERATORS;
  }
});
Object.defineProperty(exports, "UPDATE_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.UPDATE_OPERATORS;
  }
});
Object.defineProperty(exports, "BOOLEAN_NUMBER_BINARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.BOOLEAN_NUMBER_BINARY_OPERATORS;
  }
});
Object.defineProperty(exports, "EQUALITY_BINARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.EQUALITY_BINARY_OPERATORS;
  }
});
Object.defineProperty(exports, "COMPARISON_BINARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.COMPARISON_BINARY_OPERATORS;
  }
});
Object.defineProperty(exports, "BOOLEAN_BINARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.BOOLEAN_BINARY_OPERATORS;
  }
});
Object.defineProperty(exports, "NUMBER_BINARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.NUMBER_BINARY_OPERATORS;
  }
});
Object.defineProperty(exports, "BINARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.BINARY_OPERATORS;
  }
});
Object.defineProperty(exports, "BOOLEAN_UNARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.BOOLEAN_UNARY_OPERATORS;
  }
});
Object.defineProperty(exports, "NUMBER_UNARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.NUMBER_UNARY_OPERATORS;
  }
});
Object.defineProperty(exports, "STRING_UNARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.STRING_UNARY_OPERATORS;
  }
});
Object.defineProperty(exports, "UNARY_OPERATORS", {
  enumerable: true,
  get: function get() {
    return _constants.UNARY_OPERATORS;
  }
});
Object.defineProperty(exports, "INHERIT_KEYS", {
  enumerable: true,
  get: function get() {
    return _constants.INHERIT_KEYS;
  }
});
Object.defineProperty(exports, "BLOCK_SCOPED_SYMBOL", {
  enumerable: true,
  get: function get() {
    return _constants.BLOCK_SCOPED_SYMBOL;
  }
});
Object.defineProperty(exports, "NOT_LOCAL_BINDING", {
  enumerable: true,
  get: function get() {
    return _constants.NOT_LOCAL_BINDING;
  }
});
exports.is = is;
exports.isType = isType;
exports.validate = validate;
exports.shallowEqual = shallowEqual;
exports.appendToMemberExpression = appendToMemberExpression;
exports.prependToMemberExpression = prependToMemberExpression;
exports.ensureBlock = ensureBlock;
exports.clone = clone;
exports.cloneWithoutLoc = cloneWithoutLoc;
exports.cloneDeep = cloneDeep;
exports.buildMatchMemberExpression = buildMatchMemberExpression;
exports.removeComments = removeComments;
exports.inheritsComments = inheritsComments;
exports.inheritTrailingComments = inheritTrailingComments;
exports.inheritLeadingComments = inheritLeadingComments;
exports.inheritInnerComments = inheritInnerComments;
exports.inherits = inherits;
exports.assertNode = assertNode;
exports.isNode = isNode;
exports.traverseFast = traverseFast;
exports.removeProperties = removeProperties;
exports.removePropertiesDeep = removePropertiesDeep;

var _retrievers = require("./retrievers");

Object.defineProperty(exports, "getBindingIdentifiers", {
  enumerable: true,
  get: function get() {
    return _retrievers.getBindingIdentifiers;
  }
});
Object.defineProperty(exports, "getOuterBindingIdentifiers", {
  enumerable: true,
  get: function get() {
    return _retrievers.getOuterBindingIdentifiers;
  }
});

var _validators = require("./validators");

Object.defineProperty(exports, "isBinding", {
  enumerable: true,
  get: function get() {
    return _validators.isBinding;
  }
});
Object.defineProperty(exports, "isReferenced", {
  enumerable: true,
  get: function get() {
    return _validators.isReferenced;
  }
});
Object.defineProperty(exports, "isValidIdentifier", {
  enumerable: true,
  get: function get() {
    return _validators.isValidIdentifier;
  }
});
Object.defineProperty(exports, "isLet", {
  enumerable: true,
  get: function get() {
    return _validators.isLet;
  }
});
Object.defineProperty(exports, "isBlockScoped", {
  enumerable: true,
  get: function get() {
    return _validators.isBlockScoped;
  }
});
Object.defineProperty(exports, "isVar", {
  enumerable: true,
  get: function get() {
    return _validators.isVar;
  }
});
Object.defineProperty(exports, "isSpecifierDefault", {
  enumerable: true,
  get: function get() {
    return _validators.isSpecifierDefault;
  }
});
Object.defineProperty(exports, "isScope", {
  enumerable: true,
  get: function get() {
    return _validators.isScope;
  }
});
Object.defineProperty(exports, "isImmutable", {
  enumerable: true,
  get: function get() {
    return _validators.isImmutable;
  }
});
Object.defineProperty(exports, "isNodesEquivalent", {
  enumerable: true,
  get: function get() {
    return _validators.isNodesEquivalent;
  }
});

var _converters = require("./converters");

Object.defineProperty(exports, "toComputedKey", {
  enumerable: true,
  get: function get() {
    return _converters.toComputedKey;
  }
});
Object.defineProperty(exports, "toSequenceExpression", {
  enumerable: true,
  get: function get() {
    return _converters.toSequenceExpression;
  }
});
Object.defineProperty(exports, "toKeyAlias", {
  enumerable: true,
  get: function get() {
    return _converters.toKeyAlias;
  }
});
Object.defineProperty(exports, "toIdentifier", {
  enumerable: true,
  get: function get() {
    return _converters.toIdentifier;
  }
});
Object.defineProperty(exports, "toBindingIdentifierName", {
  enumerable: true,
  get: function get() {
    return _converters.toBindingIdentifierName;
  }
});
Object.defineProperty(exports, "toStatement", {
  enumerable: true,
  get: function get() {
    return _converters.toStatement;
  }
});
Object.defineProperty(exports, "toExpression", {
  enumerable: true,
  get: function get() {
    return _converters.toExpression;
  }
});
Object.defineProperty(exports, "toBlock", {
  enumerable: true,
  get: function get() {
    return _converters.toBlock;
  }
});
Object.defineProperty(exports, "valueToNode", {
  enumerable: true,
  get: function get() {
    return _converters.valueToNode;
  }
});

var _flow = require("./flow");

Object.defineProperty(exports, "createUnionTypeAnnotation", {
  enumerable: true,
  get: function get() {
    return _flow.createUnionTypeAnnotation;
  }
});
Object.defineProperty(exports, "removeTypeDuplicates", {
  enumerable: true,
  get: function get() {
    return _flow.removeTypeDuplicates;
  }
});
Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
  enumerable: true,
  get: function get() {
    return _flow.createTypeAnnotationBasedOnTypeof;
  }
});

var _toFastProperties = require("to-fast-properties");

var _toFastProperties2 = _interopRequireDefault(_toFastProperties);

var _clone = require("lodash/clone");

var _clone2 = _interopRequireDefault(_clone);

var _uniq = require("lodash/uniq");

var _uniq2 = _interopRequireDefault(_uniq);

require("./definitions/init");

var _definitions = require("./definitions");

var _react2 = require("./react");

var _react = _interopRequireWildcard(_react2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var t = exports;

function registerType(type) {
  var is = t["is" + type];
  if (!is) {
    is = t["is" + type] = function (node, opts) {
      return t.is(type, node, opts);
    };
  }

  t["assert" + type] = function (node, opts) {
    opts = opts || {};
    if (!is(node, opts)) {
      throw new Error("Expected type " + (0, _stringify2.default)(type) + " with option " + (0, _stringify2.default)(opts));
    }
  };
}

exports.VISITOR_KEYS = _definitions.VISITOR_KEYS;
exports.ALIAS_KEYS = _definitions.ALIAS_KEYS;
exports.NODE_FIELDS = _definitions.NODE_FIELDS;
exports.BUILDER_KEYS = _definitions.BUILDER_KEYS;
exports.DEPRECATED_KEYS = _definitions.DEPRECATED_KEYS;
exports.react = _react;


for (var type in t.VISITOR_KEYS) {
  registerType(type);
}

t.FLIPPED_ALIAS_KEYS = {};

(0, _keys2.default)(t.ALIAS_KEYS).forEach(function (type) {
  t.ALIAS_KEYS[type].forEach(function (alias) {
    var types = t.FLIPPED_ALIAS_KEYS[alias] = t.FLIPPED_ALIAS_KEYS[alias] || [];
    types.push(type);
  });
});

(0, _keys2.default)(t.FLIPPED_ALIAS_KEYS).forEach(function (type) {
  t[type.toUpperCase() + "_TYPES"] = t.FLIPPED_ALIAS_KEYS[type];
  registerType(type);
});

var TYPES = exports.TYPES = (0, _keys2.default)(t.VISITOR_KEYS).concat((0, _keys2.default)(t.FLIPPED_ALIAS_KEYS)).concat((0, _keys2.default)(t.DEPRECATED_KEYS));

function is(type, node, opts) {
  if (!node) return false;

  var matches = isType(node.type, type);
  if (!matches) return false;

  if (typeof opts === "undefined") {
    return true;
  } else {
    return t.shallowEqual(node, opts);
  }
}

function isType(nodeType, targetType) {
  if (nodeType === targetType) return true;

  if (t.ALIAS_KEYS[targetType]) return false;

  var aliases = t.FLIPPED_ALIAS_KEYS[targetType];
  if (aliases) {
    if (aliases[0] === nodeType) return true;

    for (var _iterator = aliases, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var alias = _ref;

      if (nodeType === alias) return true;
    }
  }

  return false;
}

(0, _keys2.default)(t.BUILDER_KEYS).forEach(function (type) {
  var keys = t.BUILDER_KEYS[type];

  function builder() {
    if (arguments.length > keys.length) {
      throw new Error("t." + type + ": Too many arguments passed. Received " + arguments.length + " but can receive " + ("no more than " + keys.length));
    }

    var node = {};
    node.type = type;

    var i = 0;

    for (var _iterator2 = keys, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var _key = _ref2;

      var field = t.NODE_FIELDS[type][_key];

      var arg = arguments[i++];
      if (arg === undefined) arg = (0, _clone2.default)(field.default);

      node[_key] = arg;
    }

    for (var key in node) {
      validate(node, key, node[key]);
    }

    return node;
  }

  t[type] = builder;
  t[type[0].toLowerCase() + type.slice(1)] = builder;
});

var _loop = function _loop(_type) {
  var newType = t.DEPRECATED_KEYS[_type];

  function proxy(fn) {
    return function () {
      console.trace("The node type " + _type + " has been renamed to " + newType);
      return fn.apply(this, arguments);
    };
  }

  t[_type] = t[_type[0].toLowerCase() + _type.slice(1)] = proxy(t[newType]);
  t["is" + _type] = proxy(t["is" + newType]);
  t["assert" + _type] = proxy(t["assert" + newType]);
};

for (var _type in t.DEPRECATED_KEYS) {
  _loop(_type);
}

function validate(node, key, val) {
  if (!node) return;

  var fields = t.NODE_FIELDS[node.type];
  if (!fields) return;

  var field = fields[key];
  if (!field || !field.validate) return;
  if (field.optional && val == null) return;

  field.validate(node, key, val);
}

function shallowEqual(actual, expected) {
  var keys = (0, _keys2.default)(expected);

  for (var _iterator3 = keys, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
    var _ref3;

    if (_isArray3) {
      if (_i3 >= _iterator3.length) break;
      _ref3 = _iterator3[_i3++];
    } else {
      _i3 = _iterator3.next();
      if (_i3.done) break;
      _ref3 = _i3.value;
    }

    var key = _ref3;

    if (actual[key] !== expected[key]) {
      return false;
    }
  }

  return true;
}

function appendToMemberExpression(member, append, computed) {
  member.object = t.memberExpression(member.object, member.property, member.computed);
  member.property = append;
  member.computed = !!computed;
  return member;
}

function prependToMemberExpression(member, prepend) {
  member.object = t.memberExpression(prepend, member.object);
  return member;
}

function ensureBlock(node) {
  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "body";

  return node[key] = t.toBlock(node[key], node);
}

function clone(node) {
  if (!node) return node;
  var newNode = {};
  for (var key in node) {
    if (key[0] === "_") continue;
    newNode[key] = node[key];
  }
  return newNode;
}

function cloneWithoutLoc(node) {
  var newNode = clone(node);
  delete newNode.loc;
  return newNode;
}

function cloneDeep(node) {
  if (!node) return node;
  var newNode = {};

  for (var key in node) {
    if (key[0] === "_") continue;

    var val = node[key];

    if (val) {
      if (val.type) {
        val = t.cloneDeep(val);
      } else if (Array.isArray(val)) {
        val = val.map(t.cloneDeep);
      }
    }

    newNode[key] = val;
  }

  return newNode;
}

function buildMatchMemberExpression(match, allowPartial) {
  var parts = match.split(".");

  return function (member) {
    if (!t.isMemberExpression(member)) return false;

    var search = [member];
    var i = 0;

    while (search.length) {
      var node = search.shift();

      if (allowPartial && i === parts.length) {
        return true;
      }

      if (t.isIdentifier(node)) {
        if (parts[i] !== node.name) return false;
      } else if (t.isStringLiteral(node)) {
        if (parts[i] !== node.value) return false;
      } else if (t.isMemberExpression(node)) {
        if (node.computed && !t.isStringLiteral(node.property)) {
          return false;
        } else {
          search.push(node.object);
          search.push(node.property);
          continue;
        }
      } else {
        return false;
      }

      if (++i > parts.length) {
        return false;
      }
    }

    return true;
  };
}

function removeComments(node) {
  for (var _iterator4 = t.COMMENT_KEYS, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {
    var _ref4;

    if (_isArray4) {
      if (_i4 >= _iterator4.length) break;
      _ref4 = _iterator4[_i4++];
    } else {
      _i4 = _iterator4.next();
      if (_i4.done) break;
      _ref4 = _i4.value;
    }

    var key = _ref4;

    delete node[key];
  }
  return node;
}

function inheritsComments(child, parent) {
  inheritTrailingComments(child, parent);
  inheritLeadingComments(child, parent);
  inheritInnerComments(child, parent);
  return child;
}

function inheritTrailingComments(child, parent) {
  _inheritComments("trailingComments", child, parent);
}

function inheritLeadingComments(child, parent) {
  _inheritComments("leadingComments", child, parent);
}

function inheritInnerComments(child, parent) {
  _inheritComments("innerComments", child, parent);
}

function _inheritComments(key, child, parent) {
  if (child && parent) {
    child[key] = (0, _uniq2.default)([].concat(child[key], parent[key]).filter(Boolean));
  }
}

function inherits(child, parent) {
  if (!child || !parent) return child;

  for (var _iterator5 = t.INHERIT_KEYS.optional, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);;) {
    var _ref5;

    if (_isArray5) {
      if (_i5 >= _iterator5.length) break;
      _ref5 = _iterator5[_i5++];
    } else {
      _i5 = _iterator5.next();
      if (_i5.done) break;
      _ref5 = _i5.value;
    }

    var _key2 = _ref5;

    if (child[_key2] == null) {
      child[_key2] = parent[_key2];
    }
  }

  for (var key in parent) {
    if (key[0] === "_") child[key] = parent[key];
  }

  for (var _iterator6 = t.INHERIT_KEYS.force, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : (0, _getIterator3.default)(_iterator6);;) {
    var _ref6;

    if (_isArray6) {
      if (_i6 >= _iterator6.length) break;
      _ref6 = _iterator6[_i6++];
    } else {
      _i6 = _iterator6.next();
      if (_i6.done) break;
      _ref6 = _i6.value;
    }

    var _key3 = _ref6;

    child[_key3] = parent[_key3];
  }

  t.inheritsComments(child, parent);

  return child;
}

function assertNode(node) {
  if (!isNode(node)) {
    throw new TypeError("Not a valid node " + (node && node.type));
  }
}

function isNode(node) {
  return !!(node && _definitions.VISITOR_KEYS[node.type]);
}

(0, _toFastProperties2.default)(t);
(0, _toFastProperties2.default)(t.VISITOR_KEYS);

function traverseFast(node, enter, opts) {
  if (!node) return;

  var keys = t.VISITOR_KEYS[node.type];
  if (!keys) return;

  opts = opts || {};
  enter(node, opts);

  for (var _iterator7 = keys, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : (0, _getIterator3.default)(_iterator7);;) {
    var _ref7;

    if (_isArray7) {
      if (_i7 >= _iterator7.length) break;
      _ref7 = _iterator7[_i7++];
    } else {
      _i7 = _iterator7.next();
      if (_i7.done) break;
      _ref7 = _i7.value;
    }

    var key = _ref7;

    var subNode = node[key];

    if (Array.isArray(subNode)) {
      for (var _iterator8 = subNode, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : (0, _getIterator3.default)(_iterator8);;) {
        var _ref8;

        if (_isArray8) {
          if (_i8 >= _iterator8.length) break;
          _ref8 = _iterator8[_i8++];
        } else {
          _i8 = _iterator8.next();
          if (_i8.done) break;
          _ref8 = _i8.value;
        }

        var _node = _ref8;

        traverseFast(_node, enter, opts);
      }
    } else {
      traverseFast(subNode, enter, opts);
    }
  }
}

var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];

var CLEAR_KEYS_PLUS_COMMENTS = t.COMMENT_KEYS.concat(["comments"]).concat(CLEAR_KEYS);

function removeProperties(node, opts) {
  opts = opts || {};
  var map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
  for (var _iterator9 = map, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : (0, _getIterator3.default)(_iterator9);;) {
    var _ref9;

    if (_isArray9) {
      if (_i9 >= _iterator9.length) break;
      _ref9 = _iterator9[_i9++];
    } else {
      _i9 = _iterator9.next();
      if (_i9.done) break;
      _ref9 = _i9.value;
    }

    var _key4 = _ref9;

    if (node[_key4] != null) node[_key4] = undefined;
  }

  for (var key in node) {
    if (key[0] === "_" && node[key] != null) node[key] = undefined;
  }

  var syms = (0, _getOwnPropertySymbols2.default)(node);
  for (var _iterator10 = syms, _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : (0, _getIterator3.default)(_iterator10);;) {
    var _ref10;

    if (_isArray10) {
      if (_i10 >= _iterator10.length) break;
      _ref10 = _iterator10[_i10++];
    } else {
      _i10 = _iterator10.next();
      if (_i10.done) break;
      _ref10 = _i10.value;
    }

    var sym = _ref10;

    node[sym] = null;
  }
}

function removePropertiesDeep(tree, opts) {
  traverseFast(tree, removeProperties, opts);
  return tree;
}
},{"./constants":47,"./converters":48,"./definitions":53,"./definitions/init":54,"./flow":57,"./react":59,"./retrievers":60,"./validators":61,"babel-runtime/core-js/get-iterator":9,"babel-runtime/core-js/json/stringify":10,"babel-runtime/core-js/object/get-own-property-symbols":14,"babel-runtime/core-js/object/keys":15,"lodash/clone":331,"lodash/uniq":360,"to-fast-properties":372}],59:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.isReactComponent = undefined;
exports.isCompatTag = isCompatTag;
exports.buildChildren = buildChildren;

var _index = require("./index");

var t = _interopRequireWildcard(_index);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var isReactComponent = exports.isReactComponent = t.buildMatchMemberExpression("React.Component");

function isCompatTag(tagName) {
  return !!tagName && /^[a-z]|\-/.test(tagName);
}

function cleanJSXElementLiteralChild(child, args) {
  var lines = child.value.split(/\r\n|\n|\r/);

  var lastNonEmptyLine = 0;

  for (var i = 0; i < lines.length; i++) {
    if (lines[i].match(/[^ \t]/)) {
      lastNonEmptyLine = i;
    }
  }

  var str = "";

  for (var _i = 0; _i < lines.length; _i++) {
    var line = lines[_i];

    var isFirstLine = _i === 0;
    var isLastLine = _i === lines.length - 1;
    var isLastNonEmptyLine = _i === lastNonEmptyLine;

    var trimmedLine = line.replace(/\t/g, " ");

    if (!isFirstLine) {
      trimmedLine = trimmedLine.replace(/^[ ]+/, "");
    }

    if (!isLastLine) {
      trimmedLine = trimmedLine.replace(/[ ]+$/, "");
    }

    if (trimmedLine) {
      if (!isLastNonEmptyLine) {
        trimmedLine += " ";
      }

      str += trimmedLine;
    }
  }

  if (str) args.push(t.stringLiteral(str));
}

function buildChildren(node) {
  var elems = [];

  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];

    if (t.isJSXText(child)) {
      cleanJSXElementLiteralChild(child, elems);
      continue;
    }

    if (t.isJSXExpressionContainer(child)) child = child.expression;
    if (t.isJSXEmptyExpression(child)) continue;

    elems.push(child);
  }

  return elems;
}
},{"./index":58}],60:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _create = require("babel-runtime/core-js/object/create");

var _create2 = _interopRequireDefault(_create);

exports.getBindingIdentifiers = getBindingIdentifiers;
exports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;

var _index = require("./index");

var t = _interopRequireWildcard(_index);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getBindingIdentifiers(node, duplicates, outerOnly) {
  var search = [].concat(node);
  var ids = (0, _create2.default)(null);

  while (search.length) {
    var id = search.shift();
    if (!id) continue;

    var keys = t.getBindingIdentifiers.keys[id.type];

    if (t.isIdentifier(id)) {
      if (duplicates) {
        var _ids = ids[id.name] = ids[id.name] || [];
        _ids.push(id);
      } else {
        ids[id.name] = id;
      }
      continue;
    }

    if (t.isExportDeclaration(id)) {
      if (t.isDeclaration(id.declaration)) {
        search.push(id.declaration);
      }
      continue;
    }

    if (outerOnly) {
      if (t.isFunctionDeclaration(id)) {
        search.push(id.id);
        continue;
      }

      if (t.isFunctionExpression(id)) {
        continue;
      }
    }

    if (keys) {
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (id[key]) {
          search = search.concat(id[key]);
        }
      }
    }
  }

  return ids;
}

getBindingIdentifiers.keys = {
  DeclareClass: ["id"],
  DeclareFunction: ["id"],
  DeclareModule: ["id"],
  DeclareVariable: ["id"],
  InterfaceDeclaration: ["id"],
  TypeAlias: ["id"],

  CatchClause: ["param"],
  LabeledStatement: ["label"],
  UnaryExpression: ["argument"],
  AssignmentExpression: ["left"],

  ImportSpecifier: ["local"],
  ImportNamespaceSpecifier: ["local"],
  ImportDefaultSpecifier: ["local"],
  ImportDeclaration: ["specifiers"],

  ExportSpecifier: ["exported"],
  ExportNamespaceSpecifier: ["exported"],
  ExportDefaultSpecifier: ["exported"],

  FunctionDeclaration: ["id", "params"],
  FunctionExpression: ["id", "params"],

  ClassDeclaration: ["id"],
  ClassExpression: ["id"],

  RestElement: ["argument"],
  UpdateExpression: ["argument"],

  RestProperty: ["argument"],
  ObjectProperty: ["value"],

  AssignmentPattern: ["left"],
  ArrayPattern: ["elements"],
  ObjectPattern: ["properties"],

  VariableDeclaration: ["declarations"],
  VariableDeclarator: ["id"]
};

function getOuterBindingIdentifiers(node, duplicates) {
  return getBindingIdentifiers(node, duplicates, true);
}
},{"./index":58,"babel-runtime/core-js/object/create":13}],61:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.isBinding = isBinding;
exports.isReferenced = isReferenced;
exports.isValidIdentifier = isValidIdentifier;
exports.isLet = isLet;
exports.isBlockScoped = isBlockScoped;
exports.isVar = isVar;
exports.isSpecifierDefault = isSpecifierDefault;
exports.isScope = isScope;
exports.isImmutable = isImmutable;
exports.isNodesEquivalent = isNodesEquivalent;

var _retrievers = require("./retrievers");

var _esutils = require("esutils");

var _esutils2 = _interopRequireDefault(_esutils);

var _index = require("./index");

var t = _interopRequireWildcard(_index);

var _constants = require("./constants");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isBinding(node, parent) {
  var keys = _retrievers.getBindingIdentifiers.keys[parent.type];
  if (keys) {
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var val = parent[key];
      if (Array.isArray(val)) {
        if (val.indexOf(node) >= 0) return true;
      } else {
        if (val === node) return true;
      }
    }
  }

  return false;
}

function isReferenced(node, parent) {
  switch (parent.type) {
    case "BindExpression":
      return parent.object === node || parent.callee === node;

    case "MemberExpression":
    case "JSXMemberExpression":
      if (parent.property === node && parent.computed) {
        return true;
      } else if (parent.object === node) {
        return true;
      } else {
        return false;
      }

    case "MetaProperty":
      return false;

    case "ObjectProperty":
      if (parent.key === node) {
        return parent.computed;
      }

    case "VariableDeclarator":
      return parent.id !== node;

    case "ArrowFunctionExpression":
    case "FunctionDeclaration":
    case "FunctionExpression":
      for (var _iterator = parent.params, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var param = _ref;

        if (param === node) return false;
      }

      return parent.id !== node;

    case "ExportSpecifier":
      if (parent.source) {
        return false;
      } else {
        return parent.local === node;
      }

    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      return false;

    case "JSXAttribute":
      return parent.name !== node;

    case "ClassProperty":
      if (parent.key === node) {
        return parent.computed;
      } else {
        return parent.value === node;
      }

    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
      return false;

    case "ClassDeclaration":
    case "ClassExpression":
      return parent.id !== node;

    case "ClassMethod":
    case "ObjectMethod":
      return parent.key === node && parent.computed;

    case "LabeledStatement":
      return false;

    case "CatchClause":
      return parent.param !== node;

    case "RestElement":
      return false;

    case "AssignmentExpression":
      return parent.right === node;

    case "AssignmentPattern":
      return parent.right === node;

    case "ObjectPattern":
    case "ArrayPattern":
      return false;
  }

  return true;
}

function isValidIdentifier(name) {
  if (typeof name !== "string" || _esutils2.default.keyword.isReservedWordES6(name, true)) {
    return false;
  } else if (name === "await") {
    return false;
  } else {
    return _esutils2.default.keyword.isIdentifierNameES6(name);
  }
}

function isLet(node) {
  return t.isVariableDeclaration(node) && (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL]);
}

function isBlockScoped(node) {
  return t.isFunctionDeclaration(node) || t.isClassDeclaration(node) || t.isLet(node);
}

function isVar(node) {
  return t.isVariableDeclaration(node, { kind: "var" }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
}

function isSpecifierDefault(specifier) {
  return t.isImportDefaultSpecifier(specifier) || t.isIdentifier(specifier.imported || specifier.exported, { name: "default" });
}

function isScope(node, parent) {
  if (t.isBlockStatement(node) && t.isFunction(parent, { body: node })) {
    return false;
  }

  return t.isScopable(node);
}

function isImmutable(node) {
  if (t.isType(node.type, "Immutable")) return true;

  if (t.isIdentifier(node)) {
    if (node.name === "undefined") {
      return true;
    } else {
      return false;
    }
  }

  return false;
}

function isNodesEquivalent(a, b) {
  if ((typeof a === "undefined" ? "undefined" : (0, _typeof3.default)(a)) !== "object" || (typeof a === "undefined" ? "undefined" : (0, _typeof3.default)(a)) !== "object" || a == null || b == null) {
    return a === b;
  }

  if (a.type !== b.type) {
    return false;
  }

  var fields = (0, _keys2.default)(t.NODE_FIELDS[a.type] || a.type);

  for (var _iterator2 = fields, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
    var _ref2;

    if (_isArray2) {
      if (_i2 >= _iterator2.length) break;
      _ref2 = _iterator2[_i2++];
    } else {
      _i2 = _iterator2.next();
      if (_i2.done) break;
      _ref2 = _i2.value;
    }

    var field = _ref2;

    if ((0, _typeof3.default)(a[field]) !== (0, _typeof3.default)(b[field])) {
      return false;
    }

    if (Array.isArray(a[field])) {
      if (!Array.isArray(b[field])) {
        return false;
      }
      if (a[field].length !== b[field].length) {
        return false;
      }

      for (var i = 0; i < a[field].length; i++) {
        if (!isNodesEquivalent(a[field][i], b[field][i])) {
          return false;
        }
      }
      continue;
    }

    if (!isNodesEquivalent(a[field], b[field])) {
      return false;
    }
  }

  return true;
}
},{"./constants":47,"./index":58,"./retrievers":60,"babel-runtime/core-js/get-iterator":9,"babel-runtime/core-js/object/keys":15,"babel-runtime/helpers/typeof":21,"esutils":197}],62:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/* eslint max-len: 0 */

// This is a trick taken from Esprima. It turns out that, on
// non-Chrome browsers, to check whether a string is in a set, a
// predicate containing a big ugly `switch` statement is faster than
// a regular expression, and on Chrome the two are about on par.
// This function uses `eval` (non-lexical) to produce such a
// predicate from a space-separated string of words.
//
// It starts by sorting the words by length.

function makePredicate(words) {
  words = words.split(" ");
  return function (str) {
    return words.indexOf(str) >= 0;
  };
}

// Reserved word lists for various dialects of the language

var reservedWords = {
  6: makePredicate("enum await"),
  strict: makePredicate("implements interface let package private protected public static yield"),
  strictBind: makePredicate("eval arguments")
};

// And the keywords

var isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this let const class extends export import yield super");

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.

var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA900-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by `bin/generate-identifier-regex.js`.
// eslint-disable-next-line comma-spacing
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 449, 56, 264, 8, 2, 36, 18, 0, 50, 29, 881, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 65, 0, 32, 6124, 20, 754, 9486, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 10591, 541];
// eslint-disable-next-line comma-spacing
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 87, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 838, 7, 2, 7, 17, 9, 57, 21, 2, 13, 19882, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239];

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) return false;

    pos += set[i + 1];
    if (pos >= code) return true;
  }
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code) {
  if (code < 65) return code === 36;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  return isInAstralSet(code, astralIdentifierStartCodes);
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}

// A second optional argument can be given to further configure
var defaultOptions = {
  // Source type ("script" or "module") for different semantics
  sourceType: "script",
  // Source filename.
  sourceFilename: undefined,
  // Line from which to start counting source. Useful for
  // integration with other tools.
  startLine: 1,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // TODO
  allowSuperOutsideMethod: false,
  // An array of plugins to enable
  plugins: [],
  // TODO
  strictMode: null
};

// Interpret and default an options object

function getOptions(opts) {
  var options = {};
  for (var key in defaultOptions) {
    options[key] = opts && key in opts ? opts[key] : defaultOptions[key];
  }
  return options;
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};











var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var beforeExpr = true;
var startsExpr = true;
var isLoop = true;
var isAssign = true;
var prefix = true;
var postfix = true;

var TokenType = function TokenType(label) {
  var conf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  classCallCheck(this, TokenType);

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.rightAssociative = !!conf.rightAssociative;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

var KeywordTokenType = function (_TokenType) {
  inherits(KeywordTokenType, _TokenType);

  function KeywordTokenType(name) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, KeywordTokenType);

    options.keyword = name;

    return possibleConstructorReturn(this, _TokenType.call(this, name, options));
  }

  return KeywordTokenType;
}(TokenType);

var BinopTokenType = function (_TokenType2) {
  inherits(BinopTokenType, _TokenType2);

  function BinopTokenType(name, prec) {
    classCallCheck(this, BinopTokenType);
    return possibleConstructorReturn(this, _TokenType2.call(this, name, { beforeExpr: beforeExpr, binop: prec }));
  }

  return BinopTokenType;
}(TokenType);

var types = {
  num: new TokenType("num", { startsExpr: startsExpr }),
  regexp: new TokenType("regexp", { startsExpr: startsExpr }),
  string: new TokenType("string", { startsExpr: startsExpr }),
  name: new TokenType("name", { startsExpr: startsExpr }),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  braceBarL: new TokenType("{|", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  braceR: new TokenType("}"),
  braceBarR: new TokenType("|}"),
  parenL: new TokenType("(", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", { beforeExpr: beforeExpr }),
  semi: new TokenType(";", { beforeExpr: beforeExpr }),
  colon: new TokenType(":", { beforeExpr: beforeExpr }),
  doubleColon: new TokenType("::", { beforeExpr: beforeExpr }),
  dot: new TokenType("."),
  question: new TokenType("?", { beforeExpr: beforeExpr }),
  arrow: new TokenType("=>", { beforeExpr: beforeExpr }),
  template: new TokenType("template"),
  ellipsis: new TokenType("...", { beforeExpr: beforeExpr }),
  backQuote: new TokenType("`", { startsExpr: startsExpr }),
  dollarBraceL: new TokenType("${", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  at: new TokenType("@"),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", { beforeExpr: beforeExpr, isAssign: isAssign }),
  assign: new TokenType("_=", { beforeExpr: beforeExpr, isAssign: isAssign }),
  incDec: new TokenType("++/--", { prefix: prefix, postfix: postfix, startsExpr: startsExpr }),
  prefix: new TokenType("prefix", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr }),
  logicalOR: new BinopTokenType("||", 1),
  logicalAND: new BinopTokenType("&&", 2),
  bitwiseOR: new BinopTokenType("|", 3),
  bitwiseXOR: new BinopTokenType("^", 4),
  bitwiseAND: new BinopTokenType("&", 5),
  equality: new BinopTokenType("==/!=", 6),
  relational: new BinopTokenType("</>", 7),
  bitShift: new BinopTokenType("<</>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: beforeExpr, binop: 9, prefix: prefix, startsExpr: startsExpr }),
  modulo: new BinopTokenType("%", 10),
  star: new BinopTokenType("*", 10),
  slash: new BinopTokenType("/", 10),
  exponent: new TokenType("**", { beforeExpr: beforeExpr, binop: 11, rightAssociative: true })
};

var keywords = {
  "break": new KeywordTokenType("break"),
  "case": new KeywordTokenType("case", { beforeExpr: beforeExpr }),
  "catch": new KeywordTokenType("catch"),
  "continue": new KeywordTokenType("continue"),
  "debugger": new KeywordTokenType("debugger"),
  "default": new KeywordTokenType("default", { beforeExpr: beforeExpr }),
  "do": new KeywordTokenType("do", { isLoop: isLoop, beforeExpr: beforeExpr }),
  "else": new KeywordTokenType("else", { beforeExpr: beforeExpr }),
  "finally": new KeywordTokenType("finally"),
  "for": new KeywordTokenType("for", { isLoop: isLoop }),
  "function": new KeywordTokenType("function", { startsExpr: startsExpr }),
  "if": new KeywordTokenType("if"),
  "return": new KeywordTokenType("return", { beforeExpr: beforeExpr }),
  "switch": new KeywordTokenType("switch"),
  "throw": new KeywordTokenType("throw", { beforeExpr: beforeExpr }),
  "try": new KeywordTokenType("try"),
  "var": new KeywordTokenType("var"),
  "let": new KeywordTokenType("let"),
  "const": new KeywordTokenType("const"),
  "while": new KeywordTokenType("while", { isLoop: isLoop }),
  "with": new KeywordTokenType("with"),
  "new": new KeywordTokenType("new", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  "this": new KeywordTokenType("this", { startsExpr: startsExpr }),
  "super": new KeywordTokenType("super", { startsExpr: startsExpr }),
  "class": new KeywordTokenType("class"),
  "extends": new KeywordTokenType("extends", { beforeExpr: beforeExpr }),
  "export": new KeywordTokenType("export"),
  "import": new KeywordTokenType("import"),
  "yield": new KeywordTokenType("yield", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  "null": new KeywordTokenType("null", { startsExpr: startsExpr }),
  "true": new KeywordTokenType("true", { startsExpr: startsExpr }),
  "false": new KeywordTokenType("false", { startsExpr: startsExpr }),
  "in": new KeywordTokenType("in", { beforeExpr: beforeExpr, binop: 7 }),
  "instanceof": new KeywordTokenType("instanceof", { beforeExpr: beforeExpr, binop: 7 }),
  "typeof": new KeywordTokenType("typeof", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr }),
  "void": new KeywordTokenType("void", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr }),
  "delete": new KeywordTokenType("delete", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr })
};

// Map keyword names to token types.
Object.keys(keywords).forEach(function (name) {
  types["_" + name] = keywords[name];
});

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;
}

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

// The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js' approach.
// See https://github.com/mozilla/sweet.js/wiki/design

var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
  classCallCheck(this, TokContext);

  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
};

var types$1 = {
  braceStatement: new TokContext("{", false),
  braceExpression: new TokContext("{", true),
  templateQuasi: new TokContext("${", true),
  parenStatement: new TokContext("(", false),
  parenExpression: new TokContext("(", true),
  template: new TokContext("`", true, true, function (p) {
    return p.readTmplToken();
  }),
  functionExpression: new TokContext("function", true)
};

// Token-specific context update code

types.parenR.updateContext = types.braceR.updateContext = function () {
  if (this.state.context.length === 1) {
    this.state.exprAllowed = true;
    return;
  }

  var out = this.state.context.pop();
  if (out === types$1.braceStatement && this.curContext() === types$1.functionExpression) {
    this.state.context.pop();
    this.state.exprAllowed = false;
  } else if (out === types$1.templateQuasi) {
    this.state.exprAllowed = true;
  } else {
    this.state.exprAllowed = !out.isExpr;
  }
};

types.name.updateContext = function (prevType) {
  this.state.exprAllowed = false;

  if (prevType === types._let || prevType === types._const || prevType === types._var) {
    if (lineBreak.test(this.input.slice(this.state.end))) {
      this.state.exprAllowed = true;
    }
  }
};

types.braceL.updateContext = function (prevType) {
  this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);
  this.state.exprAllowed = true;
};

types.dollarBraceL.updateContext = function () {
  this.state.context.push(types$1.templateQuasi);
  this.state.exprAllowed = true;
};

types.parenL.updateContext = function (prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);
  this.state.exprAllowed = true;
};

types.incDec.updateContext = function () {
  // tokExprAllowed stays unchanged
};

types._function.updateContext = function () {
  if (this.curContext() !== types$1.braceStatement) {
    this.state.context.push(types$1.functionExpression);
  }

  this.state.exprAllowed = false;
};

types.backQuote.updateContext = function () {
  if (this.curContext() === types$1.template) {
    this.state.context.pop();
  } else {
    this.state.context.push(types$1.template);
  }
  this.state.exprAllowed = false;
};

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  classCallCheck(this, Position);

  this.line = line;
  this.column = col;
};

var SourceLocation = function SourceLocation(start, end) {
  classCallCheck(this, SourceLocation);

  this.start = start;
  this.end = end;
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur);
    }
  }
}

var State = function () {
  function State() {
    classCallCheck(this, State);
  }

  State.prototype.init = function init(options, input) {
    this.strict = options.strictMode === false ? false : options.sourceType === "module";

    this.input = input;

    this.potentialArrowAt = -1;

    this.inMethod = this.inFunction = this.inGenerator = this.inAsync = this.inPropertyName = this.inType = this.noAnonFunctionType = false;

    this.labels = [];

    this.decorators = [];

    this.tokens = [];

    this.comments = [];

    this.trailingComments = [];
    this.leadingComments = [];
    this.commentStack = [];

    this.pos = this.lineStart = 0;
    this.curLine = options.startLine;

    this.type = types.eof;
    this.value = null;
    this.start = this.end = this.pos;
    this.startLoc = this.endLoc = this.curPosition();

    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;

    this.context = [types$1.braceStatement];
    this.exprAllowed = true;

    this.containsEsc = this.containsOctal = false;
    this.octalPosition = null;

    this.exportedIdentifiers = [];

    return this;
  };

  // TODO


  // TODO


  // Used to signify the start of a potential arrow function


  // Flags to track whether we are in a function, a generator.


  // Labels in scope.


  // Leading decorators.


  // Token store.


  // Comment store.


  // Comment attachment store


  // The current position of the tokenizer in the input.


  // Properties of the current token:
  // Its type


  // For tokens that include more information than their type, the value


  // Its start and end offset


  // And, if locations are used, the {line, column} object
  // corresponding to those offsets


  // Position information for the previous token


  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.


  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.


  // TODO


  // Names of exports store. `default` is stored as a name for both
  // `export default foo;` and `export { foo as default };`.


  State.prototype.curPosition = function curPosition() {
    return new Position(this.curLine, this.pos - this.lineStart);
  };

  State.prototype.clone = function clone(skipArrays) {
    var state = new State();
    for (var key in this) {
      var val = this[key];

      if ((!skipArrays || key === "context") && Array.isArray(val)) {
        val = val.slice();
      }

      state[key] = val;
    }
    return state;
  };

  return State;
}();

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(state) {
  classCallCheck(this, Token);

  this.type = state.type;
  this.value = state.value;
  this.start = state.start;
  this.end = state.end;
  this.loc = new SourceLocation(state.startLoc, state.endLoc);
};

// ## Tokenizer

function codePointToString(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) {
    return String.fromCharCode(code);
  } else {
    return String.fromCharCode((code - 0x10000 >> 10) + 0xD800, (code - 0x10000 & 1023) + 0xDC00);
  }
}

var Tokenizer = function () {
  function Tokenizer(options, input) {
    classCallCheck(this, Tokenizer);

    this.state = new State();
    this.state.init(options, input);
  }

  // Move to the next token

  Tokenizer.prototype.next = function next() {
    if (!this.isLookahead) {
      this.state.tokens.push(new Token(this.state));
    }

    this.state.lastTokEnd = this.state.end;
    this.state.lastTokStart = this.state.start;
    this.state.lastTokEndLoc = this.state.endLoc;
    this.state.lastTokStartLoc = this.state.startLoc;
    this.nextToken();
  };

  // TODO

  Tokenizer.prototype.eat = function eat(type) {
    if (this.match(type)) {
      this.next();
      return true;
    } else {
      return false;
    }
  };

  // TODO

  Tokenizer.prototype.match = function match(type) {
    return this.state.type === type;
  };

  // TODO

  Tokenizer.prototype.isKeyword = function isKeyword$$1(word) {
    return isKeyword(word);
  };

  // TODO

  Tokenizer.prototype.lookahead = function lookahead() {
    var old = this.state;
    this.state = old.clone(true);

    this.isLookahead = true;
    this.next();
    this.isLookahead = false;

    var curr = this.state.clone(true);
    this.state = old;
    return curr;
  };

  // Toggle strict mode. Re-reads the next number or string to please
  // pedantic tests (`"use strict"; 010;` should fail).

  Tokenizer.prototype.setStrict = function setStrict(strict) {
    this.state.strict = strict;
    if (!this.match(types.num) && !this.match(types.string)) return;
    this.state.pos = this.state.start;
    while (this.state.pos < this.state.lineStart) {
      this.state.lineStart = this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1;
      --this.state.curLine;
    }
    this.nextToken();
  };

  Tokenizer.prototype.curContext = function curContext() {
    return this.state.context[this.state.context.length - 1];
  };

  // Read a single token, updating the parser object's token-related
  // properties.

  Tokenizer.prototype.nextToken = function nextToken() {
    var curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) this.skipSpace();

    this.state.containsOctal = false;
    this.state.octalPosition = null;
    this.state.start = this.state.pos;
    this.state.startLoc = this.state.curPosition();
    if (this.state.pos >= this.input.length) return this.finishToken(types.eof);

    if (curContext.override) {
      return curContext.override(this);
    } else {
      return this.readToken(this.fullCharCodeAtPos());
    }
  };

  Tokenizer.prototype.readToken = function readToken(code) {
    // Identifier or keyword. '\uXXXX' sequences are allowed in
    // identifiers, so '\' also dispatches to that.
    if (isIdentifierStart(code) || code === 92 /* '\' */) {
        return this.readWord();
      } else {
      return this.getTokenFromCode(code);
    }
  };

  Tokenizer.prototype.fullCharCodeAtPos = function fullCharCodeAtPos() {
    var code = this.input.charCodeAt(this.state.pos);
    if (code <= 0xd7ff || code >= 0xe000) return code;

    var next = this.input.charCodeAt(this.state.pos + 1);
    return (code << 10) + next - 0x35fdc00;
  };

  Tokenizer.prototype.pushComment = function pushComment(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "CommentBlock" : "CommentLine",
      value: text,
      start: start,
      end: end,
      loc: new SourceLocation(startLoc, endLoc)
    };

    if (!this.isLookahead) {
      this.state.tokens.push(comment);
      this.state.comments.push(comment);
      this.addComment(comment);
    }
  };

  Tokenizer.prototype.skipBlockComment = function skipBlockComment() {
    var startLoc = this.state.curPosition();
    var start = this.state.pos;
    var end = this.input.indexOf("*/", this.state.pos += 2);
    if (end === -1) this.raise(this.state.pos - 2, "Unterminated comment");

    this.state.pos = end + 2;
    lineBreakG.lastIndex = start;
    var match = void 0;
    while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {
      ++this.state.curLine;
      this.state.lineStart = match.index + match[0].length;
    }

    this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());
  };

  Tokenizer.prototype.skipLineComment = function skipLineComment(startSkip) {
    var start = this.state.pos;
    var startLoc = this.state.curPosition();
    var ch = this.input.charCodeAt(this.state.pos += startSkip);
    while (this.state.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
      ++this.state.pos;
      ch = this.input.charCodeAt(this.state.pos);
    }

    this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());
  };

  // Called at the start of the parse and after every token. Skips
  // whitespace and comments, and.

  Tokenizer.prototype.skipSpace = function skipSpace() {
    loop: while (this.state.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.state.pos);
      switch (ch) {
        case 32:case 160:
          // ' '
          ++this.state.pos;
          break;

        case 13:
          if (this.input.charCodeAt(this.state.pos + 1) === 10) {
            ++this.state.pos;
          }

        case 10:case 8232:case 8233:
          ++this.state.pos;
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          break;

        case 47:
          // '/'
          switch (this.input.charCodeAt(this.state.pos + 1)) {
            case 42:
              // '*'
              this.skipBlockComment();
              break;

            case 47:
              this.skipLineComment(2);
              break;

            default:
              break loop;
          }
          break;

        default:
          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this.state.pos;
          } else {
            break loop;
          }
      }
    }
  };

  // Called at the end of every token. Sets `end`, `val`, and
  // maintains `context` and `exprAllowed`, and skips the space after
  // the token, so that the next one's `start` will point at the
  // right position.

  Tokenizer.prototype.finishToken = function finishToken(type, val) {
    this.state.end = this.state.pos;
    this.state.endLoc = this.state.curPosition();
    var prevType = this.state.type;
    this.state.type = type;
    this.state.value = val;

    this.updateContext(prevType);
  };

  // ### Token reading

  // This is the function that is called to fetch the next token. It
  // is somewhat obscure, because it works in character codes rather
  // than characters, and because operator parsing has been inlined
  // into it.
  //
  // All in the name of speed.
  //


  Tokenizer.prototype.readToken_dot = function readToken_dot() {
    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next >= 48 && next <= 57) {
      return this.readNumber(true);
    }

    var next2 = this.input.charCodeAt(this.state.pos + 2);
    if (next === 46 && next2 === 46) {
      // 46 = dot '.'
      this.state.pos += 3;
      return this.finishToken(types.ellipsis);
    } else {
      ++this.state.pos;
      return this.finishToken(types.dot);
    }
  };

  Tokenizer.prototype.readToken_slash = function readToken_slash() {
    // '/'
    if (this.state.exprAllowed) {
      ++this.state.pos;
      return this.readRegexp();
    }

    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next === 61) {
      return this.finishOp(types.assign, 2);
    } else {
      return this.finishOp(types.slash, 1);
    }
  };

  Tokenizer.prototype.readToken_mult_modulo = function readToken_mult_modulo(code) {
    // '%*'
    var type = code === 42 ? types.star : types.modulo;
    var width = 1;
    var next = this.input.charCodeAt(this.state.pos + 1);

    if (next === 42) {
      // '*'
      width++;
      next = this.input.charCodeAt(this.state.pos + 2);
      type = types.exponent;
    }

    if (next === 61) {
      width++;
      type = types.assign;
    }

    return this.finishOp(type, width);
  };

  Tokenizer.prototype.readToken_pipe_amp = function readToken_pipe_amp(code) {
    // '|&'
    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next === code) return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
    if (next === 61) return this.finishOp(types.assign, 2);
    if (code === 124 && next === 125 && this.hasPlugin("flow")) return this.finishOp(types.braceBarR, 2);
    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
  };

  Tokenizer.prototype.readToken_caret = function readToken_caret() {
    // '^'
    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next === 61) {
      return this.finishOp(types.assign, 2);
    } else {
      return this.finishOp(types.bitwiseXOR, 1);
    }
  };

  Tokenizer.prototype.readToken_plus_min = function readToken_plus_min(code) {
    // '+-'
    var next = this.input.charCodeAt(this.state.pos + 1);

    if (next === code) {
      if (next === 45 && this.input.charCodeAt(this.state.pos + 2) === 62 && lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos))) {
        // A `-->` line comment
        this.skipLineComment(3);
        this.skipSpace();
        return this.nextToken();
      }
      return this.finishOp(types.incDec, 2);
    }

    if (next === 61) {
      return this.finishOp(types.assign, 2);
    } else {
      return this.finishOp(types.plusMin, 1);
    }
  };

  Tokenizer.prototype.readToken_lt_gt = function readToken_lt_gt(code) {
    // '<>'
    var next = this.input.charCodeAt(this.state.pos + 1);
    var size = 1;

    if (next === code) {
      size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(this.state.pos + size) === 61) return this.finishOp(types.assign, size + 1);
      return this.finishOp(types.bitShift, size);
    }

    if (next === 33 && code === 60 && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {
      if (this.inModule) this.unexpected();
      // `<!--`, an XML-style comment that should be interpreted as a line comment
      this.skipLineComment(4);
      this.skipSpace();
      return this.nextToken();
    }

    if (next === 61) {
      // <= | >=
      size = 2;
    }

    return this.finishOp(types.relational, size);
  };

  Tokenizer.prototype.readToken_eq_excl = function readToken_eq_excl(code) {
    // '=!'
    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next === 61) return this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
    if (code === 61 && next === 62) {
      // '=>'
      this.state.pos += 2;
      return this.finishToken(types.arrow);
    }
    return this.finishOp(code === 61 ? types.eq : types.prefix, 1);
  };

  Tokenizer.prototype.getTokenFromCode = function getTokenFromCode(code) {
    switch (code) {
      // The interpretation of a dot depends on whether it is followed
      // by a digit or another two dots.
      case 46:
        // '.'
        return this.readToken_dot();

      // Punctuation tokens.
      case 40:
        ++this.state.pos;return this.finishToken(types.parenL);
      case 41:
        ++this.state.pos;return this.finishToken(types.parenR);
      case 59:
        ++this.state.pos;return this.finishToken(types.semi);
      case 44:
        ++this.state.pos;return this.finishToken(types.comma);
      case 91:
        ++this.state.pos;return this.finishToken(types.bracketL);
      case 93:
        ++this.state.pos;return this.finishToken(types.bracketR);

      case 123:
        if (this.hasPlugin("flow") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          return this.finishOp(types.braceBarL, 2);
        } else {
          ++this.state.pos;
          return this.finishToken(types.braceL);
        }

      case 125:
        ++this.state.pos;return this.finishToken(types.braceR);

      case 58:
        if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
          return this.finishOp(types.doubleColon, 2);
        } else {
          ++this.state.pos;
          return this.finishToken(types.colon);
        }

      case 63:
        ++this.state.pos;return this.finishToken(types.question);
      case 64:
        ++this.state.pos;return this.finishToken(types.at);

      case 96:
        // '`'
        ++this.state.pos;
        return this.finishToken(types.backQuote);

      case 48:
        // '0'
        var next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
        if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number
      // Anything else beginning with a digit is an integer, octal
      // number, or float.
      case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
        // 1-9
        return this.readNumber(false);

      // Quotes produce strings.
      case 34:case 39:
        // '"', "'"
        return this.readString(code);

      // Operators are parsed inline in tiny state machines. '=' (61) is
      // often referred to. `finishOp` simply skips the amount of
      // characters it is given as second argument, and returns a token
      // of the type given by its first argument.

      case 47:
        // '/'
        return this.readToken_slash();

      case 37:case 42:
        // '%*'
        return this.readToken_mult_modulo(code);

      case 124:case 38:
        // '|&'
        return this.readToken_pipe_amp(code);

      case 94:
        // '^'
        return this.readToken_caret();

      case 43:case 45:
        // '+-'
        return this.readToken_plus_min(code);

      case 60:case 62:
        // '<>'
        return this.readToken_lt_gt(code);

      case 61:case 33:
        // '=!'
        return this.readToken_eq_excl(code);

      case 126:
        // '~'
        return this.finishOp(types.prefix, 1);
    }

    this.raise(this.state.pos, "Unexpected character '" + codePointToString(code) + "'");
  };

  Tokenizer.prototype.finishOp = function finishOp(type, size) {
    var str = this.input.slice(this.state.pos, this.state.pos + size);
    this.state.pos += size;
    return this.finishToken(type, str);
  };

  Tokenizer.prototype.readRegexp = function readRegexp() {
    var start = this.state.pos;
    var escaped = void 0,
        inClass = void 0;
    for (;;) {
      if (this.state.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
      var ch = this.input.charAt(this.state.pos);
      if (lineBreak.test(ch)) {
        this.raise(start, "Unterminated regular expression");
      }
      if (escaped) {
        escaped = false;
      } else {
        if (ch === "[") {
          inClass = true;
        } else if (ch === "]" && inClass) {
          inClass = false;
        } else if (ch === "/" && !inClass) {
          break;
        }
        escaped = ch === "\\";
      }
      ++this.state.pos;
    }
    var content = this.input.slice(start, this.state.pos);
    ++this.state.pos;
    // Need to use `readWord1` because '\uXXXX' sequences are allowed
    // here (don't ask).
    var mods = this.readWord1();
    if (mods) {
      var validFlags = /^[gmsiyu]*$/;
      if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
    }
    return this.finishToken(types.regexp, {
      pattern: content,
      flags: mods
    });
  };

  // Read an integer in the given radix. Return null if zero digits
  // were read, the integer value otherwise. When `len` is given, this
  // will return `null` unless the integer has exactly `len` digits.

  Tokenizer.prototype.readInt = function readInt(radix, len) {
    var start = this.state.pos;
    var total = 0;

    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      var code = this.input.charCodeAt(this.state.pos);
      var val = void 0;
      if (code >= 97) {
        val = code - 97 + 10; // a
      } else if (code >= 65) {
        val = code - 65 + 10; // A
      } else if (code >= 48 && code <= 57) {
        val = code - 48; // 0-9
      } else {
        val = Infinity;
      }
      if (val >= radix) break;
      ++this.state.pos;
      total = total * radix + val;
    }
    if (this.state.pos === start || len != null && this.state.pos - start !== len) return null;

    return total;
  };

  Tokenizer.prototype.readRadixNumber = function readRadixNumber(radix) {
    this.state.pos += 2; // 0x
    var val = this.readInt(radix);
    if (val == null) this.raise(this.state.start + 2, "Expected number in radix " + radix);
    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.state.pos, "Identifier directly after number");
    return this.finishToken(types.num, val);
  };

  // Read an integer, octal integer, or floating-point number.

  Tokenizer.prototype.readNumber = function readNumber(startsWithDot) {
    var start = this.state.pos;
    var octal = this.input.charCodeAt(this.state.pos) === 48;
    var isFloat = false;

    if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
    var next = this.input.charCodeAt(this.state.pos);
    if (next === 46) {
      // '.'
      ++this.state.pos;
      this.readInt(10);
      isFloat = true;
      next = this.input.charCodeAt(this.state.pos);
    }
    if (next === 69 || next === 101) {
      // 'eE'
      next = this.input.charCodeAt(++this.state.pos);
      if (next === 43 || next === 45) ++this.state.pos; // '+-'
      if (this.readInt(10) === null) this.raise(start, "Invalid number");
      isFloat = true;
    }
    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.state.pos, "Identifier directly after number");

    var str = this.input.slice(start, this.state.pos);
    var val = void 0;
    if (isFloat) {
      val = parseFloat(str);
    } else if (!octal || str.length === 1) {
      val = parseInt(str, 10);
    } else if (/[89]/.test(str) || this.state.strict) {
      this.raise(start, "Invalid number");
    } else {
      val = parseInt(str, 8);
    }
    return this.finishToken(types.num, val);
  };

  // Read a string value, interpreting backslash-escapes.

  Tokenizer.prototype.readCodePoint = function readCodePoint() {
    var ch = this.input.charCodeAt(this.state.pos);
    var code = void 0;

    if (ch === 123) {
      var codePos = ++this.state.pos;
      code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos);
      ++this.state.pos;
      if (code > 0x10FFFF) this.raise(codePos, "Code point out of bounds");
    } else {
      code = this.readHexChar(4);
    }
    return code;
  };

  Tokenizer.prototype.readString = function readString(quote) {
    var out = "",
        chunkStart = ++this.state.pos;
    for (;;) {
      if (this.state.pos >= this.input.length) this.raise(this.state.start, "Unterminated string constant");
      var ch = this.input.charCodeAt(this.state.pos);
      if (ch === quote) break;
      if (ch === 92) {
        // '\'
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.state.pos;
      } else {
        if (isNewLine(ch)) this.raise(this.state.start, "Unterminated string constant");
        ++this.state.pos;
      }
    }
    out += this.input.slice(chunkStart, this.state.pos++);
    return this.finishToken(types.string, out);
  };

  // Reads template string tokens.

  Tokenizer.prototype.readTmplToken = function readTmplToken() {
    var out = "",
        chunkStart = this.state.pos;
    for (;;) {
      if (this.state.pos >= this.input.length) this.raise(this.state.start, "Unterminated template");
      var ch = this.input.charCodeAt(this.state.pos);
      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
        // '`', '${'
        if (this.state.pos === this.state.start && this.match(types.template)) {
          if (ch === 36) {
            this.state.pos += 2;
            return this.finishToken(types.dollarBraceL);
          } else {
            ++this.state.pos;
            return this.finishToken(types.backQuote);
          }
        }
        out += this.input.slice(chunkStart, this.state.pos);
        return this.finishToken(types.template, out);
      }
      if (ch === 92) {
        // '\'
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.readEscapedChar(true);
        chunkStart = this.state.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.state.pos);
        ++this.state.pos;
        switch (ch) {
          case 13:
            if (this.input.charCodeAt(this.state.pos) === 10) ++this.state.pos;
          case 10:
            out += "\n";
            break;
          default:
            out += String.fromCharCode(ch);
            break;
        }
        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        chunkStart = this.state.pos;
      } else {
        ++this.state.pos;
      }
    }
  };

  // Used to read escaped characters

  Tokenizer.prototype.readEscapedChar = function readEscapedChar(inTemplate) {
    var ch = this.input.charCodeAt(++this.state.pos);
    ++this.state.pos;
    switch (ch) {
      case 110:
        return "\n"; // 'n' -> '\n'
      case 114:
        return "\r"; // 'r' -> '\r'
      case 120:
        return String.fromCharCode(this.readHexChar(2)); // 'x'
      case 117:
        return codePointToString(this.readCodePoint()); // 'u'
      case 116:
        return "\t"; // 't' -> '\t'
      case 98:
        return "\b"; // 'b' -> '\b'
      case 118:
        return "\x0B"; // 'v' -> '\u000b'
      case 102:
        return "\f"; // 'f' -> '\f'
      case 13:
        if (this.input.charCodeAt(this.state.pos) === 10) ++this.state.pos; // '\r\n'
      case 10:
        // ' \n'
        this.state.lineStart = this.state.pos;
        ++this.state.curLine;
        return "";
      default:
        if (ch >= 48 && ch <= 55) {
          var octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0];
          var octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          if (octal > 0) {
            if (!this.state.containsOctal) {
              this.state.containsOctal = true;
              this.state.octalPosition = this.state.pos - 2;
            }
            if (this.state.strict || inTemplate) {
              this.raise(this.state.pos - 2, "Octal literal in strict mode");
            }
          }
          this.state.pos += octalStr.length - 1;
          return String.fromCharCode(octal);
        }
        return String.fromCharCode(ch);
    }
  };

  // Used to read character escape sequences ('\x', '\u', '\U').

  Tokenizer.prototype.readHexChar = function readHexChar(len) {
    var codePos = this.state.pos;
    var n = this.readInt(16, len);
    if (n === null) this.raise(codePos, "Bad character escape sequence");
    return n;
  };

  // Read an identifier, and return it as a string. Sets `this.state.containsEsc`
  // to whether the word contained a '\u' escape.
  //
  // Incrementally adds only escaped chars, adding other chunks as-is
  // as a micro-optimization.

  Tokenizer.prototype.readWord1 = function readWord1() {
    this.state.containsEsc = false;
    var word = "",
        first = true,
        chunkStart = this.state.pos;
    while (this.state.pos < this.input.length) {
      var ch = this.fullCharCodeAtPos();
      if (isIdentifierChar(ch)) {
        this.state.pos += ch <= 0xffff ? 1 : 2;
      } else if (ch === 92) {
        // "\"
        this.state.containsEsc = true;

        word += this.input.slice(chunkStart, this.state.pos);
        var escStart = this.state.pos;

        if (this.input.charCodeAt(++this.state.pos) !== 117) {
          // "u"
          this.raise(this.state.pos, "Expecting Unicode escape sequence \\uXXXX");
        }

        ++this.state.pos;
        var esc = this.readCodePoint();
        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, true)) {
          this.raise(escStart, "Invalid Unicode escape");
        }

        word += codePointToString(esc);
        chunkStart = this.state.pos;
      } else {
        break;
      }
      first = false;
    }
    return word + this.input.slice(chunkStart, this.state.pos);
  };

  // Read an identifier or keyword token. Will check for reserved
  // words when necessary.

  Tokenizer.prototype.readWord = function readWord() {
    var word = this.readWord1();
    var type = types.name;
    if (!this.state.containsEsc && this.isKeyword(word)) {
      type = keywords[word];
    }
    return this.finishToken(type, word);
  };

  Tokenizer.prototype.braceIsBlock = function braceIsBlock(prevType) {
    if (prevType === types.colon) {
      var parent = this.curContext();
      if (parent === types$1.braceStatement || parent === types$1.braceExpression) {
        return !parent.isExpr;
      }
    }

    if (prevType === types._return) {
      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
    }

    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR) {
      return true;
    }

    if (prevType === types.braceL) {
      return this.curContext() === types$1.braceStatement;
    }

    return !this.state.exprAllowed;
  };

  Tokenizer.prototype.updateContext = function updateContext(prevType) {
    var type = this.state.type;
    var update = void 0;

    if (type.keyword && prevType === types.dot) {
      this.state.exprAllowed = false;
    } else if (update = type.updateContext) {
      update.call(this, prevType);
    } else {
      this.state.exprAllowed = type.beforeExpr;
    }
  };

  return Tokenizer;
}();

var plugins = {};
var frozenDeprecatedWildcardPluginList = ["jsx", "doExpressions", "objectRestSpread", "decorators", "classProperties", "exportExtensions", "asyncGenerators", "functionBind", "functionSent", "dynamicImport", "flow"];

var Parser = function (_Tokenizer) {
  inherits(Parser, _Tokenizer);

  function Parser(options, input) {
    classCallCheck(this, Parser);

    options = getOptions(options);

    var _this = possibleConstructorReturn(this, _Tokenizer.call(this, options, input));

    _this.options = options;
    _this.inModule = _this.options.sourceType === "module";
    _this.input = input;
    _this.plugins = _this.loadPlugins(_this.options.plugins);
    _this.filename = options.sourceFilename;

    // If enabled, skip leading hashbang line.
    if (_this.state.pos === 0 && _this.input[0] === "#" && _this.input[1] === "!") {
      _this.skipLineComment(2);
    }
    return _this;
  }

  Parser.prototype.isReservedWord = function isReservedWord(word) {
    if (word === "await") {
      return this.inModule;
    } else {
      return reservedWords[6](word);
    }
  };

  Parser.prototype.hasPlugin = function hasPlugin(name) {
    if (this.plugins["*"] && frozenDeprecatedWildcardPluginList.indexOf(name) > -1) {
      return true;
    }

    return !!this.plugins[name];
  };

  Parser.prototype.extend = function extend(name, f) {
    this[name] = f(this[name]);
  };

  Parser.prototype.loadAllPlugins = function loadAllPlugins() {
    var _this2 = this;

    // ensure flow plugin loads last, also ensure estree is not loaded with *
    var pluginNames = Object.keys(plugins).filter(function (name) {
      return name !== "flow" && name !== "estree";
    });
    pluginNames.push("flow");

    pluginNames.forEach(function (name) {
      var plugin = plugins[name];
      if (plugin) plugin(_this2);
    });
  };

  Parser.prototype.loadPlugins = function loadPlugins(pluginList) {
    // TODO: Deprecate "*" option in next major version of Babylon
    if (pluginList.indexOf("*") >= 0) {
      this.loadAllPlugins();

      return { "*": true };
    }

    var pluginMap = {};

    if (pluginList.indexOf("flow") >= 0) {
      // ensure flow plugin loads last
      pluginList = pluginList.filter(function (plugin) {
        return plugin !== "flow";
      });
      pluginList.push("flow");
    }

    if (pluginList.indexOf("estree") >= 0) {
      // ensure estree plugin loads first
      pluginList = pluginList.filter(function (plugin) {
        return plugin !== "estree";
      });
      pluginList.unshift("estree");
    }

    for (var _iterator = pluginList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var name = _ref;

      if (!pluginMap[name]) {
        pluginMap[name] = true;

        var plugin = plugins[name];
        if (plugin) plugin(this);
      }
    }

    return pluginMap;
  };

  Parser.prototype.parse = function parse() {
    var file = this.startNode();
    var program = this.startNode();
    this.nextToken();
    return this.parseTopLevel(file, program);
  };

  return Parser;
}(Tokenizer);

var pp = Parser.prototype;

// ## Parser utilities

// TODO

pp.addExtra = function (node, key, val) {
  if (!node) return;

  var extra = node.extra = node.extra || {};
  extra[key] = val;
};

// TODO

pp.isRelational = function (op) {
  return this.match(types.relational) && this.state.value === op;
};

// TODO

pp.expectRelational = function (op) {
  if (this.isRelational(op)) {
    this.next();
  } else {
    this.unexpected(null, types.relational);
  }
};

// Tests whether parsed token is a contextual keyword.

pp.isContextual = function (name) {
  return this.match(types.name) && this.state.value === name;
};

// Consumes contextual keyword if possible.

pp.eatContextual = function (name) {
  return this.state.value === name && this.eat(types.name);
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function (name, message) {
  if (!this.eatContextual(name)) this.unexpected(null, message);
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function () {
  return this.match(types.eof) || this.match(types.braceR) || lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
};

// TODO

pp.isLineTerminator = function () {
  return this.eat(types.semi) || this.canInsertSemicolon();
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function () {
  if (!this.isLineTerminator()) this.unexpected(null, types.semi);
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error at given pos.

pp.expect = function (type, pos) {
  return this.eat(type) || this.unexpected(pos, type);
};

// Raise an unexpected token error. Can take the expected token type
// instead of a message string.

pp.unexpected = function (pos) {
  var messageOrType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Unexpected token";

  if (messageOrType && (typeof messageOrType === "undefined" ? "undefined" : _typeof(messageOrType)) === "object" && messageOrType.label) {
    messageOrType = "Unexpected token, expected " + messageOrType.label;
  }
  this.raise(pos != null ? pos : this.state.start, messageOrType);
};

/* eslint max-len: 0 */

var pp$1 = Parser.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function (file, program) {
  program.sourceType = this.options.sourceType;

  this.parseBlockBody(program, true, true, types.eof);

  file.program = this.finishNode(program, "Program");
  file.comments = this.state.comments;
  file.tokens = this.state.tokens;

  return this.finishNode(file, "File");
};

var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };

// TODO

pp$1.stmtToDirective = function (stmt) {
  var expr = stmt.expression;

  var directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);
  var directive = this.startNodeAt(stmt.start, stmt.loc.start);

  var raw = this.input.slice(expr.start, expr.end);
  var val = directiveLiteral.value = raw.slice(1, -1); // remove quotes

  this.addExtra(directiveLiteral, "raw", raw);
  this.addExtra(directiveLiteral, "rawValue", val);

  directive.value = this.finishNodeAt(directiveLiteral, "DirectiveLiteral", expr.end, expr.loc.end);

  return this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end);
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$1.parseStatement = function (declaration, topLevel) {
  if (this.match(types.at)) {
    this.parseDecorators(true);
  }

  var starttype = this.state.type;
  var node = this.startNode();

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
    case types._break:case types._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case types._debugger:
      return this.parseDebuggerStatement(node);
    case types._do:
      return this.parseDoStatement(node);
    case types._for:
      return this.parseForStatement(node);
    case types._function:
      if (!declaration) this.unexpected();
      return this.parseFunctionStatement(node);

    case types._class:
      if (!declaration) this.unexpected();
      return this.parseClass(node, true);

    case types._if:
      return this.parseIfStatement(node);
    case types._return:
      return this.parseReturnStatement(node);
    case types._switch:
      return this.parseSwitchStatement(node);
    case types._throw:
      return this.parseThrowStatement(node);
    case types._try:
      return this.parseTryStatement(node);

    case types._let:
    case types._const:
      if (!declaration) this.unexpected(); // NOTE: falls through to _var

    case types._var:
      return this.parseVarStatement(node, starttype);

    case types._while:
      return this.parseWhileStatement(node);
    case types._with:
      return this.parseWithStatement(node);
    case types.braceL:
      return this.parseBlock();
    case types.semi:
      return this.parseEmptyStatement(node);
    case types._export:
    case types._import:
      if (this.hasPlugin("dynamicImport") && this.lookahead().type === types.parenL) break;

      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.state.start, "'import' and 'export' may only appear at the top level");
        }

        if (!this.inModule) {
          this.raise(this.state.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types._import ? this.parseImport(node) : this.parseExport(node);

    case types.name:
      if (this.state.value === "async") {
        // peek ahead and see if next token is a function
        var state = this.state.clone();
        this.next();
        if (this.match(types._function) && !this.canInsertSemicolon()) {
          this.expect(types._function);
          return this.parseFunction(node, true, false, true);
        } else {
          this.state = state;
        }
      }
  }

  // If the statement does not start with a statement keyword or a
  // brace, it's an ExpressionStatement or LabeledStatement. We
  // simply start parsing an expression, and afterwards, if the
  // next token is a colon and the expression was a simple
  // Identifier node, we switch to interpreting it as a label.
  var maybeName = this.state.value;
  var expr = this.parseExpression();

  if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
    return this.parseLabeledStatement(node, maybeName, expr);
  } else {
    return this.parseExpressionStatement(node, expr);
  }
};

pp$1.takeDecorators = function (node) {
  if (this.state.decorators.length) {
    node.decorators = this.state.decorators;
    this.state.decorators = [];
  }
};

pp$1.parseDecorators = function (allowExport) {
  while (this.match(types.at)) {
    var decorator = this.parseDecorator();
    this.state.decorators.push(decorator);
  }

  if (allowExport && this.match(types._export)) {
    return;
  }

  if (!this.match(types._class)) {
    this.raise(this.state.start, "Leading decorators must be attached to a class declaration");
  }
};

pp$1.parseDecorator = function () {
  if (!this.hasPlugin("decorators")) {
    this.unexpected();
  }
  var node = this.startNode();
  this.next();
  node.expression = this.parseMaybeAssign();
  return this.finishNode(node, "Decorator");
};

pp$1.parseBreakContinueStatement = function (node, keyword) {
  var isBreak = keyword === "break";
  this.next();

  if (this.isLineTerminator()) {
    node.label = null;
  } else if (!this.match(types.name)) {
    this.unexpected();
  } else {
    node.label = this.parseIdentifier();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = void 0;
  for (i = 0; i < this.state.labels.length; ++i) {
    var lab = this.state.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
      if (node.label && isBreak) break;
    }
  }
  if (i === this.state.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};

pp$1.parseDebuggerStatement = function (node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};

pp$1.parseDoStatement = function (node) {
  this.next();
  this.state.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();
  this.eat(types.semi);
  return this.finishNode(node, "DoWhileStatement");
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$1.parseForStatement = function (node) {
  this.next();
  this.state.labels.push(loopLabel);

  var forAwait = false;
  if (this.hasPlugin("asyncGenerators") && this.state.inAsync && this.isContextual("await")) {
    forAwait = true;
    this.next();
  }
  this.expect(types.parenL);

  if (this.match(types.semi)) {
    if (forAwait) {
      this.unexpected();
    }
    return this.parseFor(node, null);
  }

  if (this.match(types._var) || this.match(types._let) || this.match(types._const)) {
    var _init = this.startNode();
    var varKind = this.state.type;
    this.next();
    this.parseVar(_init, true, varKind);
    this.finishNode(_init, "VariableDeclaration");

    if (this.match(types._in) || this.isContextual("of")) {
      if (_init.declarations.length === 1 && !_init.declarations[0].init) {
        return this.parseForIn(node, _init, forAwait);
      }
    }
    if (forAwait) {
      this.unexpected();
    }
    return this.parseFor(node, _init);
  }

  var refShorthandDefaultPos = { start: 0 };
  var init = this.parseExpression(true, refShorthandDefaultPos);
  if (this.match(types._in) || this.isContextual("of")) {
    var description = this.isContextual("of") ? "for-of statement" : "for-in statement";
    this.toAssignable(init, undefined, description);
    this.checkLVal(init, undefined, undefined, description);
    return this.parseForIn(node, init, forAwait);
  } else if (refShorthandDefaultPos.start) {
    this.unexpected(refShorthandDefaultPos.start);
  }
  if (forAwait) {
    this.unexpected();
  }
  return this.parseFor(node, init);
};

pp$1.parseFunctionStatement = function (node) {
  this.next();
  return this.parseFunction(node, true);
};

pp$1.parseIfStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement(false);
  node.alternate = this.eat(types._else) ? this.parseStatement(false) : null;
  return this.finishNode(node, "IfStatement");
};

pp$1.parseReturnStatement = function (node) {
  if (!this.state.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.state.start, "'return' outside of function");
  }

  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.isLineTerminator()) {
    node.argument = null;
  } else {
    node.argument = this.parseExpression();
    this.semicolon();
  }

  return this.finishNode(node, "ReturnStatement");
};

pp$1.parseSwitchStatement = function (node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.state.labels.push(switchLabel);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur = void 0;
  for (var sawDefault; !this.match(types.braceR);) {
    if (this.match(types._case) || this.match(types._default)) {
      var isCase = this.match(types._case);
      if (cur) this.finishNode(cur, "SwitchCase");
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) this.raise(this.state.lastTokStart, "Multiple default clauses");
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types.colon);
    } else {
      if (cur) {
        cur.consequent.push(this.parseStatement(true));
      } else {
        this.unexpected();
      }
    }
  }
  if (cur) this.finishNode(cur, "SwitchCase");
  this.next(); // Closing brace
  this.state.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};

pp$1.parseThrowStatement = function (node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) this.raise(this.state.lastTokEnd, "Illegal newline after throw");
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};

// Reused empty array added for node fields that are always empty.

var empty = [];

pp$1.parseTryStatement = function (node) {
  this.next();

  node.block = this.parseBlock();
  node.handler = null;

  if (this.match(types._catch)) {
    var clause = this.startNode();
    this.next();

    this.expect(types.parenL);
    clause.param = this.parseBindingAtom();
    this.checkLVal(clause.param, true, Object.create(null), "catch clause");
    this.expect(types.parenR);

    clause.body = this.parseBlock();
    node.handler = this.finishNode(clause, "CatchClause");
  }

  node.guardedHandlers = empty;
  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;

  if (!node.handler && !node.finalizer) {
    this.raise(node.start, "Missing catch or finally clause");
  }

  return this.finishNode(node, "TryStatement");
};

pp$1.parseVarStatement = function (node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

pp$1.parseWhileStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  this.state.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  return this.finishNode(node, "WhileStatement");
};

pp$1.parseWithStatement = function (node) {
  if (this.state.strict) this.raise(this.state.start, "'with' in strict mode");
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, "WithStatement");
};

pp$1.parseEmptyStatement = function (node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};

pp$1.parseLabeledStatement = function (node, maybeName, expr) {
  for (var _iterator = this.state.labels, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var _label = _ref;

    if (_label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }

  var kind = this.state.type.isLoop ? "loop" : this.match(types._switch) ? "switch" : null;
  for (var i = this.state.labels.length - 1; i >= 0; i--) {
    var label = this.state.labels[i];
    if (label.statementStart === node.start) {
      label.statementStart = this.state.start;
      label.kind = kind;
    } else {
      break;
    }
  }

  this.state.labels.push({ name: maybeName, kind: kind, statementStart: this.state.start });
  node.body = this.parseStatement(true);
  this.state.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};

pp$1.parseExpressionStatement = function (node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp$1.parseBlock = function (allowDirectives) {
  var node = this.startNode();
  this.expect(types.braceL);
  this.parseBlockBody(node, allowDirectives, false, types.braceR);
  return this.finishNode(node, "BlockStatement");
};

pp$1.isValidDirective = function (stmt) {
  return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
};

pp$1.parseBlockBody = function (node, allowDirectives, topLevel, end) {
  node.body = [];
  node.directives = [];

  var parsedNonDirective = false;
  var oldStrict = void 0;
  var octalPosition = void 0;

  while (!this.eat(end)) {
    if (!parsedNonDirective && this.state.containsOctal && !octalPosition) {
      octalPosition = this.state.octalPosition;
    }

    var stmt = this.parseStatement(true, topLevel);

    if (allowDirectives && !parsedNonDirective && this.isValidDirective(stmt)) {
      var directive = this.stmtToDirective(stmt);
      node.directives.push(directive);

      if (oldStrict === undefined && directive.value.value === "use strict") {
        oldStrict = this.state.strict;
        this.setStrict(true);

        if (octalPosition) {
          this.raise(octalPosition, "Octal literal in strict mode");
        }
      }

      continue;
    }

    parsedNonDirective = true;
    node.body.push(stmt);
  }

  if (oldStrict === false) {
    this.setStrict(false);
  }
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$1.parseFor = function (node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.match(types.semi) ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.match(types.parenR) ? null : this.parseExpression();
  this.expect(types.parenR);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  return this.finishNode(node, "ForStatement");
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp$1.parseForIn = function (node, init, forAwait) {
  var type = void 0;
  if (forAwait) {
    this.eatContextual("of");
    type = "ForAwaitStatement";
  } else {
    type = this.match(types._in) ? "ForInStatement" : "ForOfStatement";
    this.next();
  }
  node.left = init;
  node.right = this.parseExpression();
  this.expect(types.parenR);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  return this.finishNode(node, type);
};

// Parse a list of variable declarations.

pp$1.parseVar = function (node, isFor, kind) {
  node.declarations = [];
  node.kind = kind.keyword;
  for (;;) {
    var decl = this.startNode();
    this.parseVarHead(decl);
    if (this.eat(types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === types._const && !(this.match(types._in) || this.isContextual("of"))) {
      this.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(types._in) || this.isContextual("of")))) {
      this.raise(this.state.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types.comma)) break;
  }
  return node;
};

pp$1.parseVarHead = function (decl) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, true, undefined, "variable declaration");
};

// Parse a function declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseFunction = function (node, isStatement, allowExpressionBody, isAsync, optionalId) {
  var oldInMethod = this.state.inMethod;
  this.state.inMethod = false;

  this.initFunction(node, isAsync);

  if (this.match(types.star)) {
    if (node.async && !this.hasPlugin("asyncGenerators")) {
      this.unexpected();
    } else {
      node.generator = true;
      this.next();
    }
  }

  if (isStatement && !optionalId && !this.match(types.name) && !this.match(types._yield)) {
    this.unexpected();
  }

  if (this.match(types.name) || this.match(types._yield)) {
    node.id = this.parseBindingIdentifier();
  }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);

  this.state.inMethod = oldInMethod;

  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
};

pp$1.parseFunctionParams = function (node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR);
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function (node, isStatement, optionalId) {
  this.next();
  this.takeDecorators(node);
  this.parseClassId(node, isStatement, optionalId);
  this.parseClassSuper(node);
  this.parseClassBody(node);
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

pp$1.isClassProperty = function () {
  return this.match(types.eq) || this.isLineTerminator();
};

pp$1.isClassMutatorStarter = function () {
  return false;
};

pp$1.parseClassBody = function (node) {
  // class bodies are implicitly strict
  var oldStrict = this.state.strict;
  this.state.strict = true;

  var hadConstructorCall = false;
  var hadConstructor = false;
  var decorators = [];
  var classBody = this.startNode();

  classBody.body = [];

  this.expect(types.braceL);

  while (!this.eat(types.braceR)) {
    if (this.eat(types.semi)) {
      if (decorators.length > 0) {
        this.raise(this.state.lastTokEnd, "Decorators must not be followed by a semicolon");
      }
      continue;
    }

    if (this.match(types.at)) {
      decorators.push(this.parseDecorator());
      continue;
    }

    var method = this.startNode();

    // steal the decorators if there are any
    if (decorators.length) {
      method.decorators = decorators;
      decorators = [];
    }

    var isConstructorCall = false;
    var isMaybeStatic = this.match(types.name) && this.state.value === "static";
    var isGenerator = this.eat(types.star);
    var isGetSet = false;
    var isAsync = false;

    this.parsePropertyName(method);

    method.static = isMaybeStatic && !this.match(types.parenL);
    if (method.static) {
      isGenerator = this.eat(types.star);
      this.parsePropertyName(method);
    }

    if (!isGenerator) {
      if (this.isClassProperty()) {
        classBody.body.push(this.parseClassProperty(method));
        continue;
      }

      if (method.key.type === "Identifier" && !method.computed && this.hasPlugin("classConstructorCall") && method.key.name === "call" && this.match(types.name) && this.state.value === "constructor") {
        isConstructorCall = true;
        this.parsePropertyName(method);
      }
    }

    var isAsyncMethod = !this.match(types.parenL) && !method.computed && method.key.type === "Identifier" && method.key.name === "async";
    if (isAsyncMethod) {
      if (this.hasPlugin("asyncGenerators") && this.eat(types.star)) isGenerator = true;
      isAsync = true;
      this.parsePropertyName(method);
    }

    method.kind = "method";

    if (!method.computed) {
      var key = method.key;

      // handle get/set methods
      // eg. class Foo { get bar() {} set bar() {} }

      if (!isAsync && !isGenerator && !this.isClassMutatorStarter() && key.type === "Identifier" && !this.match(types.parenL) && (key.name === "get" || key.name === "set")) {
        isGetSet = true;
        method.kind = key.name;
        key = this.parsePropertyName(method);
      }

      // disallow invalid constructors
      var isConstructor = !isConstructorCall && !method.static && (key.name === "constructor" || // Identifier
      key.value === "constructor" // Literal
      );
      if (isConstructor) {
        if (hadConstructor) this.raise(key.start, "Duplicate constructor in the same class");
        if (isGetSet) this.raise(key.start, "Constructor can't have get/set modifier");
        if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
        if (isAsync) this.raise(key.start, "Constructor can't be an async function");
        method.kind = "constructor";
        hadConstructor = true;
      }

      // disallow static prototype method
      var isStaticPrototype = method.static && (key.name === "prototype" || // Identifier
      key.value === "prototype" // Literal
      );
      if (isStaticPrototype) {
        this.raise(key.start, "Classes may not have static property named prototype");
      }
    }

    // convert constructor to a constructor call
    if (isConstructorCall) {
      if (hadConstructorCall) this.raise(method.start, "Duplicate constructor call in the same class");
      method.kind = "constructorCall";
      hadConstructorCall = true;
    }

    // disallow decorators on class constructors
    if ((method.kind === "constructor" || method.kind === "constructorCall") && method.decorators) {
      this.raise(method.start, "You can't attach decorators to a class constructor");
    }

    this.parseClassMethod(classBody, method, isGenerator, isAsync);

    if (isGetSet) {
      this.checkGetterSetterParamCount(method);
    }
  }

  if (decorators.length) {
    this.raise(this.state.start, "You have trailing decorators with no method");
  }

  node.body = this.finishNode(classBody, "ClassBody");

  this.state.strict = oldStrict;
};

pp$1.parseClassProperty = function (node) {
  if (this.match(types.eq)) {
    if (!this.hasPlugin("classProperties")) this.unexpected();
    this.next();
    node.value = this.parseMaybeAssign();
  } else {
    node.value = null;
  }
  this.semicolon();
  return this.finishNode(node, "ClassProperty");
};

pp$1.parseClassMethod = function (classBody, method, isGenerator, isAsync) {
  this.parseMethod(method, isGenerator, isAsync);
  classBody.body.push(this.finishNode(method, "ClassMethod"));
};

pp$1.parseClassId = function (node, isStatement, optionalId) {
  if (this.match(types.name)) {
    node.id = this.parseIdentifier();
  } else {
    if (optionalId || !isStatement) {
      node.id = null;
    } else {
      this.unexpected();
    }
  }
};

pp$1.parseClassSuper = function (node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
};

// Parses module export declaration.

pp$1.parseExport = function (node) {
  this.next();
  // export * from '...'
  if (this.match(types.star)) {
    var specifier = this.startNode();
    this.next();
    if (this.hasPlugin("exportExtensions") && this.eatContextual("as")) {
      specifier.exported = this.parseIdentifier();
      node.specifiers = [this.finishNode(specifier, "ExportNamespaceSpecifier")];
      this.parseExportSpecifiersMaybe(node);
      this.parseExportFrom(node, true);
    } else {
      this.parseExportFrom(node, true);
      return this.finishNode(node, "ExportAllDeclaration");
    }
  } else if (this.hasPlugin("exportExtensions") && this.isExportDefaultSpecifier()) {
    var _specifier = this.startNode();
    _specifier.exported = this.parseIdentifier(true);
    node.specifiers = [this.finishNode(_specifier, "ExportDefaultSpecifier")];
    if (this.match(types.comma) && this.lookahead().type === types.star) {
      this.expect(types.comma);
      var _specifier2 = this.startNode();
      this.expect(types.star);
      this.expectContextual("as");
      _specifier2.exported = this.parseIdentifier();
      node.specifiers.push(this.finishNode(_specifier2, "ExportNamespaceSpecifier"));
    } else {
      this.parseExportSpecifiersMaybe(node);
    }
    this.parseExportFrom(node, true);
  } else if (this.eat(types._default)) {
    // export default ...
    var expr = this.startNode();
    var needsSemi = false;
    if (this.eat(types._function)) {
      expr = this.parseFunction(expr, true, false, false, true);
    } else if (this.match(types._class)) {
      expr = this.parseClass(expr, true, true);
    } else {
      needsSemi = true;
      expr = this.parseMaybeAssign();
    }
    node.declaration = expr;
    if (needsSemi) this.semicolon();
    this.checkExport(node, true, true);
    return this.finishNode(node, "ExportDefaultDeclaration");
  } else if (this.shouldParseExportDeclaration()) {
    node.specifiers = [];
    node.source = null;
    node.declaration = this.parseExportDeclaration(node);
  } else {
    // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers();
    this.parseExportFrom(node);
  }
  this.checkExport(node, true);
  return this.finishNode(node, "ExportNamedDeclaration");
};

pp$1.parseExportDeclaration = function () {
  return this.parseStatement(true);
};

pp$1.isExportDefaultSpecifier = function () {
  if (this.match(types.name)) {
    return this.state.value !== "type" && this.state.value !== "async" && this.state.value !== "interface";
  }

  if (!this.match(types._default)) {
    return false;
  }

  var lookahead = this.lookahead();
  return lookahead.type === types.comma || lookahead.type === types.name && lookahead.value === "from";
};

pp$1.parseExportSpecifiersMaybe = function (node) {
  if (this.eat(types.comma)) {
    node.specifiers = node.specifiers.concat(this.parseExportSpecifiers());
  }
};

pp$1.parseExportFrom = function (node, expect) {
  if (this.eatContextual("from")) {
    node.source = this.match(types.string) ? this.parseExprAtom() : this.unexpected();
    this.checkExport(node);
  } else {
    if (expect) {
      this.unexpected();
    } else {
      node.source = null;
    }
  }

  this.semicolon();
};

pp$1.shouldParseExportDeclaration = function () {
  return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "let" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isContextual("async");
};

pp$1.checkExport = function (node, checkNames, isDefault) {
  if (checkNames) {
    // Check for duplicate exports
    if (isDefault) {
      // Default exports
      this.checkDuplicateExports(node, "default");
    } else if (node.specifiers && node.specifiers.length) {
      // Named exports
      for (var _iterator2 = node.specifiers, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var specifier = _ref2;

        this.checkDuplicateExports(specifier, specifier.exported.name);
      }
    } else if (node.declaration) {
      // Exported declarations
      if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
        this.checkDuplicateExports(node, node.declaration.id.name);
      } else if (node.declaration.type === "VariableDeclaration") {
        for (var _iterator3 = node.declaration.declarations, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
          var _ref3;

          if (_isArray3) {
            if (_i3 >= _iterator3.length) break;
            _ref3 = _iterator3[_i3++];
          } else {
            _i3 = _iterator3.next();
            if (_i3.done) break;
            _ref3 = _i3.value;
          }

          var declaration = _ref3;

          this.checkDeclaration(declaration.id);
        }
      }
    }
  }

  if (this.state.decorators.length) {
    var isClass = node.declaration && (node.declaration.type === "ClassDeclaration" || node.declaration.type === "ClassExpression");
    if (!node.declaration || !isClass) {
      this.raise(node.start, "You can only use decorators on an export when exporting a class");
    }
    this.takeDecorators(node.declaration);
  }
};

pp$1.checkDeclaration = function (node) {
  if (node.type === "ObjectPattern") {
    for (var _iterator4 = node.properties, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
      var _ref4;

      if (_isArray4) {
        if (_i4 >= _iterator4.length) break;
        _ref4 = _iterator4[_i4++];
      } else {
        _i4 = _iterator4.next();
        if (_i4.done) break;
        _ref4 = _i4.value;
      }

      var prop = _ref4;

      this.checkDeclaration(prop);
    }
  } else if (node.type === "ArrayPattern") {
    for (var _iterator5 = node.elements, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
      var _ref5;

      if (_isArray5) {
        if (_i5 >= _iterator5.length) break;
        _ref5 = _iterator5[_i5++];
      } else {
        _i5 = _iterator5.next();
        if (_i5.done) break;
        _ref5 = _i5.value;
      }

      var elem = _ref5;

      if (elem) {
        this.checkDeclaration(elem);
      }
    }
  } else if (node.type === "ObjectProperty") {
    this.checkDeclaration(node.value);
  } else if (node.type === "RestElement" || node.type === "RestProperty") {
    this.checkDeclaration(node.argument);
  } else if (node.type === "Identifier") {
    this.checkDuplicateExports(node, node.name);
  }
};

pp$1.checkDuplicateExports = function (node, name) {
  if (this.state.exportedIdentifiers.indexOf(name) > -1) {
    this.raiseDuplicateExportError(node, name);
  }
  this.state.exportedIdentifiers.push(name);
};

pp$1.raiseDuplicateExportError = function (node, name) {
  this.raise(node.start, name === "default" ? "Only one default export allowed per module." : "`" + name + "` has already been exported. Exported identifiers must be unique.");
};

// Parses a comma-separated list of module exports.

pp$1.parseExportSpecifiers = function () {
  var nodes = [];
  var first = true;
  var needsFrom = void 0;

  // export { x, y as z } [from '...']
  this.expect(types.braceL);

  while (!this.eat(types.braceR)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma);
      if (this.eat(types.braceR)) break;
    }

    var isDefault = this.match(types._default);
    if (isDefault && !needsFrom) needsFrom = true;

    var node = this.startNode();
    node.local = this.parseIdentifier(isDefault);
    node.exported = this.eatContextual("as") ? this.parseIdentifier(true) : node.local.__clone();
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }

  // https://github.com/ember-cli/ember-cli/pull/3739
  if (needsFrom && !this.isContextual("from")) {
    this.unexpected();
  }

  return nodes;
};

// Parses import declaration.

pp$1.parseImport = function (node) {
  this.eat(types._import);

  // import '...'
  if (this.match(types.string)) {
    node.specifiers = [];
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = [];
    this.parseImportSpecifiers(node);
    this.expectContextual("from");
    node.source = this.match(types.string) ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};

// Parses a comma-separated list of module imports.

pp$1.parseImportSpecifiers = function (node) {
  var first = true;
  if (this.match(types.name)) {
    // import defaultObj, { x, y as z } from '...'
    var startPos = this.state.start;
    var startLoc = this.state.startLoc;
    node.specifiers.push(this.parseImportSpecifierDefault(this.parseIdentifier(), startPos, startLoc));
    if (!this.eat(types.comma)) return;
  }

  if (this.match(types.star)) {
    var specifier = this.startNode();
    this.next();
    this.expectContextual("as");
    specifier.local = this.parseIdentifier();
    this.checkLVal(specifier.local, true, undefined, "import namespace specifier");
    node.specifiers.push(this.finishNode(specifier, "ImportNamespaceSpecifier"));
    return;
  }

  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (first) {
      first = false;
    } else {
      // Detect an attempt to deep destructure
      if (this.eat(types.colon)) {
        this.unexpected(null, "ES2015 named imports do not destructure. Use another statement for destructuring after the import.");
      }

      this.expect(types.comma);
      if (this.eat(types.braceR)) break;
    }

    this.parseImportSpecifier(node);
  }
};

pp$1.parseImportSpecifier = function (node) {
  var specifier = this.startNode();
  specifier.imported = this.parseIdentifier(true);
  if (this.eatContextual("as")) {
    specifier.local = this.parseIdentifier();
  } else {
    this.checkReservedWord(specifier.imported.name, specifier.start, true, true);
    specifier.local = specifier.imported.__clone();
  }
  this.checkLVal(specifier.local, true, undefined, "import specifier");
  node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
};

pp$1.parseImportSpecifierDefault = function (id, startPos, startLoc) {
  var node = this.startNodeAt(startPos, startLoc);
  node.local = id;
  this.checkLVal(node.local, true, undefined, "default import specifier");
  return this.finishNode(node, "ImportDefaultSpecifier");
};

var pp$2 = Parser.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp$2.toAssignable = function (node, isBinding, contextDescription) {
  if (node) {
    switch (node.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
        break;

      case "ObjectExpression":
        node.type = "ObjectPattern";
        for (var _iterator = node.properties, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          var prop = _ref;

          if (prop.type === "ObjectMethod") {
            if (prop.kind === "get" || prop.kind === "set") {
              this.raise(prop.key.start, "Object pattern can't contain getter or setter");
            } else {
              this.raise(prop.key.start, "Object pattern can't contain methods");
            }
          } else {
            this.toAssignable(prop, isBinding, "object destructuring pattern");
          }
        }
        break;

      case "ObjectProperty":
        this.toAssignable(node.value, isBinding, contextDescription);
        break;

      case "SpreadProperty":
        node.type = "RestProperty";
        break;

      case "ArrayExpression":
        node.type = "ArrayPattern";
        this.toAssignableList(node.elements, isBinding, contextDescription);
        break;

      case "AssignmentExpression":
        if (node.operator === "=") {
          node.type = "AssignmentPattern";
          delete node.operator;
        } else {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }
        break;

      case "MemberExpression":
        if (!isBinding) break;

      default:
        {
          var message = "Invalid left-hand side" + (contextDescription ? " in " + contextDescription : /* istanbul ignore next */"expression");
          this.raise(node.start, message);
        }
    }
  }
  return node;
};

// Convert list of expression atoms to binding list.

pp$2.toAssignableList = function (exprList, isBinding, contextDescription) {
  var end = exprList.length;
  if (end) {
    var last = exprList[end - 1];
    if (last && last.type === "RestElement") {
      --end;
    } else if (last && last.type === "SpreadElement") {
      last.type = "RestElement";
      var arg = last.argument;
      this.toAssignable(arg, isBinding, contextDescription);
      if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") {
        this.unexpected(arg.start);
      }
      --end;
    }
  }
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) this.toAssignable(elt, isBinding, contextDescription);
  }
  return exprList;
};

// Convert list of expression atoms to a list of

pp$2.toReferencedList = function (exprList) {
  return exprList;
};

// Parses spread element.

pp$2.parseSpread = function (refShorthandDefaultPos) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refShorthandDefaultPos);
  return this.finishNode(node, "SpreadElement");
};

pp$2.parseRest = function () {
  var node = this.startNode();
  this.next();
  node.argument = this.parseBindingIdentifier();
  return this.finishNode(node, "RestElement");
};

pp$2.shouldAllowYieldIdentifier = function () {
  return this.match(types._yield) && !this.state.strict && !this.state.inGenerator;
};

pp$2.parseBindingIdentifier = function () {
  return this.parseIdentifier(this.shouldAllowYieldIdentifier());
};

// Parses lvalue (assignable) atom.

pp$2.parseBindingAtom = function () {
  switch (this.state.type) {
    case types._yield:
      if (this.state.strict || this.state.inGenerator) this.unexpected();
    // fall-through
    case types.name:
      return this.parseIdentifier(true);

    case types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types.bracketR, true);
      return this.finishNode(node, "ArrayPattern");

    case types.braceL:
      return this.parseObj(true);

    default:
      this.unexpected();
  }
};

pp$2.parseBindingList = function (close, allowEmpty) {
  var elts = [];
  var first = true;
  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma);
    }
    if (allowEmpty && this.match(types.comma)) {
      elts.push(null);
    } else if (this.eat(close)) {
      break;
    } else if (this.match(types.ellipsis)) {
      elts.push(this.parseAssignableListItemTypes(this.parseRest()));
      this.expect(close);
      break;
    } else {
      var decorators = [];
      while (this.match(types.at)) {
        decorators.push(this.parseDecorator());
      }
      var left = this.parseMaybeDefault();
      if (decorators.length) {
        left.decorators = decorators;
      }
      this.parseAssignableListItemTypes(left);
      elts.push(this.parseMaybeDefault(left.start, left.loc.start, left));
    }
  }
  return elts;
};

pp$2.parseAssignableListItemTypes = function (param) {
  return param;
};

// Parses assignment pattern around given atom if possible.

pp$2.parseMaybeDefault = function (startPos, startLoc, left) {
  startLoc = startLoc || this.state.startLoc;
  startPos = startPos || this.state.start;
  left = left || this.parseBindingAtom();
  if (!this.eat(types.eq)) return left;

  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};

// Verify that a node is an lval — something that can be assigned
// to.

pp$2.checkLVal = function (expr, isBinding, checkClashes, contextDescription) {
  switch (expr.type) {
    case "Identifier":
      this.checkReservedWord(expr.name, expr.start, false, true);

      if (checkClashes) {
        // we need to prefix this with an underscore for the cases where we have a key of
        // `__proto__`. there's a bug in old V8 where the following wouldn't work:
        //
        //   > var obj = Object.create(null);
        //   undefined
        //   > obj.__proto__
        //   null
        //   > obj.__proto__ = true;
        //   true
        //   > obj.__proto__
        //   null
        var key = "_" + expr.name;

        if (checkClashes[key]) {
          this.raise(expr.start, "Argument name clash in strict mode");
        } else {
          checkClashes[key] = true;
        }
      }
      break;

    case "MemberExpression":
      if (isBinding) this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
      break;

    case "ObjectPattern":
      for (var _iterator2 = expr.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var prop = _ref2;

        if (prop.type === "ObjectProperty") prop = prop.value;
        this.checkLVal(prop, isBinding, checkClashes, "object destructuring pattern");
      }
      break;

    case "ArrayPattern":
      for (var _iterator3 = expr.elements, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref3 = _i3.value;
        }

        var elem = _ref3;

        if (elem) this.checkLVal(elem, isBinding, checkClashes, "array destructuring pattern");
      }
      break;

    case "AssignmentPattern":
      this.checkLVal(expr.left, isBinding, checkClashes, "assignment pattern");
      break;

    case "RestProperty":
      this.checkLVal(expr.argument, isBinding, checkClashes, "rest property");
      break;

    case "RestElement":
      this.checkLVal(expr.argument, isBinding, checkClashes, "rest element");
      break;

    default:
      {
        var message = (isBinding ? /* istanbul ignore next */"Binding invalid" : "Invalid") + " left-hand side" + (contextDescription ? " in " + contextDescription : /* istanbul ignore next */"expression");
        this.raise(expr.start, message);
      }
  }
};

/* eslint max-len: 0 */

// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts — that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

var pp$3 = Parser.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash —
// either with each other or with an init property — and in
// strict mode, init properties are also not allowed to be repeated.

pp$3.checkPropClash = function (prop, propHash) {
  if (prop.computed || prop.kind) return;

  var key = prop.key;
  // It is either an Identifier or a String/NumericLiteral
  var name = key.type === "Identifier" ? key.name : String(key.value);

  if (name === "__proto__") {
    if (propHash.proto) this.raise(key.start, "Redefinition of __proto__ property");
    propHash.proto = true;
  }
};

// Convenience method to parse an Expression only
pp$3.getExpression = function () {
  this.nextToken();
  var expr = this.parseExpression();
  if (!this.match(types.eof)) {
    this.unexpected();
  }
  return expr;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function (s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp$3.parseExpression = function (noIn, refShorthandDefaultPos) {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);
  if (this.match(types.comma)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types.comma)) {
      node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));
    }
    this.toReferencedList(node.expressions);
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$3.parseMaybeAssign = function (noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;

  if (this.match(types._yield) && this.state.inGenerator) {
    var _left = this.parseYield();
    if (afterLeftParse) _left = afterLeftParse.call(this, _left, startPos, startLoc);
    return _left;
  }

  var failOnShorthandAssign = void 0;
  if (refShorthandDefaultPos) {
    failOnShorthandAssign = false;
  } else {
    refShorthandDefaultPos = { start: 0 };
    failOnShorthandAssign = true;
  }

  if (this.match(types.parenL) || this.match(types.name)) {
    this.state.potentialArrowAt = this.state.start;
  }

  var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos);
  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
  if (this.state.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.state.value;
    node.left = this.match(types.eq) ? this.toAssignable(left, undefined, "assignment expression") : left;
    refShorthandDefaultPos.start = 0; // reset because shorthand default was used correctly

    this.checkLVal(left, undefined, undefined, "assignment expression");

    if (left.extra && left.extra.parenthesized) {
      var errorMsg = void 0;
      if (left.type === "ObjectPattern") {
        errorMsg = "`({a}) = 0` use `({a} = 0)`";
      } else if (left.type === "ArrayPattern") {
        errorMsg = "`([a]) = 0` use `([a] = 0)`";
      }
      if (errorMsg) {
        this.raise(left.start, "You're trying to assign to a parenthesized expression, eg. instead of " + errorMsg);
      }
    }

    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression");
  } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
    this.unexpected(refShorthandDefaultPos.start);
  }

  return left;
};

// Parse a ternary conditional (`?:`) operator.

pp$3.parseMaybeConditional = function (noIn, refShorthandDefaultPos, refNeedsArrowPos) {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var expr = this.parseExprOps(noIn, refShorthandDefaultPos);
  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;

  return this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);
};

pp$3.parseConditional = function (expr, noIn, startPos, startLoc) {
  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};

// Start the precedence parser.

pp$3.parseExprOps = function (noIn, refShorthandDefaultPos) {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var expr = this.parseMaybeUnary(refShorthandDefaultPos);
  if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
    return expr;
  } else {
    return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
  }
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp$3.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.state.type.binop;
  if (prec != null && (!noIn || !this.match(types._in))) {
    if (prec > minPrec) {
      var node = this.startNodeAt(leftStartPos, leftStartLoc);
      node.left = left;
      node.operator = this.state.value;

      if (node.operator === "**" && left.type === "UnaryExpression" && left.extra && !left.extra.parenthesizedArgument && !left.extra.parenthesized) {
        this.raise(left.argument.start, "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.");
      }

      var op = this.state.type;
      this.next();

      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);

      this.finishNode(node, op === types.logicalOR || op === types.logicalAND ? "LogicalExpression" : "BinaryExpression");
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
    }
  }
  return left;
};

// Parse unary operators, both prefix and postfix.

pp$3.parseMaybeUnary = function (refShorthandDefaultPos) {
  if (this.state.type.prefix) {
    var node = this.startNode();
    var update = this.match(types.incDec);
    node.operator = this.state.value;
    node.prefix = true;
    this.next();

    var argType = this.state.type;
    node.argument = this.parseMaybeUnary();

    this.addExtra(node, "parenthesizedArgument", argType === types.parenL && (!node.argument.extra || !node.argument.extra.parenthesized));

    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
      this.unexpected(refShorthandDefaultPos.start);
    }

    if (update) {
      this.checkLVal(node.argument, undefined, undefined, "prefix operation");
    } else if (this.state.strict && node.operator === "delete" && node.argument.type === "Identifier") {
      this.raise(node.start, "Deleting local variable in strict mode");
    }

    return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  }

  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var expr = this.parseExprSubscripts(refShorthandDefaultPos);
  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
  while (this.state.type.postfix && !this.canInsertSemicolon()) {
    var _node = this.startNodeAt(startPos, startLoc);
    _node.operator = this.state.value;
    _node.prefix = false;
    _node.argument = expr;
    this.checkLVal(expr, undefined, undefined, "postfix operation");
    this.next();
    expr = this.finishNode(_node, "UpdateExpression");
  }
  return expr;
};

// Parse call, dot, and `[]`-subscript expressions.

pp$3.parseExprSubscripts = function (refShorthandDefaultPos) {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var potentialArrowAt = this.state.potentialArrowAt;
  var expr = this.parseExprAtom(refShorthandDefaultPos);

  if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
    return expr;
  }

  if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
    return expr;
  }

  return this.parseSubscripts(expr, startPos, startLoc);
};

pp$3.parseSubscripts = function (base, startPos, startLoc, noCalls) {
  for (;;) {
    if (!noCalls && this.eat(types.doubleColon)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.callee = this.parseNoCallExpr();
      return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
    } else if (this.eat(types.dot)) {
      var _node2 = this.startNodeAt(startPos, startLoc);
      _node2.object = base;
      _node2.property = this.parseIdentifier(true);
      _node2.computed = false;
      base = this.finishNode(_node2, "MemberExpression");
    } else if (this.eat(types.bracketL)) {
      var _node3 = this.startNodeAt(startPos, startLoc);
      _node3.object = base;
      _node3.property = this.parseExpression();
      _node3.computed = true;
      this.expect(types.bracketR);
      base = this.finishNode(_node3, "MemberExpression");
    } else if (!noCalls && this.match(types.parenL)) {
      var possibleAsync = this.state.potentialArrowAt === base.start && base.type === "Identifier" && base.name === "async" && !this.canInsertSemicolon();
      this.next();

      var _node4 = this.startNodeAt(startPos, startLoc);
      _node4.callee = base;
      _node4.arguments = this.parseCallExpressionArguments(types.parenR, possibleAsync);
      if (_node4.callee.type === "Import" && _node4.arguments.length !== 1) {
        this.raise(_node4.start, "import() requires exactly one argument");
      }
      base = this.finishNode(_node4, "CallExpression");

      if (possibleAsync && this.shouldParseAsyncArrow()) {
        return this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), _node4);
      } else {
        this.toReferencedList(_node4.arguments);
      }
    } else if (this.match(types.backQuote)) {
      var _node5 = this.startNodeAt(startPos, startLoc);
      _node5.tag = base;
      _node5.quasi = this.parseTemplate();
      base = this.finishNode(_node5, "TaggedTemplateExpression");
    } else {
      return base;
    }
  }
};

pp$3.parseCallExpressionArguments = function (close, possibleAsyncArrow) {
  var elts = [];
  var innerParenStart = void 0;
  var first = true;

  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma);
      if (this.eat(close)) break;
    }

    // we need to make sure that if this is an async arrow functions, that we don't allow inner parens inside the params
    if (this.match(types.parenL) && !innerParenStart) {
      innerParenStart = this.state.start;
    }

    elts.push(this.parseExprListItem(false, possibleAsyncArrow ? { start: 0 } : undefined, possibleAsyncArrow ? { start: 0 } : undefined));
  }

  // we found an async arrow function so let's not allow any inner parens
  if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {
    this.unexpected();
  }

  return elts;
};

pp$3.shouldParseAsyncArrow = function () {
  return this.match(types.arrow);
};

pp$3.parseAsyncArrowFromCallExpression = function (node, call) {
  this.expect(types.arrow);
  return this.parseArrowExpression(node, call.arguments, true);
};

// Parse a no-call expression (like argument of `new` or `::` operators).

pp$3.parseNoCallExpr = function () {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
};

// Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp$3.parseExprAtom = function (refShorthandDefaultPos) {
  var canBeArrow = this.state.potentialArrowAt === this.state.start;
  var node = void 0;

  switch (this.state.type) {
    case types._super:
      if (!this.state.inMethod && !this.options.allowSuperOutsideMethod) {
        this.raise(this.state.start, "'super' outside of function or class");
      }

      node = this.startNode();
      this.next();
      if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {
        this.unexpected();
      }
      if (this.match(types.parenL) && this.state.inMethod !== "constructor" && !this.options.allowSuperOutsideMethod) {
        this.raise(node.start, "super() outside of class constructor");
      }
      return this.finishNode(node, "Super");

    case types._import:
      if (!this.hasPlugin("dynamicImport")) this.unexpected();

      node = this.startNode();
      this.next();
      if (!this.match(types.parenL)) {
        this.unexpected(null, types.parenL);
      }
      return this.finishNode(node, "Import");

    case types._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression");

    case types._yield:
      if (this.state.inGenerator) this.unexpected();

    case types.name:
      node = this.startNode();
      var allowAwait = this.state.value === "await" && this.state.inAsync;
      var allowYield = this.shouldAllowYieldIdentifier();
      var id = this.parseIdentifier(allowAwait || allowYield);

      if (id.name === "await") {
        if (this.state.inAsync || this.inModule) {
          return this.parseAwait(node);
        }
      } else if (id.name === "async" && this.match(types._function) && !this.canInsertSemicolon()) {
        this.next();
        return this.parseFunction(node, false, false, true);
      } else if (canBeArrow && id.name === "async" && this.match(types.name)) {
        var params = [this.parseIdentifier()];
        this.expect(types.arrow);
        // let foo = bar => {};
        return this.parseArrowExpression(node, params, true);
      }

      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        return this.parseArrowExpression(node, [id]);
      }

      return id;

    case types._do:
      if (this.hasPlugin("doExpressions")) {
        var _node6 = this.startNode();
        this.next();
        var oldInFunction = this.state.inFunction;
        var oldLabels = this.state.labels;
        this.state.labels = [];
        this.state.inFunction = false;
        _node6.body = this.parseBlock(false, true);
        this.state.inFunction = oldInFunction;
        this.state.labels = oldLabels;
        return this.finishNode(_node6, "DoExpression");
      }

    case types.regexp:
      var value = this.state.value;
      node = this.parseLiteral(value.value, "RegExpLiteral");
      node.pattern = value.pattern;
      node.flags = value.flags;
      return node;

    case types.num:
      return this.parseLiteral(this.state.value, "NumericLiteral");

    case types.string:
      return this.parseLiteral(this.state.value, "StringLiteral");

    case types._null:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "NullLiteral");

    case types._true:case types._false:
      node = this.startNode();
      node.value = this.match(types._true);
      this.next();
      return this.finishNode(node, "BooleanLiteral");

    case types.parenL:
      return this.parseParenAndDistinguishExpression(null, null, canBeArrow);

    case types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types.bracketR, true, refShorthandDefaultPos);
      this.toReferencedList(node.elements);
      return this.finishNode(node, "ArrayExpression");

    case types.braceL:
      return this.parseObj(false, refShorthandDefaultPos);

    case types._function:
      return this.parseFunctionExpression();

    case types.at:
      this.parseDecorators();

    case types._class:
      node = this.startNode();
      this.takeDecorators(node);
      return this.parseClass(node, false);

    case types._new:
      return this.parseNew();

    case types.backQuote:
      return this.parseTemplate();

    case types.doubleColon:
      node = this.startNode();
      this.next();
      node.object = null;
      var callee = node.callee = this.parseNoCallExpr();
      if (callee.type === "MemberExpression") {
        return this.finishNode(node, "BindExpression");
      } else {
        this.raise(callee.start, "Binding should be performed on object property.");
      }

    default:
      this.unexpected();
  }
};

pp$3.parseFunctionExpression = function () {
  var node = this.startNode();
  var meta = this.parseIdentifier(true);
  if (this.state.inGenerator && this.eat(types.dot) && this.hasPlugin("functionSent")) {
    return this.parseMetaProperty(node, meta, "sent");
  } else {
    return this.parseFunction(node, false);
  }
};

pp$3.parseMetaProperty = function (node, meta, propertyName) {
  node.meta = meta;
  node.property = this.parseIdentifier(true);

  if (node.property.name !== propertyName) {
    this.raise(node.property.start, "The only valid meta property for new is " + meta.name + "." + propertyName);
  }

  return this.finishNode(node, "MetaProperty");
};

pp$3.parseLiteral = function (value, type, startPos, startLoc) {
  startPos = startPos || this.state.start;
  startLoc = startLoc || this.state.startLoc;

  var node = this.startNodeAt(startPos, startLoc);
  this.addExtra(node, "rawValue", value);
  this.addExtra(node, "raw", this.input.slice(startPos, this.state.end));
  node.value = value;
  this.next();
  return this.finishNode(node, type);
};

pp$3.parseParenExpression = function () {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val;
};

pp$3.parseParenAndDistinguishExpression = function (startPos, startLoc, canBeArrow) {
  startPos = startPos || this.state.start;
  startLoc = startLoc || this.state.startLoc;

  var val = void 0;
  this.expect(types.parenL);

  var innerStartPos = this.state.start;
  var innerStartLoc = this.state.startLoc;
  var exprList = [];
  var refShorthandDefaultPos = { start: 0 };
  var refNeedsArrowPos = { start: 0 };
  var first = true;
  var spreadStart = void 0;
  var optionalCommaStart = void 0;

  while (!this.match(types.parenR)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma, refNeedsArrowPos.start || null);
      if (this.match(types.parenR)) {
        optionalCommaStart = this.state.start;
        break;
      }
    }

    if (this.match(types.ellipsis)) {
      var spreadNodeStartPos = this.state.start;
      var spreadNodeStartLoc = this.state.startLoc;
      spreadStart = this.state.start;
      exprList.push(this.parseParenItem(this.parseRest(), spreadNodeStartLoc, spreadNodeStartPos));
      break;
    } else {
      exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos));
    }
  }

  var innerEndPos = this.state.start;
  var innerEndLoc = this.state.startLoc;
  this.expect(types.parenR);

  var arrowNode = this.startNodeAt(startPos, startLoc);
  if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {
    for (var _iterator = exprList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var param = _ref;

      if (param.extra && param.extra.parenthesized) this.unexpected(param.extra.parenStart);
    }

    return this.parseArrowExpression(arrowNode, exprList);
  }

  if (!exprList.length) {
    this.unexpected(this.state.lastTokStart);
  }
  if (optionalCommaStart) this.unexpected(optionalCommaStart);
  if (spreadStart) this.unexpected(spreadStart);
  if (refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);
  if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);

  if (exprList.length > 1) {
    val = this.startNodeAt(innerStartPos, innerStartLoc);
    val.expressions = exprList;
    this.toReferencedList(val.expressions);
    this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
  } else {
    val = exprList[0];
  }

  this.addExtra(val, "parenthesized", true);
  this.addExtra(val, "parenStart", startPos);

  return val;
};

pp$3.shouldParseArrow = function () {
  return !this.canInsertSemicolon();
};

pp$3.parseArrow = function (node) {
  if (this.eat(types.arrow)) {
    return node;
  }
};

pp$3.parseParenItem = function (node) {
  return node;
};

// New's precedence is slightly tricky. It must allow its argument
// to be a `[]` or dot subscript expression, but not a call — at
// least, not without wrapping it in parentheses. Thus, it uses the

pp$3.parseNew = function () {
  var node = this.startNode();
  var meta = this.parseIdentifier(true);

  if (this.eat(types.dot)) {
    return this.parseMetaProperty(node, meta, "target");
  }

  node.callee = this.parseNoCallExpr();

  if (this.eat(types.parenL)) {
    node.arguments = this.parseExprList(types.parenR);
    this.toReferencedList(node.arguments);
  } else {
    node.arguments = [];
  }

  return this.finishNode(node, "NewExpression");
};

// Parse template expression.

pp$3.parseTemplateElement = function () {
  var elem = this.startNode();
  elem.value = {
    raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
    cooked: this.state.value
  };
  this.next();
  elem.tail = this.match(types.backQuote);
  return this.finishNode(elem, "TemplateElement");
};

pp$3.parseTemplate = function () {
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement();
  node.quasis = [curElt];
  while (!curElt.tail) {
    this.expect(types.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types.braceR);
    node.quasis.push(curElt = this.parseTemplateElement());
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};

// Parse an object literal or binding pattern.

pp$3.parseObj = function (isPattern, refShorthandDefaultPos) {
  var decorators = [];
  var propHash = Object.create(null);
  var first = true;
  var node = this.startNode();

  node.properties = [];
  this.next();

  var firstRestLocation = null;

  while (!this.eat(types.braceR)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma);
      if (this.eat(types.braceR)) break;
    }

    while (this.match(types.at)) {
      decorators.push(this.parseDecorator());
    }

    var prop = this.startNode(),
        isGenerator = false,
        isAsync = false,
        startPos = void 0,
        startLoc = void 0;
    if (decorators.length) {
      prop.decorators = decorators;
      decorators = [];
    }

    if (this.hasPlugin("objectRestSpread") && this.match(types.ellipsis)) {
      prop = this.parseSpread(isPattern ? { start: 0 } : undefined);
      prop.type = isPattern ? "RestProperty" : "SpreadProperty";
      if (isPattern) this.toAssignable(prop.argument, true, "object pattern");
      node.properties.push(prop);
      if (isPattern) {
        var position = this.state.start;
        if (firstRestLocation !== null) {
          this.unexpected(firstRestLocation, "Cannot have multiple rest elements when destructuring");
        } else if (this.eat(types.braceR)) {
          break;
        } else if (this.match(types.comma) && this.lookahead().type === types.braceR) {
          // TODO: temporary rollback
          // this.unexpected(position, "A trailing comma is not permitted after the rest element");
          continue;
        } else {
          firstRestLocation = position;
          continue;
        }
      } else {
        continue;
      }
    }

    prop.method = false;
    prop.shorthand = false;

    if (isPattern || refShorthandDefaultPos) {
      startPos = this.state.start;
      startLoc = this.state.startLoc;
    }

    if (!isPattern) {
      isGenerator = this.eat(types.star);
    }

    if (!isPattern && this.isContextual("async")) {
      if (isGenerator) this.unexpected();

      var asyncId = this.parseIdentifier();
      if (this.match(types.colon) || this.match(types.parenL) || this.match(types.braceR) || this.match(types.eq) || this.match(types.comma)) {
        prop.key = asyncId;
        prop.computed = false;
      } else {
        isAsync = true;
        if (this.hasPlugin("asyncGenerators")) isGenerator = this.eat(types.star);
        this.parsePropertyName(prop);
      }
    } else {
      this.parsePropertyName(prop);
    }

    this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos);
    this.checkPropClash(prop, propHash);

    if (prop.shorthand) {
      this.addExtra(prop, "shorthand", true);
    }

    node.properties.push(prop);
  }

  if (firstRestLocation !== null) {
    this.unexpected(firstRestLocation, "The rest element has to be the last element when destructuring");
  }

  if (decorators.length) {
    this.raise(this.state.start, "You have trailing decorators with no property");
  }

  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};

pp$3.isGetterOrSetterMethod = function (prop, isPattern) {
  return !isPattern && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.match(types.string) || // get "string"() {}
  this.match(types.num) || // get 1() {}
  this.match(types.bracketL) || // get ["string"]() {}
  this.match(types.name) || // get foo() {}
  this.state.type.keyword // get debugger() {}
  );
};

// get methods aren't allowed to have any parameters
// set methods must have exactly 1 parameter
pp$3.checkGetterSetterParamCount = function (method) {
  var paramCount = method.kind === "get" ? 0 : 1;
  if (method.params.length !== paramCount) {
    var start = method.start;
    if (method.kind === "get") {
      this.raise(start, "getter should have no params");
    } else {
      this.raise(start, "setter should have exactly one param");
    }
  }
};

pp$3.parseObjectMethod = function (prop, isGenerator, isAsync, isPattern) {
  if (isAsync || isGenerator || this.match(types.parenL)) {
    if (isPattern) this.unexpected();
    prop.kind = "method";
    prop.method = true;
    this.parseMethod(prop, isGenerator, isAsync);

    return this.finishNode(prop, "ObjectMethod");
  }

  if (this.isGetterOrSetterMethod(prop, isPattern)) {
    if (isGenerator || isAsync) this.unexpected();
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    this.parseMethod(prop);
    this.checkGetterSetterParamCount(prop);

    return this.finishNode(prop, "ObjectMethod");
  }
};

pp$3.parseObjectProperty = function (prop, startPos, startLoc, isPattern, refShorthandDefaultPos) {
  if (this.eat(types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos);

    return this.finishNode(prop, "ObjectProperty");
  }

  if (!prop.computed && prop.key.type === "Identifier") {
    if (isPattern) {
      this.checkReservedWord(prop.key.name, prop.key.start, true, true);
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
    } else if (this.match(types.eq) && refShorthandDefaultPos) {
      if (!refShorthandDefaultPos.start) {
        refShorthandDefaultPos.start = this.state.start;
      }
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
    } else {
      prop.value = prop.key.__clone();
    }
    prop.shorthand = true;

    return this.finishNode(prop, "ObjectProperty");
  }
};

pp$3.parseObjPropValue = function (prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos) {
  var node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos);

  if (!node) this.unexpected();

  return node;
};

pp$3.parsePropertyName = function (prop) {
  if (this.eat(types.bracketL)) {
    prop.computed = true;
    prop.key = this.parseMaybeAssign();
    this.expect(types.bracketR);
  } else {
    prop.computed = false;
    var oldInPropertyName = this.state.inPropertyName;
    this.state.inPropertyName = true;
    prop.key = this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
    this.state.inPropertyName = oldInPropertyName;
  }
  return prop.key;
};

// Initialize empty function node.

pp$3.initFunction = function (node, isAsync) {
  node.id = null;
  node.generator = false;
  node.expression = false;
  node.async = !!isAsync;
};

// Parse object or class method.

pp$3.parseMethod = function (node, isGenerator, isAsync) {
  var oldInMethod = this.state.inMethod;
  this.state.inMethod = node.kind || true;
  this.initFunction(node, isAsync);
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR);
  node.generator = !!isGenerator;
  this.parseFunctionBody(node);
  this.state.inMethod = oldInMethod;
  return node;
};

// Parse arrow function expression with given parameters.

pp$3.parseArrowExpression = function (node, params, isAsync) {
  this.initFunction(node, isAsync);
  node.params = this.toAssignableList(params, true, "arrow function parameters");
  this.parseFunctionBody(node, true);
  return this.finishNode(node, "ArrowFunctionExpression");
};

pp$3.isStrictBody = function (node, isExpression) {
  if (!isExpression && node.body.directives.length) {
    for (var _iterator2 = node.body.directives, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var directive = _ref2;

      if (directive.value.value === "use strict") {
        return true;
      }
    }
  }

  return false;
};

// Parse function body and check parameters.
pp$3.parseFunctionBody = function (node, allowExpression) {
  var isExpression = allowExpression && !this.match(types.braceL);

  var oldInAsync = this.state.inAsync;
  this.state.inAsync = node.async;
  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
  } else {
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldInFunc = this.state.inFunction;
    var oldInGen = this.state.inGenerator;
    var oldLabels = this.state.labels;
    this.state.inFunction = true;this.state.inGenerator = node.generator;this.state.labels = [];
    node.body = this.parseBlock(true);
    node.expression = false;
    this.state.inFunction = oldInFunc;this.state.inGenerator = oldInGen;this.state.labels = oldLabels;
  }
  this.state.inAsync = oldInAsync;

  // If this is a strict mode function, verify that argument names
  // are not repeated, and it does not try to bind the words `eval`
  // or `arguments`.
  var isStrict = this.isStrictBody(node, isExpression);
  // Also check when allowExpression === true for arrow functions
  var checkLVal = this.state.strict || allowExpression || isStrict;

  if (isStrict && node.id && node.id.type === "Identifier" && node.id.name === "yield") {
    this.raise(node.id.start, "Binding yield in strict mode");
  }

  if (checkLVal) {
    var nameHash = Object.create(null);
    var oldStrict = this.state.strict;
    if (isStrict) this.state.strict = true;
    if (node.id) {
      this.checkLVal(node.id, true, undefined, "function name");
    }
    for (var _iterator3 = node.params, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var param = _ref3;

      if (isStrict && param.type !== "Identifier") {
        this.raise(param.start, "Non-simple parameter in strict mode");
      }
      this.checkLVal(param, true, nameHash, "function parameter list");
    }
    this.state.strict = oldStrict;
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp$3.parseExprList = function (close, allowEmpty, refShorthandDefaultPos) {
  var elts = [];
  var first = true;

  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma);
      if (this.eat(close)) break;
    }

    elts.push(this.parseExprListItem(allowEmpty, refShorthandDefaultPos));
  }
  return elts;
};

pp$3.parseExprListItem = function (allowEmpty, refShorthandDefaultPos, refNeedsArrowPos) {
  var elt = void 0;
  if (allowEmpty && this.match(types.comma)) {
    elt = null;
  } else if (this.match(types.ellipsis)) {
    elt = this.parseSpread(refShorthandDefaultPos);
  } else {
    elt = this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos);
  }
  return elt;
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp$3.parseIdentifier = function (liberal) {
  var node = this.startNode();
  if (!liberal) {
    this.checkReservedWord(this.state.value, this.state.start, !!this.state.type.keyword, false);
  }

  if (this.match(types.name)) {
    node.name = this.state.value;
  } else if (this.state.type.keyword) {
    node.name = this.state.type.keyword;
  } else {
    this.unexpected();
  }

  if (!liberal && node.name === "await" && this.state.inAsync) {
    this.raise(node.start, "invalid use of await inside of an async function");
  }

  node.loc.identifierName = node.name;

  this.next();
  return this.finishNode(node, "Identifier");
};

pp$3.checkReservedWord = function (word, startLoc, checkKeywords, isBinding) {
  if (this.isReservedWord(word) || checkKeywords && this.isKeyword(word)) {
    this.raise(startLoc, word + " is a reserved word");
  }

  if (this.state.strict && (reservedWords.strict(word) || isBinding && reservedWords.strictBind(word))) {
    this.raise(startLoc, word + " is a reserved word in strict mode");
  }
};

// Parses await expression inside async function.

pp$3.parseAwait = function (node) {
  // istanbul ignore next: this condition is checked at the call site so won't be hit here
  if (!this.state.inAsync) {
    this.unexpected();
  }
  if (this.match(types.star)) {
    this.raise(node.start, "await* has been removed from the async functions proposal. Use Promise.all() instead.");
  }
  node.argument = this.parseMaybeUnary();
  return this.finishNode(node, "AwaitExpression");
};

// Parses yield expression inside generator.

pp$3.parseYield = function () {
  var node = this.startNode();
  this.next();
  if (this.match(types.semi) || this.canInsertSemicolon() || !this.match(types.star) && !this.state.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types.star);
    node.argument = this.parseMaybeAssign();
  }
  return this.finishNode(node, "YieldExpression");
};

// Start an AST node, attaching a start offset.

var pp$4 = Parser.prototype;
var commentKeys = ["leadingComments", "trailingComments", "innerComments"];

var Node = function () {
  function Node(pos, loc, filename) {
    classCallCheck(this, Node);

    this.type = "";
    this.start = pos;
    this.end = 0;
    this.loc = new SourceLocation(loc);
    if (filename) this.loc.filename = filename;
  }

  Node.prototype.__clone = function __clone() {
    var node2 = new Node();
    for (var key in this) {
      // Do not clone comments that are already attached to the node
      if (commentKeys.indexOf(key) < 0) {
        node2[key] = this[key];
      }
    }

    return node2;
  };

  return Node;
}();

pp$4.startNode = function () {
  return new Node(this.state.start, this.state.startLoc, this.filename);
};

pp$4.startNodeAt = function (pos, loc) {
  return new Node(pos, loc, this.filename);
};

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  node.loc.end = loc;
  this.processComment(node);
  return node;
}

// Finish an AST node, adding `type` and `end` properties.

pp$4.finishNode = function (node, type) {
  return finishNodeAt.call(this, node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
};

// Finish node at given position

pp$4.finishNodeAt = function (node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
};

var pp$5 = Parser.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$5.raise = function (pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  throw err;
};

/* eslint max-len: 0 */

/**
 * Based on the comment attachment algorithm used in espree and estraverse.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

function last(stack) {
  return stack[stack.length - 1];
}

var pp$6 = Parser.prototype;

pp$6.addComment = function (comment) {
  if (this.filename) comment.loc.filename = this.filename;
  this.state.trailingComments.push(comment);
  this.state.leadingComments.push(comment);
};

pp$6.processComment = function (node) {
  if (node.type === "Program" && node.body.length > 0) return;

  var stack = this.state.commentStack;

  var lastChild = void 0,
      trailingComments = void 0,
      i = void 0,
      j = void 0;

  if (this.state.trailingComments.length > 0) {
    // If the first comment in trailingComments comes after the
    // current node, then we're good - all comments in the array will
    // come after the node and so it's safe to add them as official
    // trailingComments.
    if (this.state.trailingComments[0].start >= node.end) {
      trailingComments = this.state.trailingComments;
      this.state.trailingComments = [];
    } else {
      // Otherwise, if the first comment doesn't come after the
      // current node, that means we have a mix of leading and trailing
      // comments in the array and that leadingComments contains the
      // same items as trailingComments. Reset trailingComments to
      // zero items and we'll handle this by evaluating leadingComments
      // later.
      this.state.trailingComments.length = 0;
    }
  } else {
    var lastInStack = last(stack);
    if (stack.length > 0 && lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {
      trailingComments = lastInStack.trailingComments;
      lastInStack.trailingComments = null;
    }
  }

  // Eating the stack.
  while (stack.length > 0 && last(stack).start >= node.start) {
    lastChild = stack.pop();
  }

  if (lastChild) {
    if (lastChild.leadingComments) {
      if (lastChild !== node && last(lastChild.leadingComments).end <= node.start) {
        node.leadingComments = lastChild.leadingComments;
        lastChild.leadingComments = null;
      } else {
        // A leading comment for an anonymous class had been stolen by its first ClassMethod,
        // so this takes back the leading comment.
        // See also: https://github.com/eslint/espree/issues/158
        for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
          if (lastChild.leadingComments[i].end <= node.start) {
            node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
            break;
          }
        }
      }
    }
  } else if (this.state.leadingComments.length > 0) {
    if (last(this.state.leadingComments).end <= node.start) {
      if (this.state.commentPreviousNode) {
        for (j = 0; j < this.state.leadingComments.length; j++) {
          if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
            this.state.leadingComments.splice(j, 1);
            j--;
          }
        }
      }
      if (this.state.leadingComments.length > 0) {
        node.leadingComments = this.state.leadingComments;
        this.state.leadingComments = [];
      }
    } else {
      // https://github.com/eslint/espree/issues/2
      //
      // In special cases, such as return (without a value) and
      // debugger, all comments will end up as leadingComments and
      // will otherwise be eliminated. This step runs when the
      // commentStack is empty and there are comments left
      // in leadingComments.
      //
      // This loop figures out the stopping point between the actual
      // leading and trailing comments by finding the location of the
      // first comment that comes after the given node.
      for (i = 0; i < this.state.leadingComments.length; i++) {
        if (this.state.leadingComments[i].end > node.start) {
          break;
        }
      }

      // Split the array based on the location of the first comment
      // that comes after the node. Keep in mind that this could
      // result in an empty array, and if so, the array must be
      // deleted.
      node.leadingComments = this.state.leadingComments.slice(0, i);
      if (node.leadingComments.length === 0) {
        node.leadingComments = null;
      }

      // Similarly, trailing comments are attached later. The variable
      // must be reset to null if there are no trailing comments.
      trailingComments = this.state.leadingComments.slice(i);
      if (trailingComments.length === 0) {
        trailingComments = null;
      }
    }
  }

  this.state.commentPreviousNode = node;

  if (trailingComments) {
    if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {
      node.innerComments = trailingComments;
    } else {
      node.trailingComments = trailingComments;
    }
  }

  stack.push(node);
};

var pp$7 = Parser.prototype;

pp$7.estreeParseRegExpLiteral = function (_ref) {
  var pattern = _ref.pattern,
      flags = _ref.flags;

  var regex = null;
  try {
    regex = new RegExp(pattern, flags);
  } catch (e) {
    // In environments that don't support these flags value will
    // be null as the regex can't be represented natively.
  }
  var node = this.estreeParseLiteral(regex);
  node.regex = { pattern: pattern, flags: flags };

  return node;
};

pp$7.estreeParseLiteral = function (value) {
  return this.parseLiteral(value, "Literal");
};

pp$7.directiveToStmt = function (directive) {
  var directiveLiteral = directive.value;

  var stmt = this.startNodeAt(directive.start, directive.loc.start);
  var expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);

  expression.value = directiveLiteral.value;
  expression.raw = directiveLiteral.extra.raw;

  stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end);
  stmt.directive = directiveLiteral.extra.raw.slice(1, -1);

  return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
};

function isSimpleProperty(node) {
  return node && node.type === "Property" && node.kind === "init" && node.method === false;
}

var estreePlugin = function (instance) {
  instance.extend("checkDeclaration", function (inner) {
    return function (node) {
      if (isSimpleProperty(node)) {
        this.checkDeclaration(node.value);
      } else {
        inner.call(this, node);
      }
    };
  });

  instance.extend("checkGetterSetterParamCount", function () {
    return function (prop) {
      var paramCount = prop.kind === "get" ? 0 : 1;
      if (prop.value.params.length !== paramCount) {
        var start = prop.start;
        if (prop.kind === "get") {
          this.raise(start, "getter should have no params");
        } else {
          this.raise(start, "setter should have exactly one param");
        }
      }
    };
  });

  instance.extend("checkLVal", function (inner) {
    return function (expr, isBinding, checkClashes) {
      var _this = this;

      switch (expr.type) {
        case "ObjectPattern":
          expr.properties.forEach(function (prop) {
            _this.checkLVal(prop.type === "Property" ? prop.value : prop, isBinding, checkClashes, "object destructuring pattern");
          });
          break;
        default:
          for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
            args[_key - 3] = arguments[_key];
          }

          inner.call.apply(inner, [this, expr, isBinding, checkClashes].concat(args));
      }
    };
  });

  instance.extend("checkPropClash", function () {
    return function (prop, propHash) {
      if (prop.computed || !isSimpleProperty(prop)) return;

      var key = prop.key;
      // It is either an Identifier or a String/NumericLiteral
      var name = key.type === "Identifier" ? key.name : String(key.value);

      if (name === "__proto__") {
        if (propHash.proto) this.raise(key.start, "Redefinition of __proto__ property");
        propHash.proto = true;
      }
    };
  });

  instance.extend("isStrictBody", function () {
    return function (node, isExpression) {
      if (!isExpression && node.body.body.length > 0) {
        for (var _iterator = node.body.body, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref2;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref2 = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref2 = _i.value;
          }

          var directive = _ref2;

          if (directive.type === "ExpressionStatement" && directive.expression.type === "Literal") {
            if (directive.expression.value === "use strict") return true;
          } else {
            // Break for the first non literal expression
            break;
          }
        }
      }

      return false;
    };
  });

  instance.extend("isValidDirective", function () {
    return function (stmt) {
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && (!stmt.expression.extra || !stmt.expression.extra.parenthesized);
    };
  });

  instance.extend("parseBlockBody", function (inner) {
    return function (node) {
      var _this2 = this;

      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      inner.call.apply(inner, [this, node].concat(args));

      node.directives.reverse().forEach(function (directive) {
        node.body.unshift(_this2.directiveToStmt(directive));
      });
      delete node.directives;
    };
  });

  instance.extend("parseClassMethod", function (inner) {
    return function (classBody) {
      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      inner.call.apply(inner, [this, classBody].concat(args));

      var body = classBody.body;
      body[body.length - 1].type = "MethodDefinition";
    };
  });

  instance.extend("parseExprAtom", function (inner) {
    return function () {
      switch (this.state.type) {
        case types.regexp:
          return this.estreeParseRegExpLiteral(this.state.value);

        case types.num:
        case types.string:
          return this.estreeParseLiteral(this.state.value);

        case types._null:
          return this.estreeParseLiteral(null);

        case types._true:
          return this.estreeParseLiteral(true);

        case types._false:
          return this.estreeParseLiteral(false);

        default:
          for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }

          return inner.call.apply(inner, [this].concat(args));
      }
    };
  });

  instance.extend("parseLiteral", function (inner) {
    return function () {
      for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      var node = inner.call.apply(inner, [this].concat(args));
      node.raw = node.extra.raw;
      delete node.extra;

      return node;
    };
  });

  instance.extend("parseMethod", function (inner) {
    return function (node) {
      var funcNode = this.startNode();
      funcNode.kind = node.kind; // provide kind, so inner method correctly sets state

      for (var _len6 = arguments.length, args = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
        args[_key6 - 1] = arguments[_key6];
      }

      funcNode = inner.call.apply(inner, [this, funcNode].concat(args));
      delete funcNode.kind;
      node.value = this.finishNode(funcNode, "FunctionExpression");

      return node;
    };
  });

  instance.extend("parseObjectMethod", function (inner) {
    return function () {
      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      var node = inner.call.apply(inner, [this].concat(args));

      if (node) {
        if (node.kind === "method") node.kind = "init";
        node.type = "Property";
      }

      return node;
    };
  });

  instance.extend("parseObjectProperty", function (inner) {
    return function () {
      for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }

      var node = inner.call.apply(inner, [this].concat(args));

      if (node) {
        node.kind = "init";
        node.type = "Property";
      }

      return node;
    };
  });

  instance.extend("toAssignable", function (inner) {
    return function (node, isBinding) {
      for (var _len9 = arguments.length, args = Array(_len9 > 2 ? _len9 - 2 : 0), _key9 = 2; _key9 < _len9; _key9++) {
        args[_key9 - 2] = arguments[_key9];
      }

      if (isSimpleProperty(node)) {
        this.toAssignable.apply(this, [node.value, isBinding].concat(args));

        return node;
      } else if (node.type === "ObjectExpression") {
        node.type = "ObjectPattern";
        for (var _iterator2 = node.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
          var _ref3;

          if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref3 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref3 = _i2.value;
          }

          var prop = _ref3;

          if (prop.kind === "get" || prop.kind === "set") {
            this.raise(prop.key.start, "Object pattern can't contain getter or setter");
          } else if (prop.method) {
            this.raise(prop.key.start, "Object pattern can't contain methods");
          } else {
            this.toAssignable(prop, isBinding, "object destructuring pattern");
          }
        }

        return node;
      }

      return inner.call.apply(inner, [this, node, isBinding].concat(args));
    };
  });
};

/* eslint max-len: 0 */

var primitiveTypes = ["any", "mixed", "empty", "bool", "boolean", "number", "string", "void", "null"];

var pp$8 = Parser.prototype;

pp$8.flowParseTypeInitialiser = function (tok) {
  var oldInType = this.state.inType;
  this.state.inType = true;
  this.expect(tok || types.colon);

  var type = this.flowParseType();
  this.state.inType = oldInType;
  return type;
};

pp$8.flowParsePredicate = function () {
  var node = this.startNode();
  var moduloLoc = this.state.startLoc;
  var moduloPos = this.state.start;
  this.expect(types.modulo);
  var checksLoc = this.state.startLoc;
  this.expectContextual("checks");
  // Force '%' and 'checks' to be adjacent
  if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {
    this.raise(moduloPos, "Spaces between ´%´ and ´checks´ are not allowed here.");
  }
  if (this.eat(types.parenL)) {
    node.expression = this.parseExpression();
    this.expect(types.parenR);
    return this.finishNode(node, "DeclaredPredicate");
  } else {
    return this.finishNode(node, "InferredPredicate");
  }
};

pp$8.flowParseTypeAndPredicateInitialiser = function () {
  var oldInType = this.state.inType;
  this.state.inType = true;
  this.expect(types.colon);
  var type = null;
  var predicate = null;
  if (this.match(types.modulo)) {
    this.state.inType = oldInType;
    predicate = this.flowParsePredicate();
  } else {
    type = this.flowParseType();
    this.state.inType = oldInType;
    if (this.match(types.modulo)) {
      predicate = this.flowParsePredicate();
    }
  }
  return [type, predicate];
};

pp$8.flowParseDeclareClass = function (node) {
  this.next();
  this.flowParseInterfaceish(node, true);
  return this.finishNode(node, "DeclareClass");
};

pp$8.flowParseDeclareFunction = function (node) {
  this.next();

  var id = node.id = this.parseIdentifier();

  var typeNode = this.startNode();
  var typeContainer = this.startNode();

  if (this.isRelational("<")) {
    typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
  } else {
    typeNode.typeParameters = null;
  }

  this.expect(types.parenL);
  var tmp = this.flowParseFunctionTypeParams();
  typeNode.params = tmp.params;
  typeNode.rest = tmp.rest;
  this.expect(types.parenR);
  var predicate = null;

  var _flowParseTypeAndPred = this.flowParseTypeAndPredicateInitialiser();

  typeNode.returnType = _flowParseTypeAndPred[0];
  predicate = _flowParseTypeAndPred[1];

  typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
  typeContainer.predicate = predicate;
  id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");

  this.finishNode(id, id.type);

  this.semicolon();

  return this.finishNode(node, "DeclareFunction");
};

pp$8.flowParseDeclare = function (node) {
  if (this.match(types._class)) {
    return this.flowParseDeclareClass(node);
  } else if (this.match(types._function)) {
    return this.flowParseDeclareFunction(node);
  } else if (this.match(types._var)) {
    return this.flowParseDeclareVariable(node);
  } else if (this.isContextual("module")) {
    if (this.lookahead().type === types.dot) {
      return this.flowParseDeclareModuleExports(node);
    } else {
      return this.flowParseDeclareModule(node);
    }
  } else if (this.isContextual("type")) {
    return this.flowParseDeclareTypeAlias(node);
  } else if (this.isContextual("interface")) {
    return this.flowParseDeclareInterface(node);
  } else {
    this.unexpected();
  }
};

pp$8.flowParseDeclareVariable = function (node) {
  this.next();
  node.id = this.flowParseTypeAnnotatableIdentifier();
  this.semicolon();
  return this.finishNode(node, "DeclareVariable");
};

pp$8.flowParseDeclareModule = function (node) {
  this.next();

  if (this.match(types.string)) {
    node.id = this.parseExprAtom();
  } else {
    node.id = this.parseIdentifier();
  }

  var bodyNode = node.body = this.startNode();
  var body = bodyNode.body = [];
  this.expect(types.braceL);
  while (!this.match(types.braceR)) {
    var _bodyNode = this.startNode();

    if (this.match(types._import)) {
      var lookahead = this.lookahead();
      if (lookahead.value !== "type" && lookahead.value !== "typeof") {
        this.unexpected(null, "Imports within a `declare module` body must always be `import type` or `import typeof`");
      }

      this.parseImport(_bodyNode);
    } else {
      this.expectContextual("declare", "Only declares and type imports are allowed inside declare module");

      _bodyNode = this.flowParseDeclare(_bodyNode, true);
    }

    body.push(_bodyNode);
  }
  this.expect(types.braceR);

  this.finishNode(bodyNode, "BlockStatement");
  return this.finishNode(node, "DeclareModule");
};

pp$8.flowParseDeclareModuleExports = function (node) {
  this.expectContextual("module");
  this.expect(types.dot);
  this.expectContextual("exports");
  node.typeAnnotation = this.flowParseTypeAnnotation();
  this.semicolon();

  return this.finishNode(node, "DeclareModuleExports");
};

pp$8.flowParseDeclareTypeAlias = function (node) {
  this.next();
  this.flowParseTypeAlias(node);
  return this.finishNode(node, "DeclareTypeAlias");
};

pp$8.flowParseDeclareInterface = function (node) {
  this.next();
  this.flowParseInterfaceish(node);
  return this.finishNode(node, "DeclareInterface");
};

// Interfaces

pp$8.flowParseInterfaceish = function (node, allowStatic) {
  node.id = this.parseIdentifier();

  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterDeclaration();
  } else {
    node.typeParameters = null;
  }

  node.extends = [];
  node.mixins = [];

  if (this.eat(types._extends)) {
    do {
      node.extends.push(this.flowParseInterfaceExtends());
    } while (this.eat(types.comma));
  }

  if (this.isContextual("mixins")) {
    this.next();
    do {
      node.mixins.push(this.flowParseInterfaceExtends());
    } while (this.eat(types.comma));
  }

  node.body = this.flowParseObjectType(allowStatic);
};

pp$8.flowParseInterfaceExtends = function () {
  var node = this.startNode();

  node.id = this.flowParseQualifiedTypeIdentifier();
  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterInstantiation();
  } else {
    node.typeParameters = null;
  }

  return this.finishNode(node, "InterfaceExtends");
};

pp$8.flowParseInterface = function (node) {
  this.flowParseInterfaceish(node, false);
  return this.finishNode(node, "InterfaceDeclaration");
};

pp$8.flowParseRestrictedIdentifier = function (liberal) {
  if (primitiveTypes.indexOf(this.state.value) > -1) {
    this.raise(this.state.start, "Cannot overwrite primitive type " + this.state.value);
  }

  return this.parseIdentifier(liberal);
};

// Type aliases

pp$8.flowParseTypeAlias = function (node) {
  node.id = this.flowParseRestrictedIdentifier();

  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterDeclaration();
  } else {
    node.typeParameters = null;
  }

  node.right = this.flowParseTypeInitialiser(types.eq);
  this.semicolon();

  return this.finishNode(node, "TypeAlias");
};

// Type annotations

pp$8.flowParseTypeParameter = function () {
  var node = this.startNode();

  var variance = this.flowParseVariance();

  var ident = this.flowParseTypeAnnotatableIdentifier();
  node.name = ident.name;
  node.variance = variance;
  node.bound = ident.typeAnnotation;

  if (this.match(types.eq)) {
    this.eat(types.eq);
    node.default = this.flowParseType();
  }

  return this.finishNode(node, "TypeParameter");
};

pp$8.flowParseTypeParameterDeclaration = function () {
  var oldInType = this.state.inType;
  var node = this.startNode();
  node.params = [];

  this.state.inType = true;

  // istanbul ignore else: this condition is already checked at all call sites
  if (this.isRelational("<") || this.match(types.jsxTagStart)) {
    this.next();
  } else {
    this.unexpected();
  }

  do {
    node.params.push(this.flowParseTypeParameter());
    if (!this.isRelational(">")) {
      this.expect(types.comma);
    }
  } while (!this.isRelational(">"));
  this.expectRelational(">");

  this.state.inType = oldInType;

  return this.finishNode(node, "TypeParameterDeclaration");
};

pp$8.flowParseTypeParameterInstantiation = function () {
  var node = this.startNode();
  var oldInType = this.state.inType;
  node.params = [];

  this.state.inType = true;

  this.expectRelational("<");
  while (!this.isRelational(">")) {
    node.params.push(this.flowParseType());
    if (!this.isRelational(">")) {
      this.expect(types.comma);
    }
  }
  this.expectRelational(">");

  this.state.inType = oldInType;

  return this.finishNode(node, "TypeParameterInstantiation");
};

pp$8.flowParseObjectPropertyKey = function () {
  return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
};

pp$8.flowParseObjectTypeIndexer = function (node, isStatic, variance) {
  node.static = isStatic;

  this.expect(types.bracketL);
  if (this.lookahead().type === types.colon) {
    node.id = this.flowParseObjectPropertyKey();
    node.key = this.flowParseTypeInitialiser();
  } else {
    node.id = null;
    node.key = this.flowParseType();
  }
  this.expect(types.bracketR);
  node.value = this.flowParseTypeInitialiser();
  node.variance = variance;

  this.flowObjectTypeSemicolon();
  return this.finishNode(node, "ObjectTypeIndexer");
};

pp$8.flowParseObjectTypeMethodish = function (node) {
  node.params = [];
  node.rest = null;
  node.typeParameters = null;

  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterDeclaration();
  }

  this.expect(types.parenL);
  while (this.match(types.name)) {
    node.params.push(this.flowParseFunctionTypeParam());
    if (!this.match(types.parenR)) {
      this.expect(types.comma);
    }
  }

  if (this.eat(types.ellipsis)) {
    node.rest = this.flowParseFunctionTypeParam();
  }
  this.expect(types.parenR);
  node.returnType = this.flowParseTypeInitialiser();

  return this.finishNode(node, "FunctionTypeAnnotation");
};

pp$8.flowParseObjectTypeMethod = function (startPos, startLoc, isStatic, key) {
  var node = this.startNodeAt(startPos, startLoc);
  node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(startPos, startLoc));
  node.static = isStatic;
  node.key = key;
  node.optional = false;
  this.flowObjectTypeSemicolon();
  return this.finishNode(node, "ObjectTypeProperty");
};

pp$8.flowParseObjectTypeCallProperty = function (node, isStatic) {
  var valueNode = this.startNode();
  node.static = isStatic;
  node.value = this.flowParseObjectTypeMethodish(valueNode);
  this.flowObjectTypeSemicolon();
  return this.finishNode(node, "ObjectTypeCallProperty");
};

pp$8.flowParseObjectType = function (allowStatic, allowExact) {
  var oldInType = this.state.inType;
  this.state.inType = true;

  var nodeStart = this.startNode();
  var node = void 0;
  var propertyKey = void 0;
  var isStatic = false;

  nodeStart.callProperties = [];
  nodeStart.properties = [];
  nodeStart.indexers = [];

  var endDelim = void 0;
  var exact = void 0;
  if (allowExact && this.match(types.braceBarL)) {
    this.expect(types.braceBarL);
    endDelim = types.braceBarR;
    exact = true;
  } else {
    this.expect(types.braceL);
    endDelim = types.braceR;
    exact = false;
  }

  nodeStart.exact = exact;

  while (!this.match(endDelim)) {
    var optional = false;
    var startPos = this.state.start;
    var startLoc = this.state.startLoc;
    node = this.startNode();
    if (allowStatic && this.isContextual("static") && this.lookahead().type !== types.colon) {
      this.next();
      isStatic = true;
    }

    var variancePos = this.state.start;
    var variance = this.flowParseVariance();

    if (this.match(types.bracketL)) {
      nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
    } else if (this.match(types.parenL) || this.isRelational("<")) {
      if (variance) {
        this.unexpected(variancePos);
      }
      nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
    } else {
      propertyKey = this.flowParseObjectPropertyKey();
      if (this.isRelational("<") || this.match(types.parenL)) {
        // This is a method property
        if (variance) {
          this.unexpected(variancePos);
        }
        nodeStart.properties.push(this.flowParseObjectTypeMethod(startPos, startLoc, isStatic, propertyKey));
      } else {
        if (this.eat(types.question)) {
          optional = true;
        }
        node.key = propertyKey;
        node.value = this.flowParseTypeInitialiser();
        node.optional = optional;
        node.static = isStatic;
        node.variance = variance;
        this.flowObjectTypeSemicolon();
        nodeStart.properties.push(this.finishNode(node, "ObjectTypeProperty"));
      }
    }

    isStatic = false;
  }

  this.expect(endDelim);

  var out = this.finishNode(nodeStart, "ObjectTypeAnnotation");

  this.state.inType = oldInType;

  return out;
};

pp$8.flowObjectTypeSemicolon = function () {
  if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {
    this.unexpected();
  }
};

pp$8.flowParseQualifiedTypeIdentifier = function (startPos, startLoc, id) {
  startPos = startPos || this.state.start;
  startLoc = startLoc || this.state.startLoc;
  var node = id || this.parseIdentifier();

  while (this.eat(types.dot)) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.qualification = node;
    node2.id = this.parseIdentifier();
    node = this.finishNode(node2, "QualifiedTypeIdentifier");
  }

  return node;
};

pp$8.flowParseGenericType = function (startPos, startLoc, id) {
  var node = this.startNodeAt(startPos, startLoc);

  node.typeParameters = null;
  node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);

  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterInstantiation();
  }

  return this.finishNode(node, "GenericTypeAnnotation");
};

pp$8.flowParseTypeofType = function () {
  var node = this.startNode();
  this.expect(types._typeof);
  node.argument = this.flowParsePrimaryType();
  return this.finishNode(node, "TypeofTypeAnnotation");
};

pp$8.flowParseTupleType = function () {
  var node = this.startNode();
  node.types = [];
  this.expect(types.bracketL);
  // We allow trailing commas
  while (this.state.pos < this.input.length && !this.match(types.bracketR)) {
    node.types.push(this.flowParseType());
    if (this.match(types.bracketR)) break;
    this.expect(types.comma);
  }
  this.expect(types.bracketR);
  return this.finishNode(node, "TupleTypeAnnotation");
};

pp$8.flowParseFunctionTypeParam = function () {
  var name = null;
  var optional = false;
  var typeAnnotation = null;
  var node = this.startNode();
  var lh = this.lookahead();
  if (lh.type === types.colon || lh.type === types.question) {
    name = this.parseIdentifier();
    if (this.eat(types.question)) {
      optional = true;
    }
    typeAnnotation = this.flowParseTypeInitialiser();
  } else {
    typeAnnotation = this.flowParseType();
  }
  node.name = name;
  node.optional = optional;
  node.typeAnnotation = typeAnnotation;
  return this.finishNode(node, "FunctionTypeParam");
};

pp$8.reinterpretTypeAsFunctionTypeParam = function (type) {
  var node = this.startNodeAt(type.start, type.loc);
  node.name = null;
  node.optional = false;
  node.typeAnnotation = type;
  return this.finishNode(node, "FunctionTypeParam");
};

pp$8.flowParseFunctionTypeParams = function () {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  var ret = { params: params, rest: null };
  while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
    ret.params.push(this.flowParseFunctionTypeParam());
    if (!this.match(types.parenR)) {
      this.expect(types.comma);
    }
  }
  if (this.eat(types.ellipsis)) {
    ret.rest = this.flowParseFunctionTypeParam();
  }
  return ret;
};

pp$8.flowIdentToTypeAnnotation = function (startPos, startLoc, node, id) {
  switch (id.name) {
    case "any":
      return this.finishNode(node, "AnyTypeAnnotation");

    case "void":
      return this.finishNode(node, "VoidTypeAnnotation");

    case "bool":
    case "boolean":
      return this.finishNode(node, "BooleanTypeAnnotation");

    case "mixed":
      return this.finishNode(node, "MixedTypeAnnotation");

    case "empty":
      return this.finishNode(node, "EmptyTypeAnnotation");

    case "number":
      return this.finishNode(node, "NumberTypeAnnotation");

    case "string":
      return this.finishNode(node, "StringTypeAnnotation");

    default:
      return this.flowParseGenericType(startPos, startLoc, id);
  }
};

// The parsing of types roughly parallels the parsing of expressions, and
// primary types are kind of like primary expressions...they're the
// primitives with which other types are constructed.
pp$8.flowParsePrimaryType = function () {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var node = this.startNode();
  var tmp = void 0;
  var type = void 0;
  var isGroupedType = false;
  var oldNoAnonFunctionType = this.state.noAnonFunctionType;

  switch (this.state.type) {
    case types.name:
      return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());

    case types.braceL:
      return this.flowParseObjectType(false, false);

    case types.braceBarL:
      return this.flowParseObjectType(false, true);

    case types.bracketL:
      return this.flowParseTupleType();

    case types.relational:
      if (this.state.value === "<") {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
        this.expect(types.parenL);
        tmp = this.flowParseFunctionTypeParams();
        node.params = tmp.params;
        node.rest = tmp.rest;
        this.expect(types.parenR);

        this.expect(types.arrow);

        node.returnType = this.flowParseType();

        return this.finishNode(node, "FunctionTypeAnnotation");
      }
      break;

    case types.parenL:
      this.next();

      // Check to see if this is actually a grouped type
      if (!this.match(types.parenR) && !this.match(types.ellipsis)) {
        if (this.match(types.name)) {
          var token = this.lookahead().type;
          isGroupedType = token !== types.question && token !== types.colon;
        } else {
          isGroupedType = true;
        }
      }

      if (isGroupedType) {
        this.state.noAnonFunctionType = false;
        type = this.flowParseType();
        this.state.noAnonFunctionType = oldNoAnonFunctionType;

        // A `,` or a `) =>` means this is an anonymous function type
        if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {
          this.expect(types.parenR);
          return type;
        } else {
          // Eat a comma if there is one
          this.eat(types.comma);
        }
      }

      if (type) {
        tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
      } else {
        tmp = this.flowParseFunctionTypeParams();
      }

      node.params = tmp.params;
      node.rest = tmp.rest;

      this.expect(types.parenR);

      this.expect(types.arrow);

      node.returnType = this.flowParseType();

      node.typeParameters = null;

      return this.finishNode(node, "FunctionTypeAnnotation");

    case types.string:
      return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");

    case types._true:case types._false:
      node.value = this.match(types._true);
      this.next();
      return this.finishNode(node, "BooleanLiteralTypeAnnotation");

    case types.plusMin:
      if (this.state.value === "-") {
        this.next();
        if (!this.match(types.num)) this.unexpected(null, "Unexpected token, expected number");

        return this.parseLiteral(-this.state.value, "NumericLiteralTypeAnnotation", node.start, node.loc.start);
      }

      this.unexpected();
    case types.num:
      return this.parseLiteral(this.state.value, "NumericLiteralTypeAnnotation");

    case types._null:
      node.value = this.match(types._null);
      this.next();
      return this.finishNode(node, "NullLiteralTypeAnnotation");

    case types._this:
      node.value = this.match(types._this);
      this.next();
      return this.finishNode(node, "ThisTypeAnnotation");

    case types.star:
      this.next();
      return this.finishNode(node, "ExistentialTypeParam");

    default:
      if (this.state.type.keyword === "typeof") {
        return this.flowParseTypeofType();
      }
  }

  this.unexpected();
};

pp$8.flowParsePostfixType = function () {
  var startPos = this.state.start,
      startLoc = this.state.startLoc;
  var type = this.flowParsePrimaryType();
  while (!this.canInsertSemicolon() && this.match(types.bracketL)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.elementType = type;
    this.expect(types.bracketL);
    this.expect(types.bracketR);
    type = this.finishNode(node, "ArrayTypeAnnotation");
  }
  return type;
};

pp$8.flowParsePrefixType = function () {
  var node = this.startNode();
  if (this.eat(types.question)) {
    node.typeAnnotation = this.flowParsePrefixType();
    return this.finishNode(node, "NullableTypeAnnotation");
  } else {
    return this.flowParsePostfixType();
  }
};

pp$8.flowParseAnonFunctionWithoutParens = function () {
  var param = this.flowParsePrefixType();
  if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {
    var node = this.startNodeAt(param.start, param.loc);
    node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
    node.rest = null;
    node.returnType = this.flowParseType();
    node.typeParameters = null;
    return this.finishNode(node, "FunctionTypeAnnotation");
  }
  return param;
};

pp$8.flowParseIntersectionType = function () {
  var node = this.startNode();
  this.eat(types.bitwiseAND);
  var type = this.flowParseAnonFunctionWithoutParens();
  node.types = [type];
  while (this.eat(types.bitwiseAND)) {
    node.types.push(this.flowParseAnonFunctionWithoutParens());
  }
  return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
};

pp$8.flowParseUnionType = function () {
  var node = this.startNode();
  this.eat(types.bitwiseOR);
  var type = this.flowParseIntersectionType();
  node.types = [type];
  while (this.eat(types.bitwiseOR)) {
    node.types.push(this.flowParseIntersectionType());
  }
  return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
};

pp$8.flowParseType = function () {
  var oldInType = this.state.inType;
  this.state.inType = true;
  var type = this.flowParseUnionType();
  this.state.inType = oldInType;
  return type;
};

pp$8.flowParseTypeAnnotation = function () {
  var node = this.startNode();
  node.typeAnnotation = this.flowParseTypeInitialiser();
  return this.finishNode(node, "TypeAnnotation");
};

pp$8.flowParseTypeAndPredicateAnnotation = function () {
  var node = this.startNode();

  var _flowParseTypeAndPred2 = this.flowParseTypeAndPredicateInitialiser();

  node.typeAnnotation = _flowParseTypeAndPred2[0];
  node.predicate = _flowParseTypeAndPred2[1];

  return this.finishNode(node, "TypeAnnotation");
};

pp$8.flowParseTypeAnnotatableIdentifier = function () {
  var ident = this.flowParseRestrictedIdentifier();
  if (this.match(types.colon)) {
    ident.typeAnnotation = this.flowParseTypeAnnotation();
    this.finishNode(ident, ident.type);
  }
  return ident;
};

pp$8.typeCastToParameter = function (node) {
  node.expression.typeAnnotation = node.typeAnnotation;

  return this.finishNodeAt(node.expression, node.expression.type, node.typeAnnotation.end, node.typeAnnotation.loc.end);
};

pp$8.flowParseVariance = function () {
  var variance = null;
  if (this.match(types.plusMin)) {
    if (this.state.value === "+") {
      variance = "plus";
    } else if (this.state.value === "-") {
      variance = "minus";
    }
    this.next();
  }
  return variance;
};

var flowPlugin = function (instance) {
  // plain function return types: function name(): string {}
  instance.extend("parseFunctionBody", function (inner) {
    return function (node, allowExpression) {
      if (this.match(types.colon) && !allowExpression) {
        // if allowExpression is true then we're parsing an arrow function and if
        // there's a return type then it's been handled elsewhere
        node.returnType = this.flowParseTypeAndPredicateAnnotation();
      }

      return inner.call(this, node, allowExpression);
    };
  });

  // interfaces
  instance.extend("parseStatement", function (inner) {
    return function (declaration, topLevel) {
      // strict mode handling of `interface` since it's a reserved word
      if (this.state.strict && this.match(types.name) && this.state.value === "interface") {
        var node = this.startNode();
        this.next();
        return this.flowParseInterface(node);
      } else {
        return inner.call(this, declaration, topLevel);
      }
    };
  });

  // declares, interfaces and type aliases
  instance.extend("parseExpressionStatement", function (inner) {
    return function (node, expr) {
      if (expr.type === "Identifier") {
        if (expr.name === "declare") {
          if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var)) {
            return this.flowParseDeclare(node);
          }
        } else if (this.match(types.name)) {
          if (expr.name === "interface") {
            return this.flowParseInterface(node);
          } else if (expr.name === "type") {
            return this.flowParseTypeAlias(node);
          }
        }
      }

      return inner.call(this, node, expr);
    };
  });

  // export type
  instance.extend("shouldParseExportDeclaration", function (inner) {
    return function () {
      return this.isContextual("type") || this.isContextual("interface") || inner.call(this);
    };
  });

  instance.extend("parseConditional", function (inner) {
    return function (expr, noIn, startPos, startLoc, refNeedsArrowPos) {
      // only do the expensive clone if there is a question mark
      // and if we come from inside parens
      if (refNeedsArrowPos && this.match(types.question)) {
        var state = this.state.clone();
        try {
          return inner.call(this, expr, noIn, startPos, startLoc);
        } catch (err) {
          if (err instanceof SyntaxError) {
            this.state = state;
            refNeedsArrowPos.start = err.pos || this.state.start;
            return expr;
          } else {
            // istanbul ignore next: no such error is expected
            throw err;
          }
        }
      }

      return inner.call(this, expr, noIn, startPos, startLoc);
    };
  });

  instance.extend("parseParenItem", function (inner) {
    return function (node, startLoc, startPos) {
      node = inner.call(this, node, startLoc, startPos);
      if (this.eat(types.question)) {
        node.optional = true;
      }

      if (this.match(types.colon)) {
        var typeCastNode = this.startNodeAt(startLoc, startPos);
        typeCastNode.expression = node;
        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();

        return this.finishNode(typeCastNode, "TypeCastExpression");
      }

      return node;
    };
  });

  instance.extend("parseExport", function (inner) {
    return function (node) {
      node = inner.call(this, node);
      if (node.type === "ExportNamedDeclaration") {
        node.exportKind = node.exportKind || "value";
      }
      return node;
    };
  });

  instance.extend("parseExportDeclaration", function (inner) {
    return function (node) {
      if (this.isContextual("type")) {
        node.exportKind = "type";

        var declarationNode = this.startNode();
        this.next();

        if (this.match(types.braceL)) {
          // export type { foo, bar };
          node.specifiers = this.parseExportSpecifiers();
          this.parseExportFrom(node);
          return null;
        } else {
          // export type Foo = Bar;
          return this.flowParseTypeAlias(declarationNode);
        }
      } else if (this.isContextual("interface")) {
        node.exportKind = "type";
        var _declarationNode = this.startNode();
        this.next();
        return this.flowParseInterface(_declarationNode);
      } else {
        return inner.call(this, node);
      }
    };
  });

  instance.extend("parseClassId", function (inner) {
    return function (node) {
      inner.apply(this, arguments);
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }
    };
  });

  // don't consider `void` to be a keyword as then it'll use the void token type
  // and set startExpr
  instance.extend("isKeyword", function (inner) {
    return function (name) {
      if (this.state.inType && name === "void") {
        return false;
      } else {
        return inner.call(this, name);
      }
    };
  });

  // ensure that inside flow types, we bypass the jsx parser plugin
  instance.extend("readToken", function (inner) {
    return function (code) {
      if (this.state.inType && (code === 62 || code === 60)) {
        return this.finishOp(types.relational, 1);
      } else {
        return inner.call(this, code);
      }
    };
  });

  // don't lex any token as a jsx one inside a flow type
  instance.extend("jsx_readToken", function (inner) {
    return function () {
      if (!this.state.inType) return inner.call(this);
    };
  });

  instance.extend("toAssignable", function (inner) {
    return function (node, isBinding, contextDescription) {
      if (node.type === "TypeCastExpression") {
        return inner.call(this, this.typeCastToParameter(node), isBinding, contextDescription);
      } else {
        return inner.call(this, node, isBinding, contextDescription);
      }
    };
  });

  // turn type casts that we found in function parameter head into type annotated params
  instance.extend("toAssignableList", function (inner) {
    return function (exprList, isBinding, contextDescription) {
      for (var i = 0; i < exprList.length; i++) {
        var expr = exprList[i];
        if (expr && expr.type === "TypeCastExpression") {
          exprList[i] = this.typeCastToParameter(expr);
        }
      }
      return inner.call(this, exprList, isBinding, contextDescription);
    };
  });

  // this is a list of nodes, from something like a call expression, we need to filter the
  // type casts that we've found that are illegal in this context
  instance.extend("toReferencedList", function () {
    return function (exprList) {
      for (var i = 0; i < exprList.length; i++) {
        var expr = exprList[i];
        if (expr && expr._exprListItem && expr.type === "TypeCastExpression") {
          this.raise(expr.start, "Unexpected type cast");
        }
      }

      return exprList;
    };
  });

  // parse an item inside a expression list eg. `(NODE, NODE)` where NODE represents
  // the position where this function is called
  instance.extend("parseExprListItem", function (inner) {
    return function () {
      var container = this.startNode();

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var node = inner.call.apply(inner, [this].concat(args));
      if (this.match(types.colon)) {
        container._exprListItem = true;
        container.expression = node;
        container.typeAnnotation = this.flowParseTypeAnnotation();
        return this.finishNode(container, "TypeCastExpression");
      } else {
        return node;
      }
    };
  });

  instance.extend("checkLVal", function (inner) {
    return function (node) {
      if (node.type !== "TypeCastExpression") {
        return inner.apply(this, arguments);
      }
    };
  });

  // parse class property type annotations
  instance.extend("parseClassProperty", function (inner) {
    return function (node) {
      delete node.variancePos;
      if (this.match(types.colon)) {
        node.typeAnnotation = this.flowParseTypeAnnotation();
      }
      return inner.call(this, node);
    };
  });

  // determine whether or not we're currently in the position where a class property would appear
  instance.extend("isClassProperty", function (inner) {
    return function () {
      return this.match(types.colon) || inner.call(this);
    };
  });

  // parse type parameters for class methods
  instance.extend("parseClassMethod", function (inner) {
    return function (classBody, method) {
      if (method.variance) {
        this.unexpected(method.variancePos);
      }
      delete method.variance;
      delete method.variancePos;
      if (this.isRelational("<")) {
        method.typeParameters = this.flowParseTypeParameterDeclaration();
      }

      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      inner.call.apply(inner, [this, classBody, method].concat(args));
    };
  });

  // parse a the super class type parameters and implements
  instance.extend("parseClassSuper", function (inner) {
    return function (node, isStatement) {
      inner.call(this, node, isStatement);
      if (node.superClass && this.isRelational("<")) {
        node.superTypeParameters = this.flowParseTypeParameterInstantiation();
      }
      if (this.isContextual("implements")) {
        this.next();
        var implemented = node.implements = [];
        do {
          var _node = this.startNode();
          _node.id = this.parseIdentifier();
          if (this.isRelational("<")) {
            _node.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            _node.typeParameters = null;
          }
          implemented.push(this.finishNode(_node, "ClassImplements"));
        } while (this.eat(types.comma));
      }
    };
  });

  instance.extend("parsePropertyName", function (inner) {
    return function (node) {
      var variancePos = this.state.start;
      var variance = this.flowParseVariance();
      var key = inner.call(this, node);
      node.variance = variance;
      node.variancePos = variancePos;
      return key;
    };
  });

  // parse type parameters for object method shorthand
  instance.extend("parseObjPropValue", function (inner) {
    return function (prop) {
      if (prop.variance) {
        this.unexpected(prop.variancePos);
      }
      delete prop.variance;
      delete prop.variancePos;

      var typeParameters = void 0;

      // method shorthand
      if (this.isRelational("<")) {
        typeParameters = this.flowParseTypeParameterDeclaration();
        if (!this.match(types.parenL)) this.unexpected();
      }

      inner.apply(this, arguments);

      // add typeParameters if we found them
      if (typeParameters) {
        (prop.value || prop).typeParameters = typeParameters;
      }
    };
  });

  instance.extend("parseAssignableListItemTypes", function () {
    return function (param) {
      if (this.eat(types.question)) {
        param.optional = true;
      }
      if (this.match(types.colon)) {
        param.typeAnnotation = this.flowParseTypeAnnotation();
      }
      this.finishNode(param, param.type);
      return param;
    };
  });

  instance.extend("parseMaybeDefault", function (inner) {
    return function () {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      var node = inner.apply(this, args);

      if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
        this.raise(node.typeAnnotation.start, "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`");
      }

      return node;
    };
  });

  // parse typeof and type imports
  instance.extend("parseImportSpecifiers", function (inner) {
    return function (node) {
      node.importKind = "value";

      var kind = null;
      if (this.match(types._typeof)) {
        kind = "typeof";
      } else if (this.isContextual("type")) {
        kind = "type";
      }
      if (kind) {
        var lh = this.lookahead();
        if (lh.type === types.name && lh.value !== "from" || lh.type === types.braceL || lh.type === types.star) {
          this.next();
          node.importKind = kind;
        }
      }

      inner.call(this, node);
    };
  });

  // parse import-type/typeof shorthand
  instance.extend("parseImportSpecifier", function () {
    return function (node) {
      var specifier = this.startNode();
      var firstIdentLoc = this.state.start;
      var firstIdent = this.parseIdentifier(true);

      var specifierTypeKind = null;
      if (firstIdent.name === "type") {
        specifierTypeKind = "type";
      } else if (firstIdent.name === "typeof") {
        specifierTypeKind = "typeof";
      }

      var isBinding = false;
      if (this.isContextual("as")) {
        var as_ident = this.parseIdentifier(true);
        if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {
          // `import {type as ,` or `import {type as }`
          specifier.imported = as_ident;
          specifier.importKind = specifierTypeKind;
          specifier.local = as_ident.__clone();
        } else {
          // `import {type as foo`
          specifier.imported = firstIdent;
          specifier.importKind = null;
          specifier.local = this.parseIdentifier();
        }
      } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {
        // `import {type foo`
        specifier.imported = this.parseIdentifier(true);
        specifier.importKind = specifierTypeKind;
        if (this.eatContextual("as")) {
          specifier.local = this.parseIdentifier();
        } else {
          isBinding = true;
          specifier.local = specifier.imported.__clone();
        }
      } else {
        isBinding = true;
        specifier.imported = firstIdent;
        specifier.importKind = null;
        specifier.local = specifier.imported.__clone();
      }

      if ((node.importKind === "type" || node.importKind === "typeof") && (specifier.importKind === "type" || specifier.importKind === "typeof")) {
        this.raise(firstIdentLoc, "`The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements`");
      }

      if (isBinding) this.checkReservedWord(specifier.local.name, specifier.start, true, true);

      this.checkLVal(specifier.local, true, undefined, "import specifier");
      node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
    };
  });

  // parse function type parameters - function foo<T>() {}
  instance.extend("parseFunctionParams", function (inner) {
    return function (node) {
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      inner.call(this, node);
    };
  });

  // parse flow type annotations on variable declarator heads - let foo: string = bar
  instance.extend("parseVarHead", function (inner) {
    return function (decl) {
      inner.call(this, decl);
      if (this.match(types.colon)) {
        decl.id.typeAnnotation = this.flowParseTypeAnnotation();
        this.finishNode(decl.id, decl.id.type);
      }
    };
  });

  // parse the return type of an async arrow function - let foo = (async (): number => {});
  instance.extend("parseAsyncArrowFromCallExpression", function (inner) {
    return function (node, call) {
      if (this.match(types.colon)) {
        var oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true;
        node.returnType = this.flowParseTypeAnnotation();
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
      }

      return inner.call(this, node, call);
    };
  });

  // todo description
  instance.extend("shouldParseAsyncArrow", function (inner) {
    return function () {
      return this.match(types.colon) || inner.call(this);
    };
  });

  // We need to support type parameter declarations for arrow functions. This
  // is tricky. There are three situations we need to handle
  //
  // 1. This is either JSX or an arrow function. We'll try JSX first. If that
  //    fails, we'll try an arrow function. If that fails, we'll throw the JSX
  //    error.
  // 2. This is an arrow function. We'll parse the type parameter declaration,
  //    parse the rest, make sure the rest is an arrow function, and go from
  //    there
  // 3. This is neither. Just call the inner function
  instance.extend("parseMaybeAssign", function (inner) {
    return function () {
      var jsxError = null;

      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      if (types.jsxTagStart && this.match(types.jsxTagStart)) {
        var state = this.state.clone();
        try {
          return inner.apply(this, args);
        } catch (err) {
          if (err instanceof SyntaxError) {
            this.state = state;
            jsxError = err;
          } else {
            // istanbul ignore next: no such error is expected
            throw err;
          }
        }
      }

      // Need to push something onto the context to stop
      // the JSX plugin from messing with the tokens
      this.state.context.push(types$1.parenExpression);
      if (jsxError != null || this.isRelational("<")) {
        var arrowExpression = void 0;
        var typeParameters = void 0;
        try {
          typeParameters = this.flowParseTypeParameterDeclaration();

          arrowExpression = inner.apply(this, args);
          arrowExpression.typeParameters = typeParameters;
          arrowExpression.start = typeParameters.start;
          arrowExpression.loc.start = typeParameters.loc.start;
        } catch (err) {
          throw jsxError || err;
        }

        if (arrowExpression.type === "ArrowFunctionExpression") {
          return arrowExpression;
        } else if (jsxError != null) {
          throw jsxError;
        } else {
          this.raise(typeParameters.start, "Expected an arrow function after this type parameter declaration");
        }
      }
      this.state.context.pop();

      return inner.apply(this, args);
    };
  });

  // handle return types for arrow functions
  instance.extend("parseArrow", function (inner) {
    return function (node) {
      if (this.match(types.colon)) {
        var state = this.state.clone();
        try {
          var oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          var returnType = this.flowParseTypeAndPredicateAnnotation();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;

          if (this.canInsertSemicolon()) this.unexpected();
          if (!this.match(types.arrow)) this.unexpected();
          // assign after it is clear it is an arrow
          node.returnType = returnType;
        } catch (err) {
          if (err instanceof SyntaxError) {
            this.state = state;
          } else {
            // istanbul ignore next: no such error is expected
            throw err;
          }
        }
      }

      return inner.call(this, node);
    };
  });

  instance.extend("shouldParseArrow", function (inner) {
    return function () {
      return this.match(types.colon) || inner.call(this);
    };
  });

  instance.extend("isClassMutatorStarter", function (inner) {
    return function () {
      if (this.isRelational("<")) {
        return true;
      } else {
        return inner.call(this);
      }
    };
  });
};

// Adapted from String.fromcodepoint to export the function without modifying String
/*! https://mths.be/fromcodepoint v0.2.1 by @mathias */

// The MIT License (MIT)
// Copyright (c) Mathias Bynens
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
// associated documentation files (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge, publish, distribute,
// sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or
// substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
// NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var fromCodePoint = String.fromCodePoint;

if (!fromCodePoint) {
  var stringFromCharCode = String.fromCharCode;
  var floor = Math.floor;
  fromCodePoint = function fromCodePoint() {
    var MAX_SIZE = 0x4000;
    var codeUnits = [];
    var highSurrogate = void 0;
    var lowSurrogate = void 0;
    var index = -1;
    var length = arguments.length;
    if (!length) {
      return "";
    }
    var result = "";
    while (++index < length) {
      var codePoint = Number(arguments[index]);
      if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
      codePoint < 0 || // not a valid Unicode code point
      codePoint > 0x10FFFF || // not a valid Unicode code point
      floor(codePoint) != codePoint // not an integer
      ) {
          throw RangeError("Invalid code point: " + codePoint);
        }
      if (codePoint <= 0xFFFF) {
        // BMP code point
        codeUnits.push(codePoint);
      } else {
        // Astral code point; split in surrogate halves
        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        codePoint -= 0x10000;
        highSurrogate = (codePoint >> 10) + 0xD800;
        lowSurrogate = codePoint % 0x400 + 0xDC00;
        codeUnits.push(highSurrogate, lowSurrogate);
      }
      if (index + 1 == length || codeUnits.length > MAX_SIZE) {
        result += stringFromCharCode.apply(null, codeUnits);
        codeUnits.length = 0;
      }
    }
    return result;
  };
}

var fromCodePoint$1 = fromCodePoint;

var XHTMLEntities = {
  quot: "\"",
  amp: "&",
  apos: "'",
  lt: "<",
  gt: ">",
  nbsp: "\xA0",
  iexcl: "\xA1",
  cent: "\xA2",
  pound: "\xA3",
  curren: "\xA4",
  yen: "\xA5",
  brvbar: "\xA6",
  sect: "\xA7",
  uml: "\xA8",
  copy: "\xA9",
  ordf: "\xAA",
  laquo: "\xAB",
  not: "\xAC",
  shy: "\xAD",
  reg: "\xAE",
  macr: "\xAF",
  deg: "\xB0",
  plusmn: "\xB1",
  sup2: "\xB2",
  sup3: "\xB3",
  acute: "\xB4",
  micro: "\xB5",
  para: "\xB6",
  middot: "\xB7",
  cedil: "\xB8",
  sup1: "\xB9",
  ordm: "\xBA",
  raquo: "\xBB",
  frac14: "\xBC",
  frac12: "\xBD",
  frac34: "\xBE",
  iquest: "\xBF",
  Agrave: "\xC0",
  Aacute: "\xC1",
  Acirc: "\xC2",
  Atilde: "\xC3",
  Auml: "\xC4",
  Aring: "\xC5",
  AElig: "\xC6",
  Ccedil: "\xC7",
  Egrave: "\xC8",
  Eacute: "\xC9",
  Ecirc: "\xCA",
  Euml: "\xCB",
  Igrave: "\xCC",
  Iacute: "\xCD",
  Icirc: "\xCE",
  Iuml: "\xCF",
  ETH: "\xD0",
  Ntilde: "\xD1",
  Ograve: "\xD2",
  Oacute: "\xD3",
  Ocirc: "\xD4",
  Otilde: "\xD5",
  Ouml: "\xD6",
  times: "\xD7",
  Oslash: "\xD8",
  Ugrave: "\xD9",
  Uacute: "\xDA",
  Ucirc: "\xDB",
  Uuml: "\xDC",
  Yacute: "\xDD",
  THORN: "\xDE",
  szlig: "\xDF",
  agrave: "\xE0",
  aacute: "\xE1",
  acirc: "\xE2",
  atilde: "\xE3",
  auml: "\xE4",
  aring: "\xE5",
  aelig: "\xE6",
  ccedil: "\xE7",
  egrave: "\xE8",
  eacute: "\xE9",
  ecirc: "\xEA",
  euml: "\xEB",
  igrave: "\xEC",
  iacute: "\xED",
  icirc: "\xEE",
  iuml: "\xEF",
  eth: "\xF0",
  ntilde: "\xF1",
  ograve: "\xF2",
  oacute: "\xF3",
  ocirc: "\xF4",
  otilde: "\xF5",
  ouml: "\xF6",
  divide: "\xF7",
  oslash: "\xF8",
  ugrave: "\xF9",
  uacute: "\xFA",
  ucirc: "\xFB",
  uuml: "\xFC",
  yacute: "\xFD",
  thorn: "\xFE",
  yuml: "\xFF",
  OElig: "\u0152",
  oelig: "\u0153",
  Scaron: "\u0160",
  scaron: "\u0161",
  Yuml: "\u0178",
  fnof: "\u0192",
  circ: "\u02C6",
  tilde: "\u02DC",
  Alpha: "\u0391",
  Beta: "\u0392",
  Gamma: "\u0393",
  Delta: "\u0394",
  Epsilon: "\u0395",
  Zeta: "\u0396",
  Eta: "\u0397",
  Theta: "\u0398",
  Iota: "\u0399",
  Kappa: "\u039A",
  Lambda: "\u039B",
  Mu: "\u039C",
  Nu: "\u039D",
  Xi: "\u039E",
  Omicron: "\u039F",
  Pi: "\u03A0",
  Rho: "\u03A1",
  Sigma: "\u03A3",
  Tau: "\u03A4",
  Upsilon: "\u03A5",
  Phi: "\u03A6",
  Chi: "\u03A7",
  Psi: "\u03A8",
  Omega: "\u03A9",
  alpha: "\u03B1",
  beta: "\u03B2",
  gamma: "\u03B3",
  delta: "\u03B4",
  epsilon: "\u03B5",
  zeta: "\u03B6",
  eta: "\u03B7",
  theta: "\u03B8",
  iota: "\u03B9",
  kappa: "\u03BA",
  lambda: "\u03BB",
  mu: "\u03BC",
  nu: "\u03BD",
  xi: "\u03BE",
  omicron: "\u03BF",
  pi: "\u03C0",
  rho: "\u03C1",
  sigmaf: "\u03C2",
  sigma: "\u03C3",
  tau: "\u03C4",
  upsilon: "\u03C5",
  phi: "\u03C6",
  chi: "\u03C7",
  psi: "\u03C8",
  omega: "\u03C9",
  thetasym: "\u03D1",
  upsih: "\u03D2",
  piv: "\u03D6",
  ensp: "\u2002",
  emsp: "\u2003",
  thinsp: "\u2009",
  zwnj: "\u200C",
  zwj: "\u200D",
  lrm: "\u200E",
  rlm: "\u200F",
  ndash: "\u2013",
  mdash: "\u2014",
  lsquo: "\u2018",
  rsquo: "\u2019",
  sbquo: "\u201A",
  ldquo: "\u201C",
  rdquo: "\u201D",
  bdquo: "\u201E",
  dagger: "\u2020",
  Dagger: "\u2021",
  bull: "\u2022",
  hellip: "\u2026",
  permil: "\u2030",
  prime: "\u2032",
  Prime: "\u2033",
  lsaquo: "\u2039",
  rsaquo: "\u203A",
  oline: "\u203E",
  frasl: "\u2044",
  euro: "\u20AC",
  image: "\u2111",
  weierp: "\u2118",
  real: "\u211C",
  trade: "\u2122",
  alefsym: "\u2135",
  larr: "\u2190",
  uarr: "\u2191",
  rarr: "\u2192",
  darr: "\u2193",
  harr: "\u2194",
  crarr: "\u21B5",
  lArr: "\u21D0",
  uArr: "\u21D1",
  rArr: "\u21D2",
  dArr: "\u21D3",
  hArr: "\u21D4",
  forall: "\u2200",
  part: "\u2202",
  exist: "\u2203",
  empty: "\u2205",
  nabla: "\u2207",
  isin: "\u2208",
  notin: "\u2209",
  ni: "\u220B",
  prod: "\u220F",
  sum: "\u2211",
  minus: "\u2212",
  lowast: "\u2217",
  radic: "\u221A",
  prop: "\u221D",
  infin: "\u221E",
  ang: "\u2220",
  and: "\u2227",
  or: "\u2228",
  cap: "\u2229",
  cup: "\u222A",
  "int": "\u222B",
  there4: "\u2234",
  sim: "\u223C",
  cong: "\u2245",
  asymp: "\u2248",
  ne: "\u2260",
  equiv: "\u2261",
  le: "\u2264",
  ge: "\u2265",
  sub: "\u2282",
  sup: "\u2283",
  nsub: "\u2284",
  sube: "\u2286",
  supe: "\u2287",
  oplus: "\u2295",
  otimes: "\u2297",
  perp: "\u22A5",
  sdot: "\u22C5",
  lceil: "\u2308",
  rceil: "\u2309",
  lfloor: "\u230A",
  rfloor: "\u230B",
  lang: "\u2329",
  rang: "\u232A",
  loz: "\u25CA",
  spades: "\u2660",
  clubs: "\u2663",
  hearts: "\u2665",
  diams: "\u2666"
};

var HEX_NUMBER = /^[\da-fA-F]+$/;
var DECIMAL_NUMBER = /^\d+$/;

types$1.j_oTag = new TokContext("<tag", false);
types$1.j_cTag = new TokContext("</tag", false);
types$1.j_expr = new TokContext("<tag>...</tag>", true, true);

types.jsxName = new TokenType("jsxName");
types.jsxText = new TokenType("jsxText", { beforeExpr: true });
types.jsxTagStart = new TokenType("jsxTagStart", { startsExpr: true });
types.jsxTagEnd = new TokenType("jsxTagEnd");

types.jsxTagStart.updateContext = function () {
  this.state.context.push(types$1.j_expr); // treat as beginning of JSX expression
  this.state.context.push(types$1.j_oTag); // start opening tag context
  this.state.exprAllowed = false;
};

types.jsxTagEnd.updateContext = function (prevType) {
  var out = this.state.context.pop();
  if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {
    this.state.context.pop();
    this.state.exprAllowed = this.curContext() === types$1.j_expr;
  } else {
    this.state.exprAllowed = true;
  }
};

var pp$9 = Parser.prototype;

// Reads inline JSX contents token.

pp$9.jsxReadToken = function () {
  var out = "";
  var chunkStart = this.state.pos;
  for (;;) {
    if (this.state.pos >= this.input.length) {
      this.raise(this.state.start, "Unterminated JSX contents");
    }

    var ch = this.input.charCodeAt(this.state.pos);

    switch (ch) {
      case 60: // "<"
      case 123:
        // "{"
        if (this.state.pos === this.state.start) {
          if (ch === 60 && this.state.exprAllowed) {
            ++this.state.pos;
            return this.finishToken(types.jsxTagStart);
          }
          return this.getTokenFromCode(ch);
        }
        out += this.input.slice(chunkStart, this.state.pos);
        return this.finishToken(types.jsxText, out);

      case 38:
        // "&"
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.jsxReadEntity();
        chunkStart = this.state.pos;
        break;

      default:
        if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadNewLine(true);
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
    }
  }
};

pp$9.jsxReadNewLine = function (normalizeCRLF) {
  var ch = this.input.charCodeAt(this.state.pos);
  var out = void 0;
  ++this.state.pos;
  if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
    ++this.state.pos;
    out = normalizeCRLF ? "\n" : "\r\n";
  } else {
    out = String.fromCharCode(ch);
  }
  ++this.state.curLine;
  this.state.lineStart = this.state.pos;

  return out;
};

pp$9.jsxReadString = function (quote) {
  var out = "";
  var chunkStart = ++this.state.pos;
  for (;;) {
    if (this.state.pos >= this.input.length) {
      this.raise(this.state.start, "Unterminated string constant");
    }

    var ch = this.input.charCodeAt(this.state.pos);
    if (ch === quote) break;
    if (ch === 38) {
      // "&"
      out += this.input.slice(chunkStart, this.state.pos);
      out += this.jsxReadEntity();
      chunkStart = this.state.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.state.pos);
      out += this.jsxReadNewLine(false);
      chunkStart = this.state.pos;
    } else {
      ++this.state.pos;
    }
  }
  out += this.input.slice(chunkStart, this.state.pos++);
  return this.finishToken(types.string, out);
};

pp$9.jsxReadEntity = function () {
  var str = "";
  var count = 0;
  var entity = void 0;
  var ch = this.input[this.state.pos];

  var startPos = ++this.state.pos;
  while (this.state.pos < this.input.length && count++ < 10) {
    ch = this.input[this.state.pos++];
    if (ch === ";") {
      if (str[0] === "#") {
        if (str[1] === "x") {
          str = str.substr(2);
          if (HEX_NUMBER.test(str)) entity = fromCodePoint$1(parseInt(str, 16));
        } else {
          str = str.substr(1);
          if (DECIMAL_NUMBER.test(str)) entity = fromCodePoint$1(parseInt(str, 10));
        }
      } else {
        entity = XHTMLEntities[str];
      }
      break;
    }
    str += ch;
  }
  if (!entity) {
    this.state.pos = startPos;
    return "&";
  }
  return entity;
};

// Read a JSX identifier (valid tag or attribute name).
//
// Optimized version since JSX identifiers can"t contain
// escape characters and so can be read as single slice.
// Also assumes that first character was already checked
// by isIdentifierStart in readToken.

pp$9.jsxReadWord = function () {
  var ch = void 0;
  var start = this.state.pos;
  do {
    ch = this.input.charCodeAt(++this.state.pos);
  } while (isIdentifierChar(ch) || ch === 45); // "-"
  return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));
};

// Transforms JSX element name to string.

function getQualifiedJSXName(object) {
  if (object.type === "JSXIdentifier") {
    return object.name;
  }

  if (object.type === "JSXNamespacedName") {
    return object.namespace.name + ":" + object.name.name;
  }

  if (object.type === "JSXMemberExpression") {
    return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
  }
}

// Parse next token as JSX identifier

pp$9.jsxParseIdentifier = function () {
  var node = this.startNode();
  if (this.match(types.jsxName)) {
    node.name = this.state.value;
  } else if (this.state.type.keyword) {
    node.name = this.state.type.keyword;
  } else {
    this.unexpected();
  }
  this.next();
  return this.finishNode(node, "JSXIdentifier");
};

// Parse namespaced identifier.

pp$9.jsxParseNamespacedName = function () {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var name = this.jsxParseIdentifier();
  if (!this.eat(types.colon)) return name;

  var node = this.startNodeAt(startPos, startLoc);
  node.namespace = name;
  node.name = this.jsxParseIdentifier();
  return this.finishNode(node, "JSXNamespacedName");
};

// Parses element name in any form - namespaced, member
// or single identifier.

pp$9.jsxParseElementName = function () {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var node = this.jsxParseNamespacedName();
  while (this.eat(types.dot)) {
    var newNode = this.startNodeAt(startPos, startLoc);
    newNode.object = node;
    newNode.property = this.jsxParseIdentifier();
    node = this.finishNode(newNode, "JSXMemberExpression");
  }
  return node;
};

// Parses any type of JSX attribute value.

pp$9.jsxParseAttributeValue = function () {
  var node = void 0;
  switch (this.state.type) {
    case types.braceL:
      node = this.jsxParseExpressionContainer();
      if (node.expression.type === "JSXEmptyExpression") {
        this.raise(node.start, "JSX attributes must only be assigned a non-empty expression");
      } else {
        return node;
      }

    case types.jsxTagStart:
    case types.string:
      node = this.parseExprAtom();
      node.extra = null;
      return node;

    default:
      this.raise(this.state.start, "JSX value should be either an expression or a quoted JSX text");
  }
};

// JSXEmptyExpression is unique type since it doesn't actually parse anything,
// and so it should start at the end of last read token (left brace) and finish
// at the beginning of the next one (right brace).

pp$9.jsxParseEmptyExpression = function () {
  var node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
  return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc);
};

// Parse JSX spread child

pp$9.jsxParseSpreadChild = function () {
  var node = this.startNode();
  this.expect(types.braceL);
  this.expect(types.ellipsis);
  node.expression = this.parseExpression();
  this.expect(types.braceR);

  return this.finishNode(node, "JSXSpreadChild");
};

// Parses JSX expression enclosed into curly brackets.


pp$9.jsxParseExpressionContainer = function () {
  var node = this.startNode();
  this.next();
  if (this.match(types.braceR)) {
    node.expression = this.jsxParseEmptyExpression();
  } else {
    node.expression = this.parseExpression();
  }
  this.expect(types.braceR);
  return this.finishNode(node, "JSXExpressionContainer");
};

// Parses following JSX attribute name-value pair.

pp$9.jsxParseAttribute = function () {
  var node = this.startNode();
  if (this.eat(types.braceL)) {
    this.expect(types.ellipsis);
    node.argument = this.parseMaybeAssign();
    this.expect(types.braceR);
    return this.finishNode(node, "JSXSpreadAttribute");
  }
  node.name = this.jsxParseNamespacedName();
  node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;
  return this.finishNode(node, "JSXAttribute");
};

// Parses JSX opening tag starting after "<".

pp$9.jsxParseOpeningElementAt = function (startPos, startLoc) {
  var node = this.startNodeAt(startPos, startLoc);
  node.attributes = [];
  node.name = this.jsxParseElementName();
  while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {
    node.attributes.push(this.jsxParseAttribute());
  }
  node.selfClosing = this.eat(types.slash);
  this.expect(types.jsxTagEnd);
  return this.finishNode(node, "JSXOpeningElement");
};

// Parses JSX closing tag starting after "</".

pp$9.jsxParseClosingElementAt = function (startPos, startLoc) {
  var node = this.startNodeAt(startPos, startLoc);
  node.name = this.jsxParseElementName();
  this.expect(types.jsxTagEnd);
  return this.finishNode(node, "JSXClosingElement");
};

// Parses entire JSX element, including it"s opening tag
// (starting after "<"), attributes, contents and closing tag.

pp$9.jsxParseElementAt = function (startPos, startLoc) {
  var node = this.startNodeAt(startPos, startLoc);
  var children = [];
  var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
  var closingElement = null;

  if (!openingElement.selfClosing) {
    contents: for (;;) {
      switch (this.state.type) {
        case types.jsxTagStart:
          startPos = this.state.start;startLoc = this.state.startLoc;
          this.next();
          if (this.eat(types.slash)) {
            closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
            break contents;
          }
          children.push(this.jsxParseElementAt(startPos, startLoc));
          break;

        case types.jsxText:
          children.push(this.parseExprAtom());
          break;

        case types.braceL:
          if (this.lookahead().type === types.ellipsis) {
            children.push(this.jsxParseSpreadChild());
          } else {
            children.push(this.jsxParseExpressionContainer());
          }

          break;

        // istanbul ignore next - should never happen
        default:
          this.unexpected();
      }
    }

    if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
      this.raise(closingElement.start, "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">");
    }
  }

  node.openingElement = openingElement;
  node.closingElement = closingElement;
  node.children = children;
  if (this.match(types.relational) && this.state.value === "<") {
    this.raise(this.state.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
  }
  return this.finishNode(node, "JSXElement");
};

// Parses entire JSX element from current position.

pp$9.jsxParseElement = function () {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  this.next();
  return this.jsxParseElementAt(startPos, startLoc);
};

var jsxPlugin = function (instance) {
  instance.extend("parseExprAtom", function (inner) {
    return function (refShortHandDefaultPos) {
      if (this.match(types.jsxText)) {
        var node = this.parseLiteral(this.state.value, "JSXText");
        // https://github.com/babel/babel/issues/2078
        node.extra = null;
        return node;
      } else if (this.match(types.jsxTagStart)) {
        return this.jsxParseElement();
      } else {
        return inner.call(this, refShortHandDefaultPos);
      }
    };
  });

  instance.extend("readToken", function (inner) {
    return function (code) {
      if (this.state.inPropertyName) return inner.call(this, code);

      var context = this.curContext();

      if (context === types$1.j_expr) {
        return this.jsxReadToken();
      }

      if (context === types$1.j_oTag || context === types$1.j_cTag) {
        if (isIdentifierStart(code)) {
          return this.jsxReadWord();
        }

        if (code === 62) {
          ++this.state.pos;
          return this.finishToken(types.jsxTagEnd);
        }

        if ((code === 34 || code === 39) && context === types$1.j_oTag) {
          return this.jsxReadString(code);
        }
      }

      if (code === 60 && this.state.exprAllowed) {
        ++this.state.pos;
        return this.finishToken(types.jsxTagStart);
      }

      return inner.call(this, code);
    };
  });

  instance.extend("updateContext", function (inner) {
    return function (prevType) {
      if (this.match(types.braceL)) {
        var curContext = this.curContext();
        if (curContext === types$1.j_oTag) {
          this.state.context.push(types$1.braceExpression);
        } else if (curContext === types$1.j_expr) {
          this.state.context.push(types$1.templateQuasi);
        } else {
          inner.call(this, prevType);
        }
        this.state.exprAllowed = true;
      } else if (this.match(types.slash) && prevType === types.jsxTagStart) {
        this.state.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore
        this.state.context.push(types$1.j_cTag); // reconsider as closing tag context
        this.state.exprAllowed = false;
      } else {
        return inner.call(this, prevType);
      }
    };
  });
};

plugins.estree = estreePlugin;
plugins.flow = flowPlugin;
plugins.jsx = jsxPlugin;

function parse(input, options) {
  return new Parser(options, input).parse();
}

function parseExpression(input, options) {
  var parser = new Parser(options, input);
  if (parser.options.strictMode) {
    parser.state.strict = true;
  }
  return parser.getExpression();
}

exports.parse = parse;
exports.parseExpression = parseExpression;
exports.tokTypes = types;

},{}],63:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],64:[function(require,module,exports){

},{}],65:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (value instanceof ArrayBuffer) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (isArrayBufferView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (isArrayBufferView(string) || string instanceof ArrayBuffer) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`
function isArrayBufferView (obj) {
  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":63,"ieee754":201}],66:[function(require,module,exports){
(function (process){
'use strict';
var escapeStringRegexp = require('escape-string-regexp');
var ansiStyles = require('ansi-styles');
var stripAnsi = require('strip-ansi');
var hasAnsi = require('has-ansi');
var supportsColor = require('supports-color');
var defineProps = Object.defineProperties;
var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);

function Chalk(options) {
	// detect mode if not set manually
	this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
}

// use bright blue on Windows as the normal blue color is illegible
if (isSimpleWindowsTerm) {
	ansiStyles.blue.open = '\u001b[94m';
}

var styles = (function () {
	var ret = {};

	Object.keys(ansiStyles).forEach(function (key) {
		ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

		ret[key] = {
			get: function () {
				return build.call(this, this._styles.concat(key));
			}
		};
	});

	return ret;
})();

var proto = defineProps(function chalk() {}, styles);

function build(_styles) {
	var builder = function () {
		return applyStyle.apply(builder, arguments);
	};

	builder._styles = _styles;
	builder.enabled = this.enabled;
	// __proto__ is used because we must return a function, but there is
	// no way to create a function with a different prototype.
	/* eslint-disable no-proto */
	builder.__proto__ = proto;

	return builder;
}

function applyStyle() {
	// support varags, but simply cast to string in case there's only one arg
	var args = arguments;
	var argsLen = args.length;
	var str = argsLen !== 0 && String(arguments[0]);

	if (argsLen > 1) {
		// don't slice `arguments`, it prevents v8 optimizations
		for (var a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!this.enabled || !str) {
		return str;
	}

	var nestedStyles = this._styles;
	var i = nestedStyles.length;

	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
	// see https://github.com/chalk/chalk/issues/58
	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
	var originalDim = ansiStyles.dim.open;
	if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
		ansiStyles.dim.open = '';
	}

	while (i--) {
		var code = ansiStyles[nestedStyles[i]];

		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;
	}

	// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
	ansiStyles.dim.open = originalDim;

	return str;
}

function init() {
	var ret = {};

	Object.keys(styles).forEach(function (name) {
		ret[name] = {
			get: function () {
				return build.call(this, [name]);
			}
		};
	});

	return ret;
}

defineProps(Chalk.prototype, init());

module.exports = new Chalk();
module.exports.styles = ansiStyles;
module.exports.hasColor = hasAnsi;
module.exports.stripColor = stripAnsi;
module.exports.supportsColor = supportsColor;

}).call(this,require('_process'))
},{"_process":367,"ansi-styles":4,"escape-string-regexp":191,"has-ansi":200,"strip-ansi":370,"supports-color":371}],67:[function(require,module,exports){
"use strict";
exports.__esModule = true;
/**
 * Represents a change in source code type at a particular index.
 */
var SourceLocation = (function () {
    function SourceLocation(type, index) {
        this.type = type;
        this.index = index;
    }
    return SourceLocation;
}());
exports["default"] = SourceLocation;

},{}],68:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var SourceToken = (function () {
    function SourceToken(type, start, end) {
        if (start > end) {
            throw new Error("Token start may not be after end. Got " + type + ", " + start + ", " + end);
        }
        this.type = type;
        this.start = start;
        this.end = end;
    }
    return SourceToken;
}());
exports["default"] = SourceToken;

},{}],69:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var SourceTokenListIndex_1 = require("./SourceTokenListIndex");
var SourceType_1 = require("./SourceType");
/**
 * Represents a list of tokens and provides various utility functions for
 * finding tokens within it.
 */
var SourceTokenList = (function () {
    function SourceTokenList(tokens) {
        this._validateTokens(tokens);
        this._tokens = tokens;
        this._indexCache = new Array(tokens.length);
        this.length = tokens.length;
        this.startIndex = this._getIndex(0);
        this.endIndex = this._getIndex(tokens.length);
        // Precompute sparse arrays to do source-to-token mappings later. Iterate
        // backwards through the tokens so that earlier tokens win ties.
        this._indexBySourceIndex = [];
        this._indexByStartSourceIndex = [];
        this._indexByEndSourceIndex = [];
        for (var tokenIndex = tokens.length - 1; tokenIndex >= 0; tokenIndex--) {
            var token = tokens[tokenIndex];
            for (var sourceIndex = token.start; sourceIndex < token.end; sourceIndex++) {
                this._indexBySourceIndex[sourceIndex] = this._getIndex(tokenIndex);
            }
            this._indexByStartSourceIndex[token.start] = this._getIndex(tokenIndex);
            this._indexByEndSourceIndex[token.end] = this._getIndex(tokenIndex);
        }
    }
    /**
     * Iterate over each token.
     */
    SourceTokenList.prototype.forEach = function (iterator) {
        var _this = this;
        this._tokens.forEach(function (token, i) { return iterator(token, _this._getIndex(i), _this); });
    };
    /**
     * Map each token to an element of an array.
     */
    SourceTokenList.prototype.map = function (mapper) {
        var result = [];
        this.forEach(function (token, index, list) { result.push(mapper(token, index, list)); });
        return result;
    };
    /**
     * Filter tokens by a predicate.
     */
    SourceTokenList.prototype.filter = function (predicate) {
        var result = [];
        this.forEach(function (token, index, list) {
            if (predicate(token, index, list)) {
                result.push(token);
            }
        });
        return new SourceTokenList(result);
    };
    /**
     * Get a slice of this token list using the given indexes.
     */
    SourceTokenList.prototype.slice = function (start, end) {
        if (start['_sourceTokenList'] !== this || end['_sourceTokenList'] !== this) {
            throw new Error('cannot slice a list using indexes from another list');
        }
        return new SourceTokenList(this._tokens.slice(start['_index'], end['_index']));
    };
    /**
     * Get the token at the given index, if it exists.
     *
     * NOTE: The only value for which this should return `null` is this list's
     * `endIndex`.
     */
    SourceTokenList.prototype.tokenAtIndex = function (index) {
        this._validateIndex(index);
        return this._tokens[index['_index']] || null;
    };
    /**
     * Get the range of tokens representing an interpolated string that contains
     * the token at `index`. This will return the innermost interpolated string in
     * the case of nesting.
     */
    SourceTokenList.prototype.rangeOfInterpolatedStringTokensContainingTokenIndex = function (index) {
        var bestRange = null;
        for (var _i = 0, _a = [
            [SourceType_1["default"].DSTRING_START, SourceType_1["default"].DSTRING_END], [SourceType_1["default"].TDSTRING_START, SourceType_1["default"].TDSTRING_END], [SourceType_1["default"].HEREGEXP_START, SourceType_1["default"].HEREGEXP_END]
        ]; _i < _a.length; _i++) {
            var _b = _a[_i], startType = _b[0], endType = _b[1];
            var range = this.rangeOfMatchingTokensContainingTokenIndex(startType, endType, index);
            if (bestRange === null || bestRange === undefined ||
                (range !== null && range !== undefined &&
                    range[0].distance(range[1]) < bestRange[0].distance(bestRange[1]))) {
                bestRange = range;
            }
        }
        return bestRange;
    };
    /**
     * Get the range of tokens starting with a token of type `startType` and
     * ending one past a token of type `endType`, ensuring that the tokens match.
     * That is, it ensures they are balanced and properly account for nesting.
     * This range will contain `index`. If no such range can be found, `null` is
     * returned.
     */
    SourceTokenList.prototype.rangeOfMatchingTokensContainingTokenIndex = function (startType, endType, index) {
        this._validateIndex(index);
        var token = this.tokenAtIndex(index);
        if (!token) {
            return null;
        }
        switch (token.type) {
            case startType:
                {
                    var level_1 = 0;
                    var start = index;
                    var endIndex = this.indexOfTokenMatchingPredicate(function (token) {
                        if (token.type === startType) {
                            level_1 += 1;
                        }
                        else if (token.type === endType) {
                            level_1 -= 1;
                            if (level_1 === 0) {
                                return true;
                            }
                        }
                        return false;
                    }, start);
                    if (!endIndex) {
                        return null;
                    }
                    else {
                        var rangeEnd = endIndex.next();
                        if (!rangeEnd) {
                            return null;
                        }
                        return [start, rangeEnd];
                    }
                }
            case endType:
                {
                    var level_2 = 0;
                    var endIndex = index;
                    var startIndex = this.lastIndexOfTokenMatchingPredicate(function (token) {
                        if (token.type === startType) {
                            level_2 -= 1;
                            if (level_2 === 0) {
                                return true;
                            }
                        }
                        else if (token.type === endType) {
                            level_2 += 1;
                        }
                        return false;
                    }, endIndex);
                    if (!startIndex) {
                        return null;
                    }
                    else {
                        var rangeEnd = endIndex.next();
                        if (!rangeEnd) {
                            return null;
                        }
                        else {
                            return [startIndex, rangeEnd];
                        }
                    }
                }
            default:
                {
                    var level_3 = 0;
                    var startIndex = this.lastIndexOfTokenMatchingPredicate(function (token) {
                        if (token.type === startType) {
                            if (level_3 === 0) {
                                return true;
                            }
                            level_3 -= 1;
                        }
                        else if (token.type === endType) {
                            level_3 += 1;
                        }
                        return false;
                    }, index);
                    if (!startIndex) {
                        return null;
                    }
                    else {
                        return this.rangeOfMatchingTokensContainingTokenIndex(startType, endType, startIndex);
                    }
                }
        }
    };
    /**
     * Finds the index of the token whose source range includes the given index.
     * If the given index does not correspond to the range of a token, returns
     * null.
     */
    SourceTokenList.prototype.indexOfTokenContainingSourceIndex = function (index) {
        this._validateSourceIndex(index);
        return this._indexBySourceIndex[index] || null;
    };
    /**
     * If the given source index lands on a token, return the index of that token.
     * Otherwise, return the index of the previous token in the source code, or
     * the first token if there is no previous token.
     */
    SourceTokenList.prototype.indexOfTokenNearSourceIndex = function (index) {
        this._validateSourceIndex(index);
        for (var searchIndex = index; searchIndex >= 0; searchIndex--) {
            var tokenIndex = this._indexBySourceIndex[searchIndex];
            if (tokenIndex) {
                return tokenIndex;
            }
        }
        return this.startIndex;
    };
    /**
     * Finds the index of the token whose source range starts at the given index.
     */
    SourceTokenList.prototype.indexOfTokenStartingAtSourceIndex = function (index) {
        this._validateSourceIndex(index);
        return this._indexByStartSourceIndex[index] || null;
    };
    /**
     * Finds the index of the token whose source range ends at the given index.
     */
    SourceTokenList.prototype.indexOfTokenEndingAtSourceIndex = function (index) {
        this._validateSourceIndex(index);
        return this._indexByEndSourceIndex[index] || null;
    };
    /**
     * Finds the index of the first token matching a predicate.
     */
    SourceTokenList.prototype.indexOfTokenMatchingPredicate = function (predicate, start, end) {
        if (start === void 0) { start = null; }
        if (end === void 0) { end = null; }
        if (!start) {
            start = this.startIndex;
        }
        if (!end) {
            end = this.endIndex;
        }
        this._validateIndex(start);
        this._validateIndex(end);
        for (var i = start; i && i !== end; i = i.next()) {
            var token = this.tokenAtIndex(i);
            if (!token) {
                break;
            }
            else if (predicate(token)) {
                return i;
            }
        }
        return null;
    };
    /**
     * Finds the index of the first token matching a predicate, traversing
     * backwards.
     */
    SourceTokenList.prototype.lastIndexOfTokenMatchingPredicate = function (predicate, start, end) {
        if (start === void 0) { start = null; }
        if (end === void 0) { end = null; }
        if (!start) {
            start = this.endIndex.previous();
            if (!start) {
                return null;
            }
        }
        this._validateIndex(start);
        if (end) {
            this._validateIndex(end);
        }
        var i = start;
        do {
            var token = this.tokenAtIndex(i);
            if (!token) {
                break;
            }
            else if (predicate(token)) {
                return i;
            }
            else if (i) {
                i = i.previous();
            }
        } while (i && i !== end);
        return null;
    };
    /**
     * Allow iterating over the tokens in this list using e.g. `for (… of …)`.
     */
    SourceTokenList.prototype[Symbol.iterator] = function () {
        var _this = this;
        var index = this.startIndex;
        var endIndex = this.endIndex;
        return function () {
            if (index === endIndex) {
                return { done: true, value: undefined };
            }
            else {
                var result = { done: false, value: _this.tokenAtIndex(index) };
                var nextIndex = index.next();
                if (!nextIndex) {
                    throw new Error("unexpected null index before the end index");
                }
                index = nextIndex;
                return result;
            }
        };
    };
    /**
     * @internal
     */
    SourceTokenList.prototype._validateTokens = function (tokens) {
        for (var i = 0; i < tokens.length - 1; i++) {
            if (tokens[i].end > tokens[i + 1].start) {
                throw new Error("Tokens not in order. Expected " + JSON.stringify(tokens[i]) + " before " +
                    ("" + JSON.stringify(tokens[i + 1])));
            }
        }
    };
    /**
     * @internal
     */
    SourceTokenList.prototype._validateIndex = function (index) {
        if (!index) {
            throw new Error("unexpected 'null' index, perhaps you forgot to check the result of " +
                "'indexOfTokenContainingSourceIndex'?");
        }
        if (typeof index === 'number') {
            throw new Error("to get a token at index " + index + ", " +
                ("use list.tokenAtIndex(list.startIndex.advance(" + index + "))"));
        }
        if (index['_sourceTokenList'] !== this) {
            throw new Error('cannot get token in one list using an index from another');
        }
    };
    /**
     * @internal
     */
    SourceTokenList.prototype._validateSourceIndex = function (index) {
        if (typeof index !== 'number') {
            throw new Error("expected source index to be a number, got: " + index);
        }
    };
    /**
     * @internal
     */
    SourceTokenList.prototype._getIndex = function (index) {
        var cached = this._indexCache[index];
        if (!cached) {
            cached = new SourceTokenListIndex_1["default"](this, index);
            this._indexCache[index] = cached;
        }
        return cached;
    };
    /**
     * Get the list of tokens.
     */
    SourceTokenList.prototype.toArray = function () {
        return this._tokens.slice();
    };
    return SourceTokenList;
}());
exports["default"] = SourceTokenList;

},{"./SourceTokenListIndex":70,"./SourceType":71}],70:[function(require,module,exports){
"use strict";
exports.__esModule = true;
/**
 * Represents a token at a particular index within a list of tokens.
 */
var SourceTokenListIndex = (function () {
    function SourceTokenListIndex(sourceTokenList, index) {
        this._sourceTokenList = sourceTokenList;
        this._index = index;
    }
    /**
     * Get a new index offset from this one, if the resulting offset is within
     * the list range.
     */
    SourceTokenListIndex.prototype.advance = function (offset) {
        var newIndex = this._index + offset;
        if (newIndex < 0 || this._sourceTokenList.length < newIndex) {
            return null;
        }
        return this._sourceTokenList['_getIndex'](newIndex);
    };
    /**
     * Get the index of the token after this one, if it's not the last one.
     */
    SourceTokenListIndex.prototype.next = function () {
        return this.advance(1);
    };
    /**
     * Get the index of the token before this one, if it's not the first one.
     */
    SourceTokenListIndex.prototype.previous = function () {
        return this.advance(-1);
    };
    /**
     * Determines whether this index comes before another.
     */
    SourceTokenListIndex.prototype.isBefore = function (other) {
        return this.compare(other) > 0;
    };
    /**
     * Determines whether this index comes after another.
     */
    SourceTokenListIndex.prototype.isAfter = function (other) {
        return this.compare(other) < 0;
    };
    /**
     * Compare this index to another, returning 0 for equality, a negative number
     * if this is less than `other`, and a positive number otherwise.
     */
    SourceTokenListIndex.prototype.compare = function (other) {
        return this.distance(other);
    };
    /**
     * Returns an int of the relative distance between this index and the other
     * index (positive if the other one is later, negative if the other one is
     * earlier).
     */
    SourceTokenListIndex.prototype.distance = function (other) {
        if (other._sourceTokenList !== this._sourceTokenList) {
            throw new Error('cannot compare indexes from different lists');
        }
        return other._index - this._index;
    };
    return SourceTokenListIndex;
}());
exports["default"] = SourceTokenListIndex;

},{}],71:[function(require,module,exports){
"use strict";
exports.__esModule = true;
/**
 * Represents a particular type of CoffeeScript code.
 */
var SourceType;
(function (SourceType) {
    SourceType[SourceType["AT"] = 1] = "AT";
    SourceType[SourceType["BOOL"] = 2] = "BOOL";
    SourceType[SourceType["BREAK"] = 3] = "BREAK";
    SourceType[SourceType["CATCH"] = 4] = "CATCH";
    SourceType[SourceType["CALL_END"] = 5] = "CALL_END";
    SourceType[SourceType["CALL_START"] = 6] = "CALL_START";
    SourceType[SourceType["CLASS"] = 7] = "CLASS";
    SourceType[SourceType["COLON"] = 8] = "COLON";
    SourceType[SourceType["COMMA"] = 9] = "COMMA";
    SourceType[SourceType["COMMENT"] = 10] = "COMMENT";
    SourceType[SourceType["CONTINUATION"] = 11] = "CONTINUATION";
    SourceType[SourceType["CONTINUE"] = 12] = "CONTINUE";
    SourceType[SourceType["DELETE"] = 13] = "DELETE";
    SourceType[SourceType["DO"] = 14] = "DO";
    SourceType[SourceType["DOT"] = 15] = "DOT";
    SourceType[SourceType["DSTRING_START"] = 16] = "DSTRING_START";
    SourceType[SourceType["DSTRING_END"] = 17] = "DSTRING_END";
    SourceType[SourceType["ELSE"] = 18] = "ELSE";
    SourceType[SourceType["EOF"] = 19] = "EOF";
    SourceType[SourceType["EXISTENCE"] = 20] = "EXISTENCE";
    SourceType[SourceType["FINALLY"] = 21] = "FINALLY";
    SourceType[SourceType["FOR"] = 22] = "FOR";
    SourceType[SourceType["FUNCTION"] = 23] = "FUNCTION";
    SourceType[SourceType["HERECOMMENT"] = 24] = "HERECOMMENT";
    SourceType[SourceType["HEREGEXP_START"] = 25] = "HEREGEXP_START";
    SourceType[SourceType["HEREGEXP_END"] = 26] = "HEREGEXP_END";
    SourceType[SourceType["IF"] = 27] = "IF";
    SourceType[SourceType["INTERPOLATION_START"] = 28] = "INTERPOLATION_START";
    SourceType[SourceType["INTERPOLATION_END"] = 29] = "INTERPOLATION_END";
    SourceType[SourceType["JS"] = 30] = "JS";
    SourceType[SourceType["LBRACE"] = 31] = "LBRACE";
    SourceType[SourceType["LBRACKET"] = 32] = "LBRACKET";
    SourceType[SourceType["LOOP"] = 33] = "LOOP";
    SourceType[SourceType["LPAREN"] = 34] = "LPAREN";
    SourceType[SourceType["NEWLINE"] = 35] = "NEWLINE";
    SourceType[SourceType["NORMAL"] = 36] = "NORMAL";
    SourceType[SourceType["NULL"] = 37] = "NULL";
    SourceType[SourceType["NUMBER"] = 38] = "NUMBER";
    SourceType[SourceType["OPERATOR"] = 39] = "OPERATOR";
    SourceType[SourceType["OWN"] = 40] = "OWN";
    SourceType[SourceType["PROTO"] = 41] = "PROTO";
    SourceType[SourceType["RANGE"] = 42] = "RANGE";
    SourceType[SourceType["REGEXP"] = 43] = "REGEXP";
    SourceType[SourceType["RBRACE"] = 44] = "RBRACE";
    SourceType[SourceType["RBRACKET"] = 45] = "RBRACKET";
    SourceType[SourceType["RELATION"] = 46] = "RELATION";
    SourceType[SourceType["RETURN"] = 47] = "RETURN";
    SourceType[SourceType["RPAREN"] = 48] = "RPAREN";
    SourceType[SourceType["SEMICOLON"] = 49] = "SEMICOLON";
    SourceType[SourceType["SPACE"] = 50] = "SPACE";
    SourceType[SourceType["SUPER"] = 51] = "SUPER";
    SourceType[SourceType["SWITCH"] = 52] = "SWITCH";
    SourceType[SourceType["SSTRING_START"] = 53] = "SSTRING_START";
    SourceType[SourceType["SSTRING_END"] = 54] = "SSTRING_END";
    SourceType[SourceType["STRING_CONTENT"] = 55] = "STRING_CONTENT";
    SourceType[SourceType["STRING_LINE_SEPARATOR"] = 56] = "STRING_LINE_SEPARATOR";
    SourceType[SourceType["STRING_PADDING"] = 57] = "STRING_PADDING";
    SourceType[SourceType["TDSTRING_START"] = 58] = "TDSTRING_START";
    SourceType[SourceType["TDSTRING_END"] = 59] = "TDSTRING_END";
    SourceType[SourceType["THEN"] = 60] = "THEN";
    SourceType[SourceType["THIS"] = 61] = "THIS";
    SourceType[SourceType["TRY"] = 62] = "TRY";
    SourceType[SourceType["TSSTRING_START"] = 63] = "TSSTRING_START";
    SourceType[SourceType["TSSTRING_END"] = 64] = "TSSTRING_END";
    SourceType[SourceType["UNDEFINED"] = 65] = "UNDEFINED";
    SourceType[SourceType["UNKNOWN"] = 66] = "UNKNOWN";
    SourceType[SourceType["WHEN"] = 67] = "WHEN";
    SourceType[SourceType["WHILE"] = 68] = "WHILE";
    SourceType[SourceType["IDENTIFIER"] = 69] = "IDENTIFIER";
    SourceType[SourceType["YIELD"] = 70] = "YIELD";
    SourceType[SourceType["YIELDFROM"] = 71] = "YIELDFROM";
    SourceType[SourceType["INCREMENT"] = 72] = "INCREMENT";
    SourceType[SourceType["DECREMENT"] = 73] = "DECREMENT";
    SourceType[SourceType["NEW"] = 74] = "NEW";
})(SourceType || (SourceType = {}));
exports["default"] = SourceType;

},{}],72:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var SourceLocation_1 = require("./SourceLocation");
var SourceToken_1 = require("./SourceToken");
var SourceTokenList_1 = require("./SourceTokenList");
var SourceType_1 = require("./SourceType");
exports.SourceType = SourceType_1["default"];
var BufferedStream_1 = require("./utils/BufferedStream");
var calculateHeregexpPadding_1 = require("./utils/calculateHeregexpPadding");
var calculateNormalStringPadding_1 = require("./utils/calculateNormalStringPadding");
var calculateTripleQuotedStringPadding_1 = require("./utils/calculateTripleQuotedStringPadding");
/**
 * Generate a list of tokens from CoffeeScript source code.
 */
function lex(source) {
    var location;
    var previousLocation;
    var tokens = [];
    var pending = new BufferedStream_1["default"](stream(source));
    do {
        pending.unshift.apply(pending, calculateNormalStringPadding_1["default"](source, pending));
        pending.unshift.apply(pending, calculateTripleQuotedStringPadding_1["default"](source, pending));
        pending.unshift.apply(pending, calculateHeregexpPadding_1["default"](source, pending));
        pending.unshift.apply(pending, combinedLocationsForMultiwordOperators(pending, source));
        location = pending.shift();
        if (previousLocation && previousLocation.type !== SourceType_1["default"].SPACE) {
            tokens.push(new SourceToken_1["default"](previousLocation.type, previousLocation.index, location.index));
        }
        previousLocation = location;
    } while (location.type !== SourceType_1["default"].EOF);
    return new SourceTokenList_1["default"](tokens);
}
exports["default"] = lex;
function combinedLocationsForMultiwordOperators(stream, source) {
    if (!stream.hasNext(SourceType_1["default"].OPERATOR, SourceType_1["default"].SPACE, SourceType_1["default"].OPERATOR) && !stream.hasNext(SourceType_1["default"].OPERATOR, SourceType_1["default"].SPACE, SourceType_1["default"].RELATION)) {
        return [];
    }
    var not = stream.shift();
    var space = stream.shift();
    var operator = stream.shift();
    var next = stream.peek();
    if (source.slice(not.index, space.index) === 'not') {
        var op = source.slice(operator.index, next.index);
        switch (op) {
            case 'in':
            case 'of':
                return [
                    new SourceLocation_1["default"](SourceType_1["default"].RELATION, not.index)
                ];
            case 'instanceof':
                return [
                    new SourceLocation_1["default"](SourceType_1["default"].OPERATOR, not.index)
                ];
        }
    }
    // Doesn't match, so put them back.
    return [not, space, operator];
}
var REGEXP_FLAGS = ['i', 'g', 'm', 'y'];
/**
 * Borrowed, with tweaks, from CoffeeScript's lexer.coffee.
 */
var STRING = [SourceType_1["default"].SSTRING_END, SourceType_1["default"].DSTRING_END, SourceType_1["default"].TSSTRING_END, SourceType_1["default"].TDSTRING_END];
var CALLABLE = [
    SourceType_1["default"].IDENTIFIER, SourceType_1["default"].CALL_END, SourceType_1["default"].RPAREN, SourceType_1["default"].RBRACKET, SourceType_1["default"].EXISTENCE, SourceType_1["default"].AT, SourceType_1["default"].THIS, SourceType_1["default"].SUPER
];
var INDEXABLE = CALLABLE.concat([
    SourceType_1["default"].NUMBER
].concat(STRING, [
    SourceType_1["default"].REGEXP, SourceType_1["default"].HEREGEXP_END,
    SourceType_1["default"].BOOL, SourceType_1["default"].NULL, SourceType_1["default"].UNDEFINED, SourceType_1["default"].RBRACE, SourceType_1["default"].PROTO
]));
var NOT_REGEXP = INDEXABLE.concat([SourceType_1["default"].INCREMENT, SourceType_1["default"].DECREMENT]);
var IDENTIFIER_PATTERN = /^(?!\d)((?:(?!\s)[$\w\x7f-\uffff])+)/;
var NUMBER_PATTERN = /^0b[01]+|^0o[0-7]+|^0x[\da-f]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;
var SPACE_PATTERN = /^[^\n\r\S]+/;
var REGEXP_PATTERN = /^\/(?!\/)((?:[^[\/\n\\]|\\[^\n]|\[(?:\\[^\n]|[^\]\n\\])*\])*)(\/)?/;
var YIELDFROM_PATTERN = /^yield[^\n\r\S]+from/;
var OPERATORS = [
    // equality
    '===', '==', '!==', '!=',
    // assignment
    '=',
    '+=', '-=', '/=', '*=', '%=', '%%=',
    '||=', '&&=', '^=', 'or=', 'and=',
    '?=',
    '|=', '&=', '~=', '<<=', '>>>=', '>>=',
    // increment/decrement
    '++', '--',
    // math
    '+', '-', '//', '/', '*', '%', '%%',
    // logical
    '||', '&&', '^', '!',
    // existence
    '?',
    // bitwise
    '|', '&', '~', '<<', '>>>', '>>',
    // comparison
    '<=', '<', '>=', '>',
    // prototype access
    '::',
];
/**
 * Provides a stream of source type change locations.
 */
function stream(source, index) {
    if (index === void 0) { index = 0; }
    var location = new SourceLocation_1["default"](SourceType_1["default"].NORMAL, index);
    var interpolationStack = [];
    var braceStack = [];
    var parenStack = [];
    var stringStack = [];
    var start = index;
    var locations = [];
    return function step() {
        var lastLocation = location;
        var shouldStepAgain = false;
        do {
            start = index;
            if (index >= source.length) {
                setType(SourceType_1["default"].EOF);
            }
            switch (location.type) {
                case SourceType_1["default"].NORMAL:
                case SourceType_1["default"].SPACE:
                case SourceType_1["default"].IDENTIFIER:
                case SourceType_1["default"].DOT:
                case SourceType_1["default"].NUMBER:
                case SourceType_1["default"].OPERATOR:
                case SourceType_1["default"].INCREMENT:
                case SourceType_1["default"].DECREMENT:
                case SourceType_1["default"].COMMA:
                case SourceType_1["default"].LPAREN:
                case SourceType_1["default"].RPAREN:
                case SourceType_1["default"].CALL_START:
                case SourceType_1["default"].CALL_END:
                case SourceType_1["default"].NEW:
                case SourceType_1["default"].LBRACE:
                case SourceType_1["default"].RBRACE:
                case SourceType_1["default"].LBRACKET:
                case SourceType_1["default"].RBRACKET:
                case SourceType_1["default"].NEWLINE:
                case SourceType_1["default"].COLON:
                case SourceType_1["default"].FUNCTION:
                case SourceType_1["default"].THIS:
                case SourceType_1["default"].AT:
                case SourceType_1["default"].SEMICOLON:
                case SourceType_1["default"].IF:
                case SourceType_1["default"].ELSE:
                case SourceType_1["default"].THEN:
                case SourceType_1["default"].FOR:
                case SourceType_1["default"].OWN:
                case SourceType_1["default"].WHILE:
                case SourceType_1["default"].BOOL:
                case SourceType_1["default"].NULL:
                case SourceType_1["default"].UNDEFINED:
                case SourceType_1["default"].REGEXP:
                case SourceType_1["default"].SSTRING_END:
                case SourceType_1["default"].DSTRING_END:
                case SourceType_1["default"].TSSTRING_END:
                case SourceType_1["default"].TDSTRING_END:
                case SourceType_1["default"].INTERPOLATION_START:
                case SourceType_1["default"].SUPER:
                case SourceType_1["default"].TRY:
                case SourceType_1["default"].CATCH:
                case SourceType_1["default"].FINALLY:
                case SourceType_1["default"].SWITCH:
                case SourceType_1["default"].WHEN:
                case SourceType_1["default"].BREAK:
                case SourceType_1["default"].CONTINUE:
                case SourceType_1["default"].EXISTENCE:
                case SourceType_1["default"].CLASS:
                case SourceType_1["default"].PROTO:
                case SourceType_1["default"].RANGE:
                case SourceType_1["default"].DELETE:
                case SourceType_1["default"].RETURN:
                case SourceType_1["default"].RELATION:
                case SourceType_1["default"].LOOP:
                case SourceType_1["default"].DO:
                case SourceType_1["default"].YIELD:
                case SourceType_1["default"].YIELDFROM:
                case SourceType_1["default"].CONTINUATION:
                    if (consume(SPACE_PATTERN)) {
                        setType(SourceType_1["default"].SPACE);
                    }
                    else if (consume('\n')) {
                        setType(SourceType_1["default"].NEWLINE);
                    }
                    else if (consume('...') || consume('..')) {
                        setType(SourceType_1["default"].RANGE);
                    }
                    else if (consume(NUMBER_PATTERN)) {
                        setType(SourceType_1["default"].NUMBER);
                    }
                    else if (consume('.')) {
                        setType(SourceType_1["default"].DOT);
                    }
                    else if (consume('"""')) {
                        stringStack.push({
                            allowInterpolations: true,
                            endingDelimiter: '"""',
                            endSourceType: SourceType_1["default"].TDSTRING_END
                        });
                        setType(SourceType_1["default"].TDSTRING_START);
                    }
                    else if (consume('"')) {
                        stringStack.push({
                            allowInterpolations: true,
                            endingDelimiter: '"',
                            endSourceType: SourceType_1["default"].DSTRING_END
                        });
                        setType(SourceType_1["default"].DSTRING_START);
                    }
                    else if (consume('\'\'\'')) {
                        stringStack.push({
                            allowInterpolations: false,
                            endingDelimiter: '\'\'\'',
                            endSourceType: SourceType_1["default"].TSSTRING_END
                        });
                        setType(SourceType_1["default"].TSSTRING_START);
                    }
                    else if (consume('\'')) {
                        stringStack.push({
                            allowInterpolations: false,
                            endingDelimiter: '\'',
                            endSourceType: SourceType_1["default"].SSTRING_END
                        });
                        setType(SourceType_1["default"].SSTRING_START);
                    }
                    else if (consume(/^###[^#]/)) {
                        setType(SourceType_1["default"].HERECOMMENT);
                    }
                    else if (consume('#')) {
                        setType(SourceType_1["default"].COMMENT);
                    }
                    else if (consume('///')) {
                        stringStack.push({
                            allowInterpolations: true,
                            endingDelimiter: '///',
                            endSourceType: SourceType_1["default"].HEREGEXP_END
                        });
                        setType(SourceType_1["default"].HEREGEXP_START);
                    }
                    else if (consume('(')) {
                        if (CALLABLE.indexOf(location.type) >= 0) {
                            parenStack.push(SourceType_1["default"].CALL_START);
                            setType(SourceType_1["default"].CALL_START);
                        }
                        else {
                            parenStack.push(SourceType_1["default"].LPAREN);
                            setType(SourceType_1["default"].LPAREN);
                        }
                    }
                    else if (consume(')')) {
                        if (parenStack.length === 0) {
                            throw new Error("unexpected ')' at " + start);
                        }
                        else {
                            var lparen = parenStack.pop();
                            switch (lparen) {
                                case SourceType_1["default"].LPAREN:
                                    setType(SourceType_1["default"].RPAREN);
                                    break;
                                case SourceType_1["default"].CALL_START:
                                    setType(SourceType_1["default"].CALL_END);
                                    break;
                                default:
                                    throw new Error("unexpected token type for '(' matching ')' at " + start + ": " + (lparen ? lparen.toString() : '??'));
                            }
                        }
                    }
                    else if (consume('[')) {
                        setType(SourceType_1["default"].LBRACKET);
                    }
                    else if (consume(']')) {
                        setType(SourceType_1["default"].RBRACKET);
                    }
                    else if (consume('{')) {
                        braceStack.push(start);
                        setType(SourceType_1["default"].LBRACE);
                    }
                    else if (consume('}')) {
                        if (braceStack.length === 0) {
                            popInterpolation();
                        }
                        else {
                            braceStack.pop();
                            setType(SourceType_1["default"].RBRACE);
                        }
                    }
                    else if (consumeAny(['->', '=>'])) {
                        setType(SourceType_1["default"].FUNCTION);
                    }
                    else if (consumeRegexp()) {
                        setType(SourceType_1["default"].REGEXP);
                    }
                    else if (consume('::')) {
                        setType(SourceType_1["default"].PROTO);
                    }
                    else if (consume(':')) {
                        setType(SourceType_1["default"].COLON);
                    }
                    else if (consume(',')) {
                        setType(SourceType_1["default"].COMMA);
                    }
                    else if (consume('@')) {
                        setType(SourceType_1["default"].AT);
                    }
                    else if (consume(';')) {
                        setType(SourceType_1["default"].SEMICOLON);
                    }
                    else if (consume('`')) {
                        setType(SourceType_1["default"].JS);
                    }
                    else if (consumeAny(OPERATORS)) {
                        if (consumed() === '?') {
                            setType(SourceType_1["default"].EXISTENCE);
                        }
                        else if (consumed() === '++') {
                            setType(SourceType_1["default"].INCREMENT);
                        }
                        else if (consumed() === '--') {
                            setType(SourceType_1["default"].DECREMENT);
                        }
                        else {
                            setType(SourceType_1["default"].OPERATOR);
                        }
                    }
                    else if (consume(YIELDFROM_PATTERN)) {
                        setType(SourceType_1["default"].YIELDFROM);
                    }
                    else if (consume(IDENTIFIER_PATTERN)) {
                        var prevLocationIndex = locations.length - 1;
                        while (prevLocationIndex > 0 && locations[prevLocationIndex].type === SourceType_1["default"].NEWLINE) {
                            prevLocationIndex--;
                        }
                        var prev = locations[prevLocationIndex];
                        var nextIsColon = match(/^\s*:/);
                        if (nextIsColon || (prev && (prev.type === SourceType_1["default"].DOT || prev.type === SourceType_1["default"].PROTO || prev.type === SourceType_1["default"].AT))) {
                            setType(SourceType_1["default"].IDENTIFIER);
                        }
                        else {
                            switch (consumed()) {
                                case 'if':
                                case 'unless':
                                    setType(SourceType_1["default"].IF);
                                    break;
                                case 'else':
                                    setType(SourceType_1["default"].ELSE);
                                    break;
                                case 'return':
                                    setType(SourceType_1["default"].RETURN);
                                    break;
                                case 'for':
                                    setType(SourceType_1["default"].FOR);
                                    break;
                                case 'own':
                                    setType(SourceType_1["default"].OWN);
                                    break;
                                case 'while':
                                case 'until':
                                    setType(SourceType_1["default"].WHILE);
                                    break;
                                case 'loop':
                                    setType(SourceType_1["default"].LOOP);
                                    break;
                                case 'then':
                                    setType(SourceType_1["default"].THEN);
                                    break;
                                case 'switch':
                                    setType(SourceType_1["default"].SWITCH);
                                    break;
                                case 'when':
                                    setType(SourceType_1["default"].WHEN);
                                    break;
                                case 'null':
                                    setType(SourceType_1["default"].NULL);
                                    break;
                                case 'undefined':
                                    setType(SourceType_1["default"].UNDEFINED);
                                    break;
                                case 'this':
                                    setType(SourceType_1["default"].THIS);
                                    break;
                                case 'new':
                                    setType(SourceType_1["default"].NEW);
                                    break;
                                case 'super':
                                    setType(SourceType_1["default"].SUPER);
                                    break;
                                case 'true':
                                case 'false':
                                case 'yes':
                                case 'no':
                                case 'on':
                                case 'off':
                                    setType(SourceType_1["default"].BOOL);
                                    break;
                                case 'and':
                                case 'or':
                                case 'not':
                                case 'is':
                                case 'isnt':
                                case 'instanceof':
                                    setType(SourceType_1["default"].OPERATOR);
                                    break;
                                case 'class':
                                    setType(SourceType_1["default"].CLASS);
                                    break;
                                case 'break':
                                    setType(SourceType_1["default"].BREAK);
                                    break;
                                case 'continue':
                                    setType(SourceType_1["default"].CONTINUE);
                                    break;
                                case 'try':
                                    setType(SourceType_1["default"].TRY);
                                    break;
                                case 'catch':
                                    setType(SourceType_1["default"].CATCH);
                                    break;
                                case 'finally':
                                    setType(SourceType_1["default"].FINALLY);
                                    break;
                                case 'delete':
                                    setType(SourceType_1["default"].DELETE);
                                    break;
                                case 'in':
                                case 'of':
                                    setType(SourceType_1["default"].RELATION);
                                    break;
                                case 'do':
                                    setType(SourceType_1["default"].DO);
                                    break;
                                case 'yield':
                                    setType(SourceType_1["default"].YIELD);
                                    break;
                                default:
                                    setType(SourceType_1["default"].IDENTIFIER);
                            }
                        }
                    }
                    else if (consume('\\')) {
                        setType(SourceType_1["default"].CONTINUATION);
                    }
                    else {
                        setType(SourceType_1["default"].UNKNOWN);
                    }
                    break;
                case SourceType_1["default"].SSTRING_START:
                case SourceType_1["default"].DSTRING_START:
                case SourceType_1["default"].TSSTRING_START:
                case SourceType_1["default"].TDSTRING_START:
                case SourceType_1["default"].HEREGEXP_START:
                    setType(SourceType_1["default"].STRING_CONTENT);
                    break;
                case SourceType_1["default"].STRING_CONTENT: {
                    var stringOptions = stringStack[stringStack.length - 1];
                    if (!stringOptions) {
                        throw new Error('Unexpected STRING_CONTENT without anything on the string stack.');
                    }
                    if (consume('\\')) {
                        index++;
                    }
                    else if (consume(stringOptions.endingDelimiter)) {
                        stringStack.pop();
                        setType(stringOptions.endSourceType);
                    }
                    else if (stringOptions.allowInterpolations && consume('#{')) {
                        pushInterpolation();
                    }
                    else {
                        index++;
                    }
                    break;
                }
                case SourceType_1["default"].COMMENT:
                    if (consume('\n')) {
                        setType(SourceType_1["default"].NEWLINE);
                    }
                    else {
                        index++;
                    }
                    break;
                case SourceType_1["default"].HERECOMMENT:
                    if (consume('###')) {
                        setType(SourceType_1["default"].NORMAL);
                    }
                    else {
                        index++;
                    }
                    break;
                case SourceType_1["default"].INTERPOLATION_END:
                    var lastInterpolation = interpolationStack.pop();
                    if (!lastInterpolation) {
                        throw new Error("found interpolation end without any interpolation start");
                    }
                    var type = lastInterpolation.type, braces = lastInterpolation.braces;
                    setType(type);
                    braceStack = braces;
                    break;
                case SourceType_1["default"].HEREGEXP_END:
                    while (consumeAny(REGEXP_FLAGS)) {
                        // condition has side-effect
                    }
                    setType(SourceType_1["default"].NORMAL);
                    break;
                case SourceType_1["default"].JS:
                    if (consume('\\')) {
                        index++;
                    }
                    else if (consume('`')) {
                        setType(SourceType_1["default"].NORMAL);
                    }
                    else {
                        index++;
                    }
                    break;
                case SourceType_1["default"].EOF:
                    if (braceStack.length !== 0) {
                        throw new Error("unexpected EOF while looking for '}' to match '{' " +
                            ("at " + braceStack[braceStack.length - 1]));
                    }
                    if (stringStack.length !== 0) {
                        throw new Error('unexpected EOF while parsing a string');
                    }
                    break;
                case SourceType_1["default"].UNKNOWN:
                    // Jump to the end.
                    index = source.length;
                    break;
                default:
                    throw new Error("unknown source type at offset " + location.index + ": " + SourceType_1["default"][location.type]);
            }
            shouldStepAgain = (
            // Don't report on going back to "normal" source code.
            location.type === SourceType_1["default"].NORMAL ||
                // Don't report if nothing has changed, unless we're at the end.
                (location === lastLocation &&
                    location.type !== SourceType_1["default"].EOF));
        } while (shouldStepAgain);
        locations.push(location);
        return location;
    };
    function consumeAny(strings) {
        return strings.some(function (string) { return consume(string); });
    }
    function consume(value) {
        var matchData = match(value);
        if (matchData) {
            index += matchData[0].length;
            return true;
        }
        else {
            return false;
        }
    }
    function consumeRegexp() {
        var matchData = match(REGEXP_PATTERN);
        if (!matchData) {
            return false;
        }
        var regex = matchData[0], closed = matchData[2];
        var prev = locations[locations.length - 1];
        if (prev) {
            var spaced = false;
            if (prev.type === SourceType_1["default"].SPACE) {
                spaced = true;
                prev = locations[locations.length - 2];
            }
            if (spaced && CALLABLE.indexOf(prev.type) >= 0) {
                if (!closed || /^\/=?\s/.test(regex)) {
                    return false;
                }
            }
            else if (NOT_REGEXP.indexOf(prev.type) >= 0) {
                return false;
            }
        }
        if (!closed) {
            throw new Error('missing / (unclosed regex)');
        }
        index += regex.length;
        while (consumeAny(REGEXP_FLAGS)) {
            // condition has side-effect
        }
        return true;
    }
    function consumed() {
        return source.slice(start, index);
    }
    function setType(newType) {
        location = new SourceLocation_1["default"](newType, start);
    }
    function match(value) {
        if (typeof value === 'string') {
            var matches = source.slice(index, index + value.length) === value;
            return matches ? [value] : null;
        }
        else {
            return source.slice(index).match(value);
        }
    }
    function pushInterpolation() {
        interpolationStack.push({ type: location.type, braces: braceStack });
        setType(SourceType_1["default"].INTERPOLATION_START);
        braceStack = [];
    }
    function popInterpolation() {
        if (interpolationStack.length === 0) {
            throw new Error("unexpected '}' found in string at " + index + ": " + JSON.stringify(source));
        }
        setType(SourceType_1["default"].INTERPOLATION_END);
    }
}
exports.stream = stream;
function consumeStream(lexer) {
    var result = [];
    var location;
    do {
        location = lexer();
        result.push(location);
    } while (location.type !== SourceType_1["default"].EOF);
    return result;
}
exports.consumeStream = consumeStream;

},{"./SourceLocation":67,"./SourceToken":68,"./SourceTokenList":69,"./SourceType":71,"./utils/BufferedStream":73,"./utils/calculateHeregexpPadding":75,"./utils/calculateNormalStringPadding":76,"./utils/calculateTripleQuotedStringPadding":77}],73:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var BufferedStream = (function () {
    function BufferedStream(stream) {
        this.pending = [];
        this._getNextLocation = stream;
    }
    BufferedStream.prototype.shift = function () {
        return this.pending.shift() || this._getNextLocation();
    };
    BufferedStream.prototype.hasNext = function () {
        var _this = this;
        var types = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            types[_i] = arguments[_i];
        }
        var locationsToPutBack = [];
        var result = types.every(function (type) {
            var next = _this.shift();
            locationsToPutBack.push(next);
            return next.type === type;
        });
        this.unshift.apply(this, locationsToPutBack);
        return result;
    };
    BufferedStream.prototype.peek = function () {
        var result = this.shift();
        this.unshift(result);
        return result;
    };
    BufferedStream.prototype.unshift = function () {
        var tokens = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            tokens[_i] = arguments[_i];
        }
        (_a = this.pending).unshift.apply(_a, tokens);
        var _a;
    };
    return BufferedStream;
}());
exports["default"] = BufferedStream;

},{}],74:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var SourceLocation_1 = require("../SourceLocation");
var SourceType_1 = require("../SourceType");
/**
 * Helper class for defining the padding (characters to remove, typically
 * whitespace) in a string or heregexp. Also tracks "line separators", which are
 * newline characters in multiline single and double quoted strings that should
 * be turned into space characters.
 *
 * Example usage:
 *
 * let paddingTracker = new PaddingTracker(source, stream, SSTRING_END);
 *
 * // Examine underlying code to see what padding to add.
 * paddingTracker.fragments[0].content;
 *
 * // Mark padding for each fragment, indexed relative to the fragment content.
 * paddingTracker.fragments[0].markPadding(3, 5);
 * paddingTracker.fragments[1].markPadding(1, 4);
 * paddingTracker.fragments[1].markLineSeparator(5);
 *
 * // Compute the replacement source locations for the entire string/heregexp.
 * paddingTracker.computeSourceLocations();
 */
var PaddingTracker = (function () {
    function PaddingTracker(source, stream, endType) {
        this.fragments = [];
        this._originalLocations = [];
        var interpolationLevel = 0;
        var location;
        do {
            location = stream.shift();
            this._originalLocations.push(location);
            if (interpolationLevel === 0 && location.type === SourceType_1["default"].STRING_CONTENT) {
                var start = location.index;
                var end = stream.peek().index;
                var content = source.slice(start, end);
                var index = this.fragments.length;
                this.fragments.push(new TrackedFragment(content, start, end, index));
            }
            else if (location.type === SourceType_1["default"].INTERPOLATION_START) {
                interpolationLevel += 1;
            }
            else if (location.type === SourceType_1["default"].INTERPOLATION_END) {
                interpolationLevel -= 1;
            }
        } while (interpolationLevel > 0 || location.type !== endType);
    }
    PaddingTracker.prototype.computeSourceLocations = function () {
        var resultLocations = [];
        var rangeIndex = 0;
        for (var _i = 0, _a = this._originalLocations; _i < _a.length; _i++) {
            var location = _a[_i];
            var currentRange = this.fragments[rangeIndex];
            if (location.type === SourceType_1["default"].STRING_CONTENT &&
                currentRange && location.index === currentRange.start) {
                resultLocations.push.apply(resultLocations, currentRange.computeSourceLocations());
                rangeIndex++;
            }
            else {
                resultLocations.push(location);
            }
        }
        if (rangeIndex !== this.fragments.length) {
            throw new Error('Expected ranges to correspond to original locations.');
        }
        return resultLocations;
    };
    return PaddingTracker;
}());
exports["default"] = PaddingTracker;
var TrackedFragment = (function () {
    function TrackedFragment(content, start, end, index) {
        this.content = content;
        this.start = start;
        this.end = end;
        this.index = index;
        this._paddingRanges = [];
        this._lineSeparators = [];
    }
    TrackedFragment.prototype.markPadding = function (startIndex, endIndex) {
        this._paddingRanges.push({ start: startIndex, end: endIndex });
    };
    TrackedFragment.prototype.markLineSeparator = function (index) {
        this._lineSeparators.push(index);
    };
    TrackedFragment.prototype.computeSourceLocations = function () {
        if (this.start === this.end) {
            return [new SourceLocation_1["default"](SourceType_1["default"].STRING_CONTENT, this.start)];
        }
        // Break the marked ranges down into events, similar to how you might count
        // paren nesting. At each index, we can then know if we're inside padding,
        // a line separator, or neither.
        var eventsByIndex = [];
        for (var i = 0; i < this.end - this.start + 1; i++) {
            eventsByIndex.push([]);
        }
        for (var _i = 0, _a = this._paddingRanges; _i < _a.length; _i++) {
            var range = _a[_i];
            eventsByIndex[range.start].push('START_PADDING');
            eventsByIndex[range.end].push('END_PADDING');
        }
        for (var _b = 0, _c = this._lineSeparators; _b < _c.length; _b++) {
            var separatorIndex = _c[_b];
            eventsByIndex[separatorIndex].push('START_LINE_SEPARATOR');
            eventsByIndex[separatorIndex + 1].push('END_LINE_SEPARATOR');
        }
        var resultLocations = [];
        var lastSourceType = null;
        var paddingDepth = 0;
        var lineSeparatorDepth = 0;
        for (var sourceIndex = this.start; sourceIndex < this.end; sourceIndex++) {
            for (var _d = 0, _e = eventsByIndex[sourceIndex - this.start]; _d < _e.length; _d++) {
                var event = _e[_d];
                if (event === 'START_PADDING') {
                    paddingDepth += 1;
                }
                else if (event === 'END_PADDING') {
                    paddingDepth -= 1;
                }
                else if (event === 'START_LINE_SEPARATOR') {
                    lineSeparatorDepth += 1;
                }
                else if (event === 'END_LINE_SEPARATOR') {
                    lineSeparatorDepth -= 1;
                }
            }
            if (paddingDepth < 0 || lineSeparatorDepth < 0 || (paddingDepth > 0 && lineSeparatorDepth > 0)) {
                throw new Error("Illegal padding state: paddingDepth: " + paddingDepth + ", lineSeparatorDepth: " + lineSeparatorDepth);
            }
            var sourceType = void 0;
            if (paddingDepth > 0) {
                sourceType = SourceType_1["default"].STRING_PADDING;
            }
            else if (lineSeparatorDepth > 0) {
                sourceType = SourceType_1["default"].STRING_LINE_SEPARATOR;
            }
            else {
                sourceType = SourceType_1["default"].STRING_CONTENT;
            }
            if (sourceType !== lastSourceType) {
                resultLocations.push(new SourceLocation_1["default"](sourceType, sourceIndex));
                lastSourceType = sourceType;
            }
        }
        return resultLocations;
    };
    return TrackedFragment;
}());
exports.TrackedFragment = TrackedFragment;

},{"../SourceLocation":67,"../SourceType":71}],75:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var SourceType_1 = require("../SourceType");
var PaddingTracker_1 = require("./PaddingTracker");
/**
 * Compute the whitespace to remove in a heregexp. All unescaped whitespace
 * characters are removed, and comments are respected.
 */
function calculateHeregexpPadding(source, stream) {
    if (!stream.hasNext(SourceType_1["default"].HEREGEXP_START)) {
        return [];
    }
    var paddingTracker = new PaddingTracker_1["default"](source, stream, SourceType_1["default"].HEREGEXP_END);
    for (var _i = 0, _a = paddingTracker.fragments; _i < _a.length; _i++) {
        var fragment = _a[_i];
        var content = fragment.content;
        var pos = 0;
        while (pos < content.length) {
            if (/\s/.test(content[pos])) {
                if (isWhitespaceEscaped(content, pos)) {
                    // The escape character should be removed instead of the space.
                    fragment.markPadding(pos - 1, pos);
                }
                else {
                    fragment.markPadding(pos, pos + 1);
                }
                pos++;
            }
            else if (content[pos] === '#' && (pos === 0 || /\s/.test(content[pos - 1]))) {
                var commentStart = pos;
                while (pos < content.length && content[pos] !== '\n') {
                    pos++;
                }
                fragment.markPadding(commentStart, pos);
            }
            else {
                pos++;
            }
        }
    }
    return paddingTracker.computeSourceLocations();
}
exports["default"] = calculateHeregexpPadding;
/**
 * A space, tab, or newline is escaped if it is preceded by an odd number of
 * backslashes.
 */
function isWhitespaceEscaped(content, whitespacePos) {
    var prevPos = whitespacePos - 1;
    while (prevPos >= 0 && content[prevPos] === '\\') {
        prevPos--;
    }
    return (whitespacePos - prevPos) % 2 === 0;
}

},{"../SourceType":71,"./PaddingTracker":74}],76:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var SourceType_1 = require("../SourceType");
var PaddingTracker_1 = require("./PaddingTracker");
/**
 * Compute the whitespace to remove in a multiline single or double quoted
 * string. The algorithm naturally handles handles the case of a string without
 * newlines, so we don't need a special case for that. We also generally need to
 * mark newlines as "line separators" so that later they will be turned into
 * spaces, and extra whitespace at the start and end of each line (except the
 * start of the first line and the end of the last line) is ignored.
 */
function calculateNormalStringPadding(source, stream) {
    var paddingTracker;
    if (stream.hasNext(SourceType_1["default"].SSTRING_START)) {
        paddingTracker = new PaddingTracker_1["default"](source, stream, SourceType_1["default"].SSTRING_END);
    }
    else if (stream.hasNext(SourceType_1["default"].DSTRING_START)) {
        paddingTracker = new PaddingTracker_1["default"](source, stream, SourceType_1["default"].DSTRING_END);
    }
    else {
        return [];
    }
    // The general strategy is to find each newline character and mark it as a
    // line separator and mark all surrounding whitespace as padding.
    for (var fragmentIndex = 0; fragmentIndex < paddingTracker.fragments.length; fragmentIndex++) {
        var fragment = paddingTracker.fragments[fragmentIndex];
        var content = fragment.content;
        var lastNonWhitespace = -1;
        var pos = 0;
        while (pos < content.length) {
            if (content[pos] === '\n') {
                var startIndex = lastNonWhitespace + 1;
                fragment.markPadding(lastNonWhitespace + 1, pos);
                var newlinePos = pos;
                pos++;
                // Search forward until the next non-whitespace character. Even skip
                // newlines, so that two or more newlines with only spaces between them
                // will result in a single line separator.
                while (pos < content.length &&
                    (content[pos] === ' ' || content[pos] === '\t' || content[pos] === '\n')) {
                    pos++;
                }
                var endIndex = pos;
                if (isNewlineEscaped(content, newlinePos)) {
                    // Escaped newlines behave a bit strangely: whitespace is removed from
                    // the right side but not the left side, and the newline and its
                    // escape character are removed.
                    var backslashPos = content.lastIndexOf('\\', newlinePos);
                    fragment.markPadding(backslashPos, endIndex);
                }
                else if ((fragmentIndex === 0 && startIndex === 0) ||
                    (fragmentIndex === paddingTracker.fragments.length - 1 && endIndex === content.length)) {
                    // We only want spaces between, not around, lines, so if we're up
                    // against the left side or right side of the string, mark the newline
                    // as padding.
                    fragment.markPadding(startIndex, endIndex);
                }
                else {
                    // Otherwise, the newline should be a line separator that will become
                    // a space and everything else should be padding.
                    fragment.markPadding(startIndex, newlinePos);
                    fragment.markLineSeparator(newlinePos);
                    fragment.markPadding(newlinePos + 1, endIndex);
                }
                lastNonWhitespace = pos;
            }
            else {
                if (content[pos] !== ' ' && content[pos] !== '\t') {
                    lastNonWhitespace = pos;
                }
                pos++;
            }
        }
    }
    return paddingTracker.computeSourceLocations();
}
exports["default"] = calculateNormalStringPadding;
/**
 * A newline character is escaped if it's preceded by an odd number of
 * backslashes. Spaces are allowed between the backslashes and the newline.
 */
function isNewlineEscaped(content, newlinePos) {
    var numSeenBackslashes = 0;
    var prevPos = newlinePos - 1;
    while (prevPos >= 0) {
        var char = content[prevPos];
        if (numSeenBackslashes === 0 && (char === ' ' || char === '\t')) {
            prevPos--;
        }
        else if (char === '\\') {
            numSeenBackslashes++;
            prevPos--;
        }
        else {
            break;
        }
    }
    return numSeenBackslashes % 2 === 1;
}

},{"../SourceType":71,"./PaddingTracker":74}],77:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var SourceType_1 = require("../SourceType");
var PaddingTracker_1 = require("./PaddingTracker");
/**
 * Compute the padding (the extra spacing to remove) for the given herestring.
 *
 * CoffeeScript removes spacing in the following situations:
 * - If the first or last line is completely blank, it is removed.
 * - The "common leading whitespace" is removed from each line if possible. This
 *   is computed by taking the smallest nonzero amount of leading whitespace
 *   among all lines except the partial line immediately after the open quotes
 *   and except lines that consist only of whitespace. Note that this "smallest
 *   nonzero amount" behavior doesn't just ignore blank lines; *any* line with
 *   no leading whitespace will be ignored when calculating this value. Even
 *   though the initial partial line has no effect when computing leading
 *   whitespace, the common leading whitespace is still removed from that line
 *   if possible.
 * - Due to a bug in CoffeeScript, if the first full line (the one after the
 *   partial line) is nonempty and has indent zero, the entire string is
 *   considered to have "common leading whitespace" zero.
 * - Due to another bug in CoffeeScript, if the herestring has exactly two lines
 *   that both consist of only whitespace, the whitespace and newline is removed
 *   from the first line, but the second line keeps all of its whitespace.
 *
 * See the stringToken function in lexer.coffee in the CoffeeScript source code
 * for CoffeeScript's implementation of this.
 */
function calculateTripleQuotedStringPadding(source, stream) {
    var paddingTracker;
    if (stream.hasNext(SourceType_1["default"].TSSTRING_START)) {
        paddingTracker = new PaddingTracker_1["default"](source, stream, SourceType_1["default"].TSSTRING_END);
    }
    else if (stream.hasNext(SourceType_1["default"].TDSTRING_START)) {
        paddingTracker = new PaddingTracker_1["default"](source, stream, SourceType_1["default"].TDSTRING_END);
    }
    else {
        return [];
    }
    var firstFragment = paddingTracker.fragments[0];
    var firstContent = firstFragment.content;
    var lastFragment = paddingTracker.fragments[paddingTracker.fragments.length - 1];
    var lastContent = lastFragment.content;
    var sharedIndent = getIndentForFragments(paddingTracker.fragments);
    if (firstContent.indexOf('\n') > -1 && isWhitespace(firstContent.split('\n')[0])) {
        firstFragment.markPadding(0, firstContent.indexOf('\n') + 1);
    }
    if (!shouldSkipRemovingLastLine(paddingTracker)) {
        var lastLines = lastContent.split('\n');
        if (lastLines.length > 1) {
            var lastLine = lastLines[lastLines.length - 1];
            if (isWhitespace(lastLine)) {
                lastFragment.markPadding(lastFragment.content.length - lastLine.length - 1, lastFragment.content.length);
            }
        }
    }
    for (var _i = 0, _a = paddingTracker.fragments; _i < _a.length; _i++) {
        var fragment = _a[_i];
        for (var i = 0; i < fragment.content.length; i++) {
            var isStartOfLine = i > 0 && fragment.content[i - 1] === '\n';
            var isStartOfString = fragment.index === 0 && i === 0;
            if (isStartOfLine || isStartOfString) {
                var paddingStart = i;
                var paddingEnd = i + sharedIndent.length;
                if (fragment.content.slice(paddingStart, paddingEnd) === sharedIndent) {
                    fragment.markPadding(paddingStart, paddingEnd);
                }
            }
        }
    }
    return paddingTracker.computeSourceLocations();
}
exports["default"] = calculateTripleQuotedStringPadding;
function getIndentForFragments(fragments) {
    var hasSeenLine = false;
    var smallestIndent = null;
    for (var _i = 0, fragments_1 = fragments; _i < fragments_1.length; _i++) {
        var fragment = fragments_1[_i];
        var lines = fragment.content.split('\n');
        for (var i = 1; i < lines.length; i++) {
            var line = lines[i];
            var indent = getLineIndent(line);
            // Replicate a bug in CoffeeScript: if the first line considered has
            // indentation zero and is nonempty, the empty indentation isn't ignored
            // like it should be, so the empty string is used as the indentation.
            if (!hasSeenLine && indent.length === 0 && line.length > 0) {
                return '';
            }
            hasSeenLine = true;
            var isFullLine = i < lines.length - 1 || fragment.index === fragments.length - 1;
            // Ignore zero-indentation lines and whitespace-only lines.
            if (indent.length === 0 || (isFullLine && indent === line)) {
                continue;
            }
            if (smallestIndent === null || indent.length < smallestIndent.length) {
                smallestIndent = indent;
            }
        }
    }
    if (smallestIndent === null) {
        return '';
    }
    return smallestIndent;
}
/**
 * Replicate a bug in CoffeeScript: if the string is whitespace-only with
 * exactly two lines, we run the code to remove the first line but not the last
 * line.
 */
function shouldSkipRemovingLastLine(paddingTracker) {
    if (paddingTracker.fragments.length !== 1) {
        return false;
    }
    var lines = paddingTracker.fragments[0].content.split('\n');
    return lines.length === 2 && isWhitespace(lines[0]) && isWhitespace(lines[1]);
}
function getLineIndent(line) {
    var match = /[^\n\S]*/.exec(line);
    if (match) {
        return match[0];
    }
    else {
        return '';
    }
}
function isWhitespace(line) {
    return /^[^\n\S]*$/.test(line);
}

},{"../SourceType":71,"./PaddingTracker":74}],78:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.get-iterator');
},{"../modules/core.get-iterator":163,"../modules/es6.string.iterator":170,"../modules/web.dom.iterable":176}],79:[function(require,module,exports){
var core  = require('../../modules/_core')
  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};
},{"../../modules/_core":104}],80:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.map');
require('../modules/es7.map.to-json');
module.exports = require('../modules/_core').Map;
},{"../modules/_core":104,"../modules/es6.map":165,"../modules/es6.object.to-string":169,"../modules/es6.string.iterator":170,"../modules/es7.map.to-json":173,"../modules/web.dom.iterable":176}],81:[function(require,module,exports){
require('../../modules/es6.number.max-safe-integer');
module.exports = 0x1fffffffffffff;
},{"../../modules/es6.number.max-safe-integer":166}],82:[function(require,module,exports){
require('../../modules/es6.object.create');
var $Object = require('../../modules/_core').Object;
module.exports = function create(P, D){
  return $Object.create(P, D);
};
},{"../../modules/_core":104,"../../modules/es6.object.create":167}],83:[function(require,module,exports){
require('../../modules/es6.symbol');
module.exports = require('../../modules/_core').Object.getOwnPropertySymbols;
},{"../../modules/_core":104,"../../modules/es6.symbol":171}],84:[function(require,module,exports){
require('../../modules/es6.object.keys');
module.exports = require('../../modules/_core').Object.keys;
},{"../../modules/_core":104,"../../modules/es6.object.keys":168}],85:[function(require,module,exports){
require('../../modules/es6.symbol');
module.exports = require('../../modules/_core').Symbol['for'];
},{"../../modules/_core":104,"../../modules/es6.symbol":171}],86:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
require('../../modules/es7.symbol.async-iterator');
require('../../modules/es7.symbol.observable');
module.exports = require('../../modules/_core').Symbol;
},{"../../modules/_core":104,"../../modules/es6.object.to-string":169,"../../modules/es6.symbol":171,"../../modules/es7.symbol.async-iterator":174,"../../modules/es7.symbol.observable":175}],87:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/web.dom.iterable');
module.exports = require('../../modules/_wks-ext').f('iterator');
},{"../../modules/_wks-ext":160,"../../modules/es6.string.iterator":170,"../../modules/web.dom.iterable":176}],88:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/web.dom.iterable');
require('../modules/es6.weak-map');
module.exports = require('../modules/_core').WeakMap;
},{"../modules/_core":104,"../modules/es6.object.to-string":169,"../modules/es6.weak-map":172,"../modules/web.dom.iterable":176}],89:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],90:[function(require,module,exports){
module.exports = function(){ /* empty */ };
},{}],91:[function(require,module,exports){
module.exports = function(it, Constructor, name, forbiddenField){
  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};
},{}],92:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./_is-object":122}],93:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function(iter, ITERATOR){
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":113}],94:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject')
  , toLength  = require('./_to-length')
  , toIndex   = require('./_to-index');
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};
},{"./_to-index":152,"./_to-iobject":154,"./_to-length":155}],95:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx      = require('./_ctx')
  , IObject  = require('./_iobject')
  , toObject = require('./_to-object')
  , toLength = require('./_to-length')
  , asc      = require('./_array-species-create');
module.exports = function(TYPE, $create){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
    , create        = $create || asc;
  return function($this, callbackfn, that){
    var O      = toObject($this)
      , self   = IObject(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};
},{"./_array-species-create":97,"./_ctx":105,"./_iobject":119,"./_to-length":155,"./_to-object":156}],96:[function(require,module,exports){
var isObject = require('./_is-object')
  , isArray  = require('./_is-array')
  , SPECIES  = require('./_wks')('species');

module.exports = function(original){
  var C;
  if(isArray(original)){
    C = original.constructor;
    // cross-realm fallback
    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
    if(isObject(C)){
      C = C[SPECIES];
      if(C === null)C = undefined;
    }
  } return C === undefined ? Array : C;
};
},{"./_is-array":121,"./_is-object":122,"./_wks":161}],97:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function(original, length){
  return new (speciesConstructor(original))(length);
};
},{"./_array-species-constructor":96}],98:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof')
  , TAG = require('./_wks')('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function(it, key){
  try {
    return it[key];
  } catch(e){ /* empty */ }
};

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};
},{"./_cof":99,"./_wks":161}],99:[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],100:[function(require,module,exports){
'use strict';
var dP          = require('./_object-dp').f
  , create      = require('./_object-create')
  , redefineAll = require('./_redefine-all')
  , ctx         = require('./_ctx')
  , anInstance  = require('./_an-instance')
  , defined     = require('./_defined')
  , forOf       = require('./_for-of')
  , $iterDefine = require('./_iter-define')
  , step        = require('./_iter-step')
  , setSpecies  = require('./_set-species')
  , DESCRIPTORS = require('./_descriptors')
  , fastKey     = require('./_meta').fastKey
  , SIZE        = DESCRIPTORS ? '_s' : 'size';

var getEntry = function(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        anInstance(this, C, 'forEach');
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(DESCRIPTORS)dP(C.prototype, 'size', {
      get: function(){
        return defined(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};
},{"./_an-instance":91,"./_ctx":105,"./_defined":106,"./_descriptors":107,"./_for-of":113,"./_iter-define":125,"./_iter-step":126,"./_meta":130,"./_object-create":132,"./_object-dp":133,"./_redefine-all":145,"./_set-species":147}],101:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof')
  , from    = require('./_array-from-iterable');
module.exports = function(NAME){
  return function toJSON(){
    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};
},{"./_array-from-iterable":93,"./_classof":98}],102:[function(require,module,exports){
'use strict';
var redefineAll       = require('./_redefine-all')
  , getWeak           = require('./_meta').getWeak
  , anObject          = require('./_an-object')
  , isObject          = require('./_is-object')
  , anInstance        = require('./_an-instance')
  , forOf             = require('./_for-of')
  , createArrayMethod = require('./_array-methods')
  , $has              = require('./_has')
  , arrayFind         = createArrayMethod(5)
  , arrayFindIndex    = createArrayMethod(6)
  , id                = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function(that){
  return that._l || (that._l = new UncaughtFrozenStore);
};
var UncaughtFrozenStore = function(){
  this.a = [];
};
var findUncaughtFrozen = function(store, key){
  return arrayFind(store.a, function(it){
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function(key){
    var entry = findUncaughtFrozen(this, key);
    if(entry)return entry[1];
  },
  has: function(key){
    return !!findUncaughtFrozen(this, key);
  },
  set: function(key, value){
    var entry = findUncaughtFrozen(this, key);
    if(entry)entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function(key){
    var index = arrayFindIndex(this.a, function(it){
      return it[0] === key;
    });
    if(~index)this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function(key){
        if(!isObject(key))return false;
        var data = getWeak(key);
        if(data === true)return uncaughtFrozenStore(this)['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key){
        if(!isObject(key))return false;
        var data = getWeak(key);
        if(data === true)return uncaughtFrozenStore(this).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var data = getWeak(anObject(key), true);
    if(data === true)uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};
},{"./_an-instance":91,"./_an-object":92,"./_array-methods":95,"./_for-of":113,"./_has":115,"./_is-object":122,"./_meta":130,"./_redefine-all":145}],103:[function(require,module,exports){
'use strict';
var global         = require('./_global')
  , $export        = require('./_export')
  , meta           = require('./_meta')
  , fails          = require('./_fails')
  , hide           = require('./_hide')
  , redefineAll    = require('./_redefine-all')
  , forOf          = require('./_for-of')
  , anInstance     = require('./_an-instance')
  , isObject       = require('./_is-object')
  , setToStringTag = require('./_set-to-string-tag')
  , dP             = require('./_object-dp').f
  , each           = require('./_array-methods')(0)
  , DESCRIPTORS    = require('./_descriptors');

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function(target, iterable){
      anInstance(target, C, NAME, '_c');
      target._c = new Base;
      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','),function(KEY){
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
        anInstance(this, C, KEY);
        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    if('size' in proto)dP(C.prototype, 'size', {
      get: function(){
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};
},{"./_an-instance":91,"./_array-methods":95,"./_descriptors":107,"./_export":111,"./_fails":112,"./_for-of":113,"./_global":114,"./_hide":116,"./_is-object":122,"./_meta":130,"./_object-dp":133,"./_redefine-all":145,"./_set-to-string-tag":148}],104:[function(require,module,exports){
var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],105:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./_a-function":89}],106:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],107:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_fails":112}],108:[function(require,module,exports){
var isObject = require('./_is-object')
  , document = require('./_global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./_global":114,"./_is-object":122}],109:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');
},{}],110:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys')
  , gOPS    = require('./_object-gops')
  , pIE     = require('./_object-pie');
module.exports = function(it){
  var result     = getKeys(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};
},{"./_object-gops":138,"./_object-keys":141,"./_object-pie":142}],111:[function(require,module,exports){
var global    = require('./_global')
  , core      = require('./_core')
  , ctx       = require('./_ctx')
  , hide      = require('./_hide')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE]
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(a, b, c){
        if(this instanceof C){
          switch(arguments.length){
            case 0: return new C;
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if(IS_PROTO){
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;
},{"./_core":104,"./_ctx":105,"./_global":114,"./_hide":116}],112:[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],113:[function(require,module,exports){
var ctx         = require('./_ctx')
  , call        = require('./_iter-call')
  , isArrayIter = require('./_is-array-iter')
  , anObject    = require('./_an-object')
  , toLength    = require('./_to-length')
  , getIterFn   = require('./core.get-iterator-method')
  , BREAK       = {}
  , RETURN      = {};
var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator, result;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if(result === BREAK || result === RETURN)return result;
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    result = call(iterator, f, step.value, entries);
    if(result === BREAK || result === RETURN)return result;
  }
};
exports.BREAK  = BREAK;
exports.RETURN = RETURN;
},{"./_an-object":92,"./_ctx":105,"./_is-array-iter":120,"./_iter-call":123,"./_to-length":155,"./core.get-iterator-method":162}],114:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],115:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],116:[function(require,module,exports){
var dP         = require('./_object-dp')
  , createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./_descriptors":107,"./_object-dp":133,"./_property-desc":144}],117:[function(require,module,exports){
module.exports = require('./_global').document && document.documentElement;
},{"./_global":114}],118:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function(){
  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_descriptors":107,"./_dom-create":108,"./_fails":112}],119:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./_cof":99}],120:[function(require,module,exports){
// check on default Array iterator
var Iterators  = require('./_iterators')
  , ITERATOR   = require('./_wks')('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};
},{"./_iterators":127,"./_wks":161}],121:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};
},{"./_cof":99}],122:[function(require,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],123:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};
},{"./_an-object":92}],124:[function(require,module,exports){
'use strict';
var create         = require('./_object-create')
  , descriptor     = require('./_property-desc')
  , setToStringTag = require('./_set-to-string-tag')
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};
},{"./_hide":116,"./_object-create":132,"./_property-desc":144,"./_set-to-string-tag":148,"./_wks":161}],125:[function(require,module,exports){
'use strict';
var LIBRARY        = require('./_library')
  , $export        = require('./_export')
  , redefine       = require('./_redefine')
  , hide           = require('./_hide')
  , has            = require('./_has')
  , Iterators      = require('./_iterators')
  , $iterCreate    = require('./_iter-create')
  , setToStringTag = require('./_set-to-string-tag')
  , getPrototypeOf = require('./_object-gpo')
  , ITERATOR       = require('./_wks')('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};
},{"./_export":111,"./_has":115,"./_hide":116,"./_iter-create":124,"./_iterators":127,"./_library":129,"./_object-gpo":139,"./_redefine":146,"./_set-to-string-tag":148,"./_wks":161}],126:[function(require,module,exports){
module.exports = function(done, value){
  return {value: value, done: !!done};
};
},{}],127:[function(require,module,exports){
module.exports = {};
},{}],128:[function(require,module,exports){
var getKeys   = require('./_object-keys')
  , toIObject = require('./_to-iobject');
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
},{"./_object-keys":141,"./_to-iobject":154}],129:[function(require,module,exports){
module.exports = true;
},{}],130:[function(require,module,exports){
var META     = require('./_uid')('meta')
  , isObject = require('./_is-object')
  , has      = require('./_has')
  , setDesc  = require('./_object-dp').f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !require('./_fails')(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};
},{"./_fails":112,"./_has":115,"./_is-object":122,"./_object-dp":133,"./_uid":158}],131:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys  = require('./_object-keys')
  , gOPS     = require('./_object-gops')
  , pIE      = require('./_object-pie')
  , toObject = require('./_to-object')
  , IObject  = require('./_iobject')
  , $assign  = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function(){
  var A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , aLen  = arguments.length
    , index = 1
    , getSymbols = gOPS.f
    , isEnum     = pIE.f;
  while(aLen > index){
    var S      = IObject(arguments[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  } return T;
} : $assign;
},{"./_fails":112,"./_iobject":119,"./_object-gops":138,"./_object-keys":141,"./_object-pie":142,"./_to-object":156}],132:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = require('./_an-object')
  , dPs         = require('./_object-dps')
  , enumBugKeys = require('./_enum-bug-keys')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":92,"./_dom-create":108,"./_enum-bug-keys":109,"./_html":117,"./_object-dps":134,"./_shared-key":149}],133:[function(require,module,exports){
var anObject       = require('./_an-object')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , toPrimitive    = require('./_to-primitive')
  , dP             = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};
},{"./_an-object":92,"./_descriptors":107,"./_ie8-dom-define":118,"./_to-primitive":157}],134:[function(require,module,exports){
var dP       = require('./_object-dp')
  , anObject = require('./_an-object')
  , getKeys  = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};
},{"./_an-object":92,"./_descriptors":107,"./_object-dp":133,"./_object-keys":141}],135:[function(require,module,exports){
var pIE            = require('./_object-pie')
  , createDesc     = require('./_property-desc')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , has            = require('./_has')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};
},{"./_descriptors":107,"./_has":115,"./_ie8-dom-define":118,"./_object-pie":142,"./_property-desc":144,"./_to-iobject":154,"./_to-primitive":157}],136:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject')
  , gOPN      = require('./_object-gopn').f
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it){
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":137,"./_to-iobject":154}],137:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = require('./_object-keys-internal')
  , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};
},{"./_enum-bug-keys":109,"./_object-keys-internal":140}],138:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;
},{}],139:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has         = require('./_has')
  , toObject    = require('./_to-object')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function(O){
  O = toObject(O);
  if(has(O, IE_PROTO))return O[IE_PROTO];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};
},{"./_has":115,"./_shared-key":149,"./_to-object":156}],140:[function(require,module,exports){
var has          = require('./_has')
  , toIObject    = require('./_to-iobject')
  , arrayIndexOf = require('./_array-includes')(false)
  , IE_PROTO     = require('./_shared-key')('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};
},{"./_array-includes":94,"./_has":115,"./_shared-key":149,"./_to-iobject":154}],141:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = require('./_object-keys-internal')
  , enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};
},{"./_enum-bug-keys":109,"./_object-keys-internal":140}],142:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;
},{}],143:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export')
  , core    = require('./_core')
  , fails   = require('./_fails');
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};
},{"./_core":104,"./_export":111,"./_fails":112}],144:[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],145:[function(require,module,exports){
var hide = require('./_hide');
module.exports = function(target, src, safe){
  for(var key in src){
    if(safe && target[key])target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};
},{"./_hide":116}],146:[function(require,module,exports){
module.exports = require('./_hide');
},{"./_hide":116}],147:[function(require,module,exports){
'use strict';
var global      = require('./_global')
  , core        = require('./_core')
  , dP          = require('./_object-dp')
  , DESCRIPTORS = require('./_descriptors')
  , SPECIES     = require('./_wks')('species');

module.exports = function(KEY){
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};
},{"./_core":104,"./_descriptors":107,"./_global":114,"./_object-dp":133,"./_wks":161}],148:[function(require,module,exports){
var def = require('./_object-dp').f
  , has = require('./_has')
  , TAG = require('./_wks')('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};
},{"./_has":115,"./_object-dp":133,"./_wks":161}],149:[function(require,module,exports){
var shared = require('./_shared')('keys')
  , uid    = require('./_uid');
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};
},{"./_shared":150,"./_uid":158}],150:[function(require,module,exports){
var global = require('./_global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./_global":114}],151:[function(require,module,exports){
var toInteger = require('./_to-integer')
  , defined   = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
},{"./_defined":106,"./_to-integer":153}],152:[function(require,module,exports){
var toInteger = require('./_to-integer')
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};
},{"./_to-integer":153}],153:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],154:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject')
  , defined = require('./_defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./_defined":106,"./_iobject":119}],155:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./_to-integer":153}],156:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./_defined":106}],157:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};
},{"./_is-object":122}],158:[function(require,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],159:[function(require,module,exports){
var global         = require('./_global')
  , core           = require('./_core')
  , LIBRARY        = require('./_library')
  , wksExt         = require('./_wks-ext')
  , defineProperty = require('./_object-dp').f;
module.exports = function(name){
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
};
},{"./_core":104,"./_global":114,"./_library":129,"./_object-dp":133,"./_wks-ext":160}],160:[function(require,module,exports){
exports.f = require('./_wks');
},{"./_wks":161}],161:[function(require,module,exports){
var store      = require('./_shared')('wks')
  , uid        = require('./_uid')
  , Symbol     = require('./_global').Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;
},{"./_global":114,"./_shared":150,"./_uid":158}],162:[function(require,module,exports){
var classof   = require('./_classof')
  , ITERATOR  = require('./_wks')('iterator')
  , Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};
},{"./_classof":98,"./_core":104,"./_iterators":127,"./_wks":161}],163:[function(require,module,exports){
var anObject = require('./_an-object')
  , get      = require('./core.get-iterator-method');
module.exports = require('./_core').getIterator = function(it){
  var iterFn = get(it);
  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};
},{"./_an-object":92,"./_core":104,"./core.get-iterator-method":162}],164:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables')
  , step             = require('./_iter-step')
  , Iterators        = require('./_iterators')
  , toIObject        = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
},{"./_add-to-unscopables":90,"./_iter-define":125,"./_iter-step":126,"./_iterators":127,"./_to-iobject":154}],165:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');

// 23.1 Map Objects
module.exports = require('./_collection')('Map', function(get){
  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);
},{"./_collection":103,"./_collection-strong":100}],166:[function(require,module,exports){
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});
},{"./_export":111}],167:[function(require,module,exports){
var $export = require('./_export')
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', {create: require('./_object-create')});
},{"./_export":111,"./_object-create":132}],168:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object')
  , $keys    = require('./_object-keys');

require('./_object-sap')('keys', function(){
  return function keys(it){
    return $keys(toObject(it));
  };
});
},{"./_object-keys":141,"./_object-sap":143,"./_to-object":156}],169:[function(require,module,exports){
arguments[4][64][0].apply(exports,arguments)
},{"dup":64}],170:[function(require,module,exports){
'use strict';
var $at  = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});
},{"./_iter-define":125,"./_string-at":151}],171:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global         = require('./_global')
  , has            = require('./_has')
  , DESCRIPTORS    = require('./_descriptors')
  , $export        = require('./_export')
  , redefine       = require('./_redefine')
  , META           = require('./_meta').KEY
  , $fails         = require('./_fails')
  , shared         = require('./_shared')
  , setToStringTag = require('./_set-to-string-tag')
  , uid            = require('./_uid')
  , wks            = require('./_wks')
  , wksExt         = require('./_wks-ext')
  , wksDefine      = require('./_wks-define')
  , keyOf          = require('./_keyof')
  , enumKeys       = require('./_enum-keys')
  , isArray        = require('./_is-array')
  , anObject       = require('./_an-object')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , createDesc     = require('./_property-desc')
  , _create        = require('./_object-create')
  , gOPNExt        = require('./_object-gopn-ext')
  , $GOPD          = require('./_object-gopd')
  , $DP            = require('./_object-dp')
  , $keys          = require('./_object-keys')
  , gOPD           = $GOPD.f
  , dP             = $DP.f
  , gOPN           = gOPNExt.f
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , PROTOTYPE      = 'prototype'
  , HIDDEN         = wks('_hidden')
  , TO_PRIMITIVE   = wks('toPrimitive')
  , isEnum         = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , OPSymbols      = shared('op-symbols')
  , ObjectProto    = Object[PROTOTYPE]
  , USE_NATIVE     = typeof $Symbol == 'function'
  , QObject        = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP({}, 'a', {
    get: function(){ return dP(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  dP(it, key, D);
  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D){
  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if(has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject(it);
  key = toPrimitive(key, true);
  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto
    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto)$set.call(OPSymbols, value);
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f  = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !require('./_library')){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  }
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);
},{"./_an-object":92,"./_descriptors":107,"./_enum-keys":110,"./_export":111,"./_fails":112,"./_global":114,"./_has":115,"./_hide":116,"./_is-array":121,"./_keyof":128,"./_library":129,"./_meta":130,"./_object-create":132,"./_object-dp":133,"./_object-gopd":135,"./_object-gopn":137,"./_object-gopn-ext":136,"./_object-gops":138,"./_object-keys":141,"./_object-pie":142,"./_property-desc":144,"./_redefine":146,"./_set-to-string-tag":148,"./_shared":150,"./_to-iobject":154,"./_to-primitive":157,"./_uid":158,"./_wks":161,"./_wks-define":159,"./_wks-ext":160}],172:[function(require,module,exports){
'use strict';
var each         = require('./_array-methods')(0)
  , redefine     = require('./_redefine')
  , meta         = require('./_meta')
  , assign       = require('./_object-assign')
  , weak         = require('./_collection-weak')
  , isObject     = require('./_is-object')
  , getWeak      = meta.getWeak
  , isExtensible = Object.isExtensible
  , uncaughtFrozenStore = weak.ufstore
  , tmp          = {}
  , InternalMap;

var wrapper = function(get){
  return function WeakMap(){
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key){
    if(isObject(key)){
      var data = getWeak(key);
      if(data === true)return uncaughtFrozenStore(this).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value){
    return weak.def(this, key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')('WeakMap', wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
  InternalMap = weak.getConstructor(wrapper);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function(key){
    var proto  = $WeakMap.prototype
      , method = proto[key];
    redefine(proto, key, function(a, b){
      // store frozen objects on internal weakmap shim
      if(isObject(a) && !isExtensible(a)){
        if(!this._f)this._f = new InternalMap;
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}
},{"./_array-methods":95,"./_collection":103,"./_collection-weak":102,"./_is-object":122,"./_meta":130,"./_object-assign":131,"./_redefine":146}],173:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = require('./_export');

$export($export.P + $export.R, 'Map', {toJSON: require('./_collection-to-json')('Map')});
},{"./_collection-to-json":101,"./_export":111}],174:[function(require,module,exports){
require('./_wks-define')('asyncIterator');
},{"./_wks-define":159}],175:[function(require,module,exports){
require('./_wks-define')('observable');
},{"./_wks-define":159}],176:[function(require,module,exports){
require('./es6.array.iterator');
var global        = require('./_global')
  , hide          = require('./_hide')
  , Iterators     = require('./_iterators')
  , TO_STRING_TAG = require('./_wks')('toStringTag');

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global[NAME]
    , proto      = Collection && Collection.prototype;
  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}
},{"./_global":114,"./_hide":116,"./_iterators":127,"./_wks":161,"./es6.array.iterator":164}],177:[function(require,module,exports){
(function (process){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window && typeof window.process !== 'undefined' && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document && 'WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window && window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this,require('_process'))
},{"./debug":178,"_process":367}],178:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":364}],179:[function(require,module,exports){
(function (process,global){
// Generated by CoffeeScript 1.10.0
(function() {
  var Lexer, SourceMap, base, compile, ext, formatSourcePosition, fs, getSourceMap, helpers, i, len, lexer, parser, path, ref, sourceMaps, vm, withPrettyErrors,
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  vm = require('vm');

  path = require('path');

  Lexer = require('./lexer').Lexer;

  parser = require('./parser').parser;

  helpers = require('./helpers');

  SourceMap = require('./sourcemap');

  exports.VERSION = '1.10.0';

  exports.FILE_EXTENSIONS = ['.coffee', '.litcoffee', '.coffee.md'];

  exports.helpers = helpers;

  withPrettyErrors = function(fn) {
    return function(code, options) {
      var err, error;
      if (options == null) {
        options = {};
      }
      try {
        return fn.call(this, code, options);
      } catch (error) {
        err = error;
        if (typeof code !== 'string') {
          throw err;
        }
        throw helpers.updateSyntaxError(err, code, options.filename);
      }
    };
  };

  exports.compile = compile = withPrettyErrors(function(code, options) {
    var answer, currentColumn, currentLine, extend, fragment, fragments, header, i, js, len, map, merge, newLines, token, tokens;
    merge = helpers.merge, extend = helpers.extend;
    options = extend({}, options);
    if (options.sourceMap) {
      map = new SourceMap;
    }
    tokens = lexer.tokenize(code, options);
    options.referencedVars = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = tokens.length; i < len; i++) {
        token = tokens[i];
        if (token.variable) {
          results.push(token[1]);
        }
      }
      return results;
    })();
    fragments = parser.parse(tokens).compileToFragments(options);
    currentLine = 0;
    if (options.header) {
      currentLine += 1;
    }
    if (options.shiftLine) {
      currentLine += 1;
    }
    currentColumn = 0;
    js = "";
    for (i = 0, len = fragments.length; i < len; i++) {
      fragment = fragments[i];
      if (options.sourceMap) {
        if (fragment.locationData && !/^[;\s]*$/.test(fragment.code)) {
          map.add([fragment.locationData.first_line, fragment.locationData.first_column], [currentLine, currentColumn], {
            noReplace: true
          });
        }
        newLines = helpers.count(fragment.code, "\n");
        currentLine += newLines;
        if (newLines) {
          currentColumn = fragment.code.length - (fragment.code.lastIndexOf("\n") + 1);
        } else {
          currentColumn += fragment.code.length;
        }
      }
      js += fragment.code;
    }
    if (options.header) {
      header = "Generated by CoffeeScript " + this.VERSION;
      js = "// " + header + "\n" + js;
    }
    if (options.sourceMap) {
      answer = {
        js: js
      };
      answer.sourceMap = map;
      answer.v3SourceMap = map.generate(options, code);
      return answer;
    } else {
      return js;
    }
  });

  exports.tokens = withPrettyErrors(function(code, options) {
    return lexer.tokenize(code, options);
  });

  exports.nodes = withPrettyErrors(function(source, options) {
    if (typeof source === 'string') {
      return parser.parse(lexer.tokenize(source, options));
    } else {
      return parser.parse(source);
    }
  });

  exports.run = function(code, options) {
    var answer, dir, mainModule, ref;
    if (options == null) {
      options = {};
    }
    mainModule = require.main;
    mainModule.filename = process.argv[1] = options.filename ? fs.realpathSync(options.filename) : '.';
    mainModule.moduleCache && (mainModule.moduleCache = {});
    dir = options.filename ? path.dirname(fs.realpathSync(options.filename)) : fs.realpathSync('.');
    mainModule.paths = require('module')._nodeModulePaths(dir);
    if (!helpers.isCoffee(mainModule.filename) || require.extensions) {
      answer = compile(code, options);
      code = (ref = answer.js) != null ? ref : answer;
    }
    return mainModule._compile(code, mainModule.filename);
  };

  exports["eval"] = function(code, options) {
    var Module, _module, _require, createContext, i, isContext, js, k, len, o, r, ref, ref1, ref2, ref3, sandbox, v;
    if (options == null) {
      options = {};
    }
    if (!(code = code.trim())) {
      return;
    }
    createContext = (ref = vm.Script.createContext) != null ? ref : vm.createContext;
    isContext = (ref1 = vm.isContext) != null ? ref1 : function(ctx) {
      return options.sandbox instanceof createContext().constructor;
    };
    if (createContext) {
      if (options.sandbox != null) {
        if (isContext(options.sandbox)) {
          sandbox = options.sandbox;
        } else {
          sandbox = createContext();
          ref2 = options.sandbox;
          for (k in ref2) {
            if (!hasProp.call(ref2, k)) continue;
            v = ref2[k];
            sandbox[k] = v;
          }
        }
        sandbox.global = sandbox.root = sandbox.GLOBAL = sandbox;
      } else {
        sandbox = global;
      }
      sandbox.__filename = options.filename || 'eval';
      sandbox.__dirname = path.dirname(sandbox.__filename);
      if (!(sandbox !== global || sandbox.module || sandbox.require)) {
        Module = require('module');
        sandbox.module = _module = new Module(options.modulename || 'eval');
        sandbox.require = _require = function(path) {
          return Module._load(path, _module, true);
        };
        _module.filename = sandbox.__filename;
        ref3 = Object.getOwnPropertyNames(require);
        for (i = 0, len = ref3.length; i < len; i++) {
          r = ref3[i];
          if (r !== 'paths' && r !== 'arguments' && r !== 'caller') {
            _require[r] = require[r];
          }
        }
        _require.paths = _module.paths = Module._nodeModulePaths(process.cwd());
        _require.resolve = function(request) {
          return Module._resolveFilename(request, _module);
        };
      }
    }
    o = {};
    for (k in options) {
      if (!hasProp.call(options, k)) continue;
      v = options[k];
      o[k] = v;
    }
    o.bare = true;
    js = compile(code, o);
    if (sandbox === global) {
      return vm.runInThisContext(js);
    } else {
      return vm.runInContext(js, sandbox);
    }
  };

  exports.register = function() {
    return require('./register');
  };

  if (require.extensions) {
    ref = this.FILE_EXTENSIONS;
    for (i = 0, len = ref.length; i < len; i++) {
      ext = ref[i];
      if ((base = require.extensions)[ext] == null) {
        base[ext] = function() {
          throw new Error("Use CoffeeScript.register() or require the coffee-script/register module to require " + ext + " files.");
        };
      }
    }
  }

  exports._compileFile = function(filename, sourceMap) {
    var answer, err, error, raw, stripped;
    if (sourceMap == null) {
      sourceMap = false;
    }
    raw = fs.readFileSync(filename, 'utf8');
    stripped = raw.charCodeAt(0) === 0xFEFF ? raw.substring(1) : raw;
    try {
      answer = compile(stripped, {
        filename: filename,
        sourceMap: sourceMap,
        literate: helpers.isLiterate(filename)
      });
    } catch (error) {
      err = error;
      throw helpers.updateSyntaxError(err, stripped, filename);
    }
    return answer;
  };

  lexer = new Lexer;

  parser.lexer = {
    lex: function() {
      var tag, token;
      token = parser.tokens[this.pos++];
      if (token) {
        tag = token[0], this.yytext = token[1], this.yylloc = token[2];
        parser.errorToken = token.origin || token;
        this.yylineno = this.yylloc.first_line;
      } else {
        tag = '';
      }
      return tag;
    },
    setInput: function(tokens) {
      parser.tokens = tokens;
      return this.pos = 0;
    },
    upcomingInput: function() {
      return "";
    }
  };

  parser.yy = require('./nodes');

  parser.yy.parseError = function(message, arg) {
    var errorLoc, errorTag, errorText, errorToken, token, tokens;
    token = arg.token;
    errorToken = parser.errorToken, tokens = parser.tokens;
    errorTag = errorToken[0], errorText = errorToken[1], errorLoc = errorToken[2];
    errorText = (function() {
      switch (false) {
        case errorToken !== tokens[tokens.length - 1]:
          return 'end of input';
        case errorTag !== 'INDENT' && errorTag !== 'OUTDENT':
          return 'indentation';
        case errorTag !== 'IDENTIFIER' && errorTag !== 'NUMBER' && errorTag !== 'STRING' && errorTag !== 'STRING_START' && errorTag !== 'REGEX' && errorTag !== 'REGEX_START':
          return errorTag.replace(/_START$/, '').toLowerCase();
        default:
          return helpers.nameWhitespaceCharacter(errorText);
      }
    })();
    return helpers.throwSyntaxError("unexpected " + errorText, errorLoc);
  };

  formatSourcePosition = function(frame, getSourceMapping) {
    var as, column, fileLocation, fileName, functionName, isConstructor, isMethodCall, line, methodName, source, tp, typeName;
    fileName = void 0;
    fileLocation = '';
    if (frame.isNative()) {
      fileLocation = "native";
    } else {
      if (frame.isEval()) {
        fileName = frame.getScriptNameOrSourceURL();
        if (!fileName) {
          fileLocation = (frame.getEvalOrigin()) + ", ";
        }
      } else {
        fileName = frame.getFileName();
      }
      fileName || (fileName = "<anonymous>");
      line = frame.getLineNumber();
      column = frame.getColumnNumber();
      source = getSourceMapping(fileName, line, column);
      fileLocation = source ? fileName + ":" + source[0] + ":" + source[1] : fileName + ":" + line + ":" + column;
    }
    functionName = frame.getFunctionName();
    isConstructor = frame.isConstructor();
    isMethodCall = !(frame.isToplevel() || isConstructor);
    if (isMethodCall) {
      methodName = frame.getMethodName();
      typeName = frame.getTypeName();
      if (functionName) {
        tp = as = '';
        if (typeName && functionName.indexOf(typeName)) {
          tp = typeName + ".";
        }
        if (methodName && functionName.indexOf("." + methodName) !== functionName.length - methodName.length - 1) {
          as = " [as " + methodName + "]";
        }
        return "" + tp + functionName + as + " (" + fileLocation + ")";
      } else {
        return typeName + "." + (methodName || '<anonymous>') + " (" + fileLocation + ")";
      }
    } else if (isConstructor) {
      return "new " + (functionName || '<anonymous>') + " (" + fileLocation + ")";
    } else if (functionName) {
      return functionName + " (" + fileLocation + ")";
    } else {
      return fileLocation;
    }
  };

  sourceMaps = {};

  getSourceMap = function(filename) {
    var answer, ref1;
    if (sourceMaps[filename]) {
      return sourceMaps[filename];
    }
    if (ref1 = path != null ? path.extname(filename) : void 0, indexOf.call(exports.FILE_EXTENSIONS, ref1) < 0) {
      return;
    }
    answer = exports._compileFile(filename, true);
    return sourceMaps[filename] = answer.sourceMap;
  };

  Error.prepareStackTrace = function(err, stack) {
    var frame, frames, getSourceMapping;
    getSourceMapping = function(filename, line, column) {
      var answer, sourceMap;
      sourceMap = getSourceMap(filename);
      if (sourceMap) {
        answer = sourceMap.sourceLocation([line - 1, column - 1]);
      }
      if (answer) {
        return [answer[0] + 1, answer[1] + 1];
      } else {
        return null;
      }
    };
    frames = (function() {
      var j, len1, results;
      results = [];
      for (j = 0, len1 = stack.length; j < len1; j++) {
        frame = stack[j];
        if (frame.getFunction() === exports.run) {
          break;
        }
        results.push("  at " + (formatSourcePosition(frame, getSourceMapping)));
      }
      return results;
    })();
    return (err.toString()) + "\n" + (frames.join('\n')) + "\n";
  };

}).call(this);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./helpers":180,"./lexer":181,"./nodes":182,"./parser":183,"./register":184,"./sourcemap":187,"_process":367,"fs":64,"module":64,"path":366,"vm":377}],180:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.10.0
(function() {
  var buildLocationData, extend, flatten, ref, repeat, syntaxErrorToString;

  exports.starts = function(string, literal, start) {
    return literal === string.substr(start, literal.length);
  };

  exports.ends = function(string, literal, back) {
    var len;
    len = literal.length;
    return literal === string.substr(string.length - len - (back || 0), len);
  };

  exports.repeat = repeat = function(str, n) {
    var res;
    res = '';
    while (n > 0) {
      if (n & 1) {
        res += str;
      }
      n >>>= 1;
      str += str;
    }
    return res;
  };

  exports.compact = function(array) {
    var i, item, len1, results;
    results = [];
    for (i = 0, len1 = array.length; i < len1; i++) {
      item = array[i];
      if (item) {
        results.push(item);
      }
    }
    return results;
  };

  exports.count = function(string, substr) {
    var num, pos;
    num = pos = 0;
    if (!substr.length) {
      return 1 / 0;
    }
    while (pos = 1 + string.indexOf(substr, pos)) {
      num++;
    }
    return num;
  };

  exports.merge = function(options, overrides) {
    return extend(extend({}, options), overrides);
  };

  extend = exports.extend = function(object, properties) {
    var key, val;
    for (key in properties) {
      val = properties[key];
      object[key] = val;
    }
    return object;
  };

  exports.flatten = flatten = function(array) {
    var element, flattened, i, len1;
    flattened = [];
    for (i = 0, len1 = array.length; i < len1; i++) {
      element = array[i];
      if ('[object Array]' === Object.prototype.toString.call(element)) {
        flattened = flattened.concat(flatten(element));
      } else {
        flattened.push(element);
      }
    }
    return flattened;
  };

  exports.del = function(obj, key) {
    var val;
    val = obj[key];
    delete obj[key];
    return val;
  };

  exports.some = (ref = Array.prototype.some) != null ? ref : function(fn) {
    var e, i, len1;
    for (i = 0, len1 = this.length; i < len1; i++) {
      e = this[i];
      if (fn(e)) {
        return true;
      }
    }
    return false;
  };

  exports.invertLiterate = function(code) {
    var line, lines, maybe_code;
    maybe_code = true;
    lines = (function() {
      var i, len1, ref1, results;
      ref1 = code.split('\n');
      results = [];
      for (i = 0, len1 = ref1.length; i < len1; i++) {
        line = ref1[i];
        if (maybe_code && /^([ ]{4}|[ ]{0,3}\t)/.test(line)) {
          results.push(line);
        } else if (maybe_code = /^\s*$/.test(line)) {
          results.push(line);
        } else {
          results.push('# ' + line);
        }
      }
      return results;
    })();
    return lines.join('\n');
  };

  buildLocationData = function(first, last) {
    if (!last) {
      return first;
    } else {
      return {
        first_line: first.first_line,
        first_column: first.first_column,
        last_line: last.last_line,
        last_column: last.last_column
      };
    }
  };

  exports.addLocationDataFn = function(first, last) {
    return function(obj) {
      if (((typeof obj) === 'object') && (!!obj['updateLocationDataIfMissing'])) {
        obj.updateLocationDataIfMissing(buildLocationData(first, last));
      }
      return obj;
    };
  };

  exports.locationDataToString = function(obj) {
    var locationData;
    if (("2" in obj) && ("first_line" in obj[2])) {
      locationData = obj[2];
    } else if ("first_line" in obj) {
      locationData = obj;
    }
    if (locationData) {
      return ((locationData.first_line + 1) + ":" + (locationData.first_column + 1) + "-") + ((locationData.last_line + 1) + ":" + (locationData.last_column + 1));
    } else {
      return "No location data";
    }
  };

  exports.baseFileName = function(file, stripExt, useWinPathSep) {
    var parts, pathSep;
    if (stripExt == null) {
      stripExt = false;
    }
    if (useWinPathSep == null) {
      useWinPathSep = false;
    }
    pathSep = useWinPathSep ? /\\|\// : /\//;
    parts = file.split(pathSep);
    file = parts[parts.length - 1];
    if (!(stripExt && file.indexOf('.') >= 0)) {
      return file;
    }
    parts = file.split('.');
    parts.pop();
    if (parts[parts.length - 1] === 'coffee' && parts.length > 1) {
      parts.pop();
    }
    return parts.join('.');
  };

  exports.isCoffee = function(file) {
    return /\.((lit)?coffee|coffee\.md)$/.test(file);
  };

  exports.isLiterate = function(file) {
    return /\.(litcoffee|coffee\.md)$/.test(file);
  };

  exports.throwSyntaxError = function(message, location) {
    var error;
    error = new SyntaxError(message);
    error.location = location;
    error.toString = syntaxErrorToString;
    error.stack = error.toString();
    throw error;
  };

  exports.updateSyntaxError = function(error, code, filename) {
    if (error.toString === syntaxErrorToString) {
      error.code || (error.code = code);
      error.filename || (error.filename = filename);
      error.stack = error.toString();
    }
    return error;
  };

  syntaxErrorToString = function() {
    var codeLine, colorize, colorsEnabled, end, filename, first_column, first_line, last_column, last_line, marker, ref1, ref2, ref3, ref4, start;
    if (!(this.code && this.location)) {
      return Error.prototype.toString.call(this);
    }
    ref1 = this.location, first_line = ref1.first_line, first_column = ref1.first_column, last_line = ref1.last_line, last_column = ref1.last_column;
    if (last_line == null) {
      last_line = first_line;
    }
    if (last_column == null) {
      last_column = first_column;
    }
    filename = this.filename || '[stdin]';
    codeLine = this.code.split('\n')[first_line];
    start = first_column;
    end = first_line === last_line ? last_column + 1 : codeLine.length;
    marker = codeLine.slice(0, start).replace(/[^\s]/g, ' ') + repeat('^', end - start);
    if (typeof process !== "undefined" && process !== null) {
      colorsEnabled = ((ref2 = process.stdout) != null ? ref2.isTTY : void 0) && !((ref3 = process.env) != null ? ref3.NODE_DISABLE_COLORS : void 0);
    }
    if ((ref4 = this.colorful) != null ? ref4 : colorsEnabled) {
      colorize = function(str) {
        return "\x1B[1;31m" + str + "\x1B[0m";
      };
      codeLine = codeLine.slice(0, start) + colorize(codeLine.slice(start, end)) + codeLine.slice(end);
      marker = colorize(marker);
    }
    return filename + ":" + (first_line + 1) + ":" + (first_column + 1) + ": error: " + this.message + "\n" + codeLine + "\n" + marker;
  };

  exports.nameWhitespaceCharacter = function(string) {
    switch (string) {
      case ' ':
        return 'space';
      case '\n':
        return 'newline';
      case '\r':
        return 'carriage return';
      case '\t':
        return 'tab';
      default:
        return string;
    }
  };

}).call(this);

}).call(this,require('_process'))
},{"_process":367}],181:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var BOM, BOOL, CALLABLE, CODE, COFFEE_ALIASES, COFFEE_ALIAS_MAP, COFFEE_KEYWORDS, COMMENT, COMPARE, COMPOUND_ASSIGN, HERECOMMENT_ILLEGAL, HEREDOC_DOUBLE, HEREDOC_INDENT, HEREDOC_SINGLE, HEREGEX, HEREGEX_OMIT, IDENTIFIER, INDENTABLE_CLOSERS, INDEXABLE, INVALID_ESCAPE, INVERSES, JSTOKEN, JS_FORBIDDEN, JS_KEYWORDS, LEADING_BLANK_LINE, LINE_BREAK, LINE_CONTINUER, Lexer, MATH, MULTI_DENT, NOT_REGEX, NUMBER, OPERATOR, POSSIBLY_DIVISION, REGEX, REGEX_FLAGS, REGEX_ILLEGAL, RELATION, RESERVED, Rewriter, SHIFT, SIMPLE_STRING_OMIT, STRICT_PROSCRIBED, STRING_DOUBLE, STRING_OMIT, STRING_SINGLE, STRING_START, TRAILING_BLANK_LINE, TRAILING_SPACES, UNARY, UNARY_MATH, VALID_FLAGS, WHITESPACE, compact, count, invertLiterate, key, locationDataToString, ref, ref1, repeat, starts, throwSyntaxError,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ref = require('./rewriter'), Rewriter = ref.Rewriter, INVERSES = ref.INVERSES;

  ref1 = require('./helpers'), count = ref1.count, starts = ref1.starts, compact = ref1.compact, repeat = ref1.repeat, invertLiterate = ref1.invertLiterate, locationDataToString = ref1.locationDataToString, throwSyntaxError = ref1.throwSyntaxError;

  exports.Lexer = Lexer = (function() {
    function Lexer() {}

    Lexer.prototype.tokenize = function(code, opts) {
      var consumed, end, i, ref2;
      if (opts == null) {
        opts = {};
      }
      this.literate = opts.literate;
      this.indent = 0;
      this.baseIndent = 0;
      this.indebt = 0;
      this.outdebt = 0;
      this.indents = [];
      this.ends = [];
      this.tokens = [];
      this.seenFor = false;
      this.chunkLine = opts.line || 0;
      this.chunkColumn = opts.column || 0;
      code = this.clean(code);
      i = 0;
      while (this.chunk = code.slice(i)) {
        consumed = this.identifierToken() || this.commentToken() || this.whitespaceToken() || this.lineToken() || this.stringToken() || this.numberToken() || this.regexToken() || this.jsToken() || this.literalToken();
        ref2 = this.getLineAndColumnFromChunk(consumed), this.chunkLine = ref2[0], this.chunkColumn = ref2[1];
        i += consumed;
        if (opts.untilBalanced && this.ends.length === 0) {
          return {
            tokens: this.tokens,
            index: i
          };
        }
      }
      this.closeIndentation();
      if (end = this.ends.pop()) {
        this.error("missing " + end.tag, end.origin[2]);
      }
      if (opts.rewrite === false) {
        return this.tokens;
      }
      return (new Rewriter).rewrite(this.tokens);
    };

    Lexer.prototype.clean = function(code) {
      if (code.charCodeAt(0) === BOM) {
        code = code.slice(1);
      }
      code = code.replace(/\r/g, '').replace(TRAILING_SPACES, '');
      if (WHITESPACE.test(code)) {
        code = "\n" + code;
        this.chunkLine--;
      }
      if (this.literate) {
        code = invertLiterate(code);
      }
      return code;
    };

    Lexer.prototype.identifierToken = function() {
      var alias, colon, colonOffset, forcedIdentifier, id, idLength, input, match, poppedToken, prev, ref2, ref3, ref4, ref5, tag, tagToken;
      if (!(match = IDENTIFIER.exec(this.chunk))) {
        return 0;
      }
      input = match[0], id = match[1], colon = match[2];
      idLength = id.length;
      poppedToken = void 0;
      if (id === 'own' && this.tag() === 'FOR') {
        this.token('OWN', id);
        return id.length;
      }
      if (id === 'from' && this.tag() === 'YIELD') {
        this.token('FROM', id);
        return id.length;
      }
      ref2 = this.tokens, prev = ref2[ref2.length - 1];
      forcedIdentifier = colon || (prev != null) && (((ref3 = prev[0]) === '.' || ref3 === '?.' || ref3 === '::' || ref3 === '?::') || !prev.spaced && prev[0] === '@');
      tag = 'IDENTIFIER';
      if (!forcedIdentifier && (indexOf.call(JS_KEYWORDS, id) >= 0 || indexOf.call(COFFEE_KEYWORDS, id) >= 0)) {
        tag = id.toUpperCase();
        if (tag === 'WHEN' && (ref4 = this.tag(), indexOf.call(LINE_BREAK, ref4) >= 0)) {
          tag = 'LEADING_WHEN';
        } else if (tag === 'FOR') {
          this.seenFor = true;
        } else if (tag === 'UNLESS') {
          tag = 'IF';
        } else if (indexOf.call(UNARY, tag) >= 0) {
          tag = 'UNARY';
        } else if (indexOf.call(RELATION, tag) >= 0) {
          if (tag !== 'INSTANCEOF' && this.seenFor) {
            tag = 'FOR' + tag;
            this.seenFor = false;
          } else {
            tag = 'RELATION';
            if (this.value() === '!') {
              poppedToken = this.tokens.pop();
              id = '!' + id;
            }
          }
        }
      }
      if (indexOf.call(JS_FORBIDDEN, id) >= 0) {
        if (forcedIdentifier) {
          tag = 'IDENTIFIER';
          id = new String(id);
          id.reserved = true;
        } else if (indexOf.call(RESERVED, id) >= 0) {
          this.error("reserved word '" + id + "'", {
            length: id.length
          });
        }
      }
      if (!forcedIdentifier) {
        if (indexOf.call(COFFEE_ALIASES, id) >= 0) {
          alias = id;
          id = COFFEE_ALIAS_MAP[id];
        }
        tag = (function() {
          switch (id) {
            case '!':
              return 'UNARY';
            case '==':
            case '!=':
              return 'COMPARE';
            case 'true':
            case 'false':
              return 'BOOL';
            case 'break':
            case 'continue':
              return 'STATEMENT';
            case '&&':
            case '||':
              return id;
            default:
              return tag;
          }
        })();
      }
      tagToken = this.token(tag, id, 0, idLength);
      if (alias) {
        tagToken.origin = [tag, alias, tagToken[2]];
      }
      tagToken.variable = !forcedIdentifier;
      if (poppedToken) {
        ref5 = [poppedToken[2].first_line, poppedToken[2].first_column], tagToken[2].first_line = ref5[0], tagToken[2].first_column = ref5[1];
      }
      if (colon) {
        colonOffset = input.lastIndexOf(':');
        this.token(':', ':', colonOffset, colon.length);
      }
      return input.length;
    };

    Lexer.prototype.numberToken = function() {
      var binaryLiteral, lexedLength, match, number, octalLiteral;
      if (!(match = NUMBER.exec(this.chunk))) {
        return 0;
      }
      number = match[0];
      lexedLength = number.length;
      if (/^0[BOX]/.test(number)) {
        this.error("radix prefix in '" + number + "' must be lowercase", {
          offset: 1
        });
      } else if (/E/.test(number) && !/^0x/.test(number)) {
        this.error("exponential notation in '" + number + "' must be indicated with a lowercase 'e'", {
          offset: number.indexOf('E')
        });
      } else if (/^0\d*[89]/.test(number)) {
        this.error("decimal literal '" + number + "' must not be prefixed with '0'", {
          length: lexedLength
        });
      } else if (/^0\d+/.test(number)) {
        this.error("octal literal '" + number + "' must be prefixed with '0o'", {
          length: lexedLength
        });
      }
      if (octalLiteral = /^0o([0-7]+)/.exec(number)) {
        number = '0x' + parseInt(octalLiteral[1], 8).toString(16);
      }
      if (binaryLiteral = /^0b([01]+)/.exec(number)) {
        number = '0x' + parseInt(binaryLiteral[1], 2).toString(16);
      }
      this.token('NUMBER', number, 0, lexedLength);
      return lexedLength;
    };

    Lexer.prototype.stringToken = function() {
      var $, attempt, delimiter, doc, end, heredoc, i, indent, indentRegex, match, quote, ref2, ref3, regex, token, tokens;
      quote = (STRING_START.exec(this.chunk) || [])[0];
      if (!quote) {
        return 0;
      }
      regex = (function() {
        switch (quote) {
          case "'":
            return STRING_SINGLE;
          case '"':
            return STRING_DOUBLE;
          case "'''":
            return HEREDOC_SINGLE;
          case '"""':
            return HEREDOC_DOUBLE;
        }
      })();
      heredoc = quote.length === 3;
      ref2 = this.matchWithInterpolations(regex, quote), tokens = ref2.tokens, end = ref2.index;
      $ = tokens.length - 1;
      delimiter = quote.charAt(0);
      if (heredoc) {
        indent = null;
        doc = ((function() {
          var j, len, results;
          results = [];
          for (i = j = 0, len = tokens.length; j < len; i = ++j) {
            token = tokens[i];
            if (token[0] === 'NEOSTRING') {
              results.push(token[1]);
            }
          }
          return results;
        })()).join('#{}');
        while (match = HEREDOC_INDENT.exec(doc)) {
          attempt = match[1];
          if (indent === null || (0 < (ref3 = attempt.length) && ref3 < indent.length)) {
            indent = attempt;
          }
        }
        if (indent) {
          indentRegex = RegExp("^" + indent, "gm");
        }
        this.mergeInterpolationTokens(tokens, {
          delimiter: delimiter
        }, (function(_this) {
          return function(value, i) {
            value = _this.formatString(value);
            if (i === 0) {
              value = value.replace(LEADING_BLANK_LINE, '');
            }
            if (i === $) {
              value = value.replace(TRAILING_BLANK_LINE, '');
            }
            if (indentRegex) {
              value = value.replace(indentRegex, '');
            }
            return value;
          };
        })(this));
      } else {
        this.mergeInterpolationTokens(tokens, {
          delimiter: delimiter
        }, (function(_this) {
          return function(value, i) {
            value = _this.formatString(value);
            value = value.replace(SIMPLE_STRING_OMIT, function(match, offset) {
              if ((i === 0 && offset === 0) || (i === $ && offset + match.length === value.length)) {
                return '';
              } else {
                return ' ';
              }
            });
            return value;
          };
        })(this));
      }
      return end;
    };

    Lexer.prototype.commentToken = function() {
      var comment, here, match;
      if (!(match = this.chunk.match(COMMENT))) {
        return 0;
      }
      comment = match[0], here = match[1];
      if (here) {
        if (match = HERECOMMENT_ILLEGAL.exec(comment)) {
          this.error("block comments cannot contain " + match[0], {
            offset: match.index,
            length: match[0].length
          });
        }
        if (here.indexOf('\n') >= 0) {
          here = here.replace(RegExp("\\n" + (repeat(' ', this.indent)), "g"), '\n');
        }
        this.token('HERECOMMENT', here, 0, comment.length);
      }
      return comment.length;
    };

    Lexer.prototype.jsToken = function() {
      var match, script;
      if (!(this.chunk.charAt(0) === '`' && (match = JSTOKEN.exec(this.chunk)))) {
        return 0;
      }
      this.token('JS', (script = match[0]).slice(1, -1), 0, script.length);
      return script.length;
    };

    Lexer.prototype.regexToken = function() {
      var body, closed, end, flags, index, match, origin, prev, ref2, ref3, ref4, regex, tokens;
      switch (false) {
        case !(match = REGEX_ILLEGAL.exec(this.chunk)):
          this.error("regular expressions cannot begin with " + match[2], {
            offset: match.index + match[1].length
          });
          break;
        case !(match = this.matchWithInterpolations(HEREGEX, '///')):
          tokens = match.tokens, index = match.index;
          break;
        case !(match = REGEX.exec(this.chunk)):
          regex = match[0], body = match[1], closed = match[2];
          this.validateEscapes(body, {
            isRegex: true,
            offsetInChunk: 1
          });
          index = regex.length;
          ref2 = this.tokens, prev = ref2[ref2.length - 1];
          if (prev) {
            if (prev.spaced && (ref3 = prev[0], indexOf.call(CALLABLE, ref3) >= 0)) {
              if (!closed || POSSIBLY_DIVISION.test(regex)) {
                return 0;
              }
            } else if (ref4 = prev[0], indexOf.call(NOT_REGEX, ref4) >= 0) {
              return 0;
            }
          }
          if (!closed) {
            this.error('missing / (unclosed regex)');
          }
          break;
        default:
          return 0;
      }
      flags = REGEX_FLAGS.exec(this.chunk.slice(index))[0];
      end = index + flags.length;
      origin = this.makeToken('REGEX', null, 0, end);
      switch (false) {
        case !!VALID_FLAGS.test(flags):
          this.error("invalid regular expression flags " + flags, {
            offset: index,
            length: flags.length
          });
          break;
        case !(regex || tokens.length === 1):
          if (body == null) {
            body = this.formatHeregex(tokens[0][1]);
          }
          this.token('REGEX', "" + (this.makeDelimitedLiteral(body, {
            delimiter: '/'
          })) + flags, 0, end, origin);
          break;
        default:
          this.token('REGEX_START', '(', 0, 0, origin);
          this.token('IDENTIFIER', 'RegExp', 0, 0);
          this.token('CALL_START', '(', 0, 0);
          this.mergeInterpolationTokens(tokens, {
            delimiter: '"',
            double: true
          }, this.formatHeregex);
          if (flags) {
            this.token(',', ',', index - 1, 0);
            this.token('STRING', '"' + flags + '"', index - 1, flags.length);
          }
          this.token(')', ')', end - 1, 0);
          this.token('REGEX_END', ')', end - 1, 0);
      }
      return end;
    };

    Lexer.prototype.lineToken = function() {
      var diff, indent, match, noNewlines, size;
      if (!(match = MULTI_DENT.exec(this.chunk))) {
        return 0;
      }
      indent = match[0];
      this.seenFor = false;
      size = indent.length - 1 - indent.lastIndexOf('\n');
      noNewlines = this.unfinished();
      if (size - this.indebt === this.indent) {
        if (noNewlines) {
          this.suppressNewlines();
        } else {
          this.newlineToken(0);
        }
        return indent.length;
      }
      if (size > this.indent) {
        if (noNewlines) {
          this.indebt = size - this.indent;
          this.suppressNewlines();
          return indent.length;
        }
        if (!this.tokens.length) {
          this.baseIndent = this.indent = size;
          return indent.length;
        }
        diff = size - this.indent + this.outdebt;
        this.token('INDENT', diff, indent.length - size, size);
        this.indents.push(diff);
        this.ends.push({
          tag: 'OUTDENT'
        });
        this.outdebt = this.indebt = 0;
        this.indent = size;
      } else if (size < this.baseIndent) {
        this.error('missing indentation', {
          offset: indent.length
        });
      } else {
        this.indebt = 0;
        this.outdentToken(this.indent - size, noNewlines, indent.length);
      }
      return indent.length;
    };

    Lexer.prototype.outdentToken = function(moveOut, noNewlines, outdentLength) {
      var decreasedIndent, dent, lastIndent, ref2;
      decreasedIndent = this.indent - moveOut;
      while (moveOut > 0) {
        lastIndent = this.indents[this.indents.length - 1];
        if (!lastIndent) {
          moveOut = 0;
        } else if (lastIndent === this.outdebt) {
          moveOut -= this.outdebt;
          this.outdebt = 0;
        } else if (lastIndent < this.outdebt) {
          this.outdebt -= lastIndent;
          moveOut -= lastIndent;
        } else {
          dent = this.indents.pop() + this.outdebt;
          if (outdentLength && (ref2 = this.chunk[outdentLength], indexOf.call(INDENTABLE_CLOSERS, ref2) >= 0)) {
            decreasedIndent -= dent - moveOut;
            moveOut = dent;
          }
          this.outdebt = 0;
          this.pair('OUTDENT');
          this.token('OUTDENT', moveOut, 0, outdentLength);
          moveOut -= dent;
        }
      }
      if (dent) {
        this.outdebt -= moveOut;
      }
      while (this.value() === ';') {
        this.tokens.pop();
      }
      if (!(this.tag() === 'TERMINATOR' || noNewlines)) {
        this.token('TERMINATOR', '\n', outdentLength, 0);
      }
      this.indent = decreasedIndent;
      return this;
    };

    Lexer.prototype.whitespaceToken = function() {
      var match, nline, prev, ref2;
      if (!((match = WHITESPACE.exec(this.chunk)) || (nline = this.chunk.charAt(0) === '\n'))) {
        return 0;
      }
      ref2 = this.tokens, prev = ref2[ref2.length - 1];
      if (prev) {
        prev[match ? 'spaced' : 'newLine'] = true;
      }
      if (match) {
        return match[0].length;
      } else {
        return 0;
      }
    };

    Lexer.prototype.newlineToken = function(offset) {
      while (this.value() === ';') {
        this.tokens.pop();
      }
      if (this.tag() !== 'TERMINATOR') {
        this.token('TERMINATOR', '\n', offset, 0);
      }
      return this;
    };

    Lexer.prototype.suppressNewlines = function() {
      if (this.value() === '\\') {
        this.tokens.pop();
      }
      return this;
    };

    Lexer.prototype.literalToken = function() {
      var match, prev, ref2, ref3, ref4, ref5, ref6, tag, token, value;
      if (match = OPERATOR.exec(this.chunk)) {
        value = match[0];
        if (CODE.test(value)) {
          this.tagParameters();
        }
      } else {
        value = this.chunk.charAt(0);
      }
      tag = value;
      ref2 = this.tokens, prev = ref2[ref2.length - 1];
      if (value === '=' && prev) {
        if (!prev[1].reserved && (ref3 = prev[1], indexOf.call(JS_FORBIDDEN, ref3) >= 0)) {
          if (prev.origin) {
            prev = prev.origin;
          }
          this.error("reserved word '" + prev[1] + "' can't be assigned", prev[2]);
        }
        if ((ref4 = prev[1]) === '||' || ref4 === '&&') {
          prev[0] = 'COMPOUND_ASSIGN';
          prev[1] += '=';
          return value.length;
        }
      }
      if (value === ';') {
        this.seenFor = false;
        tag = 'TERMINATOR';
      } else if (indexOf.call(MATH, value) >= 0) {
        tag = 'MATH';
      } else if (indexOf.call(COMPARE, value) >= 0) {
        tag = 'COMPARE';
      } else if (indexOf.call(COMPOUND_ASSIGN, value) >= 0) {
        tag = 'COMPOUND_ASSIGN';
      } else if (indexOf.call(UNARY, value) >= 0) {
        tag = 'UNARY';
      } else if (indexOf.call(UNARY_MATH, value) >= 0) {
        tag = 'UNARY_MATH';
      } else if (indexOf.call(SHIFT, value) >= 0) {
        tag = 'SHIFT';
      } else if (value === '?' && (prev != null ? prev.spaced : void 0)) {
        tag = 'BIN?';
      } else if (prev && !prev.spaced) {
        if (value === '(' && (ref5 = prev[0], indexOf.call(CALLABLE, ref5) >= 0)) {
          if (prev[0] === '?') {
            prev[0] = 'FUNC_EXIST';
          }
          tag = 'CALL_START';
        } else if (value === '[' && (ref6 = prev[0], indexOf.call(INDEXABLE, ref6) >= 0)) {
          tag = 'INDEX_START';
          switch (prev[0]) {
            case '?':
              prev[0] = 'INDEX_SOAK';
          }
        }
      }
      token = this.makeToken(tag, value);
      switch (value) {
        case '(':
        case '{':
        case '[':
          this.ends.push({
            tag: INVERSES[value],
            origin: token
          });
          break;
        case ')':
        case '}':
        case ']':
          this.pair(value);
      }
      this.tokens.push(token);
      return value.length;
    };

    Lexer.prototype.tagParameters = function() {
      var i, stack, tok, tokens;
      if (this.tag() !== ')') {
        return this;
      }
      stack = [];
      tokens = this.tokens;
      i = tokens.length;
      tokens[--i][0] = 'PARAM_END';
      while (tok = tokens[--i]) {
        switch (tok[0]) {
          case ')':
            stack.push(tok);
            break;
          case '(':
          case 'CALL_START':
            if (stack.length) {
              stack.pop();
            } else if (tok[0] === '(') {
              tok[0] = 'PARAM_START';
              return this;
            } else {
              return this;
            }
        }
      }
      return this;
    };

    Lexer.prototype.closeIndentation = function() {
      return this.outdentToken(this.indent);
    };

    Lexer.prototype.matchWithInterpolations = function(regex, delimiter) {
      var close, column, firstToken, index, lastToken, line, nested, offsetInChunk, open, ref2, ref3, ref4, str, strPart, tokens;
      tokens = [];
      offsetInChunk = delimiter.length;
      if (this.chunk.slice(0, offsetInChunk) !== delimiter) {
        return null;
      }
      str = this.chunk.slice(offsetInChunk);
      while (true) {
        strPart = regex.exec(str)[0];
        this.validateEscapes(strPart, {
          isRegex: delimiter.charAt(0) === '/',
          offsetInChunk: offsetInChunk
        });
        tokens.push(this.makeToken('NEOSTRING', strPart, offsetInChunk));
        str = str.slice(strPart.length);
        offsetInChunk += strPart.length;
        if (str.slice(0, 2) !== '#{') {
          break;
        }
        ref2 = this.getLineAndColumnFromChunk(offsetInChunk + 1), line = ref2[0], column = ref2[1];
        ref3 = new Lexer().tokenize(str.slice(1), {
          line: line,
          column: column,
          untilBalanced: true
        }), nested = ref3.tokens, index = ref3.index;
        index += 1;
        open = nested[0], close = nested[nested.length - 1];
        open[0] = open[1] = '(';
        close[0] = close[1] = ')';
        close.origin = ['', 'end of interpolation', close[2]];
        if (((ref4 = nested[1]) != null ? ref4[0] : void 0) === 'TERMINATOR') {
          nested.splice(1, 1);
        }
        tokens.push(['TOKENS', nested]);
        str = str.slice(index);
        offsetInChunk += index;
      }
      if (str.slice(0, delimiter.length) !== delimiter) {
        this.error("missing " + delimiter, {
          length: delimiter.length
        });
      }
      firstToken = tokens[0], lastToken = tokens[tokens.length - 1];
      firstToken[2].first_column -= delimiter.length;
      if (lastToken[1].substr(-1) === '\n') {
        lastToken[2].last_line += 1;
        lastToken[2].last_column = delimiter.length - 1;
      } else {
        lastToken[2].last_column += delimiter.length;
      }
      if (lastToken[1].length === 0) {
        lastToken[2].last_column -= 1;
      }
      return {
        tokens: tokens,
        index: offsetInChunk + delimiter.length
      };
    };

    Lexer.prototype.mergeInterpolationTokens = function(tokens, options, fn) {
      var converted, firstEmptyStringIndex, firstIndex, i, j, lastToken, len, locationToken, lparen, plusToken, ref2, rparen, tag, token, tokensToPush, value;
      if (tokens.length > 1) {
        lparen = this.token('STRING_START', '(', 0, 0);
      }
      firstIndex = this.tokens.length;
      for (i = j = 0, len = tokens.length; j < len; i = ++j) {
        token = tokens[i];
        tag = token[0], value = token[1];
        switch (tag) {
          case 'TOKENS':
            if (value.length === 2) {
              continue;
            }
            locationToken = value[0];
            tokensToPush = value;
            break;
          case 'NEOSTRING':
            converted = fn(token[1], i);
            if (converted.length === 0) {
              if (i === 0) {
                firstEmptyStringIndex = this.tokens.length;
              } else {
                continue;
              }
            }
            if (i === 2 && (firstEmptyStringIndex != null)) {
              this.tokens.splice(firstEmptyStringIndex, 2);
            }
            token[0] = 'STRING';
            token[1] = this.makeDelimitedLiteral(converted, options);
            locationToken = token;
            tokensToPush = [token];
        }
        if (this.tokens.length > firstIndex) {
          plusToken = this.token('+', '+');
          plusToken[2] = {
            first_line: locationToken[2].first_line,
            first_column: locationToken[2].first_column,
            last_line: locationToken[2].first_line,
            last_column: locationToken[2].first_column
          };
        }
        (ref2 = this.tokens).push.apply(ref2, tokensToPush);
      }
      if (lparen) {
        lastToken = tokens[tokens.length - 1];
        lparen.origin = [
          'STRING', null, {
            first_line: lparen[2].first_line,
            first_column: lparen[2].first_column,
            last_line: lastToken[2].last_line,
            last_column: lastToken[2].last_column
          }
        ];
        rparen = this.token('STRING_END', ')');
        return rparen[2] = {
          first_line: lastToken[2].last_line,
          first_column: lastToken[2].last_column,
          last_line: lastToken[2].last_line,
          last_column: lastToken[2].last_column
        };
      }
    };

    Lexer.prototype.pair = function(tag) {
      var lastIndent, prev, ref2, ref3, wanted;
      ref2 = this.ends, prev = ref2[ref2.length - 1];
      if (tag !== (wanted = prev != null ? prev.tag : void 0)) {
        if ('OUTDENT' !== wanted) {
          this.error("unmatched " + tag);
        }
        ref3 = this.indents, lastIndent = ref3[ref3.length - 1];
        this.outdentToken(lastIndent, true);
        return this.pair(tag);
      }
      return this.ends.pop();
    };

    Lexer.prototype.getLineAndColumnFromChunk = function(offset) {
      var column, lastLine, lineCount, ref2, string;
      if (offset === 0) {
        return [this.chunkLine, this.chunkColumn];
      }
      if (offset >= this.chunk.length) {
        string = this.chunk;
      } else {
        string = this.chunk.slice(0, +(offset - 1) + 1 || 9e9);
      }
      lineCount = count(string, '\n');
      column = this.chunkColumn;
      if (lineCount > 0) {
        ref2 = string.split('\n'), lastLine = ref2[ref2.length - 1];
        column = lastLine.length;
      } else {
        column += string.length;
      }
      return [this.chunkLine + lineCount, column];
    };

    Lexer.prototype.makeToken = function(tag, value, offsetInChunk, length) {
      var lastCharacter, locationData, ref2, ref3, token;
      if (offsetInChunk == null) {
        offsetInChunk = 0;
      }
      if (length == null) {
        length = value.length;
      }
      locationData = {};
      ref2 = this.getLineAndColumnFromChunk(offsetInChunk), locationData.first_line = ref2[0], locationData.first_column = ref2[1];
      lastCharacter = length > 0 ? length - 1 : 0;
      ref3 = this.getLineAndColumnFromChunk(offsetInChunk + lastCharacter), locationData.last_line = ref3[0], locationData.last_column = ref3[1];
      token = [tag, value, locationData];
      return token;
    };

    Lexer.prototype.token = function(tag, value, offsetInChunk, length, origin) {
      var token;
      token = this.makeToken(tag, value, offsetInChunk, length);
      if (origin) {
        token.origin = origin;
      }
      this.tokens.push(token);
      return token;
    };

    Lexer.prototype.tag = function() {
      var ref2, token;
      ref2 = this.tokens, token = ref2[ref2.length - 1];
      return token != null ? token[0] : void 0;
    };

    Lexer.prototype.value = function() {
      var ref2, token;
      ref2 = this.tokens, token = ref2[ref2.length - 1];
      return token != null ? token[1] : void 0;
    };

    Lexer.prototype.unfinished = function() {
      var ref2;
      return LINE_CONTINUER.test(this.chunk) || ((ref2 = this.tag()) === '\\' || ref2 === '.' || ref2 === '?.' || ref2 === '?::' || ref2 === 'UNARY' || ref2 === 'MATH' || ref2 === 'UNARY_MATH' || ref2 === '+' || ref2 === '-' || ref2 === 'YIELD' || ref2 === '**' || ref2 === 'SHIFT' || ref2 === 'RELATION' || ref2 === 'COMPARE' || ref2 === '&' || ref2 === '^' || ref2 === '|' || ref2 === '&&' || ref2 === '||' || ref2 === 'BIN?' || ref2 === 'THROW' || ref2 === 'EXTENDS');
    };

    Lexer.prototype.formatString = function(str) {
      return str.replace(STRING_OMIT, '$1');
    };

    Lexer.prototype.formatHeregex = function(str) {
      return str.replace(HEREGEX_OMIT, '$1$2');
    };

    Lexer.prototype.validateEscapes = function(str, options) {
      var before, hex, invalidEscape, match, message, octal, ref2, unicode;
      if (options == null) {
        options = {};
      }
      match = INVALID_ESCAPE.exec(str);
      if (!match) {
        return;
      }
      match[0], before = match[1], octal = match[2], hex = match[3], unicode = match[4];
      if (options.isRegex && octal && octal.charAt(0) !== '0') {
        return;
      }
      message = octal ? "octal escape sequences are not allowed" : "invalid escape sequence";
      invalidEscape = "\\" + (octal || hex || unicode);
      return this.error(message + " " + invalidEscape, {
        offset: ((ref2 = options.offsetInChunk) != null ? ref2 : 0) + match.index + before.length,
        length: invalidEscape.length
      });
    };

    Lexer.prototype.makeDelimitedLiteral = function(body, options) {
      var regex;
      if (options == null) {
        options = {};
      }
      if (body === '' && options.delimiter === '/') {
        body = '(?:)';
      }
      regex = RegExp("(\\\\\\\\)|(\\\\0(?=[1-7]))|\\\\?(" + options.delimiter + ")|\\\\?(?:(\\n)|(\\r)|(\\u2028)|(\\u2029))|(\\\\.)", "g");
      body = body.replace(regex, function(match, backslash, nul, delimiter, lf, cr, ls, ps, other) {
        switch (false) {
          case !backslash:
            if (options.double) {
              return backslash + backslash;
            } else {
              return backslash;
            }
          case !nul:
            return '\\x00';
          case !delimiter:
            return "\\" + delimiter;
          case !lf:
            return '\\n';
          case !cr:
            return '\\r';
          case !ls:
            return '\\u2028';
          case !ps:
            return '\\u2029';
          case !other:
            if (options.double) {
              return "\\" + other;
            } else {
              return other;
            }
        }
      });
      return "" + options.delimiter + body + options.delimiter;
    };

    Lexer.prototype.error = function(message, options) {
      var first_column, first_line, location, ref2, ref3, ref4;
      if (options == null) {
        options = {};
      }
      location = 'first_line' in options ? options : ((ref3 = this.getLineAndColumnFromChunk((ref2 = options.offset) != null ? ref2 : 0), first_line = ref3[0], first_column = ref3[1], ref3), {
        first_line: first_line,
        first_column: first_column,
        last_column: first_column + ((ref4 = options.length) != null ? ref4 : 1) - 1
      });
      return throwSyntaxError(message, location);
    };

    return Lexer;

  })();

  JS_KEYWORDS = ['true', 'false', 'null', 'this', 'new', 'delete', 'typeof', 'in', 'instanceof', 'return', 'throw', 'break', 'continue', 'debugger', 'yield', 'if', 'else', 'switch', 'for', 'while', 'do', 'try', 'catch', 'finally', 'class', 'extends', 'super'];

  COFFEE_KEYWORDS = ['undefined', 'then', 'unless', 'until', 'loop', 'of', 'by', 'when'];

  COFFEE_ALIAS_MAP = {
    and: '&&',
    or: '||',
    is: '==',
    isnt: '!=',
    not: '!',
    yes: 'true',
    no: 'false',
    on: 'true',
    off: 'false'
  };

  COFFEE_ALIASES = (function() {
    var results;
    results = [];
    for (key in COFFEE_ALIAS_MAP) {
      results.push(key);
    }
    return results;
  })();

  COFFEE_KEYWORDS = COFFEE_KEYWORDS.concat(COFFEE_ALIASES);

  RESERVED = ['case', 'default', 'function', 'var', 'void', 'with', 'const', 'let', 'enum', 'export', 'import', 'native', 'implements', 'interface', 'package', 'private', 'protected', 'public', 'static'];

  STRICT_PROSCRIBED = ['arguments', 'eval', 'yield*'];

  JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED).concat(STRICT_PROSCRIBED);

  exports.RESERVED = RESERVED.concat(JS_KEYWORDS).concat(COFFEE_KEYWORDS).concat(STRICT_PROSCRIBED);

  exports.STRICT_PROSCRIBED = STRICT_PROSCRIBED;

  BOM = 65279;

  IDENTIFIER = /^(?!\d)((?:(?!\s)[$\w\x7f-\uffff])+)([^\n\S]*:(?!:))?/;

  NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\da-f]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;

  OPERATOR = /^(?:[-=]>|[-+*\/%<>&|^!?=]=|>>>=?|([-+:])\1|([&|<>*\/%])\2=?|\?(\.|::)|\.{2,3})/;

  WHITESPACE = /^[^\n\S]+/;

  COMMENT = /^###([^#][\s\S]*?)(?:###[^\n\S]*|###$)|^(?:\s*#(?!##[^#]).*)+/;

  CODE = /^[-=]>/;

  MULTI_DENT = /^(?:\n[^\n\S]*)+/;

  JSTOKEN = /^`[^\\`]*(?:\\.[^\\`]*)*`/;

  STRING_START = /^(?:'''|"""|'|")/;

  STRING_SINGLE = /^(?:[^\\']|\\[\s\S])*/;

  STRING_DOUBLE = /^(?:[^\\"#]|\\[\s\S]|\#(?!\{))*/;

  HEREDOC_SINGLE = /^(?:[^\\']|\\[\s\S]|'(?!''))*/;

  HEREDOC_DOUBLE = /^(?:[^\\"#]|\\[\s\S]|"(?!"")|\#(?!\{))*/;

  STRING_OMIT = /((?:\\\\)+)|\\[^\S\n]*\n\s*/g;

  SIMPLE_STRING_OMIT = /\s*\n\s*/g;

  HEREDOC_INDENT = /\n+([^\n\S]*)(?=\S)/g;

  REGEX = /^\/(?!\/)((?:[^[\/\n\\]|\\[^\n]|\[(?:\\[^\n]|[^\]\n\\])*\])*)(\/)?/;

  REGEX_FLAGS = /^\w*/;

  VALID_FLAGS = /^(?!.*(.).*\1)[imgy]*$/;

  HEREGEX = /^(?:[^\\\/#]|\\[\s\S]|\/(?!\/\/)|\#(?!\{))*/;

  HEREGEX_OMIT = /((?:\\\\)+)|\\(\s)|\s+(?:#.*)?/g;

  REGEX_ILLEGAL = /^(\/|\/{3}\s*)(\*)/;

  POSSIBLY_DIVISION = /^\/=?\s/;

  HERECOMMENT_ILLEGAL = /\*\//;

  LINE_CONTINUER = /^\s*(?:,|\??\.(?![.\d])|::)/;

  INVALID_ESCAPE = /((?:^|[^\\])(?:\\\\)*)\\(?:(0[0-7]|[1-7])|(x(?![\da-fA-F]{2}).{0,2})|(u(?![\da-fA-F]{4}).{0,4}))/;

  LEADING_BLANK_LINE = /^[^\n\S]*\n/;

  TRAILING_BLANK_LINE = /\n[^\n\S]*$/;

  TRAILING_SPACES = /\s+$/;

  COMPOUND_ASSIGN = ['-=', '+=', '/=', '*=', '%=', '||=', '&&=', '?=', '<<=', '>>=', '>>>=', '&=', '^=', '|=', '**=', '//=', '%%='];

  UNARY = ['NEW', 'TYPEOF', 'DELETE', 'DO'];

  UNARY_MATH = ['!', '~'];

  SHIFT = ['<<', '>>', '>>>'];

  COMPARE = ['==', '!=', '<', '>', '<=', '>='];

  MATH = ['*', '/', '%', '//', '%%'];

  RELATION = ['IN', 'OF', 'INSTANCEOF'];

  BOOL = ['TRUE', 'FALSE'];

  CALLABLE = ['IDENTIFIER', ')', ']', '?', '@', 'THIS', 'SUPER'];

  INDEXABLE = CALLABLE.concat(['NUMBER', 'STRING', 'STRING_END', 'REGEX', 'REGEX_END', 'BOOL', 'NULL', 'UNDEFINED', '}', '::']);

  NOT_REGEX = INDEXABLE.concat(['++', '--']);

  LINE_BREAK = ['INDENT', 'OUTDENT', 'TERMINATOR'];

  INDENTABLE_CLOSERS = [')', '}', ']'];

}).call(this);

},{"./helpers":180,"./rewriter":185}],182:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var Access, Arr, Assign, Base, Block, Call, Class, Code, CodeFragment, Comment, Existence, Expansion, Extends, For, HEXNUM, IDENTIFIER, IS_REGEX, IS_STRING, If, In, Index, LEVEL_ACCESS, LEVEL_COND, LEVEL_LIST, LEVEL_OP, LEVEL_PAREN, LEVEL_TOP, Literal, NEGATE, NO, NUMBER, Obj, Op, Param, Parens, RESERVED, Range, Return, SIMPLENUM, STRICT_PROSCRIBED, Scope, Slice, Splat, Switch, TAB, THIS, Throw, Try, UTILITIES, Value, While, YES, addLocationDataFn, compact, del, ends, extend, flatten, fragmentsToText, isComplexOrAssignable, isLiteralArguments, isLiteralThis, locationDataToString, merge, multident, parseNum, ref1, ref2, some, starts, throwSyntaxError, unfoldSoak, utility,
    extend1 = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  Error.stackTraceLimit = Infinity;

  Scope = require('./scope').Scope;

  ref1 = require('./lexer'), RESERVED = ref1.RESERVED, STRICT_PROSCRIBED = ref1.STRICT_PROSCRIBED;

  ref2 = require('./helpers'), compact = ref2.compact, flatten = ref2.flatten, extend = ref2.extend, merge = ref2.merge, del = ref2.del, starts = ref2.starts, ends = ref2.ends, some = ref2.some, addLocationDataFn = ref2.addLocationDataFn, locationDataToString = ref2.locationDataToString, throwSyntaxError = ref2.throwSyntaxError;

  exports.extend = extend;

  exports.addLocationDataFn = addLocationDataFn;

  YES = function() {
    return true;
  };

  NO = function() {
    return false;
  };

  THIS = function() {
    return this;
  };

  NEGATE = function() {
    this.negated = !this.negated;
    return this;
  };

  exports.CodeFragment = CodeFragment = (function() {
    function CodeFragment(parent, code) {
      var ref3;
      this.code = "" + code;
      this.locationData = parent != null ? parent.locationData : void 0;
      this.type = (parent != null ? (ref3 = parent.constructor) != null ? ref3.name : void 0 : void 0) || 'unknown';
    }

    CodeFragment.prototype.toString = function() {
      return "" + this.code + (this.locationData ? ": " + locationDataToString(this.locationData) : '');
    };

    return CodeFragment;

  })();

  fragmentsToText = function(fragments) {
    var fragment;
    return ((function() {
      var j, len1, results;
      results = [];
      for (j = 0, len1 = fragments.length; j < len1; j++) {
        fragment = fragments[j];
        results.push(fragment.code);
      }
      return results;
    })()).join('');
  };

  exports.Base = Base = (function() {
    function Base() {}

    Base.prototype.compile = function(o, lvl) {
      return fragmentsToText(this.compileToFragments(o, lvl));
    };

    Base.prototype.compileToFragments = function(o, lvl) {
      var node;
      o = extend({}, o);
      if (lvl) {
        o.level = lvl;
      }
      node = this.unfoldSoak(o) || this;
      node.tab = o.indent;
      if (o.level === LEVEL_TOP || !node.isStatement(o)) {
        return node.compileNode(o);
      } else {
        return node.compileClosure(o);
      }
    };

    Base.prototype.compileClosure = function(o) {
      var args, argumentsNode, func, jumpNode, meth, parts, ref3;
      if (jumpNode = this.jumps()) {
        jumpNode.error('cannot use a pure statement in an expression');
      }
      o.sharedScope = true;
      func = new Code([], Block.wrap([this]));
      args = [];
      if ((argumentsNode = this.contains(isLiteralArguments)) || this.contains(isLiteralThis)) {
        args = [new Literal('this')];
        if (argumentsNode) {
          meth = 'apply';
          args.push(new Literal('arguments'));
        } else {
          meth = 'call';
        }
        func = new Value(func, [new Access(new Literal(meth))]);
      }
      parts = (new Call(func, args)).compileNode(o);
      if (func.isGenerator || ((ref3 = func.base) != null ? ref3.isGenerator : void 0)) {
        parts.unshift(this.makeCode("(yield* "));
        parts.push(this.makeCode(")"));
      }
      return parts;
    };

    Base.prototype.cache = function(o, level, isComplex) {
      var complex, ref, sub;
      complex = isComplex != null ? isComplex(this) : this.isComplex();
      if (complex) {
        ref = new Literal(o.scope.freeVariable('ref'));
        sub = new Assign(ref, this);
        if (level) {
          return [sub.compileToFragments(o, level), [this.makeCode(ref.value)]];
        } else {
          return [sub, ref];
        }
      } else {
        ref = level ? this.compileToFragments(o, level) : this;
        return [ref, ref];
      }
    };

    Base.prototype.cacheToCodeFragments = function(cacheValues) {
      return [fragmentsToText(cacheValues[0]), fragmentsToText(cacheValues[1])];
    };

    Base.prototype.makeReturn = function(res) {
      var me;
      me = this.unwrapAll();
      if (res) {
        return new Call(new Literal(res + ".push"), [me]);
      } else {
        return new Return(me);
      }
    };

    Base.prototype.contains = function(pred) {
      var node;
      node = void 0;
      this.traverseChildren(false, function(n) {
        if (pred(n)) {
          node = n;
          return false;
        }
      });
      return node;
    };

    Base.prototype.lastNonComment = function(list) {
      var i;
      i = list.length;
      while (i--) {
        if (!(list[i] instanceof Comment)) {
          return list[i];
        }
      }
      return null;
    };

    Base.prototype.toString = function(idt, name) {
      var tree;
      if (idt == null) {
        idt = '';
      }
      if (name == null) {
        name = this.constructor.name;
      }
      tree = '\n' + idt + name;
      if (this.soak) {
        tree += '?';
      }
      this.eachChild(function(node) {
        return tree += node.toString(idt + TAB);
      });
      return tree;
    };

    Base.prototype.eachChild = function(func) {
      var attr, child, j, k, len1, len2, ref3, ref4;
      if (!this.children) {
        return this;
      }
      ref3 = this.children;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        attr = ref3[j];
        if (this[attr]) {
          ref4 = flatten([this[attr]]);
          for (k = 0, len2 = ref4.length; k < len2; k++) {
            child = ref4[k];
            if (func(child) === false) {
              return this;
            }
          }
        }
      }
      return this;
    };

    Base.prototype.traverseChildren = function(crossScope, func) {
      return this.eachChild(function(child) {
        var recur;
        recur = func(child);
        if (recur !== false) {
          return child.traverseChildren(crossScope, func);
        }
      });
    };

    Base.prototype.invert = function() {
      return new Op('!', this);
    };

    Base.prototype.unwrapAll = function() {
      var node;
      node = this;
      while (node !== (node = node.unwrap())) {
        continue;
      }
      return node;
    };

    Base.prototype.children = [];

    Base.prototype.isStatement = NO;

    Base.prototype.jumps = NO;

    Base.prototype.isComplex = YES;

    Base.prototype.isChainable = NO;

    Base.prototype.isAssignable = NO;

    Base.prototype.unwrap = THIS;

    Base.prototype.unfoldSoak = NO;

    Base.prototype.assigns = NO;

    Base.prototype.updateLocationDataIfMissing = function(locationData) {
      if (this.locationData) {
        return this;
      }
      this.locationData = locationData;
      return this.eachChild(function(child) {
        return child.updateLocationDataIfMissing(locationData);
      });
    };

    Base.prototype.error = function(message) {
      return throwSyntaxError(message, this.locationData);
    };

    Base.prototype.makeCode = function(code) {
      return new CodeFragment(this, code);
    };

    Base.prototype.wrapInBraces = function(fragments) {
      return [].concat(this.makeCode('('), fragments, this.makeCode(')'));
    };

    Base.prototype.joinFragmentArrays = function(fragmentsList, joinStr) {
      var answer, fragments, i, j, len1;
      answer = [];
      for (i = j = 0, len1 = fragmentsList.length; j < len1; i = ++j) {
        fragments = fragmentsList[i];
        if (i) {
          answer.push(this.makeCode(joinStr));
        }
        answer = answer.concat(fragments);
      }
      return answer;
    };

    return Base;

  })();

  exports.Block = Block = (function(superClass1) {
    extend1(Block, superClass1);

    function Block(nodes) {
      this.expressions = compact(flatten(nodes || []));
    }

    Block.prototype.children = ['expressions'];

    Block.prototype.push = function(node) {
      this.expressions.push(node);
      return this;
    };

    Block.prototype.pop = function() {
      return this.expressions.pop();
    };

    Block.prototype.unshift = function(node) {
      this.expressions.unshift(node);
      return this;
    };

    Block.prototype.unwrap = function() {
      if (this.expressions.length === 1) {
        return this.expressions[0];
      } else {
        return this;
      }
    };

    Block.prototype.isEmpty = function() {
      return !this.expressions.length;
    };

    Block.prototype.isStatement = function(o) {
      var exp, j, len1, ref3;
      ref3 = this.expressions;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        exp = ref3[j];
        if (exp.isStatement(o)) {
          return true;
        }
      }
      return false;
    };

    Block.prototype.jumps = function(o) {
      var exp, j, jumpNode, len1, ref3;
      ref3 = this.expressions;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        exp = ref3[j];
        if (jumpNode = exp.jumps(o)) {
          return jumpNode;
        }
      }
    };

    Block.prototype.makeReturn = function(res) {
      var expr, len;
      len = this.expressions.length;
      while (len--) {
        expr = this.expressions[len];
        if (!(expr instanceof Comment)) {
          this.expressions[len] = expr.makeReturn(res);
          if (expr instanceof Return && !expr.expression) {
            this.expressions.splice(len, 1);
          }
          break;
        }
      }
      return this;
    };

    Block.prototype.compileToFragments = function(o, level) {
      if (o == null) {
        o = {};
      }
      if (o.scope) {
        return Block.__super__.compileToFragments.call(this, o, level);
      } else {
        return this.compileRoot(o);
      }
    };

    Block.prototype.compileNode = function(o) {
      var answer, compiledNodes, fragments, index, j, len1, node, ref3, top;
      this.tab = o.indent;
      top = o.level === LEVEL_TOP;
      compiledNodes = [];
      ref3 = this.expressions;
      for (index = j = 0, len1 = ref3.length; j < len1; index = ++j) {
        node = ref3[index];
        node = node.unwrapAll();
        node = node.unfoldSoak(o) || node;
        if (node instanceof Block) {
          compiledNodes.push(node.compileNode(o));
        } else if (top) {
          node.front = true;
          fragments = node.compileToFragments(o);
          if (!node.isStatement(o)) {
            fragments.unshift(this.makeCode("" + this.tab));
            fragments.push(this.makeCode(";"));
          }
          compiledNodes.push(fragments);
        } else {
          compiledNodes.push(node.compileToFragments(o, LEVEL_LIST));
        }
      }
      if (top) {
        if (this.spaced) {
          return [].concat(this.joinFragmentArrays(compiledNodes, '\n\n'), this.makeCode("\n"));
        } else {
          return this.joinFragmentArrays(compiledNodes, '\n');
        }
      }
      if (compiledNodes.length) {
        answer = this.joinFragmentArrays(compiledNodes, ', ');
      } else {
        answer = [this.makeCode("void 0")];
      }
      if (compiledNodes.length > 1 && o.level >= LEVEL_LIST) {
        return this.wrapInBraces(answer);
      } else {
        return answer;
      }
    };

    Block.prototype.compileRoot = function(o) {
      var exp, fragments, i, j, len1, name, prelude, preludeExps, ref3, ref4, rest;
      o.indent = o.bare ? '' : TAB;
      o.level = LEVEL_TOP;
      this.spaced = true;
      o.scope = new Scope(null, this, null, (ref3 = o.referencedVars) != null ? ref3 : []);
      ref4 = o.locals || [];
      for (j = 0, len1 = ref4.length; j < len1; j++) {
        name = ref4[j];
        o.scope.parameter(name);
      }
      prelude = [];
      if (!o.bare) {
        preludeExps = (function() {
          var k, len2, ref5, results;
          ref5 = this.expressions;
          results = [];
          for (i = k = 0, len2 = ref5.length; k < len2; i = ++k) {
            exp = ref5[i];
            if (!(exp.unwrap() instanceof Comment)) {
              break;
            }
            results.push(exp);
          }
          return results;
        }).call(this);
        rest = this.expressions.slice(preludeExps.length);
        this.expressions = preludeExps;
        if (preludeExps.length) {
          prelude = this.compileNode(merge(o, {
            indent: ''
          }));
          prelude.push(this.makeCode("\n"));
        }
        this.expressions = rest;
      }
      fragments = this.compileWithDeclarations(o);
      if (o.bare) {
        return fragments;
      }
      return [].concat(prelude, this.makeCode("(function() {\n"), fragments, this.makeCode("\n}).call(this);\n"));
    };

    Block.prototype.compileWithDeclarations = function(o) {
      var assigns, declars, exp, fragments, i, j, len1, post, ref3, ref4, ref5, rest, scope, spaced;
      fragments = [];
      post = [];
      ref3 = this.expressions;
      for (i = j = 0, len1 = ref3.length; j < len1; i = ++j) {
        exp = ref3[i];
        exp = exp.unwrap();
        if (!(exp instanceof Comment || exp instanceof Literal)) {
          break;
        }
      }
      o = merge(o, {
        level: LEVEL_TOP
      });
      if (i) {
        rest = this.expressions.splice(i, 9e9);
        ref4 = [this.spaced, false], spaced = ref4[0], this.spaced = ref4[1];
        ref5 = [this.compileNode(o), spaced], fragments = ref5[0], this.spaced = ref5[1];
        this.expressions = rest;
      }
      post = this.compileNode(o);
      scope = o.scope;
      if (scope.expressions === this) {
        declars = o.scope.hasDeclarations();
        assigns = scope.hasAssignments;
        if (declars || assigns) {
          if (i) {
            fragments.push(this.makeCode('\n'));
          }
          fragments.push(this.makeCode(this.tab + "var "));
          if (declars) {
            fragments.push(this.makeCode(scope.declaredVariables().join(', ')));
          }
          if (assigns) {
            if (declars) {
              fragments.push(this.makeCode(",\n" + (this.tab + TAB)));
            }
            fragments.push(this.makeCode(scope.assignedVariables().join(",\n" + (this.tab + TAB))));
          }
          fragments.push(this.makeCode(";\n" + (this.spaced ? '\n' : '')));
        } else if (fragments.length && post.length) {
          fragments.push(this.makeCode("\n"));
        }
      }
      return fragments.concat(post);
    };

    Block.wrap = function(nodes) {
      if (nodes.length === 1 && nodes[0] instanceof Block) {
        return nodes[0];
      }
      return new Block(nodes);
    };

    return Block;

  })(Base);

  exports.Literal = Literal = (function(superClass1) {
    extend1(Literal, superClass1);

    function Literal(value1) {
      this.value = value1;
    }

    Literal.prototype.makeReturn = function() {
      if (this.isStatement()) {
        return this;
      } else {
        return Literal.__super__.makeReturn.apply(this, arguments);
      }
    };

    Literal.prototype.isAssignable = function() {
      return IDENTIFIER.test(this.value);
    };

    Literal.prototype.isStatement = function() {
      var ref3;
      return (ref3 = this.value) === 'break' || ref3 === 'continue' || ref3 === 'debugger';
    };

    Literal.prototype.isComplex = NO;

    Literal.prototype.assigns = function(name) {
      return name === this.value;
    };

    Literal.prototype.jumps = function(o) {
      if (this.value === 'break' && !((o != null ? o.loop : void 0) || (o != null ? o.block : void 0))) {
        return this;
      }
      if (this.value === 'continue' && !(o != null ? o.loop : void 0)) {
        return this;
      }
    };

    Literal.prototype.compileNode = function(o) {
      var answer, code, ref3;
      code = this.value === 'this' ? ((ref3 = o.scope.method) != null ? ref3.bound : void 0) ? o.scope.method.context : this.value : this.value.reserved ? "\"" + this.value + "\"" : this.value;
      answer = this.isStatement() ? "" + this.tab + code + ";" : code;
      return [this.makeCode(answer)];
    };

    Literal.prototype.toString = function() {
      return ' "' + this.value + '"';
    };

    return Literal;

  })(Base);

  exports.Undefined = (function(superClass1) {
    extend1(Undefined, superClass1);

    function Undefined() {
      return Undefined.__super__.constructor.apply(this, arguments);
    }

    Undefined.prototype.isAssignable = NO;

    Undefined.prototype.isComplex = NO;

    Undefined.prototype.compileNode = function(o) {
      return [this.makeCode(o.level >= LEVEL_ACCESS ? '(void 0)' : 'void 0')];
    };

    return Undefined;

  })(Base);

  exports.Null = (function(superClass1) {
    extend1(Null, superClass1);

    function Null() {
      return Null.__super__.constructor.apply(this, arguments);
    }

    Null.prototype.isAssignable = NO;

    Null.prototype.isComplex = NO;

    Null.prototype.compileNode = function() {
      return [this.makeCode("null")];
    };

    return Null;

  })(Base);

  exports.Bool = (function(superClass1) {
    extend1(Bool, superClass1);

    Bool.prototype.isAssignable = NO;

    Bool.prototype.isComplex = NO;

    Bool.prototype.compileNode = function() {
      return [this.makeCode(this.val)];
    };

    function Bool(val1) {
      this.val = val1;
    }

    return Bool;

  })(Base);

  exports.Return = Return = (function(superClass1) {
    extend1(Return, superClass1);

    function Return(expression) {
      this.expression = expression;
    }

    Return.prototype.children = ['expression'];

    Return.prototype.isStatement = YES;

    Return.prototype.makeReturn = THIS;

    Return.prototype.jumps = THIS;

    Return.prototype.compileToFragments = function(o, level) {
      var expr, ref3;
      expr = (ref3 = this.expression) != null ? ref3.makeReturn() : void 0;
      if (expr && !(expr instanceof Return)) {
        return expr.compileToFragments(o, level);
      } else {
        return Return.__super__.compileToFragments.call(this, o, level);
      }
    };

    Return.prototype.compileNode = function(o) {
      var answer, exprIsYieldReturn, ref3;
      answer = [];
      exprIsYieldReturn = (ref3 = this.expression) != null ? typeof ref3.isYieldReturn === "function" ? ref3.isYieldReturn() : void 0 : void 0;
      if (!exprIsYieldReturn) {
        answer.push(this.makeCode(this.tab + ("return" + (this.expression ? " " : ""))));
      }
      if (this.expression) {
        answer = answer.concat(this.expression.compileToFragments(o, LEVEL_PAREN));
      }
      if (!exprIsYieldReturn) {
        answer.push(this.makeCode(";"));
      }
      return answer;
    };

    return Return;

  })(Base);

  exports.Value = Value = (function(superClass1) {
    extend1(Value, superClass1);

    function Value(base, props, tag) {
      if (!props && base instanceof Value) {
        return base;
      }
      this.base = base;
      this.properties = props || [];
      if (tag) {
        this[tag] = true;
      }
      return this;
    }

    Value.prototype.children = ['base', 'properties'];

    Value.prototype.add = function(props) {
      this.properties = this.properties.concat(props);
      return this;
    };

    Value.prototype.hasProperties = function() {
      return !!this.properties.length;
    };

    Value.prototype.bareLiteral = function(type) {
      return !this.properties.length && this.base instanceof type;
    };

    Value.prototype.isArray = function() {
      return this.bareLiteral(Arr);
    };

    Value.prototype.isRange = function() {
      return this.bareLiteral(Range);
    };

    Value.prototype.isComplex = function() {
      return this.hasProperties() || this.base.isComplex();
    };

    Value.prototype.isAssignable = function() {
      return this.hasProperties() || this.base.isAssignable();
    };

    Value.prototype.isSimpleNumber = function() {
      return this.bareLiteral(Literal) && SIMPLENUM.test(this.base.value);
    };

    Value.prototype.isString = function() {
      return this.bareLiteral(Literal) && IS_STRING.test(this.base.value);
    };

    Value.prototype.isRegex = function() {
      return this.bareLiteral(Literal) && IS_REGEX.test(this.base.value);
    };

    Value.prototype.isAtomic = function() {
      var j, len1, node, ref3;
      ref3 = this.properties.concat(this.base);
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        node = ref3[j];
        if (node.soak || node instanceof Call) {
          return false;
        }
      }
      return true;
    };

    Value.prototype.isNotCallable = function() {
      return this.isSimpleNumber() || this.isString() || this.isRegex() || this.isArray() || this.isRange() || this.isSplice() || this.isObject();
    };

    Value.prototype.isStatement = function(o) {
      return !this.properties.length && this.base.isStatement(o);
    };

    Value.prototype.assigns = function(name) {
      return !this.properties.length && this.base.assigns(name);
    };

    Value.prototype.jumps = function(o) {
      return !this.properties.length && this.base.jumps(o);
    };

    Value.prototype.isObject = function(onlyGenerated) {
      if (this.properties.length) {
        return false;
      }
      return (this.base instanceof Obj) && (!onlyGenerated || this.base.generated);
    };

    Value.prototype.isSplice = function() {
      var lastProp, ref3;
      ref3 = this.properties, lastProp = ref3[ref3.length - 1];
      return lastProp instanceof Slice;
    };

    Value.prototype.looksStatic = function(className) {
      var ref3;
      return this.base.value === className && this.properties.length === 1 && ((ref3 = this.properties[0].name) != null ? ref3.value : void 0) !== 'prototype';
    };

    Value.prototype.unwrap = function() {
      if (this.properties.length) {
        return this;
      } else {
        return this.base;
      }
    };

    Value.prototype.cacheReference = function(o) {
      var base, bref, name, nref, ref3;
      ref3 = this.properties, name = ref3[ref3.length - 1];
      if (this.properties.length < 2 && !this.base.isComplex() && !(name != null ? name.isComplex() : void 0)) {
        return [this, this];
      }
      base = new Value(this.base, this.properties.slice(0, -1));
      if (base.isComplex()) {
        bref = new Literal(o.scope.freeVariable('base'));
        base = new Value(new Parens(new Assign(bref, base)));
      }
      if (!name) {
        return [base, bref];
      }
      if (name.isComplex()) {
        nref = new Literal(o.scope.freeVariable('name'));
        name = new Index(new Assign(nref, name.index));
        nref = new Index(nref);
      }
      return [base.add(name), new Value(bref || base.base, [nref || name])];
    };

    Value.prototype.compileNode = function(o) {
      var fragments, j, len1, prop, props;
      this.base.front = this.front;
      props = this.properties;
      fragments = this.base.compileToFragments(o, (props.length ? LEVEL_ACCESS : null));
      if ((this.base instanceof Parens || props.length) && SIMPLENUM.test(fragmentsToText(fragments))) {
        fragments.push(this.makeCode('.'));
      }
      for (j = 0, len1 = props.length; j < len1; j++) {
        prop = props[j];
        fragments.push.apply(fragments, prop.compileToFragments(o));
      }
      return fragments;
    };

    Value.prototype.unfoldSoak = function(o) {
      return this.unfoldedSoak != null ? this.unfoldedSoak : this.unfoldedSoak = (function(_this) {
        return function() {
          var fst, i, ifn, j, len1, prop, ref, ref3, ref4, snd;
          if (ifn = _this.base.unfoldSoak(o)) {
            (ref3 = ifn.body.properties).push.apply(ref3, _this.properties);
            return ifn;
          }
          ref4 = _this.properties;
          for (i = j = 0, len1 = ref4.length; j < len1; i = ++j) {
            prop = ref4[i];
            if (!prop.soak) {
              continue;
            }
            prop.soak = false;
            fst = new Value(_this.base, _this.properties.slice(0, i));
            snd = new Value(_this.base, _this.properties.slice(i));
            if (fst.isComplex()) {
              ref = new Literal(o.scope.freeVariable('ref'));
              fst = new Parens(new Assign(ref, fst));
              snd.base = ref;
            }
            return new If(new Existence(fst), snd, {
              soak: true
            });
          }
          return false;
        };
      })(this)();
    };

    return Value;

  })(Base);

  exports.Comment = Comment = (function(superClass1) {
    extend1(Comment, superClass1);

    function Comment(comment1) {
      this.comment = comment1;
    }

    Comment.prototype.isStatement = YES;

    Comment.prototype.makeReturn = THIS;

    Comment.prototype.compileNode = function(o, level) {
      var code, comment;
      comment = this.comment.replace(/^(\s*)#(?=\s)/gm, "$1 *");
      code = "/*" + (multident(comment, this.tab)) + (indexOf.call(comment, '\n') >= 0 ? "\n" + this.tab : '') + " */";
      if ((level || o.level) === LEVEL_TOP) {
        code = o.indent + code;
      }
      return [this.makeCode("\n"), this.makeCode(code)];
    };

    return Comment;

  })(Base);

  exports.Call = Call = (function(superClass1) {
    extend1(Call, superClass1);

    function Call(variable, args1, soak) {
      this.args = args1 != null ? args1 : [];
      this.soak = soak;
      this.isNew = false;
      this.isSuper = variable === 'super';
      this.variable = this.isSuper ? null : variable;
      if (variable instanceof Value && variable.isNotCallable()) {
        variable.error("literal is not a function");
      }
    }

    Call.prototype.children = ['variable', 'args'];

    Call.prototype.updateLocationDataIfMissing = function(locationData) {
      var base, ref3;
      if (this.locationData && this.needsUpdatedStartLocation) {
        this.locationData.first_line = locationData.first_line;
        this.locationData.first_column = locationData.first_column;
        base = ((ref3 = this.variable) != null ? ref3.base : void 0) || this.variable;
        if (base.needsUpdatedStartLocation) {
          this.variable.locationData.first_line = locationData.first_line;
          this.variable.locationData.first_column = locationData.first_column;
          base.updateLocationDataIfMissing(locationData);
        }
        delete this.needsUpdatedStartLocation;
      }
      return Call.__super__.updateLocationDataIfMissing.apply(this, arguments);
    };

    Call.prototype.newInstance = function() {
      var base, ref3;
      base = ((ref3 = this.variable) != null ? ref3.base : void 0) || this.variable;
      if (base instanceof Call && !base.isNew) {
        base.newInstance();
      } else {
        this.isNew = true;
      }
      this.needsUpdatedStartLocation = true;
      return this;
    };

    Call.prototype.superReference = function(o) {
      var accesses, base, bref, klass, method, name, nref, variable;
      method = o.scope.namedMethod();
      if (method != null ? method.klass : void 0) {
        klass = method.klass, name = method.name, variable = method.variable;
        if (klass.isComplex()) {
          bref = new Literal(o.scope.parent.freeVariable('base'));
          base = new Value(new Parens(new Assign(bref, klass)));
          variable.base = base;
          variable.properties.splice(0, klass.properties.length);
        }
        if (name.isComplex() || (name instanceof Index && name.index.isAssignable())) {
          nref = new Literal(o.scope.parent.freeVariable('name'));
          name = new Index(new Assign(nref, name.index));
          variable.properties.pop();
          variable.properties.push(name);
        }
        accesses = [new Access(new Literal('__super__'))];
        if (method["static"]) {
          accesses.push(new Access(new Literal('constructor')));
        }
        accesses.push(nref != null ? new Index(nref) : name);
        return (new Value(bref != null ? bref : klass, accesses)).compile(o);
      } else if (method != null ? method.ctor : void 0) {
        return method.name + ".__super__.constructor";
      } else {
        return this.error('cannot call super outside of an instance method.');
      }
    };

    Call.prototype.superThis = function(o) {
      var method;
      method = o.scope.method;
      return (method && !method.klass && method.context) || "this";
    };

    Call.prototype.unfoldSoak = function(o) {
      var call, ifn, j, left, len1, list, ref3, ref4, rite;
      if (this.soak) {
        if (this.variable) {
          if (ifn = unfoldSoak(o, this, 'variable')) {
            return ifn;
          }
          ref3 = new Value(this.variable).cacheReference(o), left = ref3[0], rite = ref3[1];
        } else {
          left = new Literal(this.superReference(o));
          rite = new Value(left);
        }
        rite = new Call(rite, this.args);
        rite.isNew = this.isNew;
        left = new Literal("typeof " + (left.compile(o)) + " === \"function\"");
        return new If(left, new Value(rite), {
          soak: true
        });
      }
      call = this;
      list = [];
      while (true) {
        if (call.variable instanceof Call) {
          list.push(call);
          call = call.variable;
          continue;
        }
        if (!(call.variable instanceof Value)) {
          break;
        }
        list.push(call);
        if (!((call = call.variable.base) instanceof Call)) {
          break;
        }
      }
      ref4 = list.reverse();
      for (j = 0, len1 = ref4.length; j < len1; j++) {
        call = ref4[j];
        if (ifn) {
          if (call.variable instanceof Call) {
            call.variable = ifn;
          } else {
            call.variable.base = ifn;
          }
        }
        ifn = unfoldSoak(o, call, 'variable');
      }
      return ifn;
    };

    Call.prototype.compileNode = function(o) {
      var arg, argIndex, compiledArgs, compiledArray, fragments, j, len1, preface, ref3, ref4;
      if ((ref3 = this.variable) != null) {
        ref3.front = this.front;
      }
      compiledArray = Splat.compileSplattedArray(o, this.args, true);
      if (compiledArray.length) {
        return this.compileSplat(o, compiledArray);
      }
      compiledArgs = [];
      ref4 = this.args;
      for (argIndex = j = 0, len1 = ref4.length; j < len1; argIndex = ++j) {
        arg = ref4[argIndex];
        if (argIndex) {
          compiledArgs.push(this.makeCode(", "));
        }
        compiledArgs.push.apply(compiledArgs, arg.compileToFragments(o, LEVEL_LIST));
      }
      fragments = [];
      if (this.isSuper) {
        preface = this.superReference(o) + (".call(" + (this.superThis(o)));
        if (compiledArgs.length) {
          preface += ", ";
        }
        fragments.push(this.makeCode(preface));
      } else {
        if (this.isNew) {
          fragments.push(this.makeCode('new '));
        }
        fragments.push.apply(fragments, this.variable.compileToFragments(o, LEVEL_ACCESS));
        fragments.push(this.makeCode("("));
      }
      fragments.push.apply(fragments, compiledArgs);
      fragments.push(this.makeCode(")"));
      return fragments;
    };

    Call.prototype.compileSplat = function(o, splatArgs) {
      var answer, base, fun, idt, name, ref;
      if (this.isSuper) {
        return [].concat(this.makeCode((this.superReference(o)) + ".apply(" + (this.superThis(o)) + ", "), splatArgs, this.makeCode(")"));
      }
      if (this.isNew) {
        idt = this.tab + TAB;
        return [].concat(this.makeCode("(function(func, args, ctor) {\n" + idt + "ctor.prototype = func.prototype;\n" + idt + "var child = new ctor, result = func.apply(child, args);\n" + idt + "return Object(result) === result ? result : child;\n" + this.tab + "})("), this.variable.compileToFragments(o, LEVEL_LIST), this.makeCode(", "), splatArgs, this.makeCode(", function(){})"));
      }
      answer = [];
      base = new Value(this.variable);
      if ((name = base.properties.pop()) && base.isComplex()) {
        ref = o.scope.freeVariable('ref');
        answer = answer.concat(this.makeCode("(" + ref + " = "), base.compileToFragments(o, LEVEL_LIST), this.makeCode(")"), name.compileToFragments(o));
      } else {
        fun = base.compileToFragments(o, LEVEL_ACCESS);
        if (SIMPLENUM.test(fragmentsToText(fun))) {
          fun = this.wrapInBraces(fun);
        }
        if (name) {
          ref = fragmentsToText(fun);
          fun.push.apply(fun, name.compileToFragments(o));
        } else {
          ref = 'null';
        }
        answer = answer.concat(fun);
      }
      return answer = answer.concat(this.makeCode(".apply(" + ref + ", "), splatArgs, this.makeCode(")"));
    };

    return Call;

  })(Base);

  exports.Extends = Extends = (function(superClass1) {
    extend1(Extends, superClass1);

    function Extends(child1, parent1) {
      this.child = child1;
      this.parent = parent1;
    }

    Extends.prototype.children = ['child', 'parent'];

    Extends.prototype.compileToFragments = function(o) {
      return new Call(new Value(new Literal(utility('extend', o))), [this.child, this.parent]).compileToFragments(o);
    };

    return Extends;

  })(Base);

  exports.Access = Access = (function(superClass1) {
    extend1(Access, superClass1);

    function Access(name1, tag) {
      this.name = name1;
      this.name.asKey = true;
      this.soak = tag === 'soak';
    }

    Access.prototype.children = ['name'];

    Access.prototype.compileToFragments = function(o) {
      var name;
      name = this.name.compileToFragments(o);
      if (IDENTIFIER.test(fragmentsToText(name))) {
        name.unshift(this.makeCode("."));
      } else {
        name.unshift(this.makeCode("["));
        name.push(this.makeCode("]"));
      }
      return name;
    };

    Access.prototype.isComplex = NO;

    return Access;

  })(Base);

  exports.Index = Index = (function(superClass1) {
    extend1(Index, superClass1);

    function Index(index1) {
      this.index = index1;
    }

    Index.prototype.children = ['index'];

    Index.prototype.compileToFragments = function(o) {
      return [].concat(this.makeCode("["), this.index.compileToFragments(o, LEVEL_PAREN), this.makeCode("]"));
    };

    Index.prototype.isComplex = function() {
      return this.index.isComplex();
    };

    return Index;

  })(Base);

  exports.Range = Range = (function(superClass1) {
    extend1(Range, superClass1);

    Range.prototype.children = ['from', 'to'];

    function Range(from1, to1, tag) {
      this.from = from1;
      this.to = to1;
      this.exclusive = tag === 'exclusive';
      this.equals = this.exclusive ? '' : '=';
    }

    Range.prototype.compileVariables = function(o) {
      var isComplex, ref3, ref4, ref5, ref6, step;
      o = merge(o, {
        top: true
      });
      isComplex = del(o, 'isComplex');
      ref3 = this.cacheToCodeFragments(this.from.cache(o, LEVEL_LIST, isComplex)), this.fromC = ref3[0], this.fromVar = ref3[1];
      ref4 = this.cacheToCodeFragments(this.to.cache(o, LEVEL_LIST, isComplex)), this.toC = ref4[0], this.toVar = ref4[1];
      if (step = del(o, 'step')) {
        ref5 = this.cacheToCodeFragments(step.cache(o, LEVEL_LIST, isComplex)), this.step = ref5[0], this.stepVar = ref5[1];
      }
      ref6 = [this.fromVar.match(NUMBER), this.toVar.match(NUMBER)], this.fromNum = ref6[0], this.toNum = ref6[1];
      if (this.stepVar) {
        return this.stepNum = this.stepVar.match(NUMBER);
      }
    };

    Range.prototype.compileNode = function(o) {
      var cond, condPart, from, gt, idx, idxName, known, lt, namedIndex, ref3, ref4, stepPart, to, varPart;
      if (!this.fromVar) {
        this.compileVariables(o);
      }
      if (!o.index) {
        return this.compileArray(o);
      }
      known = this.fromNum && this.toNum;
      idx = del(o, 'index');
      idxName = del(o, 'name');
      namedIndex = idxName && idxName !== idx;
      varPart = idx + " = " + this.fromC;
      if (this.toC !== this.toVar) {
        varPart += ", " + this.toC;
      }
      if (this.step !== this.stepVar) {
        varPart += ", " + this.step;
      }
      ref3 = [idx + " <" + this.equals, idx + " >" + this.equals], lt = ref3[0], gt = ref3[1];
      condPart = this.stepNum ? parseNum(this.stepNum[0]) > 0 ? lt + " " + this.toVar : gt + " " + this.toVar : known ? ((ref4 = [parseNum(this.fromNum[0]), parseNum(this.toNum[0])], from = ref4[0], to = ref4[1], ref4), from <= to ? lt + " " + to : gt + " " + to) : (cond = this.stepVar ? this.stepVar + " > 0" : this.fromVar + " <= " + this.toVar, cond + " ? " + lt + " " + this.toVar + " : " + gt + " " + this.toVar);
      stepPart = this.stepVar ? idx + " += " + this.stepVar : known ? namedIndex ? from <= to ? "++" + idx : "--" + idx : from <= to ? idx + "++" : idx + "--" : namedIndex ? cond + " ? ++" + idx + " : --" + idx : cond + " ? " + idx + "++ : " + idx + "--";
      if (namedIndex) {
        varPart = idxName + " = " + varPart;
      }
      if (namedIndex) {
        stepPart = idxName + " = " + stepPart;
      }
      return [this.makeCode(varPart + "; " + condPart + "; " + stepPart)];
    };

    Range.prototype.compileArray = function(o) {
      var args, body, cond, hasArgs, i, idt, j, post, pre, range, ref3, ref4, result, results, vars;
      if (this.fromNum && this.toNum && Math.abs(this.fromNum - this.toNum) <= 20) {
        range = (function() {
          results = [];
          for (var j = ref3 = +this.fromNum, ref4 = +this.toNum; ref3 <= ref4 ? j <= ref4 : j >= ref4; ref3 <= ref4 ? j++ : j--){ results.push(j); }
          return results;
        }).apply(this);
        if (this.exclusive) {
          range.pop();
        }
        return [this.makeCode("[" + (range.join(', ')) + "]")];
      }
      idt = this.tab + TAB;
      i = o.scope.freeVariable('i', {
        single: true
      });
      result = o.scope.freeVariable('results');
      pre = "\n" + idt + result + " = [];";
      if (this.fromNum && this.toNum) {
        o.index = i;
        body = fragmentsToText(this.compileNode(o));
      } else {
        vars = (i + " = " + this.fromC) + (this.toC !== this.toVar ? ", " + this.toC : '');
        cond = this.fromVar + " <= " + this.toVar;
        body = "var " + vars + "; " + cond + " ? " + i + " <" + this.equals + " " + this.toVar + " : " + i + " >" + this.equals + " " + this.toVar + "; " + cond + " ? " + i + "++ : " + i + "--";
      }
      post = "{ " + result + ".push(" + i + "); }\n" + idt + "return " + result + ";\n" + o.indent;
      hasArgs = function(node) {
        return node != null ? node.contains(isLiteralArguments) : void 0;
      };
      if (hasArgs(this.from) || hasArgs(this.to)) {
        args = ', arguments';
      }
      return [this.makeCode("(function() {" + pre + "\n" + idt + "for (" + body + ")" + post + "}).apply(this" + (args != null ? args : '') + ")")];
    };

    return Range;

  })(Base);

  exports.Slice = Slice = (function(superClass1) {
    extend1(Slice, superClass1);

    Slice.prototype.children = ['range'];

    function Slice(range1) {
      this.range = range1;
      Slice.__super__.constructor.call(this);
    }

    Slice.prototype.compileNode = function(o) {
      var compiled, compiledText, from, fromCompiled, ref3, to, toStr;
      ref3 = this.range, to = ref3.to, from = ref3.from;
      fromCompiled = from && from.compileToFragments(o, LEVEL_PAREN) || [this.makeCode('0')];
      if (to) {
        compiled = to.compileToFragments(o, LEVEL_PAREN);
        compiledText = fragmentsToText(compiled);
        if (!(!this.range.exclusive && +compiledText === -1)) {
          toStr = ', ' + (this.range.exclusive ? compiledText : SIMPLENUM.test(compiledText) ? "" + (+compiledText + 1) : (compiled = to.compileToFragments(o, LEVEL_ACCESS), "+" + (fragmentsToText(compiled)) + " + 1 || 9e9"));
        }
      }
      return [this.makeCode(".slice(" + (fragmentsToText(fromCompiled)) + (toStr || '') + ")")];
    };

    return Slice;

  })(Base);

  exports.Obj = Obj = (function(superClass1) {
    extend1(Obj, superClass1);

    function Obj(props, generated) {
      this.generated = generated != null ? generated : false;
      this.objects = this.properties = props || [];
    }

    Obj.prototype.children = ['properties'];

    Obj.prototype.compileNode = function(o) {
      var answer, dynamicIndex, hasDynamic, i, idt, indent, j, join, k, key, l, lastNoncom, len1, len2, len3, node, oref, prop, props, ref3, value;
      props = this.properties;
      if (this.generated) {
        for (j = 0, len1 = props.length; j < len1; j++) {
          node = props[j];
          if (node instanceof Value) {
            node.error('cannot have an implicit value in an implicit object');
          }
        }
      }
      for (dynamicIndex = k = 0, len2 = props.length; k < len2; dynamicIndex = ++k) {
        prop = props[dynamicIndex];
        if ((prop.variable || prop).base instanceof Parens) {
          break;
        }
      }
      hasDynamic = dynamicIndex < props.length;
      idt = o.indent += TAB;
      lastNoncom = this.lastNonComment(this.properties);
      answer = [];
      if (hasDynamic) {
        oref = o.scope.freeVariable('obj');
        answer.push(this.makeCode("(\n" + idt + oref + " = "));
      }
      answer.push(this.makeCode("{" + (props.length === 0 || dynamicIndex === 0 ? '}' : '\n')));
      for (i = l = 0, len3 = props.length; l < len3; i = ++l) {
        prop = props[i];
        if (i === dynamicIndex) {
          if (i !== 0) {
            answer.push(this.makeCode("\n" + idt + "}"));
          }
          answer.push(this.makeCode(',\n'));
        }
        join = i === props.length - 1 || i === dynamicIndex - 1 ? '' : prop === lastNoncom || prop instanceof Comment ? '\n' : ',\n';
        indent = prop instanceof Comment ? '' : idt;
        if (hasDynamic && i < dynamicIndex) {
          indent += TAB;
        }
        if (prop instanceof Assign) {
          if (prop.context !== 'object') {
            prop.operatorToken.error("unexpected " + prop.operatorToken.value);
          }
          if (prop.variable instanceof Value && prop.variable.hasProperties()) {
            prop.variable.error('invalid object key');
          }
        }
        if (prop instanceof Value && prop["this"]) {
          prop = new Assign(prop.properties[0].name, prop, 'object');
        }
        if (!(prop instanceof Comment)) {
          if (i < dynamicIndex) {
            if (!(prop instanceof Assign)) {
              prop = new Assign(prop, prop, 'object');
            }
            (prop.variable.base || prop.variable).asKey = true;
          } else {
            if (prop instanceof Assign) {
              key = prop.variable;
              value = prop.value;
            } else {
              ref3 = prop.base.cache(o), key = ref3[0], value = ref3[1];
            }
            prop = new Assign(new Value(new Literal(oref), [new Access(key)]), value);
          }
        }
        if (indent) {
          answer.push(this.makeCode(indent));
        }
        answer.push.apply(answer, prop.compileToFragments(o, LEVEL_TOP));
        if (join) {
          answer.push(this.makeCode(join));
        }
      }
      if (hasDynamic) {
        answer.push(this.makeCode(",\n" + idt + oref + "\n" + this.tab + ")"));
      } else {
        if (props.length !== 0) {
          answer.push(this.makeCode("\n" + this.tab + "}"));
        }
      }
      if (this.front && !hasDynamic) {
        return this.wrapInBraces(answer);
      } else {
        return answer;
      }
    };

    Obj.prototype.assigns = function(name) {
      var j, len1, prop, ref3;
      ref3 = this.properties;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        prop = ref3[j];
        if (prop.assigns(name)) {
          return true;
        }
      }
      return false;
    };

    return Obj;

  })(Base);

  exports.Arr = Arr = (function(superClass1) {
    extend1(Arr, superClass1);

    function Arr(objs) {
      this.objects = objs || [];
    }

    Arr.prototype.children = ['objects'];

    Arr.prototype.compileNode = function(o) {
      var answer, compiledObjs, fragments, index, j, len1, obj;
      if (!this.objects.length) {
        return [this.makeCode('[]')];
      }
      o.indent += TAB;
      answer = Splat.compileSplattedArray(o, this.objects);
      if (answer.length) {
        return answer;
      }
      answer = [];
      compiledObjs = (function() {
        var j, len1, ref3, results;
        ref3 = this.objects;
        results = [];
        for (j = 0, len1 = ref3.length; j < len1; j++) {
          obj = ref3[j];
          results.push(obj.compileToFragments(o, LEVEL_LIST));
        }
        return results;
      }).call(this);
      for (index = j = 0, len1 = compiledObjs.length; j < len1; index = ++j) {
        fragments = compiledObjs[index];
        if (index) {
          answer.push(this.makeCode(", "));
        }
        answer.push.apply(answer, fragments);
      }
      if (fragmentsToText(answer).indexOf('\n') >= 0) {
        answer.unshift(this.makeCode("[\n" + o.indent));
        answer.push(this.makeCode("\n" + this.tab + "]"));
      } else {
        answer.unshift(this.makeCode("["));
        answer.push(this.makeCode("]"));
      }
      return answer;
    };

    Arr.prototype.assigns = function(name) {
      var j, len1, obj, ref3;
      ref3 = this.objects;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        obj = ref3[j];
        if (obj.assigns(name)) {
          return true;
        }
      }
      return false;
    };

    return Arr;

  })(Base);

  exports.Class = Class = (function(superClass1) {
    extend1(Class, superClass1);

    function Class(variable1, parent1, body1) {
      this.variable = variable1;
      this.parent = parent1;
      this.body = body1 != null ? body1 : new Block;
      this.boundFuncs = [];
      this.body.classBody = true;
    }

    Class.prototype.children = ['variable', 'parent', 'body'];

    Class.prototype.determineName = function() {
      var decl, ref3, tail;
      if (!this.variable) {
        return null;
      }
      ref3 = this.variable.properties, tail = ref3[ref3.length - 1];
      decl = tail ? tail instanceof Access && tail.name.value : this.variable.base.value;
      if (indexOf.call(STRICT_PROSCRIBED, decl) >= 0) {
        this.variable.error("class variable name may not be " + decl);
      }
      return decl && (decl = IDENTIFIER.test(decl) && decl);
    };

    Class.prototype.setContext = function(name) {
      return this.body.traverseChildren(false, function(node) {
        if (node.classBody) {
          return false;
        }
        if (node instanceof Literal && node.value === 'this') {
          return node.value = name;
        } else if (node instanceof Code) {
          if (node.bound) {
            return node.context = name;
          }
        }
      });
    };

    Class.prototype.addBoundFunctions = function(o) {
      var bvar, j, len1, lhs, ref3;
      ref3 = this.boundFuncs;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        bvar = ref3[j];
        lhs = (new Value(new Literal("this"), [new Access(bvar)])).compile(o);
        this.ctor.body.unshift(new Literal(lhs + " = " + (utility('bind', o)) + "(" + lhs + ", this)"));
      }
    };

    Class.prototype.addProperties = function(node, name, o) {
      var acc, assign, base, exprs, func, props;
      props = node.base.properties.slice(0);
      exprs = (function() {
        var results;
        results = [];
        while (assign = props.shift()) {
          if (assign instanceof Assign) {
            base = assign.variable.base;
            delete assign.context;
            func = assign.value;
            if (base.value === 'constructor') {
              if (this.ctor) {
                assign.error('cannot define more than one constructor in a class');
              }
              if (func.bound) {
                assign.error('cannot define a constructor as a bound function');
              }
              if (func instanceof Code) {
                assign = this.ctor = func;
              } else {
                this.externalCtor = o.classScope.freeVariable('class');
                assign = new Assign(new Literal(this.externalCtor), func);
              }
            } else {
              if (assign.variable["this"]) {
                func["static"] = true;
              } else {
                acc = base.isComplex() ? new Index(base) : new Access(base);
                assign.variable = new Value(new Literal(name), [new Access(new Literal('prototype')), acc]);
                if (func instanceof Code && func.bound) {
                  this.boundFuncs.push(base);
                  func.bound = false;
                }
              }
            }
          }
          results.push(assign);
        }
        return results;
      }).call(this);
      return compact(exprs);
    };

    Class.prototype.walkBody = function(name, o) {
      return this.traverseChildren(false, (function(_this) {
        return function(child) {
          var cont, exps, i, j, len1, node, ref3;
          cont = true;
          if (child instanceof Class) {
            return false;
          }
          if (child instanceof Block) {
            ref3 = exps = child.expressions;
            for (i = j = 0, len1 = ref3.length; j < len1; i = ++j) {
              node = ref3[i];
              if (node instanceof Assign && node.variable.looksStatic(name)) {
                node.value["static"] = true;
              } else if (node instanceof Value && node.isObject(true)) {
                cont = false;
                exps[i] = _this.addProperties(node, name, o);
              }
            }
            child.expressions = exps = flatten(exps);
          }
          return cont && !(child instanceof Class);
        };
      })(this));
    };

    Class.prototype.hoistDirectivePrologue = function() {
      var expressions, index, node;
      index = 0;
      expressions = this.body.expressions;
      while ((node = expressions[index]) && node instanceof Comment || node instanceof Value && node.isString()) {
        ++index;
      }
      return this.directives = expressions.splice(0, index);
    };

    Class.prototype.ensureConstructor = function(name) {
      if (!this.ctor) {
        this.ctor = new Code;
        if (this.externalCtor) {
          this.ctor.body.push(new Literal(this.externalCtor + ".apply(this, arguments)"));
        } else if (this.parent) {
          this.ctor.body.push(new Literal(name + ".__super__.constructor.apply(this, arguments)"));
        }
        this.ctor.body.makeReturn();
        this.body.expressions.unshift(this.ctor);
      }
      this.ctor.ctor = this.ctor.name = name;
      this.ctor.klass = null;
      return this.ctor.noReturn = true;
    };

    Class.prototype.compileNode = function(o) {
      var args, argumentsNode, func, jumpNode, klass, lname, name, ref3, superClass;
      if (jumpNode = this.body.jumps()) {
        jumpNode.error('Class bodies cannot contain pure statements');
      }
      if (argumentsNode = this.body.contains(isLiteralArguments)) {
        argumentsNode.error("Class bodies shouldn't reference arguments");
      }
      name = this.determineName() || '_Class';
      if (name.reserved) {
        name = "_" + name;
      }
      lname = new Literal(name);
      func = new Code([], Block.wrap([this.body]));
      args = [];
      o.classScope = func.makeScope(o.scope);
      this.hoistDirectivePrologue();
      this.setContext(name);
      this.walkBody(name, o);
      this.ensureConstructor(name);
      this.addBoundFunctions(o);
      this.body.spaced = true;
      this.body.expressions.push(lname);
      if (this.parent) {
        superClass = new Literal(o.classScope.freeVariable('superClass', {
          reserve: false
        }));
        this.body.expressions.unshift(new Extends(lname, superClass));
        func.params.push(new Param(superClass));
        args.push(this.parent);
      }
      (ref3 = this.body.expressions).unshift.apply(ref3, this.directives);
      klass = new Parens(new Call(func, args));
      if (this.variable) {
        klass = new Assign(this.variable, klass);
      }
      return klass.compileToFragments(o);
    };

    return Class;

  })(Base);

  exports.Assign = Assign = (function(superClass1) {
    extend1(Assign, superClass1);

    function Assign(variable1, value1, context, options) {
      var forbidden, name, ref3;
      this.variable = variable1;
      this.value = value1;
      this.context = context;
      if (options == null) {
        options = {};
      }
      this.param = options.param, this.subpattern = options.subpattern, this.operatorToken = options.operatorToken;
      forbidden = (ref3 = (name = this.variable.unwrapAll().value), indexOf.call(STRICT_PROSCRIBED, ref3) >= 0);
      if (forbidden && this.context !== 'object') {
        this.variable.error("variable name may not be \"" + name + "\"");
      }
    }

    Assign.prototype.children = ['variable', 'value'];

    Assign.prototype.isStatement = function(o) {
      return (o != null ? o.level : void 0) === LEVEL_TOP && (this.context != null) && indexOf.call(this.context, "?") >= 0;
    };

    Assign.prototype.assigns = function(name) {
      return this[this.context === 'object' ? 'value' : 'variable'].assigns(name);
    };

    Assign.prototype.unfoldSoak = function(o) {
      return unfoldSoak(o, this, 'variable');
    };

    Assign.prototype.compileNode = function(o) {
      var answer, compiledName, isValue, j, name, properties, prototype, ref3, ref4, ref5, ref6, ref7, val, varBase;
      if (isValue = this.variable instanceof Value) {
        if (this.variable.isArray() || this.variable.isObject()) {
          return this.compilePatternMatch(o);
        }
        if (this.variable.isSplice()) {
          return this.compileSplice(o);
        }
        if ((ref3 = this.context) === '||=' || ref3 === '&&=' || ref3 === '?=') {
          return this.compileConditional(o);
        }
        if ((ref4 = this.context) === '**=' || ref4 === '//=' || ref4 === '%%=') {
          return this.compileSpecialMath(o);
        }
      }
      if (this.value instanceof Code) {
        if (this.value["static"]) {
          this.value.klass = this.variable.base;
          this.value.name = this.variable.properties[0];
          this.value.variable = this.variable;
        } else if (((ref5 = this.variable.properties) != null ? ref5.length : void 0) >= 2) {
          ref6 = this.variable.properties, properties = 3 <= ref6.length ? slice.call(ref6, 0, j = ref6.length - 2) : (j = 0, []), prototype = ref6[j++], name = ref6[j++];
          if (((ref7 = prototype.name) != null ? ref7.value : void 0) === 'prototype') {
            this.value.klass = new Value(this.variable.base, properties);
            this.value.name = name;
            this.value.variable = this.variable;
          }
        }
      }
      if (!this.context) {
        varBase = this.variable.unwrapAll();
        if (!varBase.isAssignable()) {
          this.variable.error("\"" + (this.variable.compile(o)) + "\" cannot be assigned");
        }
        if (!(typeof varBase.hasProperties === "function" ? varBase.hasProperties() : void 0)) {
          if (this.param) {
            o.scope.add(varBase.value, 'var');
          } else {
            o.scope.find(varBase.value);
          }
        }
      }
      val = this.value.compileToFragments(o, LEVEL_LIST);
      if (isValue && this.variable.base instanceof Obj) {
        this.variable.front = true;
      }
      compiledName = this.variable.compileToFragments(o, LEVEL_LIST);
      if (this.context === 'object') {
        return compiledName.concat(this.makeCode(": "), val);
      }
      answer = compiledName.concat(this.makeCode(" " + (this.context || '=') + " "), val);
      if (o.level <= LEVEL_LIST) {
        return answer;
      } else {
        return this.wrapInBraces(answer);
      }
    };

    Assign.prototype.compilePatternMatch = function(o) {
      var acc, assigns, code, defaultValue, expandedIdx, fragments, i, idx, isObject, ivar, j, len1, name, obj, objects, olen, ref, ref3, ref4, ref5, ref6, ref7, rest, top, val, value, vvar, vvarText;
      top = o.level === LEVEL_TOP;
      value = this.value;
      objects = this.variable.base.objects;
      if (!(olen = objects.length)) {
        code = value.compileToFragments(o);
        if (o.level >= LEVEL_OP) {
          return this.wrapInBraces(code);
        } else {
          return code;
        }
      }
      obj = objects[0];
      if (olen === 1 && obj instanceof Expansion) {
        obj.error('Destructuring assignment has no target');
      }
      isObject = this.variable.isObject();
      if (top && olen === 1 && !(obj instanceof Splat)) {
        defaultValue = null;
        if (obj instanceof Assign && obj.context === 'object') {
          ref3 = obj, (ref4 = ref3.variable, idx = ref4.base), obj = ref3.value;
          if (obj instanceof Assign) {
            defaultValue = obj.value;
            obj = obj.variable;
          }
        } else {
          if (obj instanceof Assign) {
            defaultValue = obj.value;
            obj = obj.variable;
          }
          idx = isObject ? obj["this"] ? obj.properties[0].name : obj : new Literal(0);
        }
        acc = IDENTIFIER.test(idx.unwrap().value);
        value = new Value(value);
        value.properties.push(new (acc ? Access : Index)(idx));
        if (ref5 = obj.unwrap().value, indexOf.call(RESERVED, ref5) >= 0) {
          obj.error("assignment to a reserved word: " + (obj.compile(o)));
        }
        if (defaultValue) {
          value = new Op('?', value, defaultValue);
        }
        return new Assign(obj, value, null, {
          param: this.param
        }).compileToFragments(o, LEVEL_TOP);
      }
      vvar = value.compileToFragments(o, LEVEL_LIST);
      vvarText = fragmentsToText(vvar);
      assigns = [];
      expandedIdx = false;
      if (!IDENTIFIER.test(vvarText) || this.variable.assigns(vvarText)) {
        assigns.push([this.makeCode((ref = o.scope.freeVariable('ref')) + " = ")].concat(slice.call(vvar)));
        vvar = [this.makeCode(ref)];
        vvarText = ref;
      }
      for (i = j = 0, len1 = objects.length; j < len1; i = ++j) {
        obj = objects[i];
        idx = i;
        if (!expandedIdx && obj instanceof Splat) {
          name = obj.name.unwrap().value;
          obj = obj.unwrap();
          val = olen + " <= " + vvarText + ".length ? " + (utility('slice', o)) + ".call(" + vvarText + ", " + i;
          if (rest = olen - i - 1) {
            ivar = o.scope.freeVariable('i', {
              single: true
            });
            val += ", " + ivar + " = " + vvarText + ".length - " + rest + ") : (" + ivar + " = " + i + ", [])";
          } else {
            val += ") : []";
          }
          val = new Literal(val);
          expandedIdx = ivar + "++";
        } else if (!expandedIdx && obj instanceof Expansion) {
          if (rest = olen - i - 1) {
            if (rest === 1) {
              expandedIdx = vvarText + ".length - 1";
            } else {
              ivar = o.scope.freeVariable('i', {
                single: true
              });
              val = new Literal(ivar + " = " + vvarText + ".length - " + rest);
              expandedIdx = ivar + "++";
              assigns.push(val.compileToFragments(o, LEVEL_LIST));
            }
          }
          continue;
        } else {
          if (obj instanceof Splat || obj instanceof Expansion) {
            obj.error("multiple splats/expansions are disallowed in an assignment");
          }
          defaultValue = null;
          if (obj instanceof Assign && obj.context === 'object') {
            ref6 = obj, (ref7 = ref6.variable, idx = ref7.base), obj = ref6.value;
            if (obj instanceof Assign) {
              defaultValue = obj.value;
              obj = obj.variable;
            }
          } else {
            if (obj instanceof Assign) {
              defaultValue = obj.value;
              obj = obj.variable;
            }
            idx = isObject ? obj["this"] ? obj.properties[0].name : obj : new Literal(expandedIdx || idx);
          }
          name = obj.unwrap().value;
          acc = IDENTIFIER.test(idx.unwrap().value);
          val = new Value(new Literal(vvarText), [new (acc ? Access : Index)(idx)]);
          if (defaultValue) {
            val = new Op('?', val, defaultValue);
          }
        }
        if ((name != null) && indexOf.call(RESERVED, name) >= 0) {
          obj.error("assignment to a reserved word: " + (obj.compile(o)));
        }
        assigns.push(new Assign(obj, val, null, {
          param: this.param,
          subpattern: true
        }).compileToFragments(o, LEVEL_LIST));
      }
      if (!(top || this.subpattern)) {
        assigns.push(vvar);
      }
      fragments = this.joinFragmentArrays(assigns, ', ');
      if (o.level < LEVEL_LIST) {
        return fragments;
      } else {
        return this.wrapInBraces(fragments);
      }
    };

    Assign.prototype.compileConditional = function(o) {
      var fragments, left, ref3, right;
      ref3 = this.variable.cacheReference(o), left = ref3[0], right = ref3[1];
      if (!left.properties.length && left.base instanceof Literal && left.base.value !== "this" && !o.scope.check(left.base.value)) {
        this.variable.error("the variable \"" + left.base.value + "\" can't be assigned with " + this.context + " because it has not been declared before");
      }
      if (indexOf.call(this.context, "?") >= 0) {
        o.isExistentialEquals = true;
        return new If(new Existence(left), right, {
          type: 'if'
        }).addElse(new Assign(right, this.value, '=')).compileToFragments(o);
      } else {
        fragments = new Op(this.context.slice(0, -1), left, new Assign(right, this.value, '=')).compileToFragments(o);
        if (o.level <= LEVEL_LIST) {
          return fragments;
        } else {
          return this.wrapInBraces(fragments);
        }
      }
    };

    Assign.prototype.compileSpecialMath = function(o) {
      var left, ref3, right;
      ref3 = this.variable.cacheReference(o), left = ref3[0], right = ref3[1];
      return new Assign(left, new Op(this.context.slice(0, -1), right, this.value)).compileToFragments(o);
    };

    Assign.prototype.compileSplice = function(o) {
      var answer, exclusive, from, fromDecl, fromRef, name, ref3, ref4, ref5, to, valDef, valRef;
      ref3 = this.variable.properties.pop().range, from = ref3.from, to = ref3.to, exclusive = ref3.exclusive;
      name = this.variable.compile(o);
      if (from) {
        ref4 = this.cacheToCodeFragments(from.cache(o, LEVEL_OP)), fromDecl = ref4[0], fromRef = ref4[1];
      } else {
        fromDecl = fromRef = '0';
      }
      if (to) {
        if (from instanceof Value && from.isSimpleNumber() && to instanceof Value && to.isSimpleNumber()) {
          to = to.compile(o) - fromRef;
          if (!exclusive) {
            to += 1;
          }
        } else {
          to = to.compile(o, LEVEL_ACCESS) + ' - ' + fromRef;
          if (!exclusive) {
            to += ' + 1';
          }
        }
      } else {
        to = "9e9";
      }
      ref5 = this.value.cache(o, LEVEL_LIST), valDef = ref5[0], valRef = ref5[1];
      answer = [].concat(this.makeCode("[].splice.apply(" + name + ", [" + fromDecl + ", " + to + "].concat("), valDef, this.makeCode(")), "), valRef);
      if (o.level > LEVEL_TOP) {
        return this.wrapInBraces(answer);
      } else {
        return answer;
      }
    };

    return Assign;

  })(Base);

  exports.Code = Code = (function(superClass1) {
    extend1(Code, superClass1);

    function Code(params, body, tag) {
      this.params = params || [];
      this.body = body || new Block;
      this.bound = tag === 'boundfunc';
      this.isGenerator = !!this.body.contains(function(node) {
        var ref3;
        return node instanceof Op && ((ref3 = node.operator) === 'yield' || ref3 === 'yield*');
      });
    }

    Code.prototype.children = ['params', 'body'];

    Code.prototype.isStatement = function() {
      return !!this.ctor;
    };

    Code.prototype.jumps = NO;

    Code.prototype.makeScope = function(parentScope) {
      return new Scope(parentScope, this.body, this);
    };

    Code.prototype.compileNode = function(o) {
      var answer, boundfunc, code, exprs, i, j, k, l, len1, len2, len3, len4, len5, len6, lit, m, p, param, params, q, r, ref, ref3, ref4, ref5, ref6, ref7, ref8, splats, uniqs, val, wasEmpty, wrapper;
      if (this.bound && ((ref3 = o.scope.method) != null ? ref3.bound : void 0)) {
        this.context = o.scope.method.context;
      }
      if (this.bound && !this.context) {
        this.context = '_this';
        wrapper = new Code([new Param(new Literal(this.context))], new Block([this]));
        boundfunc = new Call(wrapper, [new Literal('this')]);
        boundfunc.updateLocationDataIfMissing(this.locationData);
        return boundfunc.compileNode(o);
      }
      o.scope = del(o, 'classScope') || this.makeScope(o.scope);
      o.scope.shared = del(o, 'sharedScope');
      o.indent += TAB;
      delete o.bare;
      delete o.isExistentialEquals;
      params = [];
      exprs = [];
      ref4 = this.params;
      for (j = 0, len1 = ref4.length; j < len1; j++) {
        param = ref4[j];
        if (!(param instanceof Expansion)) {
          o.scope.parameter(param.asReference(o));
        }
      }
      ref5 = this.params;
      for (k = 0, len2 = ref5.length; k < len2; k++) {
        param = ref5[k];
        if (!(param.splat || param instanceof Expansion)) {
          continue;
        }
        ref6 = this.params;
        for (l = 0, len3 = ref6.length; l < len3; l++) {
          p = ref6[l];
          if (!(p instanceof Expansion) && p.name.value) {
            o.scope.add(p.name.value, 'var', true);
          }
        }
        splats = new Assign(new Value(new Arr((function() {
          var len4, m, ref7, results;
          ref7 = this.params;
          results = [];
          for (m = 0, len4 = ref7.length; m < len4; m++) {
            p = ref7[m];
            results.push(p.asReference(o));
          }
          return results;
        }).call(this))), new Value(new Literal('arguments')));
        break;
      }
      ref7 = this.params;
      for (m = 0, len4 = ref7.length; m < len4; m++) {
        param = ref7[m];
        if (param.isComplex()) {
          val = ref = param.asReference(o);
          if (param.value) {
            val = new Op('?', ref, param.value);
          }
          exprs.push(new Assign(new Value(param.name), val, '=', {
            param: true
          }));
        } else {
          ref = param;
          if (param.value) {
            lit = new Literal(ref.name.value + ' == null');
            val = new Assign(new Value(param.name), param.value, '=');
            exprs.push(new If(lit, val));
          }
        }
        if (!splats) {
          params.push(ref);
        }
      }
      wasEmpty = this.body.isEmpty();
      if (splats) {
        exprs.unshift(splats);
      }
      if (exprs.length) {
        (ref8 = this.body.expressions).unshift.apply(ref8, exprs);
      }
      for (i = q = 0, len5 = params.length; q < len5; i = ++q) {
        p = params[i];
        params[i] = p.compileToFragments(o);
        o.scope.parameter(fragmentsToText(params[i]));
      }
      uniqs = [];
      this.eachParamName(function(name, node) {
        if (indexOf.call(uniqs, name) >= 0) {
          node.error("multiple parameters named " + name);
        }
        return uniqs.push(name);
      });
      if (!(wasEmpty || this.noReturn)) {
        this.body.makeReturn();
      }
      code = 'function';
      if (this.isGenerator) {
        code += '*';
      }
      if (this.ctor) {
        code += ' ' + this.name;
      }
      code += '(';
      answer = [this.makeCode(code)];
      for (i = r = 0, len6 = params.length; r < len6; i = ++r) {
        p = params[i];
        if (i) {
          answer.push(this.makeCode(", "));
        }
        answer.push.apply(answer, p);
      }
      answer.push(this.makeCode(') {'));
      if (!this.body.isEmpty()) {
        answer = answer.concat(this.makeCode("\n"), this.body.compileWithDeclarations(o), this.makeCode("\n" + this.tab));
      }
      answer.push(this.makeCode('}'));
      if (this.ctor) {
        return [this.makeCode(this.tab)].concat(slice.call(answer));
      }
      if (this.front || (o.level >= LEVEL_ACCESS)) {
        return this.wrapInBraces(answer);
      } else {
        return answer;
      }
    };

    Code.prototype.eachParamName = function(iterator) {
      var j, len1, param, ref3, results;
      ref3 = this.params;
      results = [];
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        param = ref3[j];
        results.push(param.eachName(iterator));
      }
      return results;
    };

    Code.prototype.traverseChildren = function(crossScope, func) {
      if (crossScope) {
        return Code.__super__.traverseChildren.call(this, crossScope, func);
      }
    };

    return Code;

  })(Base);

  exports.Param = Param = (function(superClass1) {
    extend1(Param, superClass1);

    function Param(name1, value1, splat) {
      var name, ref3, token;
      this.name = name1;
      this.value = value1;
      this.splat = splat;
      if (ref3 = (name = this.name.unwrapAll().value), indexOf.call(STRICT_PROSCRIBED, ref3) >= 0) {
        this.name.error("parameter name \"" + name + "\" is not allowed");
      }
      if (this.name instanceof Obj && this.name.generated) {
        token = this.name.objects[0].operatorToken;
        token.error("unexpected " + token.value);
      }
    }

    Param.prototype.children = ['name', 'value'];

    Param.prototype.compileToFragments = function(o) {
      return this.name.compileToFragments(o, LEVEL_LIST);
    };

    Param.prototype.asReference = function(o) {
      var name, node;
      if (this.reference) {
        return this.reference;
      }
      node = this.name;
      if (node["this"]) {
        name = node.properties[0].name.value;
        if (name.reserved) {
          name = "_" + name;
        }
        node = new Literal(o.scope.freeVariable(name));
      } else if (node.isComplex()) {
        node = new Literal(o.scope.freeVariable('arg'));
      }
      node = new Value(node);
      if (this.splat) {
        node = new Splat(node);
      }
      node.updateLocationDataIfMissing(this.locationData);
      return this.reference = node;
    };

    Param.prototype.isComplex = function() {
      return this.name.isComplex();
    };

    Param.prototype.eachName = function(iterator, name) {
      var atParam, j, len1, node, obj, ref3;
      if (name == null) {
        name = this.name;
      }
      atParam = function(obj) {
        return iterator("@" + obj.properties[0].name.value, obj);
      };
      if (name instanceof Literal) {
        return iterator(name.value, name);
      }
      if (name instanceof Value) {
        return atParam(name);
      }
      ref3 = name.objects;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        obj = ref3[j];
        if (obj instanceof Assign && (obj.context == null)) {
          obj = obj.variable;
        }
        if (obj instanceof Assign) {
          this.eachName(iterator, obj.value.unwrap());
        } else if (obj instanceof Splat) {
          node = obj.name.unwrap();
          iterator(node.value, node);
        } else if (obj instanceof Value) {
          if (obj.isArray() || obj.isObject()) {
            this.eachName(iterator, obj.base);
          } else if (obj["this"]) {
            atParam(obj);
          } else {
            iterator(obj.base.value, obj.base);
          }
        } else if (!(obj instanceof Expansion)) {
          obj.error("illegal parameter " + (obj.compile()));
        }
      }
    };

    return Param;

  })(Base);

  exports.Splat = Splat = (function(superClass1) {
    extend1(Splat, superClass1);

    Splat.prototype.children = ['name'];

    Splat.prototype.isAssignable = YES;

    function Splat(name) {
      this.name = name.compile ? name : new Literal(name);
    }

    Splat.prototype.assigns = function(name) {
      return this.name.assigns(name);
    };

    Splat.prototype.compileToFragments = function(o) {
      return this.name.compileToFragments(o);
    };

    Splat.prototype.unwrap = function() {
      return this.name;
    };

    Splat.compileSplattedArray = function(o, list, apply) {
      var args, base, compiledNode, concatPart, fragments, i, index, j, last, len1, node;
      index = -1;
      while ((node = list[++index]) && !(node instanceof Splat)) {
        continue;
      }
      if (index >= list.length) {
        return [];
      }
      if (list.length === 1) {
        node = list[0];
        fragments = node.compileToFragments(o, LEVEL_LIST);
        if (apply) {
          return fragments;
        }
        return [].concat(node.makeCode((utility('slice', o)) + ".call("), fragments, node.makeCode(")"));
      }
      args = list.slice(index);
      for (i = j = 0, len1 = args.length; j < len1; i = ++j) {
        node = args[i];
        compiledNode = node.compileToFragments(o, LEVEL_LIST);
        args[i] = node instanceof Splat ? [].concat(node.makeCode((utility('slice', o)) + ".call("), compiledNode, node.makeCode(")")) : [].concat(node.makeCode("["), compiledNode, node.makeCode("]"));
      }
      if (index === 0) {
        node = list[0];
        concatPart = node.joinFragmentArrays(args.slice(1), ', ');
        return args[0].concat(node.makeCode(".concat("), concatPart, node.makeCode(")"));
      }
      base = (function() {
        var k, len2, ref3, results;
        ref3 = list.slice(0, index);
        results = [];
        for (k = 0, len2 = ref3.length; k < len2; k++) {
          node = ref3[k];
          results.push(node.compileToFragments(o, LEVEL_LIST));
        }
        return results;
      })();
      base = list[0].joinFragmentArrays(base, ', ');
      concatPart = list[index].joinFragmentArrays(args, ', ');
      last = list[list.length - 1];
      return [].concat(list[0].makeCode("["), base, list[index].makeCode("].concat("), concatPart, last.makeCode(")"));
    };

    return Splat;

  })(Base);

  exports.Expansion = Expansion = (function(superClass1) {
    extend1(Expansion, superClass1);

    function Expansion() {
      return Expansion.__super__.constructor.apply(this, arguments);
    }

    Expansion.prototype.isComplex = NO;

    Expansion.prototype.compileNode = function(o) {
      return this.error('Expansion must be used inside a destructuring assignment or parameter list');
    };

    Expansion.prototype.asReference = function(o) {
      return this;
    };

    Expansion.prototype.eachName = function(iterator) {};

    return Expansion;

  })(Base);

  exports.While = While = (function(superClass1) {
    extend1(While, superClass1);

    function While(condition, options) {
      this.condition = (options != null ? options.invert : void 0) ? condition.invert() : condition;
      this.guard = options != null ? options.guard : void 0;
    }

    While.prototype.children = ['condition', 'guard', 'body'];

    While.prototype.isStatement = YES;

    While.prototype.makeReturn = function(res) {
      if (res) {
        return While.__super__.makeReturn.apply(this, arguments);
      } else {
        this.returns = !this.jumps({
          loop: true
        });
        return this;
      }
    };

    While.prototype.addBody = function(body1) {
      this.body = body1;
      return this;
    };

    While.prototype.jumps = function() {
      var expressions, j, jumpNode, len1, node;
      expressions = this.body.expressions;
      if (!expressions.length) {
        return false;
      }
      for (j = 0, len1 = expressions.length; j < len1; j++) {
        node = expressions[j];
        if (jumpNode = node.jumps({
          loop: true
        })) {
          return jumpNode;
        }
      }
      return false;
    };

    While.prototype.compileNode = function(o) {
      var answer, body, rvar, set;
      o.indent += TAB;
      set = '';
      body = this.body;
      if (body.isEmpty()) {
        body = this.makeCode('');
      } else {
        if (this.returns) {
          body.makeReturn(rvar = o.scope.freeVariable('results'));
          set = "" + this.tab + rvar + " = [];\n";
        }
        if (this.guard) {
          if (body.expressions.length > 1) {
            body.expressions.unshift(new If((new Parens(this.guard)).invert(), new Literal("continue")));
          } else {
            if (this.guard) {
              body = Block.wrap([new If(this.guard, body)]);
            }
          }
        }
        body = [].concat(this.makeCode("\n"), body.compileToFragments(o, LEVEL_TOP), this.makeCode("\n" + this.tab));
      }
      answer = [].concat(this.makeCode(set + this.tab + "while ("), this.condition.compileToFragments(o, LEVEL_PAREN), this.makeCode(") {"), body, this.makeCode("}"));
      if (this.returns) {
        answer.push(this.makeCode("\n" + this.tab + "return " + rvar + ";"));
      }
      return answer;
    };

    return While;

  })(Base);

  exports.Op = Op = (function(superClass1) {
    var CONVERSIONS, INVERSIONS;

    extend1(Op, superClass1);

    function Op(op, first, second, flip) {
      if (op === 'in') {
        return new In(first, second);
      }
      if (op === 'do') {
        return this.generateDo(first);
      }
      if (op === 'new') {
        if (first instanceof Call && !first["do"] && !first.isNew) {
          return first.newInstance();
        }
        if (first instanceof Code && first.bound || first["do"]) {
          first = new Parens(first);
        }
      }
      this.operator = CONVERSIONS[op] || op;
      this.first = first;
      this.second = second;
      this.flip = !!flip;
      return this;
    }

    CONVERSIONS = {
      '==': '===',
      '!=': '!==',
      'of': 'in',
      'yieldfrom': 'yield*'
    };

    INVERSIONS = {
      '!==': '===',
      '===': '!=='
    };

    Op.prototype.children = ['first', 'second'];

    Op.prototype.isSimpleNumber = NO;

    Op.prototype.isYield = function() {
      var ref3;
      return (ref3 = this.operator) === 'yield' || ref3 === 'yield*';
    };

    Op.prototype.isYieldReturn = function() {
      return this.isYield() && this.first instanceof Return;
    };

    Op.prototype.isUnary = function() {
      return !this.second;
    };

    Op.prototype.isComplex = function() {
      var ref3;
      return !(this.isUnary() && ((ref3 = this.operator) === '+' || ref3 === '-') && this.first instanceof Value && this.first.isSimpleNumber());
    };

    Op.prototype.isChainable = function() {
      var ref3;
      return (ref3 = this.operator) === '<' || ref3 === '>' || ref3 === '>=' || ref3 === '<=' || ref3 === '===' || ref3 === '!==';
    };

    Op.prototype.invert = function() {
      var allInvertable, curr, fst, op, ref3;
      if (this.isChainable() && this.first.isChainable()) {
        allInvertable = true;
        curr = this;
        while (curr && curr.operator) {
          allInvertable && (allInvertable = curr.operator in INVERSIONS);
          curr = curr.first;
        }
        if (!allInvertable) {
          return new Parens(this).invert();
        }
        curr = this;
        while (curr && curr.operator) {
          curr.invert = !curr.invert;
          curr.operator = INVERSIONS[curr.operator];
          curr = curr.first;
        }
        return this;
      } else if (op = INVERSIONS[this.operator]) {
        this.operator = op;
        if (this.first.unwrap() instanceof Op) {
          this.first.invert();
        }
        return this;
      } else if (this.second) {
        return new Parens(this).invert();
      } else if (this.operator === '!' && (fst = this.first.unwrap()) instanceof Op && ((ref3 = fst.operator) === '!' || ref3 === 'in' || ref3 === 'instanceof')) {
        return fst;
      } else {
        return new Op('!', this);
      }
    };

    Op.prototype.unfoldSoak = function(o) {
      var ref3;
      return ((ref3 = this.operator) === '++' || ref3 === '--' || ref3 === 'delete') && unfoldSoak(o, this, 'first');
    };

    Op.prototype.generateDo = function(exp) {
      var call, func, j, len1, param, passedParams, ref, ref3;
      passedParams = [];
      func = exp instanceof Assign && (ref = exp.value.unwrap()) instanceof Code ? ref : exp;
      ref3 = func.params || [];
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        param = ref3[j];
        if (param.value) {
          passedParams.push(param.value);
          delete param.value;
        } else {
          passedParams.push(param);
        }
      }
      call = new Call(exp, passedParams);
      call["do"] = true;
      return call;
    };

    Op.prototype.compileNode = function(o) {
      var answer, isChain, lhs, ref3, ref4, rhs;
      isChain = this.isChainable() && this.first.isChainable();
      if (!isChain) {
        this.first.front = this.front;
      }
      if (this.operator === 'delete' && o.scope.check(this.first.unwrapAll().value)) {
        this.error('delete operand may not be argument or var');
      }
      if (((ref3 = this.operator) === '--' || ref3 === '++') && (ref4 = this.first.unwrapAll().value, indexOf.call(STRICT_PROSCRIBED, ref4) >= 0)) {
        this.error("cannot increment/decrement \"" + (this.first.unwrapAll().value) + "\"");
      }
      if (this.isYield()) {
        return this.compileYield(o);
      }
      if (this.isUnary()) {
        return this.compileUnary(o);
      }
      if (isChain) {
        return this.compileChain(o);
      }
      switch (this.operator) {
        case '?':
          return this.compileExistence(o);
        case '**':
          return this.compilePower(o);
        case '//':
          return this.compileFloorDivision(o);
        case '%%':
          return this.compileModulo(o);
        default:
          lhs = this.first.compileToFragments(o, LEVEL_OP);
          rhs = this.second.compileToFragments(o, LEVEL_OP);
          answer = [].concat(lhs, this.makeCode(" " + this.operator + " "), rhs);
          if (o.level <= LEVEL_OP) {
            return answer;
          } else {
            return this.wrapInBraces(answer);
          }
      }
    };

    Op.prototype.compileChain = function(o) {
      var fragments, fst, ref3, shared;
      ref3 = this.first.second.cache(o), this.first.second = ref3[0], shared = ref3[1];
      fst = this.first.compileToFragments(o, LEVEL_OP);
      fragments = fst.concat(this.makeCode(" " + (this.invert ? '&&' : '||') + " "), shared.compileToFragments(o), this.makeCode(" " + this.operator + " "), this.second.compileToFragments(o, LEVEL_OP));
      return this.wrapInBraces(fragments);
    };

    Op.prototype.compileExistence = function(o) {
      var fst, ref;
      if (this.first.isComplex()) {
        ref = new Literal(o.scope.freeVariable('ref'));
        fst = new Parens(new Assign(ref, this.first));
      } else {
        fst = this.first;
        ref = fst;
      }
      return new If(new Existence(fst), ref, {
        type: 'if'
      }).addElse(this.second).compileToFragments(o);
    };

    Op.prototype.compileUnary = function(o) {
      var op, parts, plusMinus;
      parts = [];
      op = this.operator;
      parts.push([this.makeCode(op)]);
      if (op === '!' && this.first instanceof Existence) {
        this.first.negated = !this.first.negated;
        return this.first.compileToFragments(o);
      }
      if (o.level >= LEVEL_ACCESS) {
        return (new Parens(this)).compileToFragments(o);
      }
      plusMinus = op === '+' || op === '-';
      if ((op === 'new' || op === 'typeof' || op === 'delete') || plusMinus && this.first instanceof Op && this.first.operator === op) {
        parts.push([this.makeCode(' ')]);
      }
      if ((plusMinus && this.first instanceof Op) || (op === 'new' && this.first.isStatement(o))) {
        this.first = new Parens(this.first);
      }
      parts.push(this.first.compileToFragments(o, LEVEL_OP));
      if (this.flip) {
        parts.reverse();
      }
      return this.joinFragmentArrays(parts, '');
    };

    Op.prototype.compileYield = function(o) {
      var op, parts;
      parts = [];
      op = this.operator;
      if (o.scope.parent == null) {
        this.error('yield statements must occur within a function generator.');
      }
      if (indexOf.call(Object.keys(this.first), 'expression') >= 0 && !(this.first instanceof Throw)) {
        if (this.isYieldReturn()) {
          parts.push(this.first.compileToFragments(o, LEVEL_TOP));
        } else if (this.first.expression != null) {
          parts.push(this.first.expression.compileToFragments(o, LEVEL_OP));
        }
      } else {
        parts.push([this.makeCode("(" + op + " ")]);
        parts.push(this.first.compileToFragments(o, LEVEL_OP));
        parts.push([this.makeCode(")")]);
      }
      return this.joinFragmentArrays(parts, '');
    };

    Op.prototype.compilePower = function(o) {
      var pow;
      pow = new Value(new Literal('Math'), [new Access(new Literal('pow'))]);
      return new Call(pow, [this.first, this.second]).compileToFragments(o);
    };

    Op.prototype.compileFloorDivision = function(o) {
      var div, floor;
      floor = new Value(new Literal('Math'), [new Access(new Literal('floor'))]);
      div = new Op('/', this.first, this.second);
      return new Call(floor, [div]).compileToFragments(o);
    };

    Op.prototype.compileModulo = function(o) {
      var mod;
      mod = new Value(new Literal(utility('modulo', o)));
      return new Call(mod, [this.first, this.second]).compileToFragments(o);
    };

    Op.prototype.toString = function(idt) {
      return Op.__super__.toString.call(this, idt, this.constructor.name + ' ' + this.operator);
    };

    return Op;

  })(Base);

  exports.In = In = (function(superClass1) {
    extend1(In, superClass1);

    function In(object, array) {
      this.object = object;
      this.array = array;
    }

    In.prototype.children = ['object', 'array'];

    In.prototype.invert = NEGATE;

    In.prototype.compileNode = function(o) {
      var hasSplat, j, len1, obj, ref3;
      if (this.array instanceof Value && this.array.isArray() && this.array.base.objects.length) {
        ref3 = this.array.base.objects;
        for (j = 0, len1 = ref3.length; j < len1; j++) {
          obj = ref3[j];
          if (!(obj instanceof Splat)) {
            continue;
          }
          hasSplat = true;
          break;
        }
        if (!hasSplat) {
          return this.compileOrTest(o);
        }
      }
      return this.compileLoopTest(o);
    };

    In.prototype.compileOrTest = function(o) {
      var cmp, cnj, i, item, j, len1, ref, ref3, ref4, ref5, sub, tests;
      ref3 = this.object.cache(o, LEVEL_OP), sub = ref3[0], ref = ref3[1];
      ref4 = this.negated ? [' !== ', ' && '] : [' === ', ' || '], cmp = ref4[0], cnj = ref4[1];
      tests = [];
      ref5 = this.array.base.objects;
      for (i = j = 0, len1 = ref5.length; j < len1; i = ++j) {
        item = ref5[i];
        if (i) {
          tests.push(this.makeCode(cnj));
        }
        tests = tests.concat((i ? ref : sub), this.makeCode(cmp), item.compileToFragments(o, LEVEL_ACCESS));
      }
      if (o.level < LEVEL_OP) {
        return tests;
      } else {
        return this.wrapInBraces(tests);
      }
    };

    In.prototype.compileLoopTest = function(o) {
      var fragments, ref, ref3, sub;
      ref3 = this.object.cache(o, LEVEL_LIST), sub = ref3[0], ref = ref3[1];
      fragments = [].concat(this.makeCode(utility('indexOf', o) + ".call("), this.array.compileToFragments(o, LEVEL_LIST), this.makeCode(", "), ref, this.makeCode(") " + (this.negated ? '< 0' : '>= 0')));
      if (fragmentsToText(sub) === fragmentsToText(ref)) {
        return fragments;
      }
      fragments = sub.concat(this.makeCode(', '), fragments);
      if (o.level < LEVEL_LIST) {
        return fragments;
      } else {
        return this.wrapInBraces(fragments);
      }
    };

    In.prototype.toString = function(idt) {
      return In.__super__.toString.call(this, idt, this.constructor.name + (this.negated ? '!' : ''));
    };

    return In;

  })(Base);

  exports.Try = Try = (function(superClass1) {
    extend1(Try, superClass1);

    function Try(attempt, errorVariable, recovery, ensure) {
      this.attempt = attempt;
      this.errorVariable = errorVariable;
      this.recovery = recovery;
      this.ensure = ensure;
    }

    Try.prototype.children = ['attempt', 'recovery', 'ensure'];

    Try.prototype.isStatement = YES;

    Try.prototype.jumps = function(o) {
      var ref3;
      return this.attempt.jumps(o) || ((ref3 = this.recovery) != null ? ref3.jumps(o) : void 0);
    };

    Try.prototype.makeReturn = function(res) {
      if (this.attempt) {
        this.attempt = this.attempt.makeReturn(res);
      }
      if (this.recovery) {
        this.recovery = this.recovery.makeReturn(res);
      }
      return this;
    };

    Try.prototype.compileNode = function(o) {
      var catchPart, ensurePart, generatedErrorVariableName, placeholder, tryPart;
      o.indent += TAB;
      tryPart = this.attempt.compileToFragments(o, LEVEL_TOP);
      catchPart = this.recovery ? (generatedErrorVariableName = o.scope.freeVariable('error'), placeholder = new Literal(generatedErrorVariableName), this.errorVariable ? this.recovery.unshift(new Assign(this.errorVariable, placeholder)) : void 0, [].concat(this.makeCode(" catch ("), placeholder.compileToFragments(o), this.makeCode(") {\n"), this.recovery.compileToFragments(o, LEVEL_TOP), this.makeCode("\n" + this.tab + "}"))) : !(this.ensure || this.recovery) ? [this.makeCode(" catch (" + generatedErrorVariableName + ") {}")] : [];
      ensurePart = this.ensure ? [].concat(this.makeCode(" finally {\n"), this.ensure.compileToFragments(o, LEVEL_TOP), this.makeCode("\n" + this.tab + "}")) : [];
      return [].concat(this.makeCode(this.tab + "try {\n"), tryPart, this.makeCode("\n" + this.tab + "}"), catchPart, ensurePart);
    };

    return Try;

  })(Base);

  exports.Throw = Throw = (function(superClass1) {
    extend1(Throw, superClass1);

    function Throw(expression) {
      this.expression = expression;
    }

    Throw.prototype.children = ['expression'];

    Throw.prototype.isStatement = YES;

    Throw.prototype.jumps = NO;

    Throw.prototype.makeReturn = THIS;

    Throw.prototype.compileNode = function(o) {
      return [].concat(this.makeCode(this.tab + "throw "), this.expression.compileToFragments(o), this.makeCode(";"));
    };

    return Throw;

  })(Base);

  exports.Existence = Existence = (function(superClass1) {
    extend1(Existence, superClass1);

    function Existence(expression) {
      this.expression = expression;
    }

    Existence.prototype.children = ['expression'];

    Existence.prototype.invert = NEGATE;

    Existence.prototype.compileNode = function(o) {
      var cmp, cnj, code, ref3;
      this.expression.front = this.front;
      code = this.expression.compile(o, LEVEL_OP);
      if (IDENTIFIER.test(code) && !o.scope.check(code)) {
        ref3 = this.negated ? ['===', '||'] : ['!==', '&&'], cmp = ref3[0], cnj = ref3[1];
        code = "typeof " + code + " " + cmp + " \"undefined\" " + cnj + " " + code + " " + cmp + " null";
      } else {
        code = code + " " + (this.negated ? '==' : '!=') + " null";
      }
      return [this.makeCode(o.level <= LEVEL_COND ? code : "(" + code + ")")];
    };

    return Existence;

  })(Base);

  exports.Parens = Parens = (function(superClass1) {
    extend1(Parens, superClass1);

    function Parens(body1) {
      this.body = body1;
    }

    Parens.prototype.children = ['body'];

    Parens.prototype.unwrap = function() {
      return this.body;
    };

    Parens.prototype.isComplex = function() {
      return this.body.isComplex();
    };

    Parens.prototype.compileNode = function(o) {
      var bare, expr, fragments;
      expr = this.body.unwrap();
      if (expr instanceof Value && expr.isAtomic()) {
        expr.front = this.front;
        return expr.compileToFragments(o);
      }
      fragments = expr.compileToFragments(o, LEVEL_PAREN);
      bare = o.level < LEVEL_OP && (expr instanceof Op || expr instanceof Call || (expr instanceof For && expr.returns));
      if (bare) {
        return fragments;
      } else {
        return this.wrapInBraces(fragments);
      }
    };

    return Parens;

  })(Base);

  exports.For = For = (function(superClass1) {
    extend1(For, superClass1);

    function For(body, source) {
      var ref3;
      this.source = source.source, this.guard = source.guard, this.step = source.step, this.name = source.name, this.index = source.index;
      this.body = Block.wrap([body]);
      this.own = !!source.own;
      this.object = !!source.object;
      if (this.object) {
        ref3 = [this.index, this.name], this.name = ref3[0], this.index = ref3[1];
      }
      if (this.index instanceof Value) {
        this.index.error('index cannot be a pattern matching expression');
      }
      this.range = this.source instanceof Value && this.source.base instanceof Range && !this.source.properties.length;
      this.pattern = this.name instanceof Value;
      if (this.range && this.index) {
        this.index.error('indexes do not apply to range loops');
      }
      if (this.range && this.pattern) {
        this.name.error('cannot pattern match over range loops');
      }
      if (this.own && !this.object) {
        this.name.error('cannot use own with for-in');
      }
      this.returns = false;
    }

    For.prototype.children = ['body', 'source', 'guard', 'step'];

    For.prototype.compileNode = function(o) {
      var body, bodyFragments, compare, compareDown, declare, declareDown, defPart, defPartFragments, down, forPartFragments, guardPart, idt1, increment, index, ivar, kvar, kvarAssign, last, lvar, name, namePart, ref, ref3, ref4, resultPart, returnResult, rvar, scope, source, step, stepNum, stepVar, svar, varPart;
      body = Block.wrap([this.body]);
      ref3 = body.expressions, last = ref3[ref3.length - 1];
      if ((last != null ? last.jumps() : void 0) instanceof Return) {
        this.returns = false;
      }
      source = this.range ? this.source.base : this.source;
      scope = o.scope;
      if (!this.pattern) {
        name = this.name && (this.name.compile(o, LEVEL_LIST));
      }
      index = this.index && (this.index.compile(o, LEVEL_LIST));
      if (name && !this.pattern) {
        scope.find(name);
      }
      if (index) {
        scope.find(index);
      }
      if (this.returns) {
        rvar = scope.freeVariable('results');
      }
      ivar = (this.object && index) || scope.freeVariable('i', {
        single: true
      });
      kvar = (this.range && name) || index || ivar;
      kvarAssign = kvar !== ivar ? kvar + " = " : "";
      if (this.step && !this.range) {
        ref4 = this.cacheToCodeFragments(this.step.cache(o, LEVEL_LIST, isComplexOrAssignable)), step = ref4[0], stepVar = ref4[1];
        stepNum = stepVar.match(NUMBER);
      }
      if (this.pattern) {
        name = ivar;
      }
      varPart = '';
      guardPart = '';
      defPart = '';
      idt1 = this.tab + TAB;
      if (this.range) {
        forPartFragments = source.compileToFragments(merge(o, {
          index: ivar,
          name: name,
          step: this.step,
          isComplex: isComplexOrAssignable
        }));
      } else {
        svar = this.source.compile(o, LEVEL_LIST);
        if ((name || this.own) && !IDENTIFIER.test(svar)) {
          defPart += "" + this.tab + (ref = scope.freeVariable('ref')) + " = " + svar + ";\n";
          svar = ref;
        }
        if (name && !this.pattern) {
          namePart = name + " = " + svar + "[" + kvar + "]";
        }
        if (!this.object) {
          if (step !== stepVar) {
            defPart += "" + this.tab + step + ";\n";
          }
          if (!(this.step && stepNum && (down = parseNum(stepNum[0]) < 0))) {
            lvar = scope.freeVariable('len');
          }
          declare = "" + kvarAssign + ivar + " = 0, " + lvar + " = " + svar + ".length";
          declareDown = "" + kvarAssign + ivar + " = " + svar + ".length - 1";
          compare = ivar + " < " + lvar;
          compareDown = ivar + " >= 0";
          if (this.step) {
            if (stepNum) {
              if (down) {
                compare = compareDown;
                declare = declareDown;
              }
            } else {
              compare = stepVar + " > 0 ? " + compare + " : " + compareDown;
              declare = "(" + stepVar + " > 0 ? (" + declare + ") : " + declareDown + ")";
            }
            increment = ivar + " += " + stepVar;
          } else {
            increment = "" + (kvar !== ivar ? "++" + ivar : ivar + "++");
          }
          forPartFragments = [this.makeCode(declare + "; " + compare + "; " + kvarAssign + increment)];
        }
      }
      if (this.returns) {
        resultPart = "" + this.tab + rvar + " = [];\n";
        returnResult = "\n" + this.tab + "return " + rvar + ";";
        body.makeReturn(rvar);
      }
      if (this.guard) {
        if (body.expressions.length > 1) {
          body.expressions.unshift(new If((new Parens(this.guard)).invert(), new Literal("continue")));
        } else {
          if (this.guard) {
            body = Block.wrap([new If(this.guard, body)]);
          }
        }
      }
      if (this.pattern) {
        body.expressions.unshift(new Assign(this.name, new Literal(svar + "[" + kvar + "]")));
      }
      defPartFragments = [].concat(this.makeCode(defPart), this.pluckDirectCall(o, body));
      if (namePart) {
        varPart = "\n" + idt1 + namePart + ";";
      }
      if (this.object) {
        forPartFragments = [this.makeCode(kvar + " in " + svar)];
        if (this.own) {
          guardPart = "\n" + idt1 + "if (!" + (utility('hasProp', o)) + ".call(" + svar + ", " + kvar + ")) continue;";
        }
      }
      bodyFragments = body.compileToFragments(merge(o, {
        indent: idt1
      }), LEVEL_TOP);
      if (bodyFragments && (bodyFragments.length > 0)) {
        bodyFragments = [].concat(this.makeCode("\n"), bodyFragments, this.makeCode("\n"));
      }
      return [].concat(defPartFragments, this.makeCode("" + (resultPart || '') + this.tab + "for ("), forPartFragments, this.makeCode(") {" + guardPart + varPart), bodyFragments, this.makeCode(this.tab + "}" + (returnResult || '')));
    };

    For.prototype.pluckDirectCall = function(o, body) {
      var base, defs, expr, fn, idx, j, len1, ref, ref3, ref4, ref5, ref6, ref7, ref8, ref9, val;
      defs = [];
      ref3 = body.expressions;
      for (idx = j = 0, len1 = ref3.length; j < len1; idx = ++j) {
        expr = ref3[idx];
        expr = expr.unwrapAll();
        if (!(expr instanceof Call)) {
          continue;
        }
        val = (ref4 = expr.variable) != null ? ref4.unwrapAll() : void 0;
        if (!((val instanceof Code) || (val instanceof Value && ((ref5 = val.base) != null ? ref5.unwrapAll() : void 0) instanceof Code && val.properties.length === 1 && ((ref6 = (ref7 = val.properties[0].name) != null ? ref7.value : void 0) === 'call' || ref6 === 'apply')))) {
          continue;
        }
        fn = ((ref8 = val.base) != null ? ref8.unwrapAll() : void 0) || val;
        ref = new Literal(o.scope.freeVariable('fn'));
        base = new Value(ref);
        if (val.base) {
          ref9 = [base, val], val.base = ref9[0], base = ref9[1];
        }
        body.expressions[idx] = new Call(base, expr.args);
        defs = defs.concat(this.makeCode(this.tab), new Assign(ref, fn).compileToFragments(o, LEVEL_TOP), this.makeCode(';\n'));
      }
      return defs;
    };

    return For;

  })(While);

  exports.Switch = Switch = (function(superClass1) {
    extend1(Switch, superClass1);

    function Switch(subject, cases, otherwise) {
      this.subject = subject;
      this.cases = cases;
      this.otherwise = otherwise;
    }

    Switch.prototype.children = ['subject', 'cases', 'otherwise'];

    Switch.prototype.isStatement = YES;

    Switch.prototype.jumps = function(o) {
      var block, conds, j, jumpNode, len1, ref3, ref4, ref5;
      if (o == null) {
        o = {
          block: true
        };
      }
      ref3 = this.cases;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        ref4 = ref3[j], conds = ref4[0], block = ref4[1];
        if (jumpNode = block.jumps(o)) {
          return jumpNode;
        }
      }
      return (ref5 = this.otherwise) != null ? ref5.jumps(o) : void 0;
    };

    Switch.prototype.makeReturn = function(res) {
      var j, len1, pair, ref3, ref4;
      ref3 = this.cases;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        pair = ref3[j];
        pair[1].makeReturn(res);
      }
      if (res) {
        this.otherwise || (this.otherwise = new Block([new Literal('void 0')]));
      }
      if ((ref4 = this.otherwise) != null) {
        ref4.makeReturn(res);
      }
      return this;
    };

    Switch.prototype.compileNode = function(o) {
      var block, body, cond, conditions, expr, fragments, i, idt1, idt2, j, k, len1, len2, ref3, ref4, ref5;
      idt1 = o.indent + TAB;
      idt2 = o.indent = idt1 + TAB;
      fragments = [].concat(this.makeCode(this.tab + "switch ("), (this.subject ? this.subject.compileToFragments(o, LEVEL_PAREN) : this.makeCode("false")), this.makeCode(") {\n"));
      ref3 = this.cases;
      for (i = j = 0, len1 = ref3.length; j < len1; i = ++j) {
        ref4 = ref3[i], conditions = ref4[0], block = ref4[1];
        ref5 = flatten([conditions]);
        for (k = 0, len2 = ref5.length; k < len2; k++) {
          cond = ref5[k];
          if (!this.subject) {
            cond = cond.invert();
          }
          fragments = fragments.concat(this.makeCode(idt1 + "case "), cond.compileToFragments(o, LEVEL_PAREN), this.makeCode(":\n"));
        }
        if ((body = block.compileToFragments(o, LEVEL_TOP)).length > 0) {
          fragments = fragments.concat(body, this.makeCode('\n'));
        }
        if (i === this.cases.length - 1 && !this.otherwise) {
          break;
        }
        expr = this.lastNonComment(block.expressions);
        if (expr instanceof Return || (expr instanceof Literal && expr.jumps() && expr.value !== 'debugger')) {
          continue;
        }
        fragments.push(cond.makeCode(idt2 + 'break;\n'));
      }
      if (this.otherwise && this.otherwise.expressions.length) {
        fragments.push.apply(fragments, [this.makeCode(idt1 + "default:\n")].concat(slice.call(this.otherwise.compileToFragments(o, LEVEL_TOP)), [this.makeCode("\n")]));
      }
      fragments.push(this.makeCode(this.tab + '}'));
      return fragments;
    };

    return Switch;

  })(Base);

  exports.If = If = (function(superClass1) {
    extend1(If, superClass1);

    function If(condition, body1, options) {
      this.body = body1;
      if (options == null) {
        options = {};
      }
      this.condition = options.type === 'unless' ? condition.invert() : condition;
      this.elseBody = null;
      this.isChain = false;
      this.soak = options.soak;
    }

    If.prototype.children = ['condition', 'body', 'elseBody'];

    If.prototype.bodyNode = function() {
      var ref3;
      return (ref3 = this.body) != null ? ref3.unwrap() : void 0;
    };

    If.prototype.elseBodyNode = function() {
      var ref3;
      return (ref3 = this.elseBody) != null ? ref3.unwrap() : void 0;
    };

    If.prototype.addElse = function(elseBody) {
      if (this.isChain) {
        this.elseBodyNode().addElse(elseBody);
      } else {
        this.isChain = elseBody instanceof If;
        this.elseBody = this.ensureBlock(elseBody);
        this.elseBody.updateLocationDataIfMissing(elseBody.locationData);
      }
      return this;
    };

    If.prototype.isStatement = function(o) {
      var ref3;
      return (o != null ? o.level : void 0) === LEVEL_TOP || this.bodyNode().isStatement(o) || ((ref3 = this.elseBodyNode()) != null ? ref3.isStatement(o) : void 0);
    };

    If.prototype.jumps = function(o) {
      var ref3;
      return this.body.jumps(o) || ((ref3 = this.elseBody) != null ? ref3.jumps(o) : void 0);
    };

    If.prototype.compileNode = function(o) {
      if (this.isStatement(o)) {
        return this.compileStatement(o);
      } else {
        return this.compileExpression(o);
      }
    };

    If.prototype.makeReturn = function(res) {
      if (res) {
        this.elseBody || (this.elseBody = new Block([new Literal('void 0')]));
      }
      this.body && (this.body = new Block([this.body.makeReturn(res)]));
      this.elseBody && (this.elseBody = new Block([this.elseBody.makeReturn(res)]));
      return this;
    };

    If.prototype.ensureBlock = function(node) {
      if (node instanceof Block) {
        return node;
      } else {
        return new Block([node]);
      }
    };

    If.prototype.compileStatement = function(o) {
      var answer, body, child, cond, exeq, ifPart, indent;
      child = del(o, 'chainChild');
      exeq = del(o, 'isExistentialEquals');
      if (exeq) {
        return new If(this.condition.invert(), this.elseBodyNode(), {
          type: 'if'
        }).compileToFragments(o);
      }
      indent = o.indent + TAB;
      cond = this.condition.compileToFragments(o, LEVEL_PAREN);
      body = this.ensureBlock(this.body).compileToFragments(merge(o, {
        indent: indent
      }));
      ifPart = [].concat(this.makeCode("if ("), cond, this.makeCode(") {\n"), body, this.makeCode("\n" + this.tab + "}"));
      if (!child) {
        ifPart.unshift(this.makeCode(this.tab));
      }
      if (!this.elseBody) {
        return ifPart;
      }
      answer = ifPart.concat(this.makeCode(' else '));
      if (this.isChain) {
        o.chainChild = true;
        answer = answer.concat(this.elseBody.unwrap().compileToFragments(o, LEVEL_TOP));
      } else {
        answer = answer.concat(this.makeCode("{\n"), this.elseBody.compileToFragments(merge(o, {
          indent: indent
        }), LEVEL_TOP), this.makeCode("\n" + this.tab + "}"));
      }
      return answer;
    };

    If.prototype.compileExpression = function(o) {
      var alt, body, cond, fragments;
      cond = this.condition.compileToFragments(o, LEVEL_COND);
      body = this.bodyNode().compileToFragments(o, LEVEL_LIST);
      alt = this.elseBodyNode() ? this.elseBodyNode().compileToFragments(o, LEVEL_LIST) : [this.makeCode('void 0')];
      fragments = cond.concat(this.makeCode(" ? "), body, this.makeCode(" : "), alt);
      if (o.level >= LEVEL_COND) {
        return this.wrapInBraces(fragments);
      } else {
        return fragments;
      }
    };

    If.prototype.unfoldSoak = function() {
      return this.soak && this;
    };

    return If;

  })(Base);

  UTILITIES = {
    extend: function(o) {
      return "function(child, parent) { for (var key in parent) { if (" + (utility('hasProp', o)) + ".call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }";
    },
    bind: function() {
      return 'function(fn, me){ return function(){ return fn.apply(me, arguments); }; }';
    },
    indexOf: function() {
      return "[].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; }";
    },
    modulo: function() {
      return "function(a, b) { return (+a % (b = +b) + b) % b; }";
    },
    hasProp: function() {
      return '{}.hasOwnProperty';
    },
    slice: function() {
      return '[].slice';
    }
  };

  LEVEL_TOP = 1;

  LEVEL_PAREN = 2;

  LEVEL_LIST = 3;

  LEVEL_COND = 4;

  LEVEL_OP = 5;

  LEVEL_ACCESS = 6;

  TAB = '  ';

  IDENTIFIER = /^(?!\d)[$\w\x7f-\uffff]+$/;

  SIMPLENUM = /^[+-]?\d+$/;

  HEXNUM = /^[+-]?0x[\da-f]+/i;

  NUMBER = /^[+-]?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)$/i;

  IS_STRING = /^['"]/;

  IS_REGEX = /^\//;

  utility = function(name, o) {
    var ref, root;
    root = o.scope.root;
    if (name in root.utilities) {
      return root.utilities[name];
    } else {
      ref = root.freeVariable(name);
      root.assign(ref, UTILITIES[name](o));
      return root.utilities[name] = ref;
    }
  };

  multident = function(code, tab) {
    code = code.replace(/\n/g, '$&' + tab);
    return code.replace(/\s+$/, '');
  };

  parseNum = function(x) {
    if (x == null) {
      return 0;
    } else if (x.match(HEXNUM)) {
      return parseInt(x, 16);
    } else {
      return parseFloat(x);
    }
  };

  isLiteralArguments = function(node) {
    return node instanceof Literal && node.value === 'arguments' && !node.asKey;
  };

  isLiteralThis = function(node) {
    return (node instanceof Literal && node.value === 'this' && !node.asKey) || (node instanceof Code && node.bound) || (node instanceof Call && node.isSuper);
  };

  isComplexOrAssignable = function(node) {
    return node.isComplex() || (typeof node.isAssignable === "function" ? node.isAssignable() : void 0);
  };

  unfoldSoak = function(o, parent, name) {
    var ifn;
    if (!(ifn = parent[name].unfoldSoak(o))) {
      return;
    }
    parent[name] = ifn.body;
    ifn.body = new Value(parent);
    return ifn;
  };

}).call(this);

},{"./helpers":180,"./lexer":181,"./scope":186}],183:[function(require,module,exports){
(function (process){
/* parser generated by jison 0.4.17 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,20],$V1=[1,75],$V2=[1,71],$V3=[1,76],$V4=[1,77],$V5=[1,73],$V6=[1,74],$V7=[1,50],$V8=[1,52],$V9=[1,53],$Va=[1,54],$Vb=[1,55],$Vc=[1,45],$Vd=[1,46],$Ve=[1,27],$Vf=[1,60],$Vg=[1,61],$Vh=[1,70],$Vi=[1,43],$Vj=[1,26],$Vk=[1,58],$Vl=[1,59],$Vm=[1,57],$Vn=[1,38],$Vo=[1,44],$Vp=[1,56],$Vq=[1,65],$Vr=[1,66],$Vs=[1,67],$Vt=[1,68],$Vu=[1,42],$Vv=[1,64],$Vw=[1,29],$Vx=[1,30],$Vy=[1,31],$Vz=[1,32],$VA=[1,33],$VB=[1,34],$VC=[1,35],$VD=[1,78],$VE=[1,6,26,34,109],$VF=[1,93],$VG=[1,81],$VH=[1,80],$VI=[1,79],$VJ=[1,82],$VK=[1,83],$VL=[1,84],$VM=[1,85],$VN=[1,86],$VO=[1,87],$VP=[1,88],$VQ=[1,89],$VR=[1,90],$VS=[1,91],$VT=[1,92],$VU=[1,96],$VV=[1,6,25,26,34,56,61,64,80,85,93,98,100,109,111,112,113,117,118,133,136,137,142,143,144,145,146,147,148,149,150,151,152,153],$VW=[1,102],$VX=[1,103],$VY=[1,104],$VZ=[1,105],$V_=[1,107],$V$=[1,108],$V01=[1,101],$V11=[2,115],$V21=[1,6,25,26,34,56,61,64,73,74,75,76,78,80,81,85,91,92,93,98,100,109,111,112,113,117,118,133,136,137,142,143,144,145,146,147,148,149,150,151,152,153],$V31=[2,82],$V41=[1,113],$V51=[2,61],$V61=[1,117],$V71=[1,122],$V81=[1,123],$V91=[1,125],$Va1=[1,6,25,26,34,46,56,61,64,73,74,75,76,78,80,81,85,91,92,93,98,100,109,111,112,113,117,118,133,136,137,142,143,144,145,146,147,148,149,150,151,152,153],$Vb1=[2,79],$Vc1=[1,6,26,34,56,61,64,80,85,93,98,100,109,111,112,113,117,118,133,136,137,142,143,144,145,146,147,148,149,150,151,152,153],$Vd1=[1,160],$Ve1=[1,162],$Vf1=[1,157],$Vg1=[1,6,25,26,34,46,56,61,64,73,74,75,76,78,80,81,85,87,91,92,93,98,100,109,111,112,113,117,118,133,136,137,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154],$Vh1=[2,98],$Vi1=[1,6,25,26,34,49,56,61,64,73,74,75,76,78,80,81,85,91,92,93,98,100,109,111,112,113,117,118,133,136,137,142,143,144,145,146,147,148,149,150,151,152,153],$Vj1=[1,6,25,26,34,46,49,56,61,64,73,74,75,76,78,80,81,85,87,91,92,93,98,100,109,111,112,113,117,118,124,125,133,136,137,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154],$Vk1=[1,217],$Vl1=[1,216],$Vm1=[1,6,25,26,34,38,56,61,64,73,74,75,76,78,80,81,85,91,92,93,98,100,109,111,112,113,117,118,133,136,137,142,143,144,145,146,147,148,149,150,151,152,153],$Vn1=[2,59],$Vo1=[1,227],$Vp1=[6,25,26,56,61],$Vq1=[6,25,26,46,56,61,64],$Vr1=[1,6,25,26,34,56,61,64,80,85,93,98,100,109,111,112,113,117,118,133,136,137,143,145,146,147,148,149,150,151,152,153],$Vs1=[1,6,25,26,34,56,61,64,80,85,93,98,100,109,111,112,113,117,118,133],$Vt1=[73,74,75,76,78,81,91,92],$Vu1=[1,246],$Vv1=[2,136],$Vw1=[1,6,25,26,34,46,56,61,64,73,74,75,76,78,80,81,85,91,92,93,98,100,109,111,112,113,117,118,124,125,133,136,137,142,143,144,145,146,147,148,149,150,151,152,153],$Vx1=[1,255],$Vy1=[6,25,26,61,93,98],$Vz1=[1,6,25,26,34,56,61,64,80,85,93,98,100,109,118,133],$VA1=[1,6,25,26,34,56,61,64,80,85,93,98,100,109,112,118,133],$VB1=[124,125],$VC1=[61,124,125],$VD1=[1,266],$VE1=[6,25,26,61,85],$VF1=[6,25,26,49,61,85],$VG1=[6,25,26,46,49,61,85],$VH1=[1,6,25,26,34,56,61,64,80,85,93,98,100,109,111,112,113,117,118,133,136,137,145,146,147,148,149,150,151,152,153],$VI1=[11,28,30,32,33,36,37,40,41,42,43,44,52,53,54,58,59,80,83,86,90,95,96,97,103,107,108,111,113,115,117,126,132,134,135,136,137,138,140,141],$VJ1=[2,125],$VK1=[6,25,26],$VL1=[2,60],$VM1=[1,280],$VN1=[1,281],$VO1=[1,6,25,26,34,56,61,64,80,85,93,98,100,105,106,109,111,112,113,117,118,128,130,133,136,137,142,143,144,145,146,147,148,149,150,151,152,153],$VP1=[26,128,130],$VQ1=[1,6,26,34,56,61,64,80,85,93,98,100,109,112,118,133],$VR1=[2,74],$VS1=[1,303],$VT1=[1,304],$VU1=[1,6,25,26,34,56,61,64,80,85,93,98,100,109,111,112,113,117,118,128,133,136,137,142,143,144,145,146,147,148,149,150,151,152,153],$VV1=[1,6,25,26,34,56,61,64,80,85,93,98,100,109,111,113,117,118,133],$VW1=[1,315],$VX1=[1,316],$VY1=[6,25,26,61],$VZ1=[1,6,25,26,34,56,61,64,80,85,93,98,100,105,109,111,112,113,117,118,133,136,137,142,143,144,145,146,147,148,149,150,151,152,153],$V_1=[25,61];
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"Root":3,"Body":4,"Line":5,"TERMINATOR":6,"Expression":7,"Statement":8,"Return":9,"Comment":10,"STATEMENT":11,"Value":12,"Invocation":13,"Code":14,"Operation":15,"Assign":16,"If":17,"Try":18,"While":19,"For":20,"Switch":21,"Class":22,"Throw":23,"Block":24,"INDENT":25,"OUTDENT":26,"Identifier":27,"IDENTIFIER":28,"AlphaNumeric":29,"NUMBER":30,"String":31,"STRING":32,"STRING_START":33,"STRING_END":34,"Regex":35,"REGEX":36,"REGEX_START":37,"REGEX_END":38,"Literal":39,"JS":40,"DEBUGGER":41,"UNDEFINED":42,"NULL":43,"BOOL":44,"Assignable":45,"=":46,"AssignObj":47,"ObjAssignable":48,":":49,"SimpleObjAssignable":50,"ThisProperty":51,"RETURN":52,"HERECOMMENT":53,"PARAM_START":54,"ParamList":55,"PARAM_END":56,"FuncGlyph":57,"->":58,"=>":59,"OptComma":60,",":61,"Param":62,"ParamVar":63,"...":64,"Array":65,"Object":66,"Splat":67,"SimpleAssignable":68,"Accessor":69,"Parenthetical":70,"Range":71,"This":72,".":73,"?.":74,"::":75,"?::":76,"Index":77,"INDEX_START":78,"IndexValue":79,"INDEX_END":80,"INDEX_SOAK":81,"Slice":82,"{":83,"AssignList":84,"}":85,"CLASS":86,"EXTENDS":87,"OptFuncExist":88,"Arguments":89,"SUPER":90,"FUNC_EXIST":91,"CALL_START":92,"CALL_END":93,"ArgList":94,"THIS":95,"@":96,"[":97,"]":98,"RangeDots":99,"..":100,"Arg":101,"SimpleArgs":102,"TRY":103,"Catch":104,"FINALLY":105,"CATCH":106,"THROW":107,"(":108,")":109,"WhileSource":110,"WHILE":111,"WHEN":112,"UNTIL":113,"Loop":114,"LOOP":115,"ForBody":116,"FOR":117,"BY":118,"ForStart":119,"ForSource":120,"ForVariables":121,"OWN":122,"ForValue":123,"FORIN":124,"FOROF":125,"SWITCH":126,"Whens":127,"ELSE":128,"When":129,"LEADING_WHEN":130,"IfBlock":131,"IF":132,"POST_IF":133,"UNARY":134,"UNARY_MATH":135,"-":136,"+":137,"YIELD":138,"FROM":139,"--":140,"++":141,"?":142,"MATH":143,"**":144,"SHIFT":145,"COMPARE":146,"&":147,"^":148,"|":149,"&&":150,"||":151,"BIN?":152,"RELATION":153,"COMPOUND_ASSIGN":154,"$accept":0,"$end":1},
terminals_: {2:"error",6:"TERMINATOR",11:"STATEMENT",25:"INDENT",26:"OUTDENT",28:"IDENTIFIER",30:"NUMBER",32:"STRING",33:"STRING_START",34:"STRING_END",36:"REGEX",37:"REGEX_START",38:"REGEX_END",40:"JS",41:"DEBUGGER",42:"UNDEFINED",43:"NULL",44:"BOOL",46:"=",49:":",52:"RETURN",53:"HERECOMMENT",54:"PARAM_START",56:"PARAM_END",58:"->",59:"=>",61:",",64:"...",73:".",74:"?.",75:"::",76:"?::",78:"INDEX_START",80:"INDEX_END",81:"INDEX_SOAK",83:"{",85:"}",86:"CLASS",87:"EXTENDS",90:"SUPER",91:"FUNC_EXIST",92:"CALL_START",93:"CALL_END",95:"THIS",96:"@",97:"[",98:"]",100:"..",103:"TRY",105:"FINALLY",106:"CATCH",107:"THROW",108:"(",109:")",111:"WHILE",112:"WHEN",113:"UNTIL",115:"LOOP",117:"FOR",118:"BY",122:"OWN",124:"FORIN",125:"FOROF",126:"SWITCH",128:"ELSE",130:"LEADING_WHEN",132:"IF",133:"POST_IF",134:"UNARY",135:"UNARY_MATH",136:"-",137:"+",138:"YIELD",139:"FROM",140:"--",141:"++",142:"?",143:"MATH",144:"**",145:"SHIFT",146:"COMPARE",147:"&",148:"^",149:"|",150:"&&",151:"||",152:"BIN?",153:"RELATION",154:"COMPOUND_ASSIGN"},
productions_: [0,[3,0],[3,1],[4,1],[4,3],[4,2],[5,1],[5,1],[8,1],[8,1],[8,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[24,2],[24,3],[27,1],[29,1],[29,1],[31,1],[31,3],[35,1],[35,3],[39,1],[39,1],[39,1],[39,1],[39,1],[39,1],[39,1],[16,3],[16,4],[16,5],[47,1],[47,3],[47,5],[47,3],[47,5],[47,1],[50,1],[50,1],[48,1],[48,1],[9,2],[9,1],[10,1],[14,5],[14,2],[57,1],[57,1],[60,0],[60,1],[55,0],[55,1],[55,3],[55,4],[55,6],[62,1],[62,2],[62,3],[62,1],[63,1],[63,1],[63,1],[63,1],[67,2],[68,1],[68,2],[68,2],[68,1],[45,1],[45,1],[45,1],[12,1],[12,1],[12,1],[12,1],[12,1],[69,2],[69,2],[69,2],[69,2],[69,1],[69,1],[77,3],[77,2],[79,1],[79,1],[66,4],[84,0],[84,1],[84,3],[84,4],[84,6],[22,1],[22,2],[22,3],[22,4],[22,2],[22,3],[22,4],[22,5],[13,3],[13,3],[13,1],[13,2],[88,0],[88,1],[89,2],[89,4],[72,1],[72,1],[51,2],[65,2],[65,4],[99,1],[99,1],[71,5],[82,3],[82,2],[82,2],[82,1],[94,1],[94,3],[94,4],[94,4],[94,6],[101,1],[101,1],[101,1],[102,1],[102,3],[18,2],[18,3],[18,4],[18,5],[104,3],[104,3],[104,2],[23,2],[70,3],[70,5],[110,2],[110,4],[110,2],[110,4],[19,2],[19,2],[19,2],[19,1],[114,2],[114,2],[20,2],[20,2],[20,2],[116,2],[116,4],[116,2],[119,2],[119,3],[123,1],[123,1],[123,1],[123,1],[121,1],[121,3],[120,2],[120,2],[120,4],[120,4],[120,4],[120,6],[120,6],[21,5],[21,7],[21,4],[21,6],[127,1],[127,2],[129,3],[129,4],[131,3],[131,5],[17,1],[17,3],[17,3],[17,3],[15,2],[15,2],[15,2],[15,2],[15,2],[15,2],[15,3],[15,2],[15,2],[15,2],[15,2],[15,2],[15,3],[15,3],[15,3],[15,3],[15,3],[15,3],[15,3],[15,3],[15,3],[15,3],[15,3],[15,3],[15,3],[15,3],[15,5],[15,4],[15,3]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
return this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Block);
break;
case 2:
return this.$ = $$[$0];
break;
case 3:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(yy.Block.wrap([$$[$0]]));
break;
case 4:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])($$[$0-2].push($$[$0]));
break;
case 5:
this.$ = $$[$0-1];
break;
case 6: case 7: case 8: case 9: case 11: case 12: case 13: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 27: case 32: case 34: case 47: case 48: case 49: case 50: case 51: case 59: case 60: case 70: case 71: case 72: case 73: case 78: case 79: case 82: case 86: case 92: case 136: case 137: case 139: case 169: case 170: case 186: case 192:
this.$ = $$[$0];
break;
case 10: case 25: case 26: case 28: case 30: case 33: case 35:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Literal($$[$0]));
break;
case 23:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Block);
break;
case 24: case 31: case 93:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])($$[$0-1]);
break;
case 29: case 149:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Parens($$[$0-1]));
break;
case 36:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Undefined);
break;
case 37:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Null);
break;
case 38:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Bool($$[$0]));
break;
case 39:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Assign($$[$0-2], $$[$0]));
break;
case 40:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Assign($$[$0-3], $$[$0]));
break;
case 41:
this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Assign($$[$0-4], $$[$0-1]));
break;
case 42: case 75: case 80: case 81: case 83: case 84: case 85: case 171: case 172:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Value($$[$0]));
break;
case 43:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Assign(yy.addLocationDataFn(_$[$0-2])(new yy.Value($$[$0-2])), $$[$0], 'object', {
          operatorToken: yy.addLocationDataFn(_$[$0-1])(new yy.Literal($$[$0-1]))
        }));
break;
case 44:
this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Assign(yy.addLocationDataFn(_$[$0-4])(new yy.Value($$[$0-4])), $$[$0-1], 'object', {
          operatorToken: yy.addLocationDataFn(_$[$0-3])(new yy.Literal($$[$0-3]))
        }));
break;
case 45:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Assign(yy.addLocationDataFn(_$[$0-2])(new yy.Value($$[$0-2])), $$[$0], null, {
          operatorToken: yy.addLocationDataFn(_$[$0-1])(new yy.Literal($$[$0-1]))
        }));
break;
case 46:
this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Assign(yy.addLocationDataFn(_$[$0-4])(new yy.Value($$[$0-4])), $$[$0-1], null, {
          operatorToken: yy.addLocationDataFn(_$[$0-3])(new yy.Literal($$[$0-3]))
        }));
break;
case 52:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Return($$[$0]));
break;
case 53:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Return);
break;
case 54:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Comment($$[$0]));
break;
case 55:
this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Code($$[$0-3], $$[$0], $$[$0-1]));
break;
case 56:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Code([], $$[$0], $$[$0-1]));
break;
case 57:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])('func');
break;
case 58:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])('boundfunc');
break;
case 61: case 98:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])([]);
break;
case 62: case 99: case 131: case 173:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])([$$[$0]]);
break;
case 63: case 100: case 132:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])($$[$0-2].concat($$[$0]));
break;
case 64: case 101: case 133:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])($$[$0-3].concat($$[$0]));
break;
case 65: case 102: case 135:
this.$ = yy.addLocationDataFn(_$[$0-5], _$[$0])($$[$0-5].concat($$[$0-2]));
break;
case 66:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Param($$[$0]));
break;
case 67:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Param($$[$0-1], null, true));
break;
case 68:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Param($$[$0-2], $$[$0]));
break;
case 69: case 138:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Expansion);
break;
case 74:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Splat($$[$0-1]));
break;
case 76:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])($$[$0-1].add($$[$0]));
break;
case 77:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Value($$[$0-1], [].concat($$[$0])));
break;
case 87:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Access($$[$0]));
break;
case 88:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Access($$[$0], 'soak'));
break;
case 89:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])([yy.addLocationDataFn(_$[$0-1])(new yy.Access(new yy.Literal('prototype'))), yy.addLocationDataFn(_$[$0])(new yy.Access($$[$0]))]);
break;
case 90:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])([yy.addLocationDataFn(_$[$0-1])(new yy.Access(new yy.Literal('prototype'), 'soak')), yy.addLocationDataFn(_$[$0])(new yy.Access($$[$0]))]);
break;
case 91:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Access(new yy.Literal('prototype')));
break;
case 94:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(yy.extend($$[$0], {
          soak: true
        }));
break;
case 95:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Index($$[$0]));
break;
case 96:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Slice($$[$0]));
break;
case 97:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Obj($$[$0-2], $$[$0-3].generated));
break;
case 103:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Class);
break;
case 104:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Class(null, null, $$[$0]));
break;
case 105:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Class(null, $$[$0]));
break;
case 106:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Class(null, $$[$0-1], $$[$0]));
break;
case 107:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Class($$[$0]));
break;
case 108:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Class($$[$0-1], null, $$[$0]));
break;
case 109:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Class($$[$0-2], $$[$0]));
break;
case 110:
this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Class($$[$0-3], $$[$0-1], $$[$0]));
break;
case 111: case 112:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Call($$[$0-2], $$[$0], $$[$0-1]));
break;
case 113:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Call('super', [new yy.Splat(new yy.Literal('arguments'))]));
break;
case 114:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Call('super', $$[$0]));
break;
case 115:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(false);
break;
case 116:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(true);
break;
case 117:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])([]);
break;
case 118: case 134:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])($$[$0-2]);
break;
case 119: case 120:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Value(new yy.Literal('this')));
break;
case 121:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Value(yy.addLocationDataFn(_$[$0-1])(new yy.Literal('this')), [yy.addLocationDataFn(_$[$0])(new yy.Access($$[$0]))], 'this'));
break;
case 122:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Arr([]));
break;
case 123:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Arr($$[$0-2]));
break;
case 124:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])('inclusive');
break;
case 125:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])('exclusive');
break;
case 126:
this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Range($$[$0-3], $$[$0-1], $$[$0-2]));
break;
case 127:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Range($$[$0-2], $$[$0], $$[$0-1]));
break;
case 128:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Range($$[$0-1], null, $$[$0]));
break;
case 129:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Range(null, $$[$0], $$[$0-1]));
break;
case 130:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Range(null, null, $$[$0]));
break;
case 140:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])([].concat($$[$0-2], $$[$0]));
break;
case 141:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Try($$[$0]));
break;
case 142:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Try($$[$0-1], $$[$0][0], $$[$0][1]));
break;
case 143:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Try($$[$0-2], null, null, $$[$0]));
break;
case 144:
this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Try($$[$0-3], $$[$0-2][0], $$[$0-2][1], $$[$0]));
break;
case 145:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])([$$[$0-1], $$[$0]]);
break;
case 146:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])([yy.addLocationDataFn(_$[$0-1])(new yy.Value($$[$0-1])), $$[$0]]);
break;
case 147:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])([null, $$[$0]]);
break;
case 148:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Throw($$[$0]));
break;
case 150:
this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Parens($$[$0-2]));
break;
case 151:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.While($$[$0]));
break;
case 152:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.While($$[$0-2], {
          guard: $$[$0]
        }));
break;
case 153:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.While($$[$0], {
          invert: true
        }));
break;
case 154:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.While($$[$0-2], {
          invert: true,
          guard: $$[$0]
        }));
break;
case 155:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])($$[$0-1].addBody($$[$0]));
break;
case 156: case 157:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])($$[$0].addBody(yy.addLocationDataFn(_$[$0-1])(yy.Block.wrap([$$[$0-1]]))));
break;
case 158:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])($$[$0]);
break;
case 159:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.While(yy.addLocationDataFn(_$[$0-1])(new yy.Literal('true'))).addBody($$[$0]));
break;
case 160:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.While(yy.addLocationDataFn(_$[$0-1])(new yy.Literal('true'))).addBody(yy.addLocationDataFn(_$[$0])(yy.Block.wrap([$$[$0]]))));
break;
case 161: case 162:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.For($$[$0-1], $$[$0]));
break;
case 163:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.For($$[$0], $$[$0-1]));
break;
case 164:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])({
          source: yy.addLocationDataFn(_$[$0])(new yy.Value($$[$0]))
        });
break;
case 165:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])({
          source: yy.addLocationDataFn(_$[$0-2])(new yy.Value($$[$0-2])),
          step: $$[$0]
        });
break;
case 166:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])((function () {
        $$[$0].own = $$[$0-1].own;
        $$[$0].name = $$[$0-1][0];
        $$[$0].index = $$[$0-1][1];
        return $$[$0];
      }()));
break;
case 167:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])($$[$0]);
break;
case 168:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])((function () {
        $$[$0].own = true;
        return $$[$0];
      }()));
break;
case 174:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])([$$[$0-2], $$[$0]]);
break;
case 175:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])({
          source: $$[$0]
        });
break;
case 176:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])({
          source: $$[$0],
          object: true
        });
break;
case 177:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])({
          source: $$[$0-2],
          guard: $$[$0]
        });
break;
case 178:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])({
          source: $$[$0-2],
          guard: $$[$0],
          object: true
        });
break;
case 179:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])({
          source: $$[$0-2],
          step: $$[$0]
        });
break;
case 180:
this.$ = yy.addLocationDataFn(_$[$0-5], _$[$0])({
          source: $$[$0-4],
          guard: $$[$0-2],
          step: $$[$0]
        });
break;
case 181:
this.$ = yy.addLocationDataFn(_$[$0-5], _$[$0])({
          source: $$[$0-4],
          step: $$[$0-2],
          guard: $$[$0]
        });
break;
case 182:
this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Switch($$[$0-3], $$[$0-1]));
break;
case 183:
this.$ = yy.addLocationDataFn(_$[$0-6], _$[$0])(new yy.Switch($$[$0-5], $$[$0-3], $$[$0-1]));
break;
case 184:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Switch(null, $$[$0-1]));
break;
case 185:
this.$ = yy.addLocationDataFn(_$[$0-5], _$[$0])(new yy.Switch(null, $$[$0-3], $$[$0-1]));
break;
case 187:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])($$[$0-1].concat($$[$0]));
break;
case 188:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])([[$$[$0-1], $$[$0]]]);
break;
case 189:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])([[$$[$0-2], $$[$0-1]]]);
break;
case 190:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.If($$[$0-1], $$[$0], {
          type: $$[$0-2]
        }));
break;
case 191:
this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])($$[$0-4].addElse(yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.If($$[$0-1], $$[$0], {
          type: $$[$0-2]
        }))));
break;
case 193:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])($$[$0-2].addElse($$[$0]));
break;
case 194: case 195:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.If($$[$0], yy.addLocationDataFn(_$[$0-2])(yy.Block.wrap([$$[$0-2]])), {
          type: $$[$0-1],
          statement: true
        }));
break;
case 196: case 197: case 200: case 201:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Op($$[$0-1], $$[$0]));
break;
case 198:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Op('-', $$[$0]));
break;
case 199:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Op('+', $$[$0]));
break;
case 202:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Op($$[$0-2].concat($$[$0-1]), $$[$0]));
break;
case 203:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Op('--', $$[$0]));
break;
case 204:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Op('++', $$[$0]));
break;
case 205:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Op('--', $$[$0-1], null, true));
break;
case 206:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Op('++', $$[$0-1], null, true));
break;
case 207:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Existence($$[$0-1]));
break;
case 208:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Op('+', $$[$0-2], $$[$0]));
break;
case 209:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Op('-', $$[$0-2], $$[$0]));
break;
case 210: case 211: case 212: case 213: case 214: case 215: case 216: case 217: case 218: case 219:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Op($$[$0-1], $$[$0-2], $$[$0]));
break;
case 220:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])((function () {
        if ($$[$0-1].charAt(0) === '!') {
          return new yy.Op($$[$0-1].slice(1), $$[$0-2], $$[$0]).invert();
        } else {
          return new yy.Op($$[$0-1], $$[$0-2], $$[$0]);
        }
      }()));
break;
case 221:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Assign($$[$0-2], $$[$0], $$[$0-1]));
break;
case 222:
this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Assign($$[$0-4], $$[$0-1], $$[$0-3]));
break;
case 223:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Assign($$[$0-3], $$[$0], $$[$0-2]));
break;
case 224:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Extends($$[$0-2], $$[$0]));
break;
}
},
table: [{1:[2,1],3:1,4:2,5:3,7:4,8:5,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{1:[3]},{1:[2,2],6:$VD},o($VE,[2,3]),o($VE,[2,6],{119:69,110:94,116:95,111:$Vq,113:$Vr,117:$Vt,133:$VF,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),o($VE,[2,7],{119:69,110:97,116:98,111:$Vq,113:$Vr,117:$Vt,133:$VU}),o($VV,[2,11],{88:99,69:100,77:106,73:$VW,74:$VX,75:$VY,76:$VZ,78:$V_,81:$V$,91:$V01,92:$V11}),o($VV,[2,12],{77:106,88:109,69:110,73:$VW,74:$VX,75:$VY,76:$VZ,78:$V_,81:$V$,91:$V01,92:$V11}),o($VV,[2,13]),o($VV,[2,14]),o($VV,[2,15]),o($VV,[2,16]),o($VV,[2,17]),o($VV,[2,18]),o($VV,[2,19]),o($VV,[2,20]),o($VV,[2,21]),o($VV,[2,22]),o($VV,[2,8]),o($VV,[2,9]),o($VV,[2,10]),o($V21,$V31,{46:[1,111]}),o($V21,[2,83]),o($V21,[2,84]),o($V21,[2,85]),o($V21,[2,86]),o([1,6,25,26,34,38,56,61,64,73,74,75,76,78,80,81,85,91,93,98,100,109,111,112,113,117,118,133,136,137,142,143,144,145,146,147,148,149,150,151,152,153],[2,113],{89:112,92:$V41}),o([6,25,56,61],$V51,{55:114,62:115,63:116,27:118,51:119,65:120,66:121,28:$V1,64:$V61,83:$Vh,96:$V71,97:$V81}),{24:124,25:$V91},{7:126,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:128,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:129,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:130,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:132,8:131,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,139:[1,133],140:$VB,141:$VC},{12:135,13:136,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:137,51:63,65:47,66:48,68:134,70:23,71:24,72:25,83:$Vh,90:$Vj,95:$Vk,96:$Vl,97:$Vm,108:$Vp},{12:135,13:136,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:137,51:63,65:47,66:48,68:138,70:23,71:24,72:25,83:$Vh,90:$Vj,95:$Vk,96:$Vl,97:$Vm,108:$Vp},o($Va1,$Vb1,{87:[1,142],140:[1,139],141:[1,140],154:[1,141]}),o($VV,[2,192],{128:[1,143]}),{24:144,25:$V91},{24:145,25:$V91},o($VV,[2,158]),{24:146,25:$V91},{7:147,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:[1,148],27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($Vc1,[2,103],{39:22,70:23,71:24,72:25,65:47,66:48,29:49,35:51,27:62,51:63,31:72,12:135,13:136,45:137,24:149,68:151,25:$V91,28:$V1,30:$V2,32:$V3,33:$V4,36:$V5,37:$V6,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,83:$Vh,87:[1,150],90:$Vj,95:$Vk,96:$Vl,97:$Vm,108:$Vp}),{7:152,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o([1,6,25,26,34,56,61,64,80,85,93,98,100,109,111,112,113,117,118,133,142,143,144,145,146,147,148,149,150,151,152,153],[2,53],{12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,9:18,10:19,45:21,39:22,70:23,71:24,72:25,57:28,68:36,131:37,110:39,114:40,116:41,65:47,66:48,29:49,35:51,27:62,51:63,119:69,31:72,8:127,7:153,11:$V0,28:$V1,30:$V2,32:$V3,33:$V4,36:$V5,37:$V6,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,52:$Vc,53:$Vd,54:$Ve,58:$Vf,59:$Vg,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,115:$Vs,126:$Vu,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC}),o($VV,[2,54]),o($Va1,[2,80]),o($Va1,[2,81]),o($V21,[2,32]),o($V21,[2,33]),o($V21,[2,34]),o($V21,[2,35]),o($V21,[2,36]),o($V21,[2,37]),o($V21,[2,38]),{4:154,5:3,7:4,8:5,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:[1,155],27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:156,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:$Vd1,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,64:$Ve1,65:47,66:48,67:161,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,94:158,95:$Vk,96:$Vl,97:$Vm,98:$Vf1,101:159,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($V21,[2,119]),o($V21,[2,120],{27:163,28:$V1}),{25:[2,57]},{25:[2,58]},o($Vg1,[2,75]),o($Vg1,[2,78]),{7:164,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:165,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:166,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:168,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,24:167,25:$V91,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{27:173,28:$V1,51:174,65:175,66:176,71:169,83:$Vh,96:$V71,97:$Vm,121:170,122:[1,171],123:172},{120:177,124:[1,178],125:[1,179]},o([6,25,61,85],$Vh1,{31:72,84:180,47:181,48:182,50:183,10:184,29:185,27:186,51:187,28:$V1,30:$V2,32:$V3,33:$V4,53:$Vd,96:$V71}),o($Vi1,[2,26]),o($Vi1,[2,27]),o($V21,[2,30]),{12:135,13:188,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:137,51:63,65:47,66:48,68:189,70:23,71:24,72:25,83:$Vh,90:$Vj,95:$Vk,96:$Vl,97:$Vm,108:$Vp},o($Vj1,[2,25]),o($Vi1,[2,28]),{4:190,5:3,7:4,8:5,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($VE,[2,5],{7:4,8:5,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,9:18,10:19,45:21,39:22,70:23,71:24,72:25,57:28,68:36,131:37,110:39,114:40,116:41,65:47,66:48,29:49,35:51,27:62,51:63,119:69,31:72,5:191,11:$V0,28:$V1,30:$V2,32:$V3,33:$V4,36:$V5,37:$V6,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,52:$Vc,53:$Vd,54:$Ve,58:$Vf,59:$Vg,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,111:$Vq,113:$Vr,115:$Vs,117:$Vt,126:$Vu,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC}),o($VV,[2,207]),{7:192,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:193,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:194,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:195,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:196,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:197,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:198,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:199,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:200,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:201,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:202,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:203,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:204,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:205,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($VV,[2,157]),o($VV,[2,162]),{7:206,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($VV,[2,156]),o($VV,[2,161]),{89:207,92:$V41},o($Vg1,[2,76]),{92:[2,116]},{27:208,28:$V1},{27:209,28:$V1},o($Vg1,[2,91],{27:210,28:$V1}),{27:211,28:$V1},o($Vg1,[2,92]),{7:213,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,64:$Vk1,65:47,66:48,68:36,70:23,71:24,72:25,79:212,82:214,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,99:215,100:$Vl1,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{77:218,78:$V_,81:$V$},{89:219,92:$V41},o($Vg1,[2,77]),{6:[1,221],7:220,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:[1,222],27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($Vm1,[2,114]),{7:225,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:$Vd1,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,64:$Ve1,65:47,66:48,67:161,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,93:[1,223],94:224,95:$Vk,96:$Vl,97:$Vm,101:159,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o([6,25],$Vn1,{60:228,56:[1,226],61:$Vo1}),o($Vp1,[2,62]),o($Vp1,[2,66],{46:[1,230],64:[1,229]}),o($Vp1,[2,69]),o($Vq1,[2,70]),o($Vq1,[2,71]),o($Vq1,[2,72]),o($Vq1,[2,73]),{27:163,28:$V1},{7:225,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:$Vd1,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,64:$Ve1,65:47,66:48,67:161,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,94:158,95:$Vk,96:$Vl,97:$Vm,98:$Vf1,101:159,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($VV,[2,56]),{4:232,5:3,7:4,8:5,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,26:[1,231],27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o([1,6,25,26,34,56,61,64,80,85,93,98,100,109,111,112,113,117,118,133,136,137,143,144,145,146,147,148,149,150,151,152,153],[2,196],{119:69,110:94,116:95,142:$VI}),{110:97,111:$Vq,113:$Vr,116:98,117:$Vt,119:69,133:$VU},o($Vr1,[2,197],{119:69,110:94,116:95,142:$VI,144:$VK}),o($Vr1,[2,198],{119:69,110:94,116:95,142:$VI,144:$VK}),o($Vr1,[2,199],{119:69,110:94,116:95,142:$VI,144:$VK}),o($VV,[2,200],{119:69,110:97,116:98}),o($Vs1,[2,201],{119:69,110:94,116:95,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),{7:233,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($VV,[2,203],{73:$Vb1,74:$Vb1,75:$Vb1,76:$Vb1,78:$Vb1,81:$Vb1,91:$Vb1,92:$Vb1}),{69:100,73:$VW,74:$VX,75:$VY,76:$VZ,77:106,78:$V_,81:$V$,88:99,91:$V01,92:$V11},{69:110,73:$VW,74:$VX,75:$VY,76:$VZ,77:106,78:$V_,81:$V$,88:109,91:$V01,92:$V11},o($Vt1,$V31),o($VV,[2,204],{73:$Vb1,74:$Vb1,75:$Vb1,76:$Vb1,78:$Vb1,81:$Vb1,91:$Vb1,92:$Vb1}),o($VV,[2,205]),o($VV,[2,206]),{6:[1,236],7:234,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:[1,235],27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:237,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{24:238,25:$V91,132:[1,239]},o($VV,[2,141],{104:240,105:[1,241],106:[1,242]}),o($VV,[2,155]),o($VV,[2,163]),{25:[1,243],110:94,111:$Vq,113:$Vr,116:95,117:$Vt,119:69,133:$VF,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT},{127:244,129:245,130:$Vu1},o($VV,[2,104]),{7:247,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($Vc1,[2,107],{24:248,25:$V91,73:$Vb1,74:$Vb1,75:$Vb1,76:$Vb1,78:$Vb1,81:$Vb1,91:$Vb1,92:$Vb1,87:[1,249]}),o($Vs1,[2,148],{119:69,110:94,116:95,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),o($Vs1,[2,52],{119:69,110:94,116:95,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),{6:$VD,109:[1,250]},{4:251,5:3,7:4,8:5,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o([6,25,61,98],$Vv1,{119:69,110:94,116:95,99:252,64:[1,253],100:$Vl1,111:$Vq,113:$Vr,117:$Vt,133:$VF,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),o($Vw1,[2,122]),o([6,25,98],$Vn1,{60:254,61:$Vx1}),o($Vy1,[2,131]),{7:225,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:$Vd1,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,64:$Ve1,65:47,66:48,67:161,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,94:256,95:$Vk,96:$Vl,97:$Vm,101:159,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($Vy1,[2,137]),o($Vy1,[2,138]),o($Vj1,[2,121]),{24:257,25:$V91,110:94,111:$Vq,113:$Vr,116:95,117:$Vt,119:69,133:$VF,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT},o($Vz1,[2,151],{119:69,110:94,116:95,111:$Vq,112:[1,258],113:$Vr,117:$Vt,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),o($Vz1,[2,153],{119:69,110:94,116:95,111:$Vq,112:[1,259],113:$Vr,117:$Vt,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),o($VV,[2,159]),o($VA1,[2,160],{119:69,110:94,116:95,111:$Vq,113:$Vr,117:$Vt,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),o([1,6,25,26,34,56,61,64,80,85,93,98,100,109,111,112,113,117,133,136,137,142,143,144,145,146,147,148,149,150,151,152,153],[2,164],{118:[1,260]}),o($VB1,[2,167]),{27:173,28:$V1,51:174,65:175,66:176,83:$Vh,96:$V71,97:$V81,121:261,123:172},o($VB1,[2,173],{61:[1,262]}),o($VC1,[2,169]),o($VC1,[2,170]),o($VC1,[2,171]),o($VC1,[2,172]),o($VV,[2,166]),{7:263,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:264,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o([6,25,85],$Vn1,{60:265,61:$VD1}),o($VE1,[2,99]),o($VE1,[2,42],{49:[1,267]}),o($VF1,[2,50],{46:[1,268]}),o($VE1,[2,47]),o($VF1,[2,51]),o($VG1,[2,48]),o($VG1,[2,49]),{38:[1,269],69:110,73:$VW,74:$VX,75:$VY,76:$VZ,77:106,78:$V_,81:$V$,88:109,91:$V01,92:$V11},o($Vt1,$Vb1),{6:$VD,34:[1,270]},o($VE,[2,4]),o($VH1,[2,208],{119:69,110:94,116:95,142:$VI,143:$VJ,144:$VK}),o($VH1,[2,209],{119:69,110:94,116:95,142:$VI,143:$VJ,144:$VK}),o($Vr1,[2,210],{119:69,110:94,116:95,142:$VI,144:$VK}),o($Vr1,[2,211],{119:69,110:94,116:95,142:$VI,144:$VK}),o([1,6,25,26,34,56,61,64,80,85,93,98,100,109,111,112,113,117,118,133,145,146,147,148,149,150,151,152,153],[2,212],{119:69,110:94,116:95,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK}),o([1,6,25,26,34,56,61,64,80,85,93,98,100,109,111,112,113,117,118,133,146,147,148,149,150,151,152],[2,213],{119:69,110:94,116:95,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,153:$VT}),o([1,6,25,26,34,56,61,64,80,85,93,98,100,109,111,112,113,117,118,133,147,148,149,150,151,152],[2,214],{119:69,110:94,116:95,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,153:$VT}),o([1,6,25,26,34,56,61,64,80,85,93,98,100,109,111,112,113,117,118,133,148,149,150,151,152],[2,215],{119:69,110:94,116:95,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,153:$VT}),o([1,6,25,26,34,56,61,64,80,85,93,98,100,109,111,112,113,117,118,133,149,150,151,152],[2,216],{119:69,110:94,116:95,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,153:$VT}),o([1,6,25,26,34,56,61,64,80,85,93,98,100,109,111,112,113,117,118,133,150,151,152],[2,217],{119:69,110:94,116:95,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,153:$VT}),o([1,6,25,26,34,56,61,64,80,85,93,98,100,109,111,112,113,117,118,133,151,152],[2,218],{119:69,110:94,116:95,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,153:$VT}),o([1,6,25,26,34,56,61,64,80,85,93,98,100,109,111,112,113,117,118,133,152],[2,219],{119:69,110:94,116:95,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,153:$VT}),o([1,6,25,26,34,56,61,64,80,85,93,98,100,109,111,112,113,117,118,133,146,147,148,149,150,151,152,153],[2,220],{119:69,110:94,116:95,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL}),o($VA1,[2,195],{119:69,110:94,116:95,111:$Vq,113:$Vr,117:$Vt,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),o($VA1,[2,194],{119:69,110:94,116:95,111:$Vq,113:$Vr,117:$Vt,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),o($Vm1,[2,111]),o($Vg1,[2,87]),o($Vg1,[2,88]),o($Vg1,[2,89]),o($Vg1,[2,90]),{80:[1,271]},{64:$Vk1,80:[2,95],99:272,100:$Vl1,110:94,111:$Vq,113:$Vr,116:95,117:$Vt,119:69,133:$VF,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT},{80:[2,96]},{7:273,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,80:[2,130],83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($VI1,[2,124]),o($VI1,$VJ1),o($Vg1,[2,94]),o($Vm1,[2,112]),o($Vs1,[2,39],{119:69,110:94,116:95,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),{7:274,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:275,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($Vm1,[2,117]),o([6,25,93],$Vn1,{60:276,61:$Vx1}),o($Vy1,$Vv1,{119:69,110:94,116:95,64:[1,277],111:$Vq,113:$Vr,117:$Vt,133:$VF,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),{57:278,58:$Vf,59:$Vg},o($VK1,$VL1,{63:116,27:118,51:119,65:120,66:121,62:279,28:$V1,64:$V61,83:$Vh,96:$V71,97:$V81}),{6:$VM1,25:$VN1},o($Vp1,[2,67]),{7:282,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($VO1,[2,23]),{6:$VD,26:[1,283]},o($Vs1,[2,202],{119:69,110:94,116:95,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),o($Vs1,[2,221],{119:69,110:94,116:95,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),{7:284,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:285,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($Vs1,[2,224],{119:69,110:94,116:95,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),o($VV,[2,193]),{7:286,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($VV,[2,142],{105:[1,287]}),{24:288,25:$V91},{24:291,25:$V91,27:289,28:$V1,66:290,83:$Vh},{127:292,129:245,130:$Vu1},{26:[1,293],128:[1,294],129:295,130:$Vu1},o($VP1,[2,186]),{7:297,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,102:296,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($VQ1,[2,105],{119:69,110:94,116:95,24:298,25:$V91,111:$Vq,113:$Vr,117:$Vt,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),o($VV,[2,108]),{7:299,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($V21,[2,149]),{6:$VD,26:[1,300]},{7:301,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o([11,28,30,32,33,36,37,40,41,42,43,44,52,53,54,58,59,83,86,90,95,96,97,103,107,108,111,113,115,117,126,132,134,135,136,137,138,140,141],$VJ1,{6:$VR1,25:$VR1,61:$VR1,98:$VR1}),{6:$VS1,25:$VT1,98:[1,302]},o([6,25,26,93,98],$VL1,{12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,9:18,10:19,45:21,39:22,70:23,71:24,72:25,57:28,68:36,131:37,110:39,114:40,116:41,65:47,66:48,29:49,35:51,27:62,51:63,119:69,31:72,8:127,67:161,7:225,101:305,11:$V0,28:$V1,30:$V2,32:$V3,33:$V4,36:$V5,37:$V6,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,52:$Vc,53:$Vd,54:$Ve,58:$Vf,59:$Vg,64:$Ve1,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,111:$Vq,113:$Vr,115:$Vs,117:$Vt,126:$Vu,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC}),o($VK1,$Vn1,{60:306,61:$Vx1}),o($VU1,[2,190]),{7:307,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:308,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:309,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($VB1,[2,168]),{27:173,28:$V1,51:174,65:175,66:176,83:$Vh,96:$V71,97:$V81,123:310},o([1,6,25,26,34,56,61,64,80,85,93,98,100,109,111,113,117,133],[2,175],{119:69,110:94,116:95,112:[1,311],118:[1,312],136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),o($VV1,[2,176],{119:69,110:94,116:95,112:[1,313],136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),{6:$VW1,25:$VX1,85:[1,314]},o([6,25,26,85],$VL1,{31:72,48:182,50:183,10:184,29:185,27:186,51:187,47:317,28:$V1,30:$V2,32:$V3,33:$V4,53:$Vd,96:$V71}),{7:318,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:[1,319],27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:320,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:[1,321],27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($V21,[2,31]),o($Vi1,[2,29]),o($Vg1,[2,93]),{7:322,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,80:[2,128],83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{80:[2,129],110:94,111:$Vq,113:$Vr,116:95,117:$Vt,119:69,133:$VF,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT},o($Vs1,[2,40],{119:69,110:94,116:95,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),{26:[1,323],110:94,111:$Vq,113:$Vr,116:95,117:$Vt,119:69,133:$VF,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT},{6:$VS1,25:$VT1,93:[1,324]},o($Vy1,$VR1),{24:325,25:$V91},o($Vp1,[2,63]),{27:118,28:$V1,51:119,62:326,63:116,64:$V61,65:120,66:121,83:$Vh,96:$V71,97:$V81},o($VY1,$V51,{62:115,63:116,27:118,51:119,65:120,66:121,55:327,28:$V1,64:$V61,83:$Vh,96:$V71,97:$V81}),o($Vp1,[2,68],{119:69,110:94,116:95,111:$Vq,113:$Vr,117:$Vt,133:$VF,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),o($VO1,[2,24]),{26:[1,328],110:94,111:$Vq,113:$Vr,116:95,117:$Vt,119:69,133:$VF,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT},o($Vs1,[2,223],{119:69,110:94,116:95,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),{24:329,25:$V91,110:94,111:$Vq,113:$Vr,116:95,117:$Vt,119:69,133:$VF,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT},{24:330,25:$V91},o($VV,[2,143]),{24:331,25:$V91},{24:332,25:$V91},o($VZ1,[2,147]),{26:[1,333],128:[1,334],129:295,130:$Vu1},o($VV,[2,184]),{24:335,25:$V91},o($VP1,[2,187]),{24:336,25:$V91,61:[1,337]},o($V_1,[2,139],{119:69,110:94,116:95,111:$Vq,113:$Vr,117:$Vt,133:$VF,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),o($VV,[2,106]),o($VQ1,[2,109],{119:69,110:94,116:95,24:338,25:$V91,111:$Vq,113:$Vr,117:$Vt,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),{109:[1,339]},{98:[1,340],110:94,111:$Vq,113:$Vr,116:95,117:$Vt,119:69,133:$VF,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT},o($Vw1,[2,123]),{7:225,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,64:$Ve1,65:47,66:48,67:161,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,101:341,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:225,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:$Vd1,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,64:$Ve1,65:47,66:48,67:161,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,94:342,95:$Vk,96:$Vl,97:$Vm,101:159,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($Vy1,[2,132]),{6:$VS1,25:$VT1,26:[1,343]},o($VA1,[2,152],{119:69,110:94,116:95,111:$Vq,113:$Vr,117:$Vt,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),o($VA1,[2,154],{119:69,110:94,116:95,111:$Vq,113:$Vr,117:$Vt,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),o($VA1,[2,165],{119:69,110:94,116:95,111:$Vq,113:$Vr,117:$Vt,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),o($VB1,[2,174]),{7:344,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:345,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:346,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($Vw1,[2,97]),{10:184,27:186,28:$V1,29:185,30:$V2,31:72,32:$V3,33:$V4,47:347,48:182,50:183,51:187,53:$Vd,96:$V71},o($VY1,$Vh1,{31:72,47:181,48:182,50:183,10:184,29:185,27:186,51:187,84:348,28:$V1,30:$V2,32:$V3,33:$V4,53:$Vd,96:$V71}),o($VE1,[2,100]),o($VE1,[2,43],{119:69,110:94,116:95,111:$Vq,113:$Vr,117:$Vt,133:$VF,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),{7:349,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($VE1,[2,45],{119:69,110:94,116:95,111:$Vq,113:$Vr,117:$Vt,133:$VF,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),{7:350,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{80:[2,127],110:94,111:$Vq,113:$Vr,116:95,117:$Vt,119:69,133:$VF,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT},o($VV,[2,41]),o($Vm1,[2,118]),o($VV,[2,55]),o($Vp1,[2,64]),o($VK1,$Vn1,{60:351,61:$Vo1}),o($VV,[2,222]),o($VU1,[2,191]),o($VV,[2,144]),o($VZ1,[2,145]),o($VZ1,[2,146]),o($VV,[2,182]),{24:352,25:$V91},{26:[1,353]},o($VP1,[2,188],{6:[1,354]}),{7:355,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},o($VV,[2,110]),o($V21,[2,150]),o($V21,[2,126]),o($Vy1,[2,133]),o($VK1,$Vn1,{60:356,61:$Vx1}),o($Vy1,[2,134]),o([1,6,25,26,34,56,61,64,80,85,93,98,100,109,111,112,113,117,133],[2,177],{119:69,110:94,116:95,118:[1,357],136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),o($VV1,[2,179],{119:69,110:94,116:95,112:[1,358],136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),o($Vs1,[2,178],{119:69,110:94,116:95,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),o($VE1,[2,101]),o($VK1,$Vn1,{60:359,61:$VD1}),{26:[1,360],110:94,111:$Vq,113:$Vr,116:95,117:$Vt,119:69,133:$VF,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT},{26:[1,361],110:94,111:$Vq,113:$Vr,116:95,117:$Vt,119:69,133:$VF,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT},{6:$VM1,25:$VN1,26:[1,362]},{26:[1,363]},o($VV,[2,185]),o($VP1,[2,189]),o($V_1,[2,140],{119:69,110:94,116:95,111:$Vq,113:$Vr,117:$Vt,133:$VF,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),{6:$VS1,25:$VT1,26:[1,364]},{7:365,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{7:366,8:127,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,51:63,52:$Vc,53:$Vd,54:$Ve,57:28,58:$Vf,59:$Vg,65:47,66:48,68:36,70:23,71:24,72:25,83:$Vh,86:$Vi,90:$Vj,95:$Vk,96:$Vl,97:$Vm,103:$Vn,107:$Vo,108:$Vp,110:39,111:$Vq,113:$Vr,114:40,115:$Vs,116:41,117:$Vt,119:69,126:$Vu,131:37,132:$Vv,134:$Vw,135:$Vx,136:$Vy,137:$Vz,138:$VA,140:$VB,141:$VC},{6:$VW1,25:$VX1,26:[1,367]},o($VE1,[2,44]),o($VE1,[2,46]),o($Vp1,[2,65]),o($VV,[2,183]),o($Vy1,[2,135]),o($Vs1,[2,180],{119:69,110:94,116:95,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),o($Vs1,[2,181],{119:69,110:94,116:95,136:$VG,137:$VH,142:$VI,143:$VJ,144:$VK,145:$VL,146:$VM,147:$VN,148:$VO,149:$VP,150:$VQ,151:$VR,152:$VS,153:$VT}),o($VE1,[2,102])],
defaultActions: {60:[2,57],61:[2,58],101:[2,116],214:[2,96]},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        function _parseError (msg, hash) {
            this.message = msg;
            this.hash = hash;
        }
        _parseError.prototype = Error;

        throw new _parseError(str, hash);
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        var lex = function () {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        };
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};

function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain(args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
}
}).call(this,require('_process'))
},{"_process":367,"fs":64,"path":366}],184:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var CoffeeScript, Module, binary, child_process, ext, findExtension, fork, helpers, i, len, loadFile, path, ref;

  CoffeeScript = require('./coffee-script');

  child_process = require('child_process');

  helpers = require('./helpers');

  path = require('path');

  loadFile = function(module, filename) {
    var answer;
    answer = CoffeeScript._compileFile(filename, false);
    return module._compile(answer, filename);
  };

  if (require.extensions) {
    ref = CoffeeScript.FILE_EXTENSIONS;
    for (i = 0, len = ref.length; i < len; i++) {
      ext = ref[i];
      require.extensions[ext] = loadFile;
    }
    Module = require('module');
    findExtension = function(filename) {
      var curExtension, extensions;
      extensions = path.basename(filename).split('.');
      if (extensions[0] === '') {
        extensions.shift();
      }
      while (extensions.shift()) {
        curExtension = '.' + extensions.join('.');
        if (Module._extensions[curExtension]) {
          return curExtension;
        }
      }
      return '.js';
    };
    Module.prototype.load = function(filename) {
      var extension;
      this.filename = filename;
      this.paths = Module._nodeModulePaths(path.dirname(filename));
      extension = findExtension(filename);
      Module._extensions[extension](this, filename);
      return this.loaded = true;
    };
  }

  if (child_process) {
    fork = child_process.fork;
    binary = require.resolve('../../bin/coffee');
    child_process.fork = function(path, args, options) {
      if (helpers.isCoffee(path)) {
        if (!Array.isArray(args)) {
          options = args || {};
          args = [];
        }
        args = [path].concat(args);
        path = binary;
      }
      return fork(path, args, options);
    };
  }

}).call(this);

},{"./coffee-script":179,"./helpers":180,"child_process":64,"module":64,"path":366}],185:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var BALANCED_PAIRS, CALL_CLOSERS, EXPRESSION_CLOSE, EXPRESSION_END, EXPRESSION_START, IMPLICIT_CALL, IMPLICIT_END, IMPLICIT_FUNC, IMPLICIT_UNSPACED_CALL, INVERSES, LINEBREAKS, SINGLE_CLOSERS, SINGLE_LINERS, generate, k, left, len, ref, rite,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  generate = function(tag, value, origin) {
    var tok;
    tok = [tag, value];
    tok.generated = true;
    if (origin) {
      tok.origin = origin;
    }
    return tok;
  };

  exports.Rewriter = (function() {
    function Rewriter() {}

    Rewriter.prototype.rewrite = function(tokens1) {
      this.tokens = tokens1;
      this.removeLeadingNewlines();
      this.closeOpenCalls();
      this.closeOpenIndexes();
      this.normalizeLines();
      this.tagPostfixConditionals();
      this.addImplicitBracesAndParens();
      this.addLocationDataToGeneratedTokens();
      this.fixOutdentLocationData();
      return this.tokens;
    };

    Rewriter.prototype.scanTokens = function(block) {
      var i, token, tokens;
      tokens = this.tokens;
      i = 0;
      while (token = tokens[i]) {
        i += block.call(this, token, i, tokens);
      }
      return true;
    };

    Rewriter.prototype.detectEnd = function(i, condition, action) {
      var levels, ref, ref1, token, tokens;
      tokens = this.tokens;
      levels = 0;
      while (token = tokens[i]) {
        if (levels === 0 && condition.call(this, token, i)) {
          return action.call(this, token, i);
        }
        if (!token || levels < 0) {
          return action.call(this, token, i - 1);
        }
        if (ref = token[0], indexOf.call(EXPRESSION_START, ref) >= 0) {
          levels += 1;
        } else if (ref1 = token[0], indexOf.call(EXPRESSION_END, ref1) >= 0) {
          levels -= 1;
        }
        i += 1;
      }
      return i - 1;
    };

    Rewriter.prototype.removeLeadingNewlines = function() {
      var i, k, len, ref, tag;
      ref = this.tokens;
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        tag = ref[i][0];
        if (tag !== 'TERMINATOR') {
          break;
        }
      }
      if (i) {
        return this.tokens.splice(0, i);
      }
    };

    Rewriter.prototype.closeOpenCalls = function() {
      var action, condition;
      condition = function(token, i) {
        var ref;
        return ((ref = token[0]) === ')' || ref === 'CALL_END') || token[0] === 'OUTDENT' && this.tag(i - 1) === ')';
      };
      action = function(token, i) {
        return this.tokens[token[0] === 'OUTDENT' ? i - 1 : i][0] = 'CALL_END';
      };
      return this.scanTokens(function(token, i) {
        if (token[0] === 'CALL_START') {
          this.detectEnd(i + 1, condition, action);
        }
        return 1;
      });
    };

    Rewriter.prototype.closeOpenIndexes = function() {
      var action, condition;
      condition = function(token, i) {
        var ref;
        return (ref = token[0]) === ']' || ref === 'INDEX_END';
      };
      action = function(token, i) {
        return token[0] = 'INDEX_END';
      };
      return this.scanTokens(function(token, i) {
        if (token[0] === 'INDEX_START') {
          this.detectEnd(i + 1, condition, action);
        }
        return 1;
      });
    };

    Rewriter.prototype.indexOfTag = function() {
      var fuzz, i, j, k, pattern, ref, ref1;
      i = arguments[0], pattern = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      fuzz = 0;
      for (j = k = 0, ref = pattern.length; 0 <= ref ? k < ref : k > ref; j = 0 <= ref ? ++k : --k) {
        while (this.tag(i + j + fuzz) === 'HERECOMMENT') {
          fuzz += 2;
        }
        if (pattern[j] == null) {
          continue;
        }
        if (typeof pattern[j] === 'string') {
          pattern[j] = [pattern[j]];
        }
        if (ref1 = this.tag(i + j + fuzz), indexOf.call(pattern[j], ref1) < 0) {
          return -1;
        }
      }
      return i + j + fuzz - 1;
    };

    Rewriter.prototype.looksObjectish = function(j) {
      var end, index;
      if (this.indexOfTag(j, '@', null, ':') > -1 || this.indexOfTag(j, null, ':') > -1) {
        return true;
      }
      index = this.indexOfTag(j, EXPRESSION_START);
      if (index > -1) {
        end = null;
        this.detectEnd(index + 1, (function(token) {
          var ref;
          return ref = token[0], indexOf.call(EXPRESSION_END, ref) >= 0;
        }), (function(token, i) {
          return end = i;
        }));
        if (this.tag(end + 1) === ':') {
          return true;
        }
      }
      return false;
    };

    Rewriter.prototype.findTagsBackwards = function(i, tags) {
      var backStack, ref, ref1, ref2, ref3, ref4, ref5;
      backStack = [];
      while (i >= 0 && (backStack.length || (ref2 = this.tag(i), indexOf.call(tags, ref2) < 0) && ((ref3 = this.tag(i), indexOf.call(EXPRESSION_START, ref3) < 0) || this.tokens[i].generated) && (ref4 = this.tag(i), indexOf.call(LINEBREAKS, ref4) < 0))) {
        if (ref = this.tag(i), indexOf.call(EXPRESSION_END, ref) >= 0) {
          backStack.push(this.tag(i));
        }
        if ((ref1 = this.tag(i), indexOf.call(EXPRESSION_START, ref1) >= 0) && backStack.length) {
          backStack.pop();
        }
        i -= 1;
      }
      return ref5 = this.tag(i), indexOf.call(tags, ref5) >= 0;
    };

    Rewriter.prototype.addImplicitBracesAndParens = function() {
      var stack, start;
      stack = [];
      start = null;
      return this.scanTokens(function(token, i, tokens) {
        var endImplicitCall, endImplicitObject, forward, inImplicit, inImplicitCall, inImplicitControl, inImplicitObject, newLine, nextTag, offset, prevTag, prevToken, ref, ref1, ref2, ref3, ref4, ref5, s, sameLine, stackIdx, stackTag, stackTop, startIdx, startImplicitCall, startImplicitObject, startsLine, tag;
        tag = token[0];
        prevTag = (prevToken = i > 0 ? tokens[i - 1] : [])[0];
        nextTag = (i < tokens.length - 1 ? tokens[i + 1] : [])[0];
        stackTop = function() {
          return stack[stack.length - 1];
        };
        startIdx = i;
        forward = function(n) {
          return i - startIdx + n;
        };
        inImplicit = function() {
          var ref, ref1;
          return (ref = stackTop()) != null ? (ref1 = ref[2]) != null ? ref1.ours : void 0 : void 0;
        };
        inImplicitCall = function() {
          var ref;
          return inImplicit() && ((ref = stackTop()) != null ? ref[0] : void 0) === '(';
        };
        inImplicitObject = function() {
          var ref;
          return inImplicit() && ((ref = stackTop()) != null ? ref[0] : void 0) === '{';
        };
        inImplicitControl = function() {
          var ref;
          return inImplicit && ((ref = stackTop()) != null ? ref[0] : void 0) === 'CONTROL';
        };
        startImplicitCall = function(j) {
          var idx;
          idx = j != null ? j : i;
          stack.push([
            '(', idx, {
              ours: true
            }
          ]);
          tokens.splice(idx, 0, generate('CALL_START', '('));
          if (j == null) {
            return i += 1;
          }
        };
        endImplicitCall = function() {
          stack.pop();
          tokens.splice(i, 0, generate('CALL_END', ')', ['', 'end of input', token[2]]));
          return i += 1;
        };
        startImplicitObject = function(j, startsLine) {
          var idx, val;
          if (startsLine == null) {
            startsLine = true;
          }
          idx = j != null ? j : i;
          stack.push([
            '{', idx, {
              sameLine: true,
              startsLine: startsLine,
              ours: true
            }
          ]);
          val = new String('{');
          val.generated = true;
          tokens.splice(idx, 0, generate('{', val, token));
          if (j == null) {
            return i += 1;
          }
        };
        endImplicitObject = function(j) {
          j = j != null ? j : i;
          stack.pop();
          tokens.splice(j, 0, generate('}', '}', token));
          return i += 1;
        };
        if (inImplicitCall() && (tag === 'IF' || tag === 'TRY' || tag === 'FINALLY' || tag === 'CATCH' || tag === 'CLASS' || tag === 'SWITCH')) {
          stack.push([
            'CONTROL', i, {
              ours: true
            }
          ]);
          return forward(1);
        }
        if (tag === 'INDENT' && inImplicit()) {
          if (prevTag !== '=>' && prevTag !== '->' && prevTag !== '[' && prevTag !== '(' && prevTag !== ',' && prevTag !== '{' && prevTag !== 'TRY' && prevTag !== 'ELSE' && prevTag !== '=') {
            while (inImplicitCall()) {
              endImplicitCall();
            }
          }
          if (inImplicitControl()) {
            stack.pop();
          }
          stack.push([tag, i]);
          return forward(1);
        }
        if (indexOf.call(EXPRESSION_START, tag) >= 0) {
          stack.push([tag, i]);
          return forward(1);
        }
        if (indexOf.call(EXPRESSION_END, tag) >= 0) {
          while (inImplicit()) {
            if (inImplicitCall()) {
              endImplicitCall();
            } else if (inImplicitObject()) {
              endImplicitObject();
            } else {
              stack.pop();
            }
          }
          start = stack.pop();
        }
        if ((indexOf.call(IMPLICIT_FUNC, tag) >= 0 && token.spaced || tag === '?' && i > 0 && !tokens[i - 1].spaced) && (indexOf.call(IMPLICIT_CALL, nextTag) >= 0 || indexOf.call(IMPLICIT_UNSPACED_CALL, nextTag) >= 0 && !((ref = tokens[i + 1]) != null ? ref.spaced : void 0) && !((ref1 = tokens[i + 1]) != null ? ref1.newLine : void 0))) {
          if (tag === '?') {
            tag = token[0] = 'FUNC_EXIST';
          }
          startImplicitCall(i + 1);
          return forward(2);
        }
        if (indexOf.call(IMPLICIT_FUNC, tag) >= 0 && this.indexOfTag(i + 1, 'INDENT') > -1 && this.looksObjectish(i + 2) && !this.findTagsBackwards(i, ['CLASS', 'EXTENDS', 'IF', 'CATCH', 'SWITCH', 'LEADING_WHEN', 'FOR', 'WHILE', 'UNTIL'])) {
          startImplicitCall(i + 1);
          stack.push(['INDENT', i + 2]);
          return forward(3);
        }
        if (tag === ':') {
          s = (function() {
            var ref2;
            switch (false) {
              case ref2 = this.tag(i - 1), indexOf.call(EXPRESSION_END, ref2) < 0:
                return start[1];
              case this.tag(i - 2) !== '@':
                return i - 2;
              default:
                return i - 1;
            }
          }).call(this);
          while (this.tag(s - 2) === 'HERECOMMENT') {
            s -= 2;
          }
          this.insideForDeclaration = nextTag === 'FOR';
          startsLine = s === 0 || (ref2 = this.tag(s - 1), indexOf.call(LINEBREAKS, ref2) >= 0) || tokens[s - 1].newLine;
          if (stackTop()) {
            ref3 = stackTop(), stackTag = ref3[0], stackIdx = ref3[1];
            if ((stackTag === '{' || stackTag === 'INDENT' && this.tag(stackIdx - 1) === '{') && (startsLine || this.tag(s - 1) === ',' || this.tag(s - 1) === '{')) {
              return forward(1);
            }
          }
          startImplicitObject(s, !!startsLine);
          return forward(2);
        }
        if (inImplicitObject() && indexOf.call(LINEBREAKS, tag) >= 0) {
          stackTop()[2].sameLine = false;
        }
        newLine = prevTag === 'OUTDENT' || prevToken.newLine;
        if (indexOf.call(IMPLICIT_END, tag) >= 0 || indexOf.call(CALL_CLOSERS, tag) >= 0 && newLine) {
          while (inImplicit()) {
            ref4 = stackTop(), stackTag = ref4[0], stackIdx = ref4[1], (ref5 = ref4[2], sameLine = ref5.sameLine, startsLine = ref5.startsLine);
            if (inImplicitCall() && prevTag !== ',') {
              endImplicitCall();
            } else if (inImplicitObject() && !this.insideForDeclaration && sameLine && tag !== 'TERMINATOR' && prevTag !== ':') {
              endImplicitObject();
            } else if (inImplicitObject() && tag === 'TERMINATOR' && prevTag !== ',' && !(startsLine && this.looksObjectish(i + 1))) {
              if (nextTag === 'HERECOMMENT') {
                return forward(1);
              }
              endImplicitObject();
            } else {
              break;
            }
          }
        }
        if (tag === ',' && !this.looksObjectish(i + 1) && inImplicitObject() && !this.insideForDeclaration && (nextTag !== 'TERMINATOR' || !this.looksObjectish(i + 2))) {
          offset = nextTag === 'OUTDENT' ? 1 : 0;
          while (inImplicitObject()) {
            endImplicitObject(i + offset);
          }
        }
        return forward(1);
      });
    };

    Rewriter.prototype.addLocationDataToGeneratedTokens = function() {
      return this.scanTokens(function(token, i, tokens) {
        var column, line, nextLocation, prevLocation, ref, ref1;
        if (token[2]) {
          return 1;
        }
        if (!(token.generated || token.explicit)) {
          return 1;
        }
        if (token[0] === '{' && (nextLocation = (ref = tokens[i + 1]) != null ? ref[2] : void 0)) {
          line = nextLocation.first_line, column = nextLocation.first_column;
        } else if (prevLocation = (ref1 = tokens[i - 1]) != null ? ref1[2] : void 0) {
          line = prevLocation.last_line, column = prevLocation.last_column;
        } else {
          line = column = 0;
        }
        token[2] = {
          first_line: line,
          first_column: column,
          last_line: line,
          last_column: column
        };
        return 1;
      });
    };

    Rewriter.prototype.fixOutdentLocationData = function() {
      return this.scanTokens(function(token, i, tokens) {
        var prevLocationData;
        if (!(token[0] === 'OUTDENT' || (token.generated && token[0] === 'CALL_END') || (token.generated && token[0] === '}'))) {
          return 1;
        }
        prevLocationData = tokens[i - 1][2];
        token[2] = {
          first_line: prevLocationData.last_line,
          first_column: prevLocationData.last_column,
          last_line: prevLocationData.last_line,
          last_column: prevLocationData.last_column
        };
        return 1;
      });
    };

    Rewriter.prototype.normalizeLines = function() {
      var action, condition, indent, outdent, starter;
      starter = indent = outdent = null;
      condition = function(token, i) {
        var ref, ref1, ref2, ref3;
        return token[1] !== ';' && (ref = token[0], indexOf.call(SINGLE_CLOSERS, ref) >= 0) && !(token[0] === 'TERMINATOR' && (ref1 = this.tag(i + 1), indexOf.call(EXPRESSION_CLOSE, ref1) >= 0)) && !(token[0] === 'ELSE' && starter !== 'THEN') && !(((ref2 = token[0]) === 'CATCH' || ref2 === 'FINALLY') && (starter === '->' || starter === '=>')) || (ref3 = token[0], indexOf.call(CALL_CLOSERS, ref3) >= 0) && this.tokens[i - 1].newLine;
      };
      action = function(token, i) {
        return this.tokens.splice((this.tag(i - 1) === ',' ? i - 1 : i), 0, outdent);
      };
      return this.scanTokens(function(token, i, tokens) {
        var j, k, ref, ref1, ref2, tag;
        tag = token[0];
        if (tag === 'TERMINATOR') {
          if (this.tag(i + 1) === 'ELSE' && this.tag(i - 1) !== 'OUTDENT') {
            tokens.splice.apply(tokens, [i, 1].concat(slice.call(this.indentation())));
            return 1;
          }
          if (ref = this.tag(i + 1), indexOf.call(EXPRESSION_CLOSE, ref) >= 0) {
            tokens.splice(i, 1);
            return 0;
          }
        }
        if (tag === 'CATCH') {
          for (j = k = 1; k <= 2; j = ++k) {
            if (!((ref1 = this.tag(i + j)) === 'OUTDENT' || ref1 === 'TERMINATOR' || ref1 === 'FINALLY')) {
              continue;
            }
            tokens.splice.apply(tokens, [i + j, 0].concat(slice.call(this.indentation())));
            return 2 + j;
          }
        }
        if (indexOf.call(SINGLE_LINERS, tag) >= 0 && this.tag(i + 1) !== 'INDENT' && !(tag === 'ELSE' && this.tag(i + 1) === 'IF')) {
          starter = tag;
          ref2 = this.indentation(tokens[i]), indent = ref2[0], outdent = ref2[1];
          if (starter === 'THEN') {
            indent.fromThen = true;
          }
          tokens.splice(i + 1, 0, indent);
          this.detectEnd(i + 2, condition, action);
          if (tag === 'THEN') {
            tokens.splice(i, 1);
          }
          return 1;
        }
        return 1;
      });
    };

    Rewriter.prototype.tagPostfixConditionals = function() {
      var action, condition, original;
      original = null;
      condition = function(token, i) {
        var prevTag, tag;
        tag = token[0];
        prevTag = this.tokens[i - 1][0];
        return tag === 'TERMINATOR' || (tag === 'INDENT' && indexOf.call(SINGLE_LINERS, prevTag) < 0);
      };
      action = function(token, i) {
        if (token[0] !== 'INDENT' || (token.generated && !token.fromThen)) {
          return original[0] = 'POST_' + original[0];
        }
      };
      return this.scanTokens(function(token, i) {
        if (token[0] !== 'IF') {
          return 1;
        }
        original = token;
        this.detectEnd(i + 1, condition, action);
        return 1;
      });
    };

    Rewriter.prototype.indentation = function(origin) {
      var indent, outdent;
      indent = ['INDENT', 2];
      outdent = ['OUTDENT', 2];
      if (origin) {
        indent.generated = outdent.generated = true;
        indent.origin = outdent.origin = origin;
      } else {
        indent.explicit = outdent.explicit = true;
      }
      return [indent, outdent];
    };

    Rewriter.prototype.generate = generate;

    Rewriter.prototype.tag = function(i) {
      var ref;
      return (ref = this.tokens[i]) != null ? ref[0] : void 0;
    };

    return Rewriter;

  })();

  BALANCED_PAIRS = [['(', ')'], ['[', ']'], ['{', '}'], ['INDENT', 'OUTDENT'], ['CALL_START', 'CALL_END'], ['PARAM_START', 'PARAM_END'], ['INDEX_START', 'INDEX_END'], ['STRING_START', 'STRING_END'], ['REGEX_START', 'REGEX_END']];

  exports.INVERSES = INVERSES = {};

  EXPRESSION_START = [];

  EXPRESSION_END = [];

  for (k = 0, len = BALANCED_PAIRS.length; k < len; k++) {
    ref = BALANCED_PAIRS[k], left = ref[0], rite = ref[1];
    EXPRESSION_START.push(INVERSES[rite] = left);
    EXPRESSION_END.push(INVERSES[left] = rite);
  }

  EXPRESSION_CLOSE = ['CATCH', 'THEN', 'ELSE', 'FINALLY'].concat(EXPRESSION_END);

  IMPLICIT_FUNC = ['IDENTIFIER', 'SUPER', ')', 'CALL_END', ']', 'INDEX_END', '@', 'THIS'];

  IMPLICIT_CALL = ['IDENTIFIER', 'NUMBER', 'STRING', 'STRING_START', 'JS', 'REGEX', 'REGEX_START', 'NEW', 'PARAM_START', 'CLASS', 'IF', 'TRY', 'SWITCH', 'THIS', 'BOOL', 'NULL', 'UNDEFINED', 'UNARY', 'YIELD', 'UNARY_MATH', 'SUPER', 'THROW', '@', '->', '=>', '[', '(', '{', '--', '++'];

  IMPLICIT_UNSPACED_CALL = ['+', '-'];

  IMPLICIT_END = ['POST_IF', 'FOR', 'WHILE', 'UNTIL', 'WHEN', 'BY', 'LOOP', 'TERMINATOR'];

  SINGLE_LINERS = ['ELSE', '->', '=>', 'TRY', 'FINALLY', 'THEN'];

  SINGLE_CLOSERS = ['TERMINATOR', 'CATCH', 'FINALLY', 'ELSE', 'OUTDENT', 'LEADING_WHEN'];

  LINEBREAKS = ['TERMINATOR', 'INDENT', 'OUTDENT'];

  CALL_CLOSERS = ['.', '?.', '::', '?::'];

}).call(this);

},{}],186:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var Scope,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  exports.Scope = Scope = (function() {
    function Scope(parent, expressions, method, referencedVars) {
      var ref, ref1;
      this.parent = parent;
      this.expressions = expressions;
      this.method = method;
      this.referencedVars = referencedVars;
      this.variables = [
        {
          name: 'arguments',
          type: 'arguments'
        }
      ];
      this.positions = {};
      if (!this.parent) {
        this.utilities = {};
      }
      this.root = (ref = (ref1 = this.parent) != null ? ref1.root : void 0) != null ? ref : this;
    }

    Scope.prototype.add = function(name, type, immediate) {
      if (this.shared && !immediate) {
        return this.parent.add(name, type, immediate);
      }
      if (Object.prototype.hasOwnProperty.call(this.positions, name)) {
        return this.variables[this.positions[name]].type = type;
      } else {
        return this.positions[name] = this.variables.push({
          name: name,
          type: type
        }) - 1;
      }
    };

    Scope.prototype.namedMethod = function() {
      var ref;
      if (((ref = this.method) != null ? ref.name : void 0) || !this.parent) {
        return this.method;
      }
      return this.parent.namedMethod();
    };

    Scope.prototype.find = function(name) {
      if (this.check(name)) {
        return true;
      }
      this.add(name, 'var');
      return false;
    };

    Scope.prototype.parameter = function(name) {
      if (this.shared && this.parent.check(name, true)) {
        return;
      }
      return this.add(name, 'param');
    };

    Scope.prototype.check = function(name) {
      var ref;
      return !!(this.type(name) || ((ref = this.parent) != null ? ref.check(name) : void 0));
    };

    Scope.prototype.temporary = function(name, index, single) {
      if (single == null) {
        single = false;
      }
      if (single) {
        return (index + parseInt(name, 36)).toString(36).replace(/\d/g, 'a');
      } else {
        return name + (index || '');
      }
    };

    Scope.prototype.type = function(name) {
      var i, len, ref, v;
      ref = this.variables;
      for (i = 0, len = ref.length; i < len; i++) {
        v = ref[i];
        if (v.name === name) {
          return v.type;
        }
      }
      return null;
    };

    Scope.prototype.freeVariable = function(name, options) {
      var index, ref, temp;
      if (options == null) {
        options = {};
      }
      index = 0;
      while (true) {
        temp = this.temporary(name, index, options.single);
        if (!(this.check(temp) || indexOf.call(this.root.referencedVars, temp) >= 0)) {
          break;
        }
        index++;
      }
      if ((ref = options.reserve) != null ? ref : true) {
        this.add(temp, 'var', true);
      }
      return temp;
    };

    Scope.prototype.assign = function(name, value) {
      this.add(name, {
        value: value,
        assigned: true
      }, true);
      return this.hasAssignments = true;
    };

    Scope.prototype.hasDeclarations = function() {
      return !!this.declaredVariables().length;
    };

    Scope.prototype.declaredVariables = function() {
      var v;
      return ((function() {
        var i, len, ref, results;
        ref = this.variables;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          v = ref[i];
          if (v.type === 'var') {
            results.push(v.name);
          }
        }
        return results;
      }).call(this)).sort();
    };

    Scope.prototype.assignedVariables = function() {
      var i, len, ref, results, v;
      ref = this.variables;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        v = ref[i];
        if (v.type.assigned) {
          results.push(v.name + " = " + v.type.value);
        }
      }
      return results;
    };

    return Scope;

  })();

}).call(this);

},{}],187:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var LineMap, SourceMap;

  LineMap = (function() {
    function LineMap(line1) {
      this.line = line1;
      this.columns = [];
    }

    LineMap.prototype.add = function(column, arg, options) {
      var sourceColumn, sourceLine;
      sourceLine = arg[0], sourceColumn = arg[1];
      if (options == null) {
        options = {};
      }
      if (this.columns[column] && options.noReplace) {
        return;
      }
      return this.columns[column] = {
        line: this.line,
        column: column,
        sourceLine: sourceLine,
        sourceColumn: sourceColumn
      };
    };

    LineMap.prototype.sourceLocation = function(column) {
      var mapping;
      while (!((mapping = this.columns[column]) || (column <= 0))) {
        column--;
      }
      return mapping && [mapping.sourceLine, mapping.sourceColumn];
    };

    return LineMap;

  })();

  SourceMap = (function() {
    var BASE64_CHARS, VLQ_CONTINUATION_BIT, VLQ_SHIFT, VLQ_VALUE_MASK;

    function SourceMap() {
      this.lines = [];
    }

    SourceMap.prototype.add = function(sourceLocation, generatedLocation, options) {
      var base, column, line, lineMap;
      if (options == null) {
        options = {};
      }
      line = generatedLocation[0], column = generatedLocation[1];
      lineMap = ((base = this.lines)[line] || (base[line] = new LineMap(line)));
      return lineMap.add(column, sourceLocation, options);
    };

    SourceMap.prototype.sourceLocation = function(arg) {
      var column, line, lineMap;
      line = arg[0], column = arg[1];
      while (!((lineMap = this.lines[line]) || (line <= 0))) {
        line--;
      }
      return lineMap && lineMap.sourceLocation(column);
    };

    SourceMap.prototype.generate = function(options, code) {
      var buffer, i, j, lastColumn, lastSourceColumn, lastSourceLine, len, len1, lineMap, lineNumber, mapping, needComma, ref, ref1, v3, writingline;
      if (options == null) {
        options = {};
      }
      if (code == null) {
        code = null;
      }
      writingline = 0;
      lastColumn = 0;
      lastSourceLine = 0;
      lastSourceColumn = 0;
      needComma = false;
      buffer = "";
      ref = this.lines;
      for (lineNumber = i = 0, len = ref.length; i < len; lineNumber = ++i) {
        lineMap = ref[lineNumber];
        if (lineMap) {
          ref1 = lineMap.columns;
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            mapping = ref1[j];
            if (!(mapping)) {
              continue;
            }
            while (writingline < mapping.line) {
              lastColumn = 0;
              needComma = false;
              buffer += ";";
              writingline++;
            }
            if (needComma) {
              buffer += ",";
              needComma = false;
            }
            buffer += this.encodeVlq(mapping.column - lastColumn);
            lastColumn = mapping.column;
            buffer += this.encodeVlq(0);
            buffer += this.encodeVlq(mapping.sourceLine - lastSourceLine);
            lastSourceLine = mapping.sourceLine;
            buffer += this.encodeVlq(mapping.sourceColumn - lastSourceColumn);
            lastSourceColumn = mapping.sourceColumn;
            needComma = true;
          }
        }
      }
      v3 = {
        version: 3,
        file: options.generatedFile || '',
        sourceRoot: options.sourceRoot || '',
        sources: options.sourceFiles || [''],
        names: [],
        mappings: buffer
      };
      if (options.inline) {
        v3.sourcesContent = [code];
      }
      return JSON.stringify(v3, null, 2);
    };

    VLQ_SHIFT = 5;

    VLQ_CONTINUATION_BIT = 1 << VLQ_SHIFT;

    VLQ_VALUE_MASK = VLQ_CONTINUATION_BIT - 1;

    SourceMap.prototype.encodeVlq = function(value) {
      var answer, nextChunk, signBit, valueToEncode;
      answer = '';
      signBit = value < 0 ? 1 : 0;
      valueToEncode = (Math.abs(value) << 1) + signBit;
      while (valueToEncode || !answer) {
        nextChunk = valueToEncode & VLQ_VALUE_MASK;
        valueToEncode = valueToEncode >> VLQ_SHIFT;
        if (valueToEncode) {
          nextChunk |= VLQ_CONTINUATION_BIT;
        }
        answer += this.encodeBase64(nextChunk);
      }
      return answer;
    };

    BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

    SourceMap.prototype.encodeBase64 = function(value) {
      return BASE64_CHARS[value] || (function() {
        throw new Error("Cannot Base64 encode value: " + value);
      })();
    };

    return SourceMap;

  })();

  module.exports = SourceMap;

}).call(this);

},{}],188:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('decaffeinate-coffeescript'), require('decaffeinate-coffeescript/lib/coffee-script/nodes'), require('lines-and-columns'), require('util'), require('coffee-lex/dist/SourceType'), require('coffee-lex'), require('babylon')) :
  typeof define === 'function' && define.amd ? define(['exports', 'decaffeinate-coffeescript', 'decaffeinate-coffeescript/lib/coffee-script/nodes', 'lines-and-columns', 'util', 'coffee-lex/dist/SourceType', 'coffee-lex', 'babylon'], factory) :
  (factory((global.decaffeinate = global.decaffeinate || {}, global.decaffeinate.parser = global.decaffeinate.parser || {}),global.CoffeeScript,global.decaffeinateCoffeescript_lib_coffeeScript_nodes,global.LinesAndColumns,global.util,global.SourceType,global.lex,global.babylon));
}(this, (function (exports,CoffeeScript,decaffeinateCoffeescript_lib_coffeeScript_nodes,LinesAndColumns,util,SourceType,lex,babylon) { 'use strict';

LinesAndColumns = 'default' in LinesAndColumns ? LinesAndColumns['default'] : LinesAndColumns;
SourceType = 'default' in SourceType ? SourceType['default'] : SourceType;
var lex__default = 'default' in lex ? lex['default'] : lex;

const __assign = Object.assign || function (target) {
    for (var source, i = 1; i < arguments.length; i++) {
        source = arguments[i];
        for (var prop in source) {
            if (Object.prototype.hasOwnProperty.call(source, prop)) {
                target[prop] = source[prop];
            }
        }
    }
    return target;
};

function __extends(d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var ParseError = function (_super) {
    __extends(ParseError, _super);
    function ParseError(syntaxError) {
        var _this = _super.call(this, syntaxError.message) || this;
        _this.syntaxError = syntaxError;
        return _this;
    }
    return ParseError;
}(Error);
var ParseContext = function () {
    function ParseContext(source, sourceTokens, ast) {
        this.source = source;
        this.linesAndColumns = new LinesAndColumns(source);
        this.ast = ast;
        this.sourceTokens = sourceTokens;
    }
    ParseContext.prototype.getRange = function (locatable) {
        if ('range' in locatable) {
            return locatable.range;
        } else if (locatable instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Base) {
            return this.getRange(locatable.locationData);
        } else {
            var locationData = locatable;
            var start = this.linesAndColumns.indexForLocation({ line: locationData.first_line, column: locationData.first_column });
            var end = this.linesAndColumns.indexForLocation({ line: locationData.last_line, column: locationData.last_column });
            if (start === null || end === null) {
                return null;
            }
            return [start, end];
        }
    };
    ParseContext.fromSource = function (source, sourceLex, parse$$1) {
        try {
            var sourceTokens = sourceLex(source);
            return new ParseContext(source, sourceTokens, parse$$1(source));
        } catch (ex) {
            if (ex instanceof SyntaxError) {
                throw new ParseError(ex);
            } else {
                throw ex;
            }
        }
    };
    return ParseContext;
}();

function expandLocationLeftThrough(context, loc, string) {
    var offset = context.linesAndColumns.indexForLocation({ line: loc.first_line, column: loc.first_column });
    offset = context.source.lastIndexOf(string, offset === null ? undefined : offset);
    var newLoc = context.linesAndColumns.locationForIndex(offset);
    if (offset < 0 || newLoc === null) {
        throw new Error("unable to expand location starting at " + (loc.first_line + 1) + ":" + (loc.first_column + 1) + " " + ("because it is not preceded by " + JSON.stringify(string)));
    }
    return {
        first_line: newLoc.line,
        first_column: newLoc.column,
        last_line: loc.last_line,
        last_column: loc.last_column
    };
}

function isComparisonOperator(node) {
    if (!(node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Op)) {
        return false;
    }
    switch (node.operator) {
        case '<':
        case '>':
        case '<=':
        case '>=':
        case '===':
        case '!==':
            return true;
        default:
            return false;
    }
}

function isChainedComparison(node) {
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Op && isComparisonOperator(node)) {
        return isComparisonOperator(node.first) || (node.second ? isComparisonOperator(node.second) : false);
    } else {
        return false;
    }
}

function unwindChainedComparison(node) {
    var operands = [];
    for (var link = node;;) {
        if (link instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Op && isComparisonOperator(link)) {
            var first = link.first,
                second = link.second;
            if (!second) {
                throw new Error("unexpected unary operator inside chained comparison: " + util.inspect(node));
            }
            operands = [second].concat(operands);
            link = first;
        } else {
            operands = [link].concat(operands);
            break;
        }
    }
    return operands;
}

var Node = function () {
    function Node(type, line, column, start, end, raw) {
        this.type = type;
        this.line = line;
        this.column = column;
        this.start = start;
        this.end = end;
        this.raw = raw;
        this.range = [start, end];
        this.raw = raw;
    }
    return Node;
}();
var Identifier = function (_super) {
    __extends(Identifier, _super);
    function Identifier(line, column, start, end, raw, data) {
        var _this = _super.call(this, 'Identifier', line, column, start, end, raw) || this;
        _this.data = data;
        return _this;
    }
    return Identifier;
}(Node);
var Bool$1 = function (_super) {
    __extends(Bool$$1, _super);
    function Bool$$1(line, column, start, end, raw, data) {
        var _this = _super.call(this, 'Bool', line, column, start, end, raw) || this;
        _this.data = data;
        return _this;
    }
    Bool$$1["true"] = function () {
        return new Bool$$1(0, 0, 0, 0, '', true);
    };
    Bool$$1["false"] = function () {
        return new Bool$$1(0, 0, 0, 0, '', false);
    };
    return Bool$$1;
}(Node);
var JavaScript = function (_super) {
    __extends(JavaScript, _super);
    function JavaScript(line, column, start, end, raw, data) {
        var _this = _super.call(this, 'JavaScript', line, column, start, end, raw) || this;
        _this.data = data;
        return _this;
    }
    return JavaScript;
}(Node);
var Number = function (_super) {
    __extends(Number, _super);
    function Number(type, line, column, start, end, raw, data) {
        var _this = _super.call(this, type, line, column, start, end, raw) || this;
        _this.data = data;
        return _this;
    }
    return Number;
}(Node);
var Float = function (_super) {
    __extends(Float, _super);
    function Float(line, column, start, end, raw, data) {
        return _super.call(this, 'Float', line, column, start, end, raw, data) || this;
    }
    return Float;
}(Number);
var Int = function (_super) {
    __extends(Int, _super);
    function Int(line, column, start, end, raw, data) {
        return _super.call(this, 'Int', line, column, start, end, raw, data) || this;
    }
    return Int;
}(Number);
var AccessOp = function (_super) {
    __extends(AccessOp, _super);
    function AccessOp(type, line, column, start, end, raw, expression) {
        var _this = _super.call(this, type, line, column, start, end, raw) || this;
        _this.expression = expression;
        return _this;
    }
    return AccessOp;
}(Node);
var MemberAccessOp = function (_super) {
    __extends(MemberAccessOp, _super);
    function MemberAccessOp(line, column, start, end, raw, expression, member) {
        var _this = _super.call(this, 'MemberAccessOp', line, column, start, end, raw, expression) || this;
        _this.member = member;
        return _this;
    }
    return MemberAccessOp;
}(AccessOp);
var ProtoMemberAccessOp = function (_super) {
    __extends(ProtoMemberAccessOp, _super);
    function ProtoMemberAccessOp(line, column, start, end, raw, expression) {
        return _super.call(this, 'ProtoMemberAccessOp', line, column, start, end, raw, expression) || this;
    }
    return ProtoMemberAccessOp;
}(AccessOp);
var SoakedMemberAccessOp = function (_super) {
    __extends(SoakedMemberAccessOp, _super);
    function SoakedMemberAccessOp(line, column, start, end, raw, expression, member) {
        var _this = _super.call(this, 'SoakedMemberAccessOp', line, column, start, end, raw, expression) || this;
        _this.member = member;
        return _this;
    }
    return SoakedMemberAccessOp;
}(AccessOp);
var SoakedProtoMemberAccessOp = function (_super) {
    __extends(SoakedProtoMemberAccessOp, _super);
    function SoakedProtoMemberAccessOp(line, column, start, end, raw, expression) {
        return _super.call(this, 'SoakedProtoMemberAccessOp', line, column, start, end, raw, expression) || this;
    }
    return SoakedProtoMemberAccessOp;
}(AccessOp);
var Quasi = function (_super) {
    __extends(Quasi, _super);
    function Quasi(line, column, start, end, raw, data) {
        var _this = _super.call(this, 'Quasi', line, column, start, end, raw) || this;
        _this.data = data;
        return _this;
    }
    return Quasi;
}(Node);
var String = function (_super) {
    __extends(String, _super);
    function String(line, column, start, end, raw, quasis, expressions) {
        var _this = _super.call(this, 'String', line, column, start, end, raw) || this;
        _this.quasis = quasis;
        _this.expressions = expressions;
        return _this;
    }
    return String;
}(Node);
var ObjectInitialiser = function (_super) {
    __extends(ObjectInitialiser, _super);
    function ObjectInitialiser(line, column, start, end, raw, members) {
        var _this = _super.call(this, 'ObjectInitialiser', line, column, start, end, raw) || this;
        _this.members = members;
        return _this;
    }
    return ObjectInitialiser;
}(Node);
var ObjectInitialiserMember = function (_super) {
    __extends(ObjectInitialiserMember, _super);
    function ObjectInitialiserMember(line, column, start, end, raw, key, expression) {
        var _this = _super.call(this, 'ObjectInitialiserMember', line, column, start, end, raw) || this;
        _this.key = key;
        _this.expression = expression;
        return _this;
    }
    return ObjectInitialiserMember;
}(Node);
var Conditional = function (_super) {
    __extends(Conditional, _super);
    function Conditional(line, column, start, end, raw, condition, consequent, alternate, isUnless) {
        var _this = _super.call(this, 'Conditional', line, column, start, end, raw) || this;
        _this.condition = condition;
        _this.consequent = consequent;
        _this.alternate = alternate;
        _this.isUnless = isUnless;
        return _this;
    }
    return Conditional;
}(Node);
var Program = function (_super) {
    __extends(Program, _super);
    function Program(line, column, start, end, raw, body) {
        var _this = _super.call(this, 'Program', line, column, start, end, raw) || this;
        _this.body = body;
        return _this;
    }
    return Program;
}(Node);
var Block$1 = function (_super) {
    __extends(Block$$1, _super);
    function Block$$1(line, column, start, end, raw, statements, inline) {
        var _this = _super.call(this, 'Block', line, column, start, end, raw) || this;
        _this.statements = statements;
        _this.inline = inline;
        return _this;
    }
    return Block$$1;
}(Node);
var Loop = function (_super) {
    __extends(Loop, _super);
    function Loop(line, column, start, end, raw, body) {
        var _this = _super.call(this, 'Loop', line, column, start, end, raw) || this;
        _this.body = body;
        return _this;
    }
    return Loop;
}(Node);
var While$1 = function (_super) {
    __extends(While$$1, _super);
    function While$$1(line, column, start, end, raw, condition, guard, body, isUntil) {
        var _this = _super.call(this, 'While', line, column, start, end, raw) || this;
        _this.condition = condition;
        _this.guard = guard;
        _this.body = body;
        _this.isUntil = isUntil;
        return _this;
    }
    return While$$1;
}(Node);
var For$1 = function (_super) {
    __extends(For$$1, _super);
    function For$$1(type, line, column, start, end, raw, keyAssignee, valAssignee, target, filter, body) {
        var _this = _super.call(this, type, line, column, start, end, raw) || this;
        _this.keyAssignee = keyAssignee;
        _this.valAssignee = valAssignee;
        _this.target = target;
        _this.filter = filter;
        _this.body = body;
        return _this;
    }
    return For$$1;
}(Node);
var ForOf = function (_super) {
    __extends(ForOf, _super);
    function ForOf(line, column, start, end, raw, keyAssignee, valAssignee, target, filter, body, isOwn) {
        var _this = _super.call(this, 'ForOf', line, column, start, end, raw, keyAssignee, valAssignee, target, filter, body) || this;
        _this.isOwn = isOwn;
        return _this;
    }
    return ForOf;
}(For$1);
var ForIn = function (_super) {
    __extends(ForIn, _super);
    function ForIn(line, column, start, end, raw, keyAssignee, valAssignee, target, filter, body, step) {
        var _this = _super.call(this, 'ForIn', line, column, start, end, raw, keyAssignee, valAssignee, target, filter, body) || this;
        _this.step = step;
        return _this;
    }
    return ForIn;
}(For$1);
var Switch$1 = function (_super) {
    __extends(Switch$$1, _super);
    function Switch$$1(line, column, start, end, raw, expression, cases, alternate) {
        var _this = _super.call(this, 'Switch', line, column, start, end, raw) || this;
        _this.expression = expression;
        _this.cases = cases;
        _this.alternate = alternate;
        return _this;
    }
    return Switch$$1;
}(Node);
var SwitchCase = function (_super) {
    __extends(SwitchCase, _super);
    function SwitchCase(line, column, start, end, raw, conditions, consequent) {
        var _this = _super.call(this, 'SwitchCase', line, column, start, end, raw) || this;
        _this.conditions = conditions;
        _this.consequent = consequent;
        return _this;
    }
    return SwitchCase;
}(Node);
var RegexFlags = function () {
    function RegexFlags(global, ignoreCase, multiline, sticky) {
        this.global = global;
        this.ignoreCase = ignoreCase;
        this.multiline = multiline;
        this.sticky = sticky;
        this.g = global;
        this.i = ignoreCase;
        this.m = multiline;
        this.y = sticky;
    }
    RegexFlags.parse = function (flags) {
        var global = false;
        var ignoreCase = false;
        var multiline = false;
        var sticky = false;
        for (var i = 0; i < flags.length; i++) {
            switch (flags.charCodeAt(i)) {
                case 103:
                    global = true;
                    break;
                case 105:
                    ignoreCase = true;
                    break;
                case 109:
                    multiline = true;
                    break;
                case 121:
                    sticky = true;
                    break;
                default:
                    throw new Error("invalid regular expression flags: " + flags);
            }
        }
        return new RegexFlags(global, ignoreCase, multiline, sticky);
    };
    return RegexFlags;
}();
var Heregex = function (_super) {
    __extends(Heregex, _super);
    function Heregex(line, column, start, end, raw, quasis, expressions, flags) {
        var _this = _super.call(this, 'Heregex', line, column, start, end, raw) || this;
        _this.quasis = quasis;
        _this.expressions = expressions;
        _this.flags = flags;
        return _this;
    }
    return Heregex;
}(Node);
var Null$1 = function (_super) {
    __extends(Null$$1, _super);
    function Null$$1(line, column, start, end, raw) {
        return _super.call(this, 'Null', line, column, start, end, raw) || this;
    }
    return Null$$1;
}(Node);
var Undefined$1 = function (_super) {
    __extends(Undefined$$1, _super);
    function Undefined$$1(line, column, start, end, raw) {
        return _super.call(this, 'Undefined', line, column, start, end, raw) || this;
    }
    return Undefined$$1;
}(Node);
var Regex = function (_super) {
    __extends(Regex, _super);
    function Regex(line, column, start, end, raw, pattern, flags) {
        var _this = _super.call(this, 'Regex', line, column, start, end, raw) || this;
        _this.pattern = pattern;
        _this.flags = flags;
        return _this;
    }
    return Regex;
}(Node);
var Return$1 = function (_super) {
    __extends(Return$$1, _super);
    function Return$$1(line, column, start, end, raw, expression) {
        var _this = _super.call(this, 'Return', line, column, start, end, raw) || this;
        _this.expression = expression;
        return _this;
    }
    return Return$$1;
}(Node);
var YieldReturn = function (_super) {
    __extends(YieldReturn, _super);
    function YieldReturn(line, column, start, end, raw, expression) {
        var _this = _super.call(this, 'YieldReturn', line, column, start, end, raw) || this;
        _this.expression = expression;
        return _this;
    }
    return YieldReturn;
}(Node);
var This = function (_super) {
    __extends(This, _super);
    function This(line, column, start, end, raw) {
        return _super.call(this, 'This', line, column, start, end, raw) || this;
    }
    return This;
}(Node);
var Throw$1 = function (_super) {
    __extends(Throw$$1, _super);
    function Throw$$1(line, column, start, end, raw, expression) {
        var _this = _super.call(this, 'Throw', line, column, start, end, raw) || this;
        _this.expression = expression;
        return _this;
    }
    return Throw$$1;
}(Node);
var ArrayInitialiser = function (_super) {
    __extends(ArrayInitialiser, _super);
    function ArrayInitialiser(line, column, start, end, raw, members) {
        var _this = _super.call(this, 'ArrayInitialiser', line, column, start, end, raw) || this;
        _this.members = members;
        return _this;
    }
    return ArrayInitialiser;
}(Node);
var DefaultParam = function (_super) {
    __extends(DefaultParam, _super);
    function DefaultParam(line, column, start, end, raw, param, defaultValue) {
        var _this = _super.call(this, 'DefaultParam', line, column, start, end, raw) || this;
        _this.param = param;
        _this["default"] = defaultValue;
        return _this;
    }
    return DefaultParam;
}(Node);
var Rest = function (_super) {
    __extends(Rest, _super);
    function Rest(line, column, start, end, raw, expression) {
        var _this = _super.call(this, 'Rest', line, column, start, end, raw) || this;
        _this.expression = expression;
        return _this;
    }
    return Rest;
}(Node);
var Break = function (_super) {
    __extends(Break, _super);
    function Break(line, column, start, end, raw) {
        return _super.call(this, 'Break', line, column, start, end, raw) || this;
    }
    return Break;
}(Node);
var Continue = function (_super) {
    __extends(Continue, _super);
    function Continue(line, column, start, end, raw) {
        return _super.call(this, 'Continue', line, column, start, end, raw) || this;
    }
    return Continue;
}(Node);
var Spread = function (_super) {
    __extends(Spread, _super);
    function Spread(line, column, start, end, raw, expression) {
        var _this = _super.call(this, 'Spread', line, column, start, end, raw) || this;
        _this.expression = expression;
        return _this;
    }
    return Spread;
}(Node);
var Range$1 = function (_super) {
    __extends(Range$$1, _super);
    function Range$$1(line, column, start, end, raw, left, right, isInclusive) {
        var _this = _super.call(this, 'Range', line, column, start, end, raw) || this;
        _this.left = left;
        _this.right = right;
        _this.isInclusive = isInclusive;
        return _this;
    }
    return Range$$1;
}(Node);
var BinaryOp = function (_super) {
    __extends(BinaryOp, _super);
    function BinaryOp(type, line, column, start, end, raw, left, right) {
        var _this = _super.call(this, type, line, column, start, end, raw) || this;
        _this.left = left;
        _this.right = right;
        return _this;
    }
    return BinaryOp;
}(Node);
var UnaryOp = function (_super) {
    __extends(UnaryOp, _super);
    function UnaryOp(type, line, column, start, end, raw, expression) {
        var _this = _super.call(this, type, line, column, start, end, raw) || this;
        _this.expression = expression;
        return _this;
    }
    return UnaryOp;
}(Node);
var ChainedComparisonOp = function (_super) {
    __extends(ChainedComparisonOp, _super);
    function ChainedComparisonOp(line, column, start, end, raw, operands, operators) {
        var _this = _super.call(this, 'ChainedComparisonOp', line, column, start, end, raw) || this;
        _this.operands = operands;
        _this.operators = operators;
        return _this;
    }
    return ChainedComparisonOp;
}(Node);
var OperatorInfo = function () {
    function OperatorInfo(operator, token) {
        this.operator = operator;
        this.token = token;
    }
    return OperatorInfo;
}();
var EQOp = function (_super) {
    __extends(EQOp, _super);
    function EQOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'EQOp', line, column, start, end, raw, left, right) || this;
    }
    return EQOp;
}(BinaryOp);
var NEQOp = function (_super) {
    __extends(NEQOp, _super);
    function NEQOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'NEQOp', line, column, start, end, raw, left, right) || this;
    }
    return NEQOp;
}(BinaryOp);
var LTOp = function (_super) {
    __extends(LTOp, _super);
    function LTOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'LTOp', line, column, start, end, raw, left, right) || this;
    }
    return LTOp;
}(BinaryOp);
var LTEOp = function (_super) {
    __extends(LTEOp, _super);
    function LTEOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'LTEOp', line, column, start, end, raw, left, right) || this;
    }
    return LTEOp;
}(BinaryOp);
var GTOp = function (_super) {
    __extends(GTOp, _super);
    function GTOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'GTOp', line, column, start, end, raw, left, right) || this;
    }
    return GTOp;
}(BinaryOp);
var GTEOp = function (_super) {
    __extends(GTEOp, _super);
    function GTEOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'GTEOp', line, column, start, end, raw, left, right) || this;
    }
    return GTEOp;
}(BinaryOp);
var LogicalNotOp = function (_super) {
    __extends(LogicalNotOp, _super);
    function LogicalNotOp(line, column, start, end, raw, expression) {
        return _super.call(this, 'LogicalNotOp', line, column, start, end, raw, expression) || this;
    }
    return LogicalNotOp;
}(UnaryOp);
var LogicalAndOp = function (_super) {
    __extends(LogicalAndOp, _super);
    function LogicalAndOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'LogicalAndOp', line, column, start, end, raw, left, right) || this;
    }
    return LogicalAndOp;
}(BinaryOp);
var LogicalOrOp = function (_super) {
    __extends(LogicalOrOp, _super);
    function LogicalOrOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'LogicalOrOp', line, column, start, end, raw, left, right) || this;
    }
    return LogicalOrOp;
}(BinaryOp);
var SubtractOp = function (_super) {
    __extends(SubtractOp, _super);
    function SubtractOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'SubtractOp', line, column, start, end, raw, left, right) || this;
    }
    return SubtractOp;
}(BinaryOp);
var PlusOp = function (_super) {
    __extends(PlusOp, _super);
    function PlusOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'PlusOp', line, column, start, end, raw, left, right) || this;
    }
    return PlusOp;
}(BinaryOp);
var UnaryPlusOp = function (_super) {
    __extends(UnaryPlusOp, _super);
    function UnaryPlusOp(line, column, start, end, raw, expression) {
        return _super.call(this, 'UnaryPlusOp', line, column, start, end, raw, expression) || this;
    }
    return UnaryPlusOp;
}(UnaryOp);
var MultiplyOp = function (_super) {
    __extends(MultiplyOp, _super);
    function MultiplyOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'MultiplyOp', line, column, start, end, raw, left, right) || this;
    }
    return MultiplyOp;
}(BinaryOp);
var DivideOp = function (_super) {
    __extends(DivideOp, _super);
    function DivideOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'DivideOp', line, column, start, end, raw, left, right) || this;
    }
    return DivideOp;
}(BinaryOp);
var UnaryExistsOp = function (_super) {
    __extends(UnaryExistsOp, _super);
    function UnaryExistsOp(line, column, start, end, raw, expression) {
        return _super.call(this, 'UnaryExistsOp', line, column, start, end, raw, expression) || this;
    }
    return UnaryExistsOp;
}(UnaryOp);
var UnaryNegateOp = function (_super) {
    __extends(UnaryNegateOp, _super);
    function UnaryNegateOp(line, column, start, end, raw, expression) {
        return _super.call(this, 'UnaryNegateOp', line, column, start, end, raw, expression) || this;
    }
    return UnaryNegateOp;
}(UnaryOp);
var BitNotOp = function (_super) {
    __extends(BitNotOp, _super);
    function BitNotOp(line, column, start, end, raw, expression) {
        return _super.call(this, 'BitNotOp', line, column, start, end, raw, expression) || this;
    }
    return BitNotOp;
}(UnaryOp);
var BitAndOp = function (_super) {
    __extends(BitAndOp, _super);
    function BitAndOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'BitAndOp', line, column, start, end, raw, left, right) || this;
    }
    return BitAndOp;
}(BinaryOp);
var BitOrOp = function (_super) {
    __extends(BitOrOp, _super);
    function BitOrOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'BitOrOp', line, column, start, end, raw, left, right) || this;
    }
    return BitOrOp;
}(BinaryOp);
var BitXorOp = function (_super) {
    __extends(BitXorOp, _super);
    function BitXorOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'BitXorOp', line, column, start, end, raw, left, right) || this;
    }
    return BitXorOp;
}(BinaryOp);
var LeftShiftOp = function (_super) {
    __extends(LeftShiftOp, _super);
    function LeftShiftOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'LeftShiftOp', line, column, start, end, raw, left, right) || this;
    }
    return LeftShiftOp;
}(BinaryOp);
var SignedRightShiftOp = function (_super) {
    __extends(SignedRightShiftOp, _super);
    function SignedRightShiftOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'SignedRightShiftOp', line, column, start, end, raw, left, right) || this;
    }
    return SignedRightShiftOp;
}(BinaryOp);
var UnsignedRightShiftOp = function (_super) {
    __extends(UnsignedRightShiftOp, _super);
    function UnsignedRightShiftOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'UnsignedRightShiftOp', line, column, start, end, raw, left, right) || this;
    }
    return UnsignedRightShiftOp;
}(BinaryOp);
var PreDecrementOp = function (_super) {
    __extends(PreDecrementOp, _super);
    function PreDecrementOp(line, column, start, end, raw, expression) {
        return _super.call(this, 'PreDecrementOp', line, column, start, end, raw, expression) || this;
    }
    return PreDecrementOp;
}(UnaryOp);
var PreIncrementOp = function (_super) {
    __extends(PreIncrementOp, _super);
    function PreIncrementOp(line, column, start, end, raw, expression) {
        return _super.call(this, 'PreIncrementOp', line, column, start, end, raw, expression) || this;
    }
    return PreIncrementOp;
}(UnaryOp);
var PostDecrementOp = function (_super) {
    __extends(PostDecrementOp, _super);
    function PostDecrementOp(line, column, start, end, raw, expression) {
        return _super.call(this, 'PostDecrementOp', line, column, start, end, raw, expression) || this;
    }
    return PostDecrementOp;
}(UnaryOp);
var PostIncrementOp = function (_super) {
    __extends(PostIncrementOp, _super);
    function PostIncrementOp(line, column, start, end, raw, expression) {
        return _super.call(this, 'PostIncrementOp', line, column, start, end, raw, expression) || this;
    }
    return PostIncrementOp;
}(UnaryOp);
var ExpOp = function (_super) {
    __extends(ExpOp, _super);
    function ExpOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'ExpOp', line, column, start, end, raw, left, right) || this;
    }
    return ExpOp;
}(BinaryOp);
var RemOp = function (_super) {
    __extends(RemOp, _super);
    function RemOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'RemOp', line, column, start, end, raw, left, right) || this;
    }
    return RemOp;
}(BinaryOp);
var ModuloOp = function (_super) {
    __extends(ModuloOp, _super);
    function ModuloOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'ModuloOp', line, column, start, end, raw, left, right) || this;
    }
    return ModuloOp;
}(BinaryOp);
var InOp = function (_super) {
    __extends(InOp, _super);
    function InOp(line, column, start, end, raw, left, right, isNot) {
        var _this = _super.call(this, 'InOp', line, column, start, end, raw, left, right) || this;
        _this.isNot = isNot;
        return _this;
    }
    return InOp;
}(BinaryOp);
var BaseAssignOp = function (_super) {
    __extends(BaseAssignOp, _super);
    function BaseAssignOp(type, line, column, start, end, raw, assignee, expression) {
        var _this = _super.call(this, type, line, column, start, end, raw) || this;
        _this.assignee = assignee;
        _this.expression = expression;
        return _this;
    }
    return BaseAssignOp;
}(Node);
var AssignOp = function (_super) {
    __extends(AssignOp, _super);
    function AssignOp(line, column, start, end, raw, assignee, expression) {
        return _super.call(this, 'AssignOp', line, column, start, end, raw, assignee, expression) || this;
    }
    AssignOp.prototype.withExpression = function (expression) {
        return new AssignOp(this.line, this.column, this.start, this.end, this.raw, this.assignee, expression);
    };
    return AssignOp;
}(BaseAssignOp);
var ExtendsOp = function (_super) {
    __extends(ExtendsOp, _super);
    function ExtendsOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'ExtendsOp', line, column, start, end, raw, left, right) || this;
    }
    return ExtendsOp;
}(BinaryOp);
var SeqOp = function (_super) {
    __extends(SeqOp, _super);
    function SeqOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'SeqOp', line, column, start, end, raw, left, right) || this;
    }
    return SeqOp;
}(BinaryOp);
var TypeofOp = function (_super) {
    __extends(TypeofOp, _super);
    function TypeofOp(line, column, start, end, raw, expression) {
        return _super.call(this, 'TypeofOp', line, column, start, end, raw, expression) || this;
    }
    return TypeofOp;
}(UnaryOp);
var InstanceofOp = function (_super) {
    __extends(InstanceofOp, _super);
    function InstanceofOp(line, column, start, end, raw, left, right, isNot) {
        var _this = _super.call(this, 'InstanceofOp', line, column, start, end, raw, left, right) || this;
        _this.isNot = isNot;
        return _this;
    }
    return InstanceofOp;
}(BinaryOp);
var OfOp = function (_super) {
    __extends(OfOp, _super);
    function OfOp(line, column, start, end, raw, left, right, isNot) {
        var _this = _super.call(this, 'OfOp', line, column, start, end, raw, left, right) || this;
        _this.isNot = isNot;
        return _this;
    }
    return OfOp;
}(BinaryOp);
var DeleteOp = function (_super) {
    __extends(DeleteOp, _super);
    function DeleteOp(line, column, start, end, raw, expression) {
        return _super.call(this, 'DeleteOp', line, column, start, end, raw, expression) || this;
    }
    return DeleteOp;
}(UnaryOp);
var Yield = function (_super) {
    __extends(Yield, _super);
    function Yield(line, column, start, end, raw, expression) {
        return _super.call(this, 'Yield', line, column, start, end, raw, expression) || this;
    }
    return Yield;
}(UnaryOp);
var YieldFrom = function (_super) {
    __extends(YieldFrom, _super);
    function YieldFrom(line, column, start, end, raw, expression) {
        return _super.call(this, 'YieldFrom', line, column, start, end, raw, expression) || this;
    }
    return YieldFrom;
}(UnaryOp);
var Slice$1 = function (_super) {
    __extends(Slice$$1, _super);
    function Slice$$1(line, column, start, end, raw, expression, left, right, isInclusive) {
        var _this = _super.call(this, 'Slice', line, column, start, end, raw) || this;
        _this.expression = expression;
        _this.left = left;
        _this.right = right;
        _this.isInclusive = isInclusive;
        return _this;
    }
    return Slice$$1;
}(Node);
var SoakedSlice = function (_super) {
    __extends(SoakedSlice, _super);
    function SoakedSlice(line, column, start, end, raw, expression, left, right, isInclusive) {
        var _this = _super.call(this, 'SoakedSlice', line, column, start, end, raw) || this;
        _this.expression = expression;
        _this.left = left;
        _this.right = right;
        _this.isInclusive = isInclusive;
        return _this;
    }
    return SoakedSlice;
}(Node);
var BaseFunction = function (_super) {
    __extends(BaseFunction, _super);
    function BaseFunction(type, line, column, start, end, raw, parameters, body) {
        var _this = _super.call(this, type, line, column, start, end, raw) || this;
        _this.parameters = parameters;
        _this.body = body;
        return _this;
    }
    return BaseFunction;
}(Node);
var Function$1 = function (_super) {
    __extends(Function, _super);
    function Function(line, column, start, end, raw, parameters, body) {
        return _super.call(this, 'Function', line, column, start, end, raw, parameters, body) || this;
    }
    Function.prototype.withParameters = function (parameters) {
        return new Function(this.line, this.column, this.start, this.end, this.raw, parameters, this.body);
    };
    return Function;
}(BaseFunction);
var BoundFunction = function (_super) {
    __extends(BoundFunction, _super);
    function BoundFunction(line, column, start, end, raw, parameters, body) {
        return _super.call(this, 'BoundFunction', line, column, start, end, raw, parameters, body) || this;
    }
    BoundFunction.prototype.withParameters = function (parameters) {
        return new BoundFunction(this.line, this.column, this.start, this.end, this.raw, parameters, this.body);
    };
    return BoundFunction;
}(BaseFunction);
var GeneratorFunction = function (_super) {
    __extends(GeneratorFunction, _super);
    function GeneratorFunction(line, column, start, end, raw, parameters, body) {
        return _super.call(this, 'GeneratorFunction', line, column, start, end, raw, parameters, body) || this;
    }
    GeneratorFunction.prototype.withParameters = function (parameters) {
        return new GeneratorFunction(this.line, this.column, this.start, this.end, this.raw, parameters, this.body);
    };
    return GeneratorFunction;
}(BaseFunction);
var BoundGeneratorFunction = function (_super) {
    __extends(BoundGeneratorFunction, _super);
    function BoundGeneratorFunction(line, column, start, end, raw, parameters, body) {
        return _super.call(this, 'BoundGeneratorFunction', line, column, start, end, raw, parameters, body) || this;
    }
    BoundGeneratorFunction.prototype.withParameters = function (parameters) {
        return new BoundGeneratorFunction(this.line, this.column, this.start, this.end, this.raw, parameters, this.body);
    };
    return BoundGeneratorFunction;
}(BaseFunction);
var Try$1 = function (_super) {
    __extends(Try$$1, _super);
    function Try$$1(line, column, start, end, raw, body, catchAssignee, catchBody, finallyBody) {
        var _this = _super.call(this, 'Try', line, column, start, end, raw) || this;
        _this.body = body;
        _this.catchAssignee = catchAssignee;
        _this.catchBody = catchBody;
        _this.finallyBody = finallyBody;
        return _this;
    }
    return Try$$1;
}(Node);
var Constructor = function (_super) {
    __extends(Constructor, _super);
    function Constructor(line, column, start, end, raw, assignee, expression) {
        return _super.call(this, 'Constructor', line, column, start, end, raw, assignee, expression) || this;
    }
    return Constructor;
}(BaseAssignOp);
var ClassProtoAssignOp = function (_super) {
    __extends(ClassProtoAssignOp, _super);
    function ClassProtoAssignOp(line, column, start, end, raw, assignee, expression) {
        return _super.call(this, 'ClassProtoAssignOp', line, column, start, end, raw, assignee, expression) || this;
    }
    return ClassProtoAssignOp;
}(BaseAssignOp);
var Class$1 = function (_super) {
    __extends(Class$$1, _super);
    function Class$$1(line, column, start, end, raw, nameAssignee, name, body, boundMembers, parent, ctor) {
        var _this = _super.call(this, 'Class', line, column, start, end, raw) || this;
        _this.nameAssignee = nameAssignee;
        _this.name = name;
        _this.body = body;
        _this.boundMembers = boundMembers;
        _this.parent = parent;
        _this.ctor = ctor;
        return _this;
    }
    return Class$$1;
}(Node);
var FunctionApplication = function (_super) {
    __extends(FunctionApplication, _super);
    function FunctionApplication(line, column, start, end, raw, fn, args) {
        var _this = _super.call(this, 'FunctionApplication', line, column, start, end, raw) || this;
        _this["function"] = fn;
        _this.arguments = args;
        return _this;
    }
    return FunctionApplication;
}(Node);
var SoakedFunctionApplication = function (_super) {
    __extends(SoakedFunctionApplication, _super);
    function SoakedFunctionApplication(line, column, start, end, raw, fn, args) {
        var _this = _super.call(this, 'SoakedFunctionApplication', line, column, start, end, raw) || this;
        _this["function"] = fn;
        _this.arguments = args;
        return _this;
    }
    return SoakedFunctionApplication;
}(Node);
var Super = function (_super) {
    __extends(Super, _super);
    function Super(line, column, start, end, raw) {
        return _super.call(this, 'Super', line, column, start, end, raw) || this;
    }
    return Super;
}(Node);
var BareSuperFunctionApplication = function (_super) {
    __extends(BareSuperFunctionApplication, _super);
    function BareSuperFunctionApplication(line, column, start, end, raw) {
        return _super.call(this, 'BareSuperFunctionApplication', line, column, start, end, raw) || this;
    }
    return BareSuperFunctionApplication;
}(Node);
var NewOp = function (_super) {
    __extends(NewOp, _super);
    function NewOp(line, column, start, end, raw, ctor, args) {
        var _this = _super.call(this, 'NewOp', line, column, start, end, raw) || this;
        _this.ctor = ctor;
        _this.arguments = args;
        return _this;
    }
    return NewOp;
}(Node);
var SoakedNewOp = function (_super) {
    __extends(SoakedNewOp, _super);
    function SoakedNewOp(line, column, start, end, raw, ctor, args) {
        var _this = _super.call(this, 'SoakedNewOp', line, column, start, end, raw) || this;
        _this.ctor = ctor;
        _this.arguments = args;
        return _this;
    }
    return SoakedNewOp;
}(Node);
var DoOp = function (_super) {
    __extends(DoOp, _super);
    function DoOp(line, column, start, end, raw, expression) {
        var _this = _super.call(this, 'DoOp', line, column, start, end, raw) || this;
        _this.expression = expression;
        return _this;
    }
    return DoOp;
}(Node);
// tslint:disable-next-line:no-any
function makeRealNode(context, type, loc, attrs) {
    if (attrs === void 0) {
        attrs = {};
    }
    // tslint:disable-next-line:no-any
    var result = { type: type };
    var start = context.linesAndColumns.indexForLocation({ line: loc.first_line, column: loc.first_column });
    var last = context.linesAndColumns.indexForLocation({ line: loc.last_line, column: loc.last_column });
    if (start === null || last === null) {
        throw new Error("unable to determine range for location: " + util.inspect(loc) + "}");
    }
    result.line = loc.first_line + 1;
    result.column = loc.first_column + 1;
    result.range = [start, last + 1];
    for (var key in attrs) {
        if (attrs.hasOwnProperty(key)) {
            var value = attrs[key];
            result[key] = value;
            if (value && result.range) {
                (Array.isArray(value) ? value : [value]).forEach(function (node) {
                    if (node.range) {
                        // Expand the range to contain all the children.
                        if (result.range[0] > node.range[0]) {
                            result.range[0] = node.range[0];
                        }
                        if (result.range[1] < node.range[1]) {
                            result.range[1] = node.range[1];
                        }
                    }
                });
            }
        }
    }
    // Shrink to be within the size of the source.
    if (result.range[0] < 0) {
        result.range[0] = 0;
    }
    if (result.range[1] > context.source.length) {
        result.range[1] = context.source.length;
    }
    // Shrink the end to the nearest semantic token.
    var lastTokenIndexOfNode = context.sourceTokens.lastIndexOfTokenMatchingPredicate(function (token) {
        return token.end <= result.range[1] && token.type !== lex.SourceType.NEWLINE && token.type !== lex.SourceType.COMMENT;
    }, context.sourceTokens.indexOfTokenNearSourceIndex(result.range[1]));
    if (lastTokenIndexOfNode === null) {
        throw new Error("unable to find last token for node: " + util.inspect(result));
    }
    var lastTokenOfNode = context.sourceTokens.tokenAtIndex(lastTokenIndexOfNode);
    if (lastTokenOfNode === null) {
        throw new Error("unable to find last token for node: " + util.inspect(result));
    }
    result.range[1] = lastTokenOfNode.end;
    result.raw = context.source.slice(result.range[0], result.range[1]);
    return result;
}
// tslint:disable-next-line:no-any
function makeNode(context, type, loc, attrs) {
    if (attrs === void 0) {
        attrs = {};
    }
    if (!loc) {
        throw new Error("location data must be provided for node type: " + type);
    }
    return makeRealNode(context, type, loc, attrs);
}

/**
 * Gets information about an operator token found between start and end source
 * offsets, exclusive. When calling, make sure `start` is before the text of
 * the operator in the range, and `end` is after it.
 */
function getOperatorInfoInRange(context, start, end) {
    var startIndex = context.sourceTokens.indexOfTokenNearSourceIndex(start);
    var endIndex = context.sourceTokens.indexOfTokenNearSourceIndex(end);
    if (!startIndex || !endIndex) {
        throw new Error("cannot find token indexes of range bounds: [" + start + ", " + end + "]");
    }
    var operatorIndex = context.sourceTokens.indexOfTokenMatchingPredicate(function (token) {
        return token.type !== SourceType.LPAREN && token.type !== SourceType.RPAREN;
    }, startIndex.next(), endIndex);
    var operatorToken = operatorIndex && context.sourceTokens.tokenAtIndex(operatorIndex);
    if (!operatorToken) {
        throw new Error("cannot find operator token in range: [" + start + ", " + end + "]");
    }
    return new OperatorInfo(context.source.slice(operatorToken.start, operatorToken.end), operatorToken);
}

/**
 * Determine if the given CoffeeScript AST node is an interpolated heregex node
 * that's pretending to be a function call to the RegExp function.
 */
function isHeregexTemplateNode(node, context) {
    if (!(node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Call) || !node.variable || !(node.variable instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Value) || !node.variable.base || !(node.variable.base instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Literal) || node.variable.base.value !== 'RegExp') {
        return false;
    }
    var sourceTokens = context.sourceTokens,
        linesAndColumns = context.linesAndColumns;
    var start = linesAndColumns.indexForLocation({ line: node.locationData.first_line, column: node.locationData.first_column });
    if (start === null) {
        return false;
    }
    var startTokenIndex = sourceTokens.indexOfTokenContainingSourceIndex(start);
    if (startTokenIndex === null) {
        return false;
    }
    var startToken = sourceTokens.tokenAtIndex(startTokenIndex);
    if (startToken === null) {
        return false;
    }
    return startToken.type === lex.SourceType.HEREGEXP_START;
}

/**
 * Given the ranges of two operands, determine from the token list whether there
 * is a real '+' operator between them. A plus operation without an actual '+'
 * operator is an implicit string interpolation operation.
 */
function isPlusTokenBetweenRanges(leftRange, rightRange, context) {
    var tokens = context.sourceTokens;
    var leftEnd = tokens.indexOfTokenContainingSourceIndex(leftRange[1] - 1);
    var rightStart = tokens.indexOfTokenContainingSourceIndex(rightRange[0]);
    // Normal '+' operators should find tokens here, so if we don't, this must be
    // an implicit '+' operator.
    if (!leftEnd || !rightStart) {
        return false;
    }
    var afterLeftEnd = leftEnd.next();
    if (!afterLeftEnd) {
        return false;
    }
    var tokensBetweenOperands = tokens.slice(afterLeftEnd, rightStart);
    // If we find an actual operator, this must have been a real '+'. Otherwise,
    // this must be an implicit '+'.
    var foundPlusToken = false;
    tokensBetweenOperands.forEach(function (_a) {
        var type = _a.type,
            start = _a.start,
            end = _a.end;
        if (type === lex.SourceType.OPERATOR && context.source.slice(start, end) === '+') {
            foundPlusToken = true;
        }
    });
    return foundPlusToken;
}

/**
 * Determine if the operator is a fake + operator for string interpolation.
 */
function isImplicitPlusOp(op, context) {
    if (op.type !== 'PlusOp') {
        return false;
    }
    return !isPlusTokenBetweenRanges(op.left.range, op.right.range, context);
}

function isInterpolatedString(node, ancestors, context) {
    var range = rangeOfInterpolatedStringForNode(node, context);
    if (!range) {
        return false;
    }
    var parentOp = null;
    for (var i = ancestors.length - 1; i >= 0; i--) {
        var ancestor = ancestors[i];
        if (ancestor instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Op) {
            parentOp = ancestor;
            break;
        }
    }
    if (!parentOp) {
        // `node` is in an interpolated string but there is no containing
        // operator, so it must be a root.
        return true;
    }
    var parentRange = rangeOfInterpolatedStringForNode(parentOp, context);
    if (!parentRange) {
        // There's a containing operator, but there's no interpolated string.
        return true;
    }
    // There's a string interpolation containing the parent operator, but is it
    // the same one? If not, then this node is the root of an interpolated string.
    return parentRange[0] !== range[0] || parentRange[1] !== range[1];
}
function rangeOfInterpolatedStringForNode(node, context) {
    if (node.operator !== '+' || !node.second) {
        return null;
    }
    var firstRange = context.getRange(node.first);
    var secondRange = context.getRange(node.second);
    if (!firstRange || !secondRange) {
        return null;
    }
    if (isPlusTokenBetweenRanges(firstRange, secondRange, context)) {
        return null;
    }
    var range = context.getRange(node);
    if (!range) {
        return null;
    }
    var tokens = context.sourceTokens;
    var startTokenIndex = tokens.indexOfTokenContainingSourceIndex(range[0]);
    if (!startTokenIndex) {
        throw new Error("no token containing start of node at " + range[0] + " found");
    }
    return tokens.rangeOfInterpolatedStringTokensContainingTokenIndex(startTokenIndex);
}

/**
 * Assumes first_line/first_column are correct.
 */
function fixInvalidLocationData(locationData, linesAndColumns) {
    var last_line = locationData.last_line,
        last_column = locationData.last_column;
    var indexForLocation = linesAndColumns.indexForLocation({ line: last_line, column: last_column });
    if (indexForLocation !== null) {
        return locationData;
    } else {
        var offset = 1;
        for (;;) {
            var index = linesAndColumns.indexForLocation({ line: last_line, column: last_column - offset });
            offset++;
            if (index !== null) {
                var location = linesAndColumns.locationForIndex(index + offset);
                if (!location) {
                    throw new Error("Unable to determine adjustment offset for incorrect location data: " + (JSON.stringify(locationData) + ". No valid location found for index: ") + ("" + (index + offset)));
                }
                last_line = location.line;
                last_column = location.column;
                break;
            }
        }
        return __assign({}, locationData, { last_line: last_line,
            last_column: last_column });
    }
}

function locationsEqual(first, second) {
    return first.first_line === second.first_line && first.first_column === second.first_column && first.last_line === second.last_line && first.last_column === second.last_column;
}

function mergeLocations(left, right) {
    var first_line;
    var first_column;
    var last_line;
    var last_column;
    if (left.first_line < right.first_line) {
        first_line = left.first_line, first_column = left.first_column;
    } else if (left.first_line > right.first_line) {
        first_line = right.first_line, first_column = right.first_column;
    } else if (left.first_column < right.first_column) {
        first_line = left.first_line, first_column = left.first_column;
    } else {
        first_line = right.first_line, first_column = right.first_column;
    }
    if (left.last_line < right.last_line) {
        last_line = right.last_line, last_column = right.last_column;
    } else if (left.last_line > right.last_line) {
        last_line = left.last_line, last_column = left.last_column;
    } else if (left.last_column < right.last_column) {
        last_line = right.last_line, last_column = right.last_column;
    } else {
        last_line = left.last_line, last_column = left.last_column;
    }
    return { first_line: first_line, first_column: first_column, last_line: last_line, last_column: last_column };
}

function locationContainingNodes() {
    var nodes$$1 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nodes$$1[_i] = arguments[_i];
    }
    switch (nodes$$1.length) {
        case 0:
            return null;
        case 1:
            return nodes$$1[0].locationData;
        case 2:
            return mergeLocations(nodes$$1[0].locationData, nodes$$1[1].locationData);
        default:
            // NOTE: force-cast since `nodes.slice(1)` cannot return `null` here.
            var tail = locationContainingNodes.apply(void 0, nodes$$1.slice(1));
            return mergeLocations(nodes$$1[0].locationData, tail);
    }
}

function locationWithLastPosition(loc, last) {
    return {
        first_line: loc.first_line,
        first_column: loc.first_column,
        last_line: last.last_line,
        last_column: last.last_column
    };
}

var UnsupportedNodeError = function (_super) {
    __extends(UnsupportedNodeError, _super);
    function UnsupportedNodeError(node) {
        var _this = _super.call(this, "node type '" + node.constructor.name + "' is not supported: " + util.inspect(node)) || this;
        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(_this, UnsupportedNodeError.prototype);
        _this.node = node;
        return _this;
    }
    return UnsupportedNodeError;
}(Error);
function mapAnyWithFallback(context, node, fallback) {
    try {
        return mapAny(context, node);
    } catch (err) {
        if (err instanceof UnsupportedNodeError) {
            return fallback();
        } else {
            throw err;
        }
    }
}

function mapBase(context, node) {
    var loc = node.locationData;
    var start = context.linesAndColumns.indexForLocation({ line: loc.first_line, column: loc.first_column });
    var last = context.linesAndColumns.indexForLocation({ line: loc.last_line, column: loc.last_column });
    if (start === null || last === null) {
        throw new Error("unable to determine range for location: " + util.inspect(loc) + "}");
    }
    var line = loc.first_line + 1;
    var column = loc.first_column + 1;
    var end = last + 1;
    // Shrink to be within the size of the source.
    if (start < 0) {
        start = 0;
    }
    if (end > context.source.length) {
        end = context.source.length;
    }
    // Shrink the end to the nearest semantic token.
    var lastTokenIndexOfNode = context.sourceTokens.lastIndexOfTokenMatchingPredicate(function (token) {
        return token.end <= end && token.type !== lex.SourceType.NEWLINE && token.type !== lex.SourceType.COMMENT;
    }, context.sourceTokens.indexOfTokenNearSourceIndex(end));
    if (lastTokenIndexOfNode === null) {
        throw new Error("unable to find last token for node: " + util.inspect(node));
    }
    var lastTokenOfNode = context.sourceTokens.tokenAtIndex(lastTokenIndexOfNode);
    if (lastTokenOfNode === null) {
        throw new Error("unable to find last token for node: " + util.inspect(node));
    }
    end = lastTokenOfNode.end;
    var raw = context.source.slice(start, end);
    return new Node('Node', line, column, start, end, raw);
}

function mapArr(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    var members = node.objects.map(function (object) {
        return mapAny(context, object);
    });
    return new ArrayInitialiser(line, column, start, end, raw, members);
}

function mapAssign(context, node) {
    if (node.context === 'object' || node.context && node.context.slice(-1) === '=') {
        throw new UnsupportedNodeError(node);
    }
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    return new AssignOp(line, column, start, end, raw, mapAny(context, node.variable), mapAny(context, node.value));
}

function mapBlock(context, node) {
    if (node.expressions.length === 0) {
        throw new UnsupportedNodeError(node);
    }
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    var previousTokenIndex = context.sourceTokens.indexOfTokenNearSourceIndex(start - 1);
    var previousToken = previousTokenIndex ? context.sourceTokens.tokenAtIndex(previousTokenIndex) : null;
    var inline = previousToken ? previousToken.type !== lex.SourceType.NEWLINE : false;
    return new Block$1(line, column, start, end, raw, node.expressions.filter(function (expression) {
        return !(expression instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Comment);
    }).map(function (expression) {
        return mapAny(context, expression);
    }), inline);
}

function mapBool(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    return new Bool$1(line, column, start, end, raw, JSON.parse(node.val));
}

function mapCall(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    if (isHeregexTemplateNode(node, context)) {
        throw new UnsupportedNodeError(node);
    }
    var args = node.args.map(function (arg) {
        return mapAny(context, arg);
    });
    if (!node.variable) {
        // This should only happen when `isSuper` is true.
        if (!node.isSuper) {
            throw new Error("callee unexpectedly null in non-super call: " + util.inspect(node));
        }
        if (node.args.length === 1 && node.args[0] instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Splat && locationsEqual(node.args[0].locationData, node.locationData)) {
            return new BareSuperFunctionApplication(line, column, start, end, raw);
        }
        var superIndex = context.sourceTokens.indexOfTokenStartingAtSourceIndex(start);
        var superToken = superIndex && context.sourceTokens.tokenAtIndex(superIndex);
        if (!superToken || superToken.type !== SourceType.SUPER) {
            throw new Error("unable to find SUPER token in 'super' function call: " + util.inspect(node));
        }
        var superLocation = context.linesAndColumns.locationForIndex(superToken.start);
        if (!superLocation) {
            throw new Error("unable to locate SUPER token for 'super' function call: " + util.inspect(node));
        }
        return new FunctionApplication(line, column, start, end, raw, new Super(superLocation.line + 1, superLocation.column + 1, superToken.start, superToken.end, context.source.slice(superToken.start, superToken.end)), args);
    }
    var callee = mapAny(context, node.variable);
    if (node.isNew) {
        return mapNewOp(context, node);
    }
    if (node.soak) {
        return new SoakedFunctionApplication(line, column, start, end, raw, callee, args);
    }
    if (node["do"]) {
        return mapDoOp(context, node);
    }
    return new FunctionApplication(line, column, start, end, raw, callee, args);
}
function mapNewOp(context, node) {
    if (!node.variable) {
        // This should only happen when `isSuper` is true.
        throw new UnsupportedNodeError(node);
    }
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    var callee = mapAny(context, node.variable);
    var args = node.args.map(function (arg) {
        return mapAny(context, arg);
    });
    if (node.soak) {
        return new SoakedNewOp(line, column, start, end, raw, callee, args);
    } else {
        return new NewOp(line, column, start, end, raw, callee, args);
    }
}
function mapDoOp(context, node) {
    if (!node.variable) {
        // This should only happen when `isSuper` is true.
        throw new UnsupportedNodeError(node);
    }
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    var expression = mapAny(context, node.variable);
    var args = node.args.map(function (arg) {
        return mapAny(context, arg);
    });
    if (expression instanceof BaseFunction) {
        expression = augmentDoFunctionWithArgs(context, expression, args);
    } else if (expression instanceof AssignOp && expression.expression instanceof BaseFunction) {
        var newRhs = augmentDoFunctionWithArgs(context, expression.expression, args);
        expression = expression.withExpression(newRhs);
    }
    return new DoOp(line, column, start, end, raw, expression);
}
function augmentDoFunctionWithArgs(context, func, args) {
    var newParameters = func.parameters.map(function (param, i) {
        var arg = args[i];
        // If there's a parameter with no default, CoffeeScript will insert a fake
        // arg with the same value and location.
        if (arg instanceof Identifier && param instanceof Identifier && arg.data === param.data && arg.start === param.start && arg.end === param.end) {
            return param;
        }
        return new DefaultParam(param.line, param.column, param.start, arg.end, context.source.slice(param.start, arg.end), param, arg);
    });
    return func.withParameters(newParameters);
}

function mapClass(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    var body = null;
    var ctor = null;
    var boundMethods = [];
    if (node.body && node.body.expressions.length > 0) {
        var statements = [];
        for (var _i = 0, _b = node.body.expressions; _i < _b.length; _i++) {
            var expression = _b[_i];
            if (expression instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Value && expression.base instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Obj) {
                for (var _c = 0, _d = expression.base.properties; _c < _d.length; _c++) {
                    var property = _d[_c];
                    if (property instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Comment) {
                        continue;
                    } else if (property instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Assign) {
                        var _e = mapBase(context, property),
                            line_1 = _e.line,
                            column_1 = _e.column,
                            start_1 = _e.start,
                            end_1 = _e.end,
                            raw_1 = _e.raw;
                        var key = mapAny(context, property.variable);
                        var value = mapAny(context, property.value);
                        var Node_1 = ClassProtoAssignOp;
                        if (key instanceof Identifier && key.data === 'constructor') {
                            Node_1 = Constructor;
                        } else if (key instanceof MemberAccessOp && key.expression instanceof This) {
                            Node_1 = AssignOp;
                        }
                        var assignment = new Node_1(line_1, column_1, start_1, end_1, raw_1, key, value);
                        statements.push(assignment);
                        if (assignment instanceof ClassProtoAssignOp && (assignment.expression instanceof BoundFunction || assignment.expression instanceof BoundGeneratorFunction)) {
                            boundMethods.push(assignment);
                        }
                        if (assignment instanceof Constructor) {
                            ctor = assignment;
                        }
                    } else {
                        throw new Error("unexpected class assignment: " + util.inspect(property));
                    }
                }
            } else {
                statements.push(mapAny(context, expression));
            }
        }
        if (statements.length > 0) {
            var firstStatement = statements[0];
            var lastStatement = statements[statements.length - 1];
            body = new Block$1(firstStatement.line, firstStatement.column, firstStatement.start, lastStatement.end, context.source.slice(firstStatement.start, lastStatement.end), statements, false);
        }
    }
    var nameAssignee = node.variable ? mapAny(context, node.variable) : null;
    var parent = node.parent ? mapAny(context, node.parent) : null;
    return new Class$1(line, column, start, end, raw, nameAssignee, nameAssignee, body, boundMethods, parent, ctor);
}

function mapCode(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    var Node$$1 = getNodeTypeForCode(node);
    return new Node$$1(line, column, start, end, raw, node.params.map(function (param) {
        return mapAny(context, param);
    }), mapBlock(context, node.body));
}
function getNodeTypeForCode(node) {
    if (node.isGenerator) {
        if (node.bound) {
            return BoundGeneratorFunction;
        } else {
            return GeneratorFunction;
        }
    } else {
        if (node.bound) {
            return BoundFunction;
        } else {
            return Function$1;
        }
    }
}

function mapExistence(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    return new UnaryExistsOp(line, column, start, end, raw, mapAny(context, node.expression));
}

function mapExtends(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    return new ExtendsOp(line, column, start, end, raw, mapAny(context, node.child), mapAny(context, node.parent));
}

function mapFor(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    var keyAssignee = node.index ? mapAny(context, node.index) : null;
    var valAssignee = node.name ? mapAny(context, node.name) : null;
    var body = mapBlock(context, node.body);
    var target = mapAny(context, node.source);
    var filter = node.guard ? mapAny(context, node.guard) : null;
    if (node.object) {
        var isOwn = node.own;
        return new ForOf(line, column, start, end, raw, keyAssignee, valAssignee, target, filter, body, isOwn);
    } else {
        var step = node.step ? mapAny(context, node.step) : null;
        return new ForIn(line, column, start, end, raw, keyAssignee, valAssignee, target, filter, body, step);
    }
}

function mapIf(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    var condition = mapAny(context, node.condition);
    var consequent = mapBlock(context, node.body);
    var alternate = node.elseBody ? mapBlock(context, node.elseBody) : null;
    var isUnless = false;
    var left = null;
    var right = null;
    if (consequent.start < condition.start) {
        // POST-if, so look for tokens between the consequent and the condition
        left = context.sourceTokens.indexOfTokenEndingAtSourceIndex(consequent.end);
        right = context.sourceTokens.indexOfTokenStartingAtSourceIndex(condition.start);
    } else {
        // regular `if`, so look from the start of the node until the condition
        left = context.sourceTokens.indexOfTokenStartingAtSourceIndex(start);
        right = context.sourceTokens.indexOfTokenStartingAtSourceIndex(condition.start);
    }
    if (left && right) {
        isUnless = context.sourceTokens.indexOfTokenMatchingPredicate(function (token) {
            return token.type === lex.SourceType.IF && context.source.slice(token.start, token.end) === 'unless';
        }, left, right) !== null;
    }
    return new Conditional(line, column, start, end, raw, condition, consequent, alternate, isUnless);
}

function mapIn(context, node) {
    // We don't use the `negated` flag on `node` because it gets set to
    // `true` when a parent `If` is an `unless`.
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    var left = mapAny(context, node.object);
    var right = mapAny(context, node.array);
    var isNot = false;
    var lastTokenIndexOfLeft = context.sourceTokens.indexOfTokenEndingAtSourceIndex(left.end);
    var firstTokenIndexOfRight = context.sourceTokens.indexOfTokenStartingAtSourceIndex(right.start);
    var relationTokenIndex = context.sourceTokens.indexOfTokenMatchingPredicate(function (token) {
        return token.type === SourceType.RELATION;
    }, lastTokenIndexOfLeft, firstTokenIndexOfRight);
    if (relationTokenIndex) {
        var relationToken = context.sourceTokens.tokenAtIndex(relationTokenIndex);
        if (relationToken) {
            isNot = context.source.slice(relationToken.start, relationToken.end) !== 'in';
            return new InOp(line, column, start, end, raw, left, right, isNot);
        }
    }
    throw new Error("unable to find RELATION token between operands");
}

/**
 * Determine if the given code position contains a real string. If not, then it
 * is an interpolated string quasi.
 */
function isStringAtPosition(start, end, context) {
    var tokens = context.sourceTokens;
    var startTokenIndex = tokens.indexOfTokenContainingSourceIndex(start);
    var endTokenIndex = tokens.indexOfTokenContainingSourceIndex(end - 1);
    if (startTokenIndex === null || endTokenIndex === null) {
        return false;
    }
    var startToken = tokens.tokenAtIndex(startTokenIndex);
    var endToken = tokens.tokenAtIndex(endTokenIndex);
    if (startToken === null || endToken === null) {
        return false;
    }
    var startType = startToken.type;
    var endType = endToken.type;
    return startType === lex.SourceType.SSTRING_START && endType === lex.SourceType.SSTRING_END || startType === lex.SourceType.DSTRING_START && endType === lex.SourceType.DSTRING_END || startType === lex.SourceType.TSSTRING_START && endType === lex.SourceType.TSSTRING_END || startType === lex.SourceType.TDSTRING_START && endType === lex.SourceType.TDSTRING_END;
}

/**
 * Parses JavaScript source representing a number.
 */
function parseNumber(string) {
  return babylon.parse("(" + string + ")").program.body[0].expression.value;
}

/**
 * Parses JavaScript source representing a regular expression.
 */
function parseRegExp(string) {
  return babylon.parse("(" + string + ")").program.body[0].expression;
}

/**
 * Parses JavaScript source representing a string.
 */
function parseString(string) {
  return babylon.parse("(" + string + ")").program.body[0].expression.value;
}

var HEREGEX_PATTERN = /^\/\/\/((?:.|\s)*)\/\/\/([gimy]*)$/;
function mapLiteral(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    if (node.value === 'this') {
        return new This(line, column, start, end, raw);
    }
    var startTokenIndex = context.sourceTokens.indexOfTokenContainingSourceIndex(start);
    var lastTokenIndex = context.sourceTokens.indexOfTokenContainingSourceIndex(end - 1);
    if (!startTokenIndex || !lastTokenIndex) {
        throw new Error("cannot find start/end tokens for literal: " + util.inspect(node));
    }
    var startToken = context.sourceTokens.tokenAtIndex(startTokenIndex);
    var lastToken = context.sourceTokens.tokenAtIndex(lastTokenIndex);
    if (!startToken || !lastToken) {
        throw new Error("cannot find start/end tokens for literal: " + util.inspect(node));
    }
    if (startToken.type === SourceType.IDENTIFIER) {
        // Sometimes the CoffeeScript AST contains a string object instead of a
        // string primitive. Convert to string primitive if necessary.
        var value = node.value.valueOf();
        return new Identifier(line, column, start, end, raw, value);
    }
    if (startToken.type === SourceType.JS) {
        return new JavaScript(line, column, start, end, raw, node.value);
    }
    if (startToken.type === SourceType.NUMBER) {
        if (raw.includes('.')) {
            return new Float(line, column, start, end, raw, parseNumber(node.value));
        } else {
            return new Int(line, column, start, end, raw, parseNumber(node.value));
        }
    }
    if (startToken.type === SourceType.REGEXP) {
        var regExp = parseRegExp(node.value);
        return new Regex(line, column, start, end, raw, regExp.pattern, RegexFlags.parse(regExp.flags));
    }
    if (isStringAtPosition(start, end, context)) {
        return new String(line, column, start, end, raw, [new Quasi(line, column, start, end, raw, parseString(node.value))], []);
    }
    if (startToken.type === SourceType.HEREGEXP_START && lastToken.type === SourceType.HEREGEXP_END) {
        var match = raw.match(HEREGEX_PATTERN);
        if (!match) {
            throw new Error("unable to parse flags of heregex: " + util.inspect(node));
        }
        var flags = match[2];
        return new Heregex(line, column, start, end, raw, [new Quasi(line, column, start, end, raw, node.value)], [], RegexFlags.parse(flags));
    }
    if (startToken.type === SourceType.SSTRING_START || startToken.type === SourceType.DSTRING_START || startToken.type === SourceType.TSSTRING_START || startToken.type === SourceType.TDSTRING_START || startToken.type === SourceType.HEREGEXP_START || startToken.type === SourceType.STRING_CONTENT || startToken.type === SourceType.STRING_PADDING || startToken.type === SourceType.STRING_LINE_SEPARATOR) {
        // Top-level strings should all be in the same format: an array of
        // quasis and expressions. For a normal string literal, this is the
        // simple case of one quasi and no expressions. But if this string
        // is actually a quasi that CoffeeScript is calling a string, then
        // just return a Quasi node, and higher-up code should insert it
        // into a string interpolation.
        return new Quasi(line, column, start, end, raw, parseString(node.value));
    }
    if (startToken.type === SourceType.BREAK) {
        return new Break(line, column, start, end, raw);
    }
    if (startToken.type === SourceType.CONTINUE) {
        return new Continue(line, column, start, end, raw);
    }
    // Fall back to identifiers.
    return new Identifier(line, column, start, end, raw, node.value);
}

function mapNull(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    return new Null$1(line, column, start, end, raw);
}

function mapValue(context, node) {
    var base = mapBase(context, node);
    return node.properties.reduce(function (reduced, property) {
        return propertyReducer(context, base, reduced, property);
    }, mapAny(context, node.base));
}
function propertyReducer(context, base, reduced, property) {
    if (property instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Access) {
        var name = property.name;
        if (!(name instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Literal)) {
            throw new Error("unexpected non-Literal property access name: " + util.inspect(name));
        }
        var startTokenIndex = tokenIndexAtLocation(context, property.locationData);
        var startToken = startTokenIndex && context.sourceTokens.tokenAtIndex(startTokenIndex);
        if (startToken && property.soak) {
            if (startToken.type !== lex.SourceType.EXISTENCE) {
                throw new Error("expected EXISTENCE token ('?') but got " + lex.SourceType[startToken.type] + ": " + util.inspect(startToken));
            }
            startTokenIndex = startTokenIndex && startTokenIndex.next();
            startToken = startTokenIndex && context.sourceTokens.tokenAtIndex(startTokenIndex);
        }
        if (!startToken) {
            throw new Error("cannot find token at start of property: " + util.inspect(property));
        }
        var last = context.linesAndColumns.indexForLocation({
            line: property.locationData.last_line,
            column: property.locationData.last_column
        });
        if (last === null) {
            throw new Error("cannot find offset of last character of property: " + util.inspect(property));
        }
        var isPrototypeAccess = startToken.type === lex.SourceType.PROTO;
        if (isPrototypeAccess) {
            var AccessOp$$1 = property.soak ? SoakedProtoMemberAccessOp : ProtoMemberAccessOp;
            return new AccessOp$$1(base.line, base.column, base.start, last + 1, context.source.slice(base.start, last + 1), reduced);
        } else {
            var member = mapAny(context, name);
            if (!(member instanceof Identifier)) {
                throw new Error("unexpected non-Identifier access member: " + util.inspect(member));
            }
            var AccessOp$$1 = property.soak ? SoakedMemberAccessOp : MemberAccessOp;
            return new AccessOp$$1(base.line, base.column, base.start, last + 1, context.source.slice(base.start, last + 1), reduced, member);
        }
    } else if (property instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Slice) {
        var last = context.linesAndColumns.indexForLocation({
            line: property.locationData.last_line,
            column: property.locationData.last_column
        });
        if (last === null) {
            throw new Error("cannot find offset of last character of slice: " + util.inspect(property));
        }
        var SliceClass = property.soak ? SoakedSlice : Slice$1;
        return new SliceClass(base.line, base.column, base.start, last + 1, context.source.slice(base.start, last + 1), reduced, property.range.from ? mapAny(context, property.range.from) : null, property.range.to ? mapAny(context, property.range.to) : null, !property.range.exclusive);
    } else {
        throw new UnsupportedNodeError(property);
    }
}
function tokenIndexAtLocation(context, location) {
    var start = context.linesAndColumns.indexForLocation({
        line: location.first_line,
        column: location.first_column
    });
    if (start === null) {
        return null;
    }
    return context.sourceTokens.indexOfTokenContainingSourceIndex(start);
}

function mapObj(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    var members = node.properties.map(function (property) {
        if (property instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Value) {
            // shorthand property
            var value = mapValue(context, property);
            if (!(value instanceof Identifier)) {
                throw new UnsupportedNodeError(property);
            }
            return new ObjectInitialiserMember(value.line, value.column, value.start, value.end, value.raw, value, value);
        } else if (property instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Assign && property.context === 'object') {
            var _a = mapBase(context, property),
                line_1 = _a.line,
                column_1 = _a.column,
                start_1 = _a.start,
                end_1 = _a.end,
                raw_1 = _a.raw;
            var key = mapAny(context, property.variable);
            var expression = mapAny(context, property.value);
            if (!(key instanceof Identifier) && !(key instanceof String)) {
                throw new UnsupportedNodeError(property);
            }
            return new ObjectInitialiserMember(line_1, column_1, start_1, end_1, raw_1, key, expression);
        } else {
            throw new UnsupportedNodeError(property);
        }
    });
    return new ObjectInitialiser(line, column, start, end, raw, members);
}

function mapOp(context, node) {
    if (isChainedComparison(node)) {
        return mapChainedComparisonOp(context, node);
    } else {
        return mapOpWithoutChainedComparison(context, node);
    }
}
function mapChainedComparisonOp(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    var coffeeOperands = unwindChainedComparison(node);
    var operands = coffeeOperands.map(function (operand) {
        return mapAny(context, operand);
    });
    var operators = [];
    for (var i = 0; i < operands.length - 1; i++) {
        var left = operands[i];
        var right = operands[i + 1];
        operators.push(getOperatorInfoInRange(context, left.end - 1, right.start));
    }
    return new ChainedComparisonOp(line, column, start, end, raw, operands, operators);
}
function mapOpWithoutChainedComparison(context, node) {
    switch (node.operator) {
        case '===':
            return mapBinaryOp(context, node, EQOp);
        case '!==':
            return mapBinaryOp(context, node, NEQOp);
        case '!':
            return mapUnaryOp(context, node, LogicalNotOp);
        case '+':
            return mapPlusOp(context, node);
        case '-':
            return mapBinaryOrUnaryOp(context, node, SubtractOp, UnaryNegateOp);
        case '&&':
            return mapBinaryOp(context, node, LogicalAndOp);
        case '||':
            return mapBinaryOp(context, node, LogicalOrOp);
        case '*':
            return mapBinaryOp(context, node, MultiplyOp);
        case '/':
            return mapBinaryOp(context, node, DivideOp);
        case '<':
            return mapBinaryOp(context, node, LTOp);
        case '<=':
            return mapBinaryOp(context, node, LTEOp);
        case '>':
            return mapBinaryOp(context, node, GTOp);
        case '>=':
            return mapBinaryOp(context, node, GTEOp);
        case '++':
            return mapUnaryOp(context, node, node.flip ? PostIncrementOp : PreIncrementOp);
        case '--':
            return mapUnaryOp(context, node, node.flip ? PostDecrementOp : PreDecrementOp);
        case 'typeof':
            return mapUnaryOp(context, node, TypeofOp);
        case 'instanceof':
            return mapNegateableBinaryOp(context, node, InstanceofOp);
        case 'delete':
            return mapUnaryOp(context, node, DeleteOp);
        case 'in':
            return mapNegateableBinaryOp(context, node, OfOp);
        case 'new':
            return mapNewOp$1(context, node);
        case '**':
            return mapBinaryOp(context, node, ExpOp);
        case '%':
            return mapBinaryOp(context, node, RemOp);
        case '%%':
            return mapBinaryOp(context, node, ModuloOp);
        case '&':
            return mapBinaryOp(context, node, BitAndOp);
        case '|':
            return mapBinaryOp(context, node, BitOrOp);
        case '^':
            return mapBinaryOp(context, node, BitXorOp);
        case '<<':
            return mapBinaryOp(context, node, LeftShiftOp);
        case '>>':
            return mapBinaryOp(context, node, SignedRightShiftOp);
        case '>>>':
            return mapBinaryOp(context, node, UnsignedRightShiftOp);
        case '~':
            return mapUnaryOp(context, node, BitNotOp);
        case 'yield':
            return mapYieldOp(context, node);
        case 'yield*':
            return mapUnaryOp(context, node, YieldFrom);
    }
    throw new UnsupportedNodeError(node);
}
function mapPlusOp(context, node) {
    if (node.second) {
        // TODO: string interpolations and binary addition
        throw new UnsupportedNodeError(node);
    }
    return mapUnaryOp(context, node, UnaryPlusOp);
}
function mapNewOp$1(context, node) {
    if (node.second) {
        throw new Error("unexpected 'new' operator with multiple operands: " + util.inspect(node));
    }
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    return new NewOp(line, column, start, end, raw, mapAny(context, node.first), []);
}
function mapYieldOp(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    if (node.first instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Return) {
        var expression = node.first.expression;
        return new YieldReturn(line, column, start, end, raw, expression ? mapAny(context, expression) : null);
    } else {
        return new Yield(line, column, start, end, raw, mapAny(context, node.first));
    }
}
function mapBinaryOp(context, node, Op$$1) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    if (!node.second) {
        throw new Error("unexpected '" + node.operator + "' operator with only one operand: " + util.inspect(node));
    }
    return new Op$$1(line, column, start, end, raw, mapAny(context, node.first), mapAny(context, node.second));
}
function mapUnaryOp(context, node, Op$$1) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    if (node.second) {
        throw new Error("unexpected '" + node.operator + "' operator with two operands: " + util.inspect(node));
    }
    return new Op$$1(line, column, start, end, raw, mapAny(context, node.first));
}
function mapBinaryOrUnaryOp(context, node, BinaryOp$$1, UnaryOp$$1) {
    if (node.second) {
        return mapBinaryOp(context, node, BinaryOp$$1);
    } else {
        return mapUnaryOp(context, node, UnaryOp$$1);
    }
}
/**
 * This class exists only to serve as a temporary binary operator, do not use.
 */
var TemporaryBinaryOp = function (_super) {
    __extends(TemporaryBinaryOp, _super);
    function TemporaryBinaryOp(line, column, start, end, raw, left, right) {
        return _super.call(this, 'TEMPORARY', line, column, start, end, raw, left, right) || this;
    }
    return TemporaryBinaryOp;
}(BinaryOp);
function mapNegateableBinaryOp(context, node, Op$$1) {
    var _a = mapBinaryOp(context, node, TemporaryBinaryOp),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw,
        left = _a.left,
        right = _a.right;
    var lastTokenIndexOfLeft = context.sourceTokens.indexOfTokenEndingAtSourceIndex(left.end);
    var firstTokenIndexOfRight = context.sourceTokens.indexOfTokenStartingAtSourceIndex(right.start);
    var isNot = false;
    if (lastTokenIndexOfLeft) {
        for (var i = lastTokenIndexOfLeft.next(); i && i !== firstTokenIndexOfRight; i = i.next()) {
            var token = context.sourceTokens.tokenAtIndex(i);
            if (token && (token.type === lex.SourceType.OPERATOR || token.type === lex.SourceType.RELATION)) {
                isNot = context.source.slice(token.start, token.start + 'not'.length) === 'not';
                break;
            }
        }
    }
    return new Op$$1(line, column, start, end, raw, left, right, isNot);
}

function mapParam(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    var param = mapAny(context, node.name);
    if (node.value) {
        var value = mapAny(context, node.value);
        return new DefaultParam(line, column, start, end, raw, param, value);
    }
    if (node.splat) {
        return new Rest(line, column, start, end, raw, param);
    }
    return param;
}

function mapParens(context, node) {
    if (!(node.body instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Block)) {
        return mapAny(context, node.body);
    }
    var expressions = node.body.expressions;
    if (expressions.length === 1) {
        return mapAny(context, expressions[0]);
    }
    return expressions.map(function (expression) {
        return mapAny(context, expression);
    }).reduceRight(function (right, left) {
        return new SeqOp(left.line, left.column, left.start, right.end, context.source.slice(left.start, right.end), left, right);
    });
}

function mapRange(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    if (!node.from || !node.to) {
        throw new Error("'from' or 'to' unexpectedly missing: " + util.inspect(node));
    }
    return new Range$1(line, column, start, end, raw, mapAny(context, node.from), mapAny(context, node.to), !node.exclusive);
}

function mapReturn(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    var argument = node.expression ? mapAny(context, node.expression) : null;
    return new Return$1(line, column, start, end, raw, argument);
}

function mapSplat(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    return new Spread(line, column, start, end, raw, mapAny(context, node.name));
}

function mapSwitch(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    var expression = node.subject ? mapAny(context, node.subject) : null;
    var cases = node.cases.map(function (_a) {
        var conditions = _a[0],
            body = _a[1];
        if (!Array.isArray(conditions)) {
            conditions = [conditions];
        }
        var switchConditions = conditions.map(function (condition) {
            return mapAny(context, condition);
        });
        var consequent = mapBlock(context, body);
        var whenToken = getWhenTokenBeforeOffset(context, switchConditions[0].start, start);
        var locationForIndex = context.linesAndColumns.locationForIndex(whenToken.start);
        if (!locationForIndex) {
            throw new Error("cannot map WHEN token start to line/column: " + whenToken.start);
        }
        var caseLine = locationForIndex.line,
            caseColumn = locationForIndex.column;
        return new SwitchCase(caseLine + 1, caseColumn + 1, whenToken.start, consequent.end, context.source.slice(whenToken.start, consequent.end), switchConditions, consequent);
    });
    return new Switch$1(line, column, start, end, raw, expression, cases, node.otherwise ? mapBlock(context, node.otherwise) : null);
}
function getWhenTokenBeforeOffset(context, offset, lowerBound) {
    var offsetTokenIndex = context.sourceTokens.indexOfTokenNearSourceIndex(offset);
    var lowerBoundTokenIndex = context.sourceTokens.indexOfTokenNearSourceIndex(lowerBound);
    var whenTokenIndex = context.sourceTokens.lastIndexOfTokenMatchingPredicate(function (token) {
        return token.type === SourceType.WHEN;
    }, offsetTokenIndex, lowerBoundTokenIndex);
    if (whenTokenIndex) {
        var whenToken = context.sourceTokens.tokenAtIndex(whenTokenIndex);
        if (whenToken) {
            return whenToken;
        }
    }
    throw new Error("unable to find WHEN token before " + offset + " (lower bound: " + lowerBound + ")");
}

function mapThrow(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    var expression = node.expression ? mapAny(context, node.expression) : null;
    return new Throw$1(line, column, start, end, raw, expression);
}

function mapTry(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    return new Try$1(line, column, start, end, raw, node.attempt ? mapAny(context, node.attempt) : null, node.errorVariable ? mapAny(context, node.errorVariable) : null, node.recovery ? mapAny(context, node.recovery) : null, node.ensure ? mapAny(context, node.ensure) : null);
}

function mapUndefined(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    return new Undefined$1(line, column, start, end, raw);
}

function mapWhile(context, node) {
    var _a = mapBase(context, node),
        line = _a.line,
        column = _a.column,
        start = _a.start,
        end = _a.end,
        raw = _a.raw;
    var startTokenIndex = context.sourceTokens.indexOfTokenStartingAtSourceIndex(start);
    var startToken = startTokenIndex && context.sourceTokens.tokenAtIndex(startTokenIndex);
    if (startToken && startToken.type === lex.SourceType.LOOP) {
        return new Loop(line, column, start, end, raw, node.body ? mapAny(context, node.body) : null);
    }
    return new While$1(line, column, start, end, raw, mapAny(context, node.condition), node.guard ? mapAny(context, node.guard) : null, node.body ? mapAny(context, node.body) : null, node.condition.inverted === true);
}

function mapAny(context, node) {
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Value) {
        return mapValue(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Literal) {
        return mapLiteral(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Op) {
        return mapOp(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Call) {
        return mapCall(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Arr) {
        return mapArr(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Bool) {
        return mapBool(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Assign) {
        return mapAssign(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Param) {
        return mapParam(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Return) {
        return mapReturn(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.If) {
        return mapIf(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Null) {
        return mapNull(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Obj) {
        return mapObj(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Parens) {
        return mapParens(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.For) {
        return mapFor(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Throw) {
        return mapThrow(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Undefined) {
        return mapUndefined(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Block) {
        return mapBlock(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Code) {
        return mapCode(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.While && !(node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.For)) {
        return mapWhile(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Try) {
        return mapTry(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Existence) {
        return mapExistence(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Class) {
        return mapClass(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Splat) {
        return mapSplat(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Switch) {
        return mapSwitch(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.In) {
        return mapIn(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Range) {
        return mapRange(context, node);
    }
    if (node instanceof decaffeinateCoffeescript_lib_coffeeScript_nodes.Extends) {
        return mapExtends(context, node);
    }
    throw new UnsupportedNodeError(node);
}

function rangeOfBracketTokensForIndexNode(context, indexNode) {
    var start = context.linesAndColumns.indexForLocation({
        line: indexNode.locationData.first_line,
        column: indexNode.locationData.first_column
    });
    if (start !== null) {
        var startTokenIndex = context.sourceTokens.indexOfTokenStartingAtSourceIndex(start);
        if (startTokenIndex !== null) {
            var range = context.sourceTokens.rangeOfMatchingTokensContainingTokenIndex(lex.SourceType.LBRACKET, lex.SourceType.RBRACKET, startTokenIndex);
            if (range !== null) {
                return range;
            }
        }
    }
    throw new Error("cannot find braces surrounding index at " + (indexNode.locationData.first_line + 1 + ":" + indexNode.locationData.first_column + ": ") + ("" + util.inspect(indexNode)));
}

// tslint:disable-next-line:no-any
// tslint:disable-next-line:no-any
function type(node) {
    return node.constructor.name;
}

function patchCoffeeScript() {
    decaffeinateCoffeescript_lib_coffeeScript_nodes.Op.prototype.invert = invert;
    decaffeinateCoffeescript_lib_coffeeScript_nodes.Base.prototype.invert = invert;
}
function invert() {
    this.inverted = !this.inverted;
    return this;
}

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

function parse$1(source) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$useFallback = _ref.useFallback,
      useFallback = _ref$useFallback === undefined ? true : _ref$useFallback,
      _ref$useMappers = _ref.useMappers,
      useMappers = _ref$useMappers === undefined ? true : _ref$useMappers;

  patchCoffeeScript();

  var context = ParseContext.fromSource(source, lex__default, CoffeeScript.nodes);

  var ast = context.ast;
  if (type(ast) === 'Block' && ast.expressions.every(function (e) {
    return type(e) === 'Comment';
  })) {
    var program = {
      type: 'Program',
      line: 1,
      column: 1,
      raw: source,
      range: [0, 0],
      body: null
    };

    Object.defineProperty(program, 'context', { value: context });
    return program;
  }

  return convert(context, useMappers ?
  // Use mappers, with or without fallback.
  useFallback ? mapAnyWithFallback : mapAny :
  // No mappers, use only the fallback.
  function (context, node, fallback) {
    return fallback();
  });
}

function convert(context, map) {
  var source = context.source,
      linesAndColumns = context.linesAndColumns;

  fixLocations(context.ast);
  return convertNode(context.ast);

  /**
   * @param {Object} node
   * @param ancestors
   */
  function fixLocations(node) {
    var ancestors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    node.eachChild(function (child) {
      if (child && child.locationData) {
        fixLocations(child, [node].concat(toConsumableArray(ancestors)));
      }
    });

    node.locationData = fixInvalidLocationData(node.locationData, context.linesAndColumns);

    switch (type(node)) {
      case 'Value':
        {
          var lastChild = node.properties[node.properties.length - 1];
          if (lastChild) {
            node.locationData = locationWithLastPosition(node.locationData, lastChild.locationData);
          }
          break;
        }

      case 'Index':
      case 'Slice':
        {
          var rangeOfBrackets = rangeOfBracketTokensForIndexNode(context, node);
          var lbracket = context.sourceTokens.tokenAtIndex(rangeOfBrackets[0]);
          var lbracketLoc = linesAndColumns.locationForIndex(lbracket.start);
          var rbracket = context.sourceTokens.tokenAtIndex(rangeOfBrackets[1].previous());
          var rbracketLoc = linesAndColumns.locationForIndex(rbracket.start);
          node.locationData = {
            first_line: lbracketLoc.line,
            first_column: lbracketLoc.column,
            last_line: rbracketLoc.line,
            last_column: rbracketLoc.column
          };
          break;
        }

      case 'Access':
      case 'Arr':
      case 'Bool':
      case 'Comment':
      case 'Existence':
      case 'Expansion':
      case 'Literal':
      case 'Null':
      case 'Parens':
      case 'Range':
      case 'Return':
      case 'Splat':
      case 'Throw':
      case 'Undefined':
        break;

      case 'Obj':
        {
          var loc = node.locationData;
          var start = linesAndColumns.indexForLocation({ line: loc.first_line, column: loc.first_column });
          var isImplicitObject = source[start] !== '{';
          if (isImplicitObject) {
            var _lastChild = node.properties[node.properties.length - 1];
            node.locationData = locationWithLastPosition(node.locationData, _lastChild.locationData);
          }
          break;
        }

      case 'Op':
        {
          var _lastChild2 = node.second;
          if (_lastChild2) {
            node.locationData = locationWithLastPosition(node.locationData, _lastChild2.locationData);
          }
          break;
        }

      case 'Assign':
        {
          var _lastChild3 = node.value;
          node.locationData = locationWithLastPosition(node.locationData, _lastChild3.locationData);
          break;
        }

      case 'In':
        {
          var _lastChild4 = node.array;
          node.locationData = locationWithLastPosition(node.locationData, _lastChild4.locationData);
          break;
        }

      case 'Call':
        {
          if (node.variable && !node.do) {
            // `super` won't have a callee (i.e. `node.variable`)
            var calleeLoc = node.variable.locationData;
            var calleeEnd = linesAndColumns.indexForLocation({ line: calleeLoc.last_line, column: calleeLoc.last_column }) + 1;
            // Account for soaked calls, e.g. `a?()`.
            if (source[calleeEnd] === '?') {
              calleeEnd += 1;
            }
            var isImplicitCall = source[calleeEnd] !== '(';
            if (isImplicitCall) {
              var _lastChild5 = node.args[node.args.length - 1] || node.variable;
              if (_lastChild5) {
                node.locationData = locationWithLastPosition(node.locationData, _lastChild5.locationData);
              }
            }
          }
          break;
        }

      case 'Block':
        {
          var _lastChild6 = node.expressions[node.expressions.length - 1];
          if (_lastChild6) {
            node.locationData = locationWithLastPosition(node.locationData, _lastChild6.locationData);
          }
          break;
        }

      case 'If':
        {
          var _lastChild7 = node.elseBody || node.body;
          node.locationData = mergeLocations(node.locationData, _lastChild7.locationData);
          break;
        }

      case 'For':
      case 'While':
        {
          var _lastChild8 = node.body;
          node.locationData = mergeLocations(node.locationData, _lastChild8.locationData);
          break;
        }

      case 'Param':
        {
          if (!node.splat) {
            var _lastChild9 = node.value || node.name;
            node.locationData = locationWithLastPosition(node.locationData, _lastChild9.locationData);
          }
          break;
        }

      case 'Code':
        {
          if (node.body) {
            node.locationData = locationWithLastPosition(node.locationData, node.body.locationData);
          }
          break;
        }

      case 'Class':
        {
          var _lastChild10 = node.body;
          node.locationData = locationWithLastPosition(node.locationData, _lastChild10.locationData);
          break;
        }

      case 'Switch':
        {
          var _lastChild11 = node.otherwise || node.cases[node.cases.length - 1][1];
          node.locationData = locationWithLastPosition(node.locationData, _lastChild11.locationData);
          break;
        }

      case 'Try':
        {
          var _lastChild12 = node.ensure || node.recovery || node.errorVariable || node.attempt;
          node.locationData = locationWithLastPosition(node.locationData, _lastChild12.locationData);
          break;
        }

      case 'Extends':
        {
          var _lastChild13 = node.parent;
          node.locationData = locationWithLastPosition(node.locationData, _lastChild13.locationData);
          break;
        }

      default:
        throw new Error('cannot fix location data for ' + type(node) + ' at ' + (node.locationData.first_line + 1 + ':' + (node.locationData.first_column + 1) + ': ') + util.inspect(node));
    }
  }

  /**
   * @param {Object} node
   * @param ancestors
   * @returns {Node}
   */
  function convertNode(node) {
    var ancestors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    if (ancestors.length === 0) {
      var programNode = {
        type: 'Program',
        line: 1,
        column: 1,
        range: [0, source.length],
        raw: source,
        body: makeNode(context, 'Block', node.locationData, {
          statements: convertChild(node.expressions)
        })
      };
      Object.defineProperty(programNode, 'context', {
        value: context,
        enumerable: false
      });
      return programNode;
    }

    switch (type(node)) {
      case 'Value':
        {
          return map(context, node, function () {
            var value = convertChild(node.base);
            node.properties.forEach(function (prop) {
              value = accessOpForProperty(value, prop, node.base.locationData);
              if (value.type === 'MemberAccessOp' && value.expression.type === 'MemberAccessOp') {
                if (value.expression.member.data === 'prototype' && value.expression.raw.slice(-2) === '::') {
                  value.expression.type = 'ProtoMemberAccessOp';
                }
              }
            });
            return value;
          });
        }

      case 'Call':
        return map(context, node, function () {
          if (isHeregexTemplateNode(node, context)) {
            var firstArgOp = convertOperator(node.args[0].base.body.expressions[0]);
            var heregexResult = createTemplateLiteral(firstArgOp, 'Heregex');
            var flags = void 0;
            if (node.args.length > 1) {
              flags = parseString(node.args[1].base.value);
            } else {
              flags = '';
            }
            heregexResult.flags = RegexFlags.parse(flags);
            return heregexResult;
          }

          if (node.isNew) {
            return makeNode(context, node.soak ? 'SoakedNewOp' : 'NewOp', node.locationData, {
              ctor: convertChild(node.variable),
              arguments: convertChild(node.args)
            });
          } else if (node.isSuper) {
            if (node.args.length === 1 && type(node.args[0]) === 'Splat' && locationsEqual(node.args[0].locationData, node.locationData)) {
              // Virtual splat argument.
              return makeNode(context, 'BareSuperFunctionApplication', node.locationData);
            }
            var superLocationData = {
              first_line: node.locationData.first_line,
              first_column: node.locationData.first_column,
              last_line: node.locationData.first_line,
              last_column: node.locationData.first_column + 'super'.length - 1
            };
            return makeNode(context, 'FunctionApplication', node.locationData, {
              function: makeNode(context, 'Super', superLocationData),
              arguments: convertChild(node.args)
            });
          } else {
            var result = makeNode(context, node.soak ? 'SoakedFunctionApplication' : 'FunctionApplication', node.locationData, {
              function: convertChild(node.variable),
              arguments: convertChild(node.args)
            });

            if (node.do) {
              result.type = 'DoOp';
              result.expression = result.function;

              // The argument to `do` may not always be a function literal.
              if (result.expression.parameters) {
                augmentDoFunctionWithArgs(node, result, result.expression, node.variable);
              } else if (result.expression.type === 'AssignOp' && result.expression.expression.parameters) {
                augmentDoFunctionWithArgs(node, result, result.expression.expression, node.variable.value);
              }
              delete result.function;
              delete result.arguments;
            }

            return result;
          }
        });

      case 'Op':
        {
          return map(context, node, function () {
            var op = convertOperator(node);
            if (isImplicitPlusOp(op, context) && isInterpolatedString(node, ancestors, context)) {
              return createTemplateLiteral(op, 'String');
            }
            if (isChainedComparison(node)) {
              var operands = unwindChainedComparison(node).map(convertChild);
              var operators = [];

              for (var i = 0; i < operands.length - 1; i++) {
                var left = operands[i];
                var right = operands[i + 1];

                operators.push(getOperatorInfoInRange(context, left.range[1] - 1, right.range[0]));
              }

              return makeNode(context, 'ChainedComparisonOp', node.locationData, {
                operands: operands,
                operators: operators
              });
            }
            return op;
          });
        }

      case 'Assign':
        return map(context, node, function () {
          if (node.context === 'object') {
            return makeNode(context, 'ObjectInitialiserMember', node.locationData, {
              key: convertChild(node.variable),
              expression: convertChild(node.value)
            });
          } else if (node.context && node.context.slice(-1) === '=') {
            return makeNode(context, 'CompoundAssignOp', node.locationData, {
              assignee: convertChild(node.variable),
              expression: convertChild(node.value),
              op: binaryOperatorNodeType(node.context.slice(0, -1))
            });
          } else {
            return makeNode(context, 'AssignOp', node.locationData, {
              assignee: convertChild(node.variable),
              expression: convertChild(node.value)
            });
          }
        });

      case 'Obj':
        return map(context, node, function () {
          return makeNode(context, 'ObjectInitialiser', node.locationData, {
            members: node.properties.map(function (property) {
              if (type(property) === 'Value') {
                // shorthand property
                var keyValue = convertChild(property);
                return makeNode(context, 'ObjectInitialiserMember', property.locationData, {
                  key: keyValue,
                  expression: keyValue
                });
              }

              return convertChild(property);
            }).filter(function (node) {
              return node;
            })
          });
        });

      case 'Arr':
        return map(context, node, function () {
          return makeNode(context, 'ArrayInitialiser', node.locationData, {
            members: convertChild(node.objects)
          });
        });

      case 'Parens':
        return map(context, node, function () {
          if (type(node.body) === 'Block') {
            var expressions = node.body.expressions;
            if (expressions.length === 1) {
              return convertChild(expressions[0]);
            } else {
              var lastExpression = expressions[expressions.length - 1];
              var result = convertChild(lastExpression);
              for (var i = expressions.length - 2; i >= 0; i--) {
                var left = expressions[i];
                result = makeNode(context, 'SeqOp', locationContainingNodes(left, lastExpression), {
                  left: convertChild(left),
                  right: result
                });
              }
              return result;
            }
          } else {
            return convertChild(node.body);
          }
        });

      case 'If':
        {
          return map(context, node, function () {
            var condition = convertChild(node.condition);
            var consequent = convertChild(node.body);
            var alternate = convertChild(node.elseBody);
            var isUnless = false;

            if (consequent && consequent.range[0] < condition.range[0]) {
              // POST-if, so look for tokens between the consequent and the condition
              consequent.inline = true;
              var lastConsequentTokenIndex = context.sourceTokens.indexOfTokenEndingAtSourceIndex(consequent.range[1]);
              var firstConditionTokenIndex = context.sourceTokens.indexOfTokenStartingAtSourceIndex(condition.range[0]);

              for (var i = lastConsequentTokenIndex; i !== firstConditionTokenIndex; i = i.next()) {
                var token = context.sourceTokens.tokenAtIndex(i);
                if (token.type === lex.SourceType.IF) {
                  isUnless = source.slice(token.start, token.end) === 'unless';
                  break;
                }
              }
            } else {
              // Regular `if`, so look at the start of the node.
              var _firstConditionTokenIndex = context.sourceTokens.indexOfTokenStartingAtSourceIndex(condition.range[0]);

              for (var _i = _firstConditionTokenIndex; _i !== null; _i = _i.previous()) {
                var _token = context.sourceTokens.tokenAtIndex(_i);
                if (_token.type === lex.SourceType.IF) {
                  isUnless = source.slice(_token.start, _token.end) === 'unless';
                  break;
                }
              }
            }

            return makeNode(context, 'Conditional', node.locationData, {
              isUnless: isUnless,
              condition: condition,
              consequent: consequent,
              alternate: alternate
            });
          });
        }

      case 'Code':
        {
          return map(context, node, function () {
            var fnType = void 0;
            if (node.bound) {
              if (node.isGenerator) {
                fnType = 'BoundGeneratorFunction';
              } else {
                fnType = 'BoundFunction';
              }
            } else {
              if (node.isGenerator) {
                fnType = 'GeneratorFunction';
              } else {
                fnType = 'Function';
              }
            }
            return makeNode(context, fnType, node.locationData, {
              body: convertChild(node.body),
              parameters: convertChild(node.params)
            });
          });
        }

      case 'Param':
        {
          return map(context, node, function () {
            var param = convertChild(node.name);
            if (node.value) {
              return makeNode(context, 'DefaultParam', node.locationData, {
                default: convertChild(node.value),
                param: param
              });
            }
            if (node.splat) {
              return makeNode(context, 'Rest', node.locationData, {
                expression: param
              });
            }
            return param;
          });
        }

      case 'Block':
        return map(context, node, function () {
          if (node.expressions.length === 0) {
            return null;
          } else {
            var block = makeNode(context, 'Block', node.locationData, {
              statements: convertChild(node.expressions)
            });

            var previousTokenIndex = context.sourceTokens.indexOfTokenNearSourceIndex(block.range[0] - 1);
            var previousToken = previousTokenIndex ? context.sourceTokens.tokenAtIndex(previousTokenIndex) : null;
            block.inline = previousToken ? previousToken.type !== lex.SourceType.NEWLINE : false;

            return block;
          }
        });

      case 'Return':
        return map(context, node, function () {
          return makeNode(context, 'Return', node.locationData, {
            expression: node.expression ? convertChild(node.expression) : null
          });
        });

      case 'For':
        return map(context, node, function () {
          if (locationsEqual(node.body.locationData, node.locationData)) {
            node.body.locationData = locationContainingNodes.apply(undefined, toConsumableArray(node.body.expressions));
          }
          if (node.object) {
            return makeNode(context, 'ForOf', node.locationData, {
              keyAssignee: convertChild(node.index),
              valAssignee: convertChild(node.name),
              body: convertChild(node.body),
              target: convertChild(node.source),
              filter: convertChild(node.guard),
              isOwn: node.own
            });
          } else {
            return makeNode(context, 'ForIn', node.locationData, {
              keyAssignee: convertChild(node.index),
              valAssignee: convertChild(node.name),
              body: convertChild(node.body),
              target: convertChild(node.source),
              filter: convertChild(node.guard),
              step: convertChild(node.step)
            });
          }
        });

      case 'While':
        {
          return map(context, node, function () {
            var start = linesAndColumns.indexForLocation({ line: node.locationData.first_line, column: node.locationData.first_column });
            var tokens = context.sourceTokens;
            var startTokenIndex = tokens.indexOfTokenContainingSourceIndex(start);
            var startTokenType = tokens.tokenAtIndex(startTokenIndex).type;

            if (startTokenType === lex.SourceType.LOOP) {
              return makeNode(context, 'Loop', locationContainingNodes(node, node.body), {
                body: convertChild(node.body)
              });
            }

            return makeNode(context, 'While', locationContainingNodes(node, node.condition, node.body), {
              condition: convertChild(node.condition),
              guard: convertChild(node.guard),
              body: convertChild(node.body),
              isUntil: node.condition.inverted === true
            });
          });
        }

      case 'Existence':
        return map(context, node, function () {
          return makeNode(context, 'UnaryExistsOp', node.locationData, {
            expression: convertChild(node.expression)
          });
        });

      case 'Class':
        {
          return map(context, node, function () {
            var nameNode = node.variable ? convertChild(node.variable) : null;

            var ctor = null;
            var boundMembers = [];
            var body = !node.body || node.body.expressions.length === 0 ? null : makeNode(context, 'Block', node.body.locationData, {
              statements: node.body.expressions.reduce(function (statements, expr) {
                if (type(expr) === 'Value' && type(expr.base) === 'Obj') {
                  expr.base.properties.forEach(function (property) {
                    var key = void 0;
                    var value = void 0;
                    switch (type(property)) {
                      case 'Value':
                        // shorthand property
                        key = value = convertChild(property);
                        break;

                      case 'Comment':
                        return;

                      default:
                        key = convertChild(property.variable);
                        value = convertChild(property.value);
                        break;
                    }
                    if (key.data === 'constructor') {
                      statements.push(ctor = makeNode(context, 'Constructor', property.locationData, {
                        assignee: key,
                        expression: value
                      }));
                    } else if (key.type === 'MemberAccessOp' && key.expression.type === 'This') {
                      statements.push(makeNode(context, 'AssignOp', property.locationData, {
                        assignee: key,
                        expression: value
                      }));
                    } else {
                      statements.push(makeNode(context, 'ClassProtoAssignOp', property.locationData, {
                        assignee: key,
                        expression: value
                      }));
                    }
                    if (value.type === 'BoundFunction') {
                      boundMembers.push(statements[statements.length - 1]);
                    }
                  });
                } else {
                  statements.push(convertChild(expr));
                }
                return statements;
              }, []),
              inline: false
            });

            return makeNode(context, 'Class', node.locationData, {
              name: nameNode,
              nameAssignee: nameNode,
              body: body,
              boundMembers: boundMembers,
              parent: node.parent ? convertChild(node.parent) : null,
              ctor: ctor
            });
          });
        }

      case 'Switch':
        return map(context, node, function () {
          return makeNode(context, 'Switch', node.locationData, {
            expression: convertChild(node.subject),
            cases: node.cases.map(function (_ref2) {
              var _ref3 = slicedToArray(_ref2, 2),
                  conditions = _ref3[0],
                  body = _ref3[1];

              if (!Array.isArray(conditions)) {
                conditions = [conditions];
              }
              var loc = expandLocationLeftThrough(context, locationContainingNodes(conditions[0], body), 'when ');
              return makeNode(context, 'SwitchCase', loc, {
                conditions: convertChild(conditions),
                consequent: convertChild(body)
              });
            }).filter(function (node) {
              return node;
            }),
            alternate: convertChild(node.otherwise)
          });
        });

      case 'Splat':
        return map(context, node, function () {
          return makeNode(context, 'Spread', node.locationData, {
            expression: convertChild(node.name)
          });
        });

      case 'Throw':
        return map(context, node, function () {
          return makeNode(context, 'Throw', node.locationData, {
            expression: convertChild(node.expression)
          });
        });

      case 'Try':
        return map(context, node, function () {
          return makeNode(context, 'Try', node.locationData, {
            body: convertChild(node.attempt),
            catchAssignee: convertChild(node.errorVariable),
            catchBody: convertChild(node.recovery),
            finallyBody: convertChild(node.ensure)
          });
        });

      case 'Range':
        return map(context, node, function () {
          return makeNode(context, 'Range', node.locationData, {
            left: convertChild(node.from),
            right: convertChild(node.to),
            isInclusive: !node.exclusive
          });
        });

      case 'In':
        {
          return map(context, node, function () {
            // We don't use the `negated` flag on `node` because it gets set to
            // `true` when a parent `If` is an `unless`.
            var left = convertChild(node.object);
            var right = convertChild(node.array);
            var isNot = false;

            var lastTokenIndexOfLeft = context.sourceTokens.indexOfTokenEndingAtSourceIndex(left.range[1]);
            var firstTokenIndexOfRight = context.sourceTokens.indexOfTokenStartingAtSourceIndex(right.range[0]);

            for (var i = lastTokenIndexOfLeft.next(); i !== firstTokenIndexOfRight; i = i.next()) {
              var token = context.sourceTokens.tokenAtIndex(i);
              if (token.type === lex.SourceType.RELATION) {
                isNot = source.slice(token.start, token.end) !== 'in';
              }
            }

            return makeNode(context, 'InOp', node.locationData, {
              left: left,
              right: right,
              isNot: isNot
            });
          });
        }

      case 'Expansion':
        return map(context, node, function () {
          return makeNode(context, 'Expansion', node.locationData);
        });

      case 'Comment':
        return map(context, node, function () {
          return null;
        });

      case 'Extends':
        return map(context, node, function () {
          return makeNode(context, 'ExtendsOp', node.locationData, {
            left: convertChild(node.child),
            right: convertChild(node.parent)
          });
        });

      default:
        // We use `mapAny` here instead of `map` because we removed the
        // fallbacks for terminal node types that had mappers (i.e. Literal),
        // so we use mappers here regardless of whether the options said not to.
        return mapAny(context, node);
    }

    function convertChild(child) {
      if (!child) {
        return null;
      } else if (Array.isArray(child)) {
        return child.map(convertChild).filter(function (node) {
          return node;
        });
      } else {
        return convertNode(child, [].concat(toConsumableArray(ancestors), [node]));
      }
    }

    function createTemplateLiteral(op, nodeType) {
      var tokens = context.sourceTokens;
      var startTokenIndex = tokens.indexOfTokenContainingSourceIndex(op.range[0]);
      var interpolatedStringTokenRange = tokens.rangeOfInterpolatedStringTokensContainingTokenIndex(startTokenIndex);
      if (!interpolatedStringTokenRange) {
        throw new Error('cannot find interpolation end for node');
      }
      var firstToken = tokens.tokenAtIndex(interpolatedStringTokenRange[0]);
      var lastToken = tokens.tokenAtIndex(interpolatedStringTokenRange[1].previous());
      op.type = nodeType;
      op.range = [firstToken.start, lastToken.end];
      op.raw = source.slice.apply(source, toConsumableArray(op.range));

      var elements = [];

      function addElements(_ref4) {
        var left = _ref4.left,
            right = _ref4.right;

        if (isImplicitPlusOp(left, context)) {
          addElements(left);
        } else {
          elements.push(left);
        }
        elements.push(right);
      }
      addElements(op);

      var quasis = [];
      var expressions = [];
      var quote = op.raw.slice(0, 3) === '"""' ? '"""' : '"';

      function findNextToken(position, tokenType) {
        var tokens = context.sourceTokens;
        var startTokenIndex = tokens.indexOfTokenNearSourceIndex(position);
        var tokenIndex = tokens.indexOfTokenMatchingPredicate(function (token) {
          return token.type === tokenType;
        }, startTokenIndex);
        return tokens.tokenAtIndex(tokenIndex);
      }

      function findPrevToken(position, tokenType) {
        var tokens = context.sourceTokens;
        var startTokenIndex = tokens.indexOfTokenNearSourceIndex(position);
        var tokenIndex = tokens.lastIndexOfTokenMatchingPredicate(function (token) {
          return token.type === tokenType;
        }, startTokenIndex);
        return tokens.tokenAtIndex(tokenIndex);
      }

      function buildFirstQuasi() {
        // Find the start of the first interpolation, i.e. "#{a}".
        //                                                  ^
        var interpolationStart = findNextToken(op.range[0], lex.SourceType.INTERPOLATION_START);
        var range = [op.range[0], interpolationStart.start];
        return buildQuasi(range);
      }

      function buildLastQuasi() {
        // Find the close of the last interpolation, i.e. "a#{b}".
        //                                                     ^
        var interpolationEnd = findPrevToken(op.range[1] - 1, lex.SourceType.INTERPOLATION_END);
        return buildQuasi([interpolationEnd.end, op.range[1]]);
      }

      function buildQuasi(range) {
        var loc = linesAndColumns.locationForIndex(range[0]);
        return {
          type: 'Quasi',
          data: '',
          raw: source.slice.apply(source, toConsumableArray(range)),
          line: loc.line + 1,
          column: loc.column + 1,
          range: range
        };
      }

      function buildQuasiWithString(range, raw) {
        var loc = linesAndColumns.locationForIndex(range[0]);
        return {
          type: 'Quasi',
          data: raw,
          raw: source.slice.apply(source, toConsumableArray(range)),
          line: loc.line + 1,
          column: loc.column,
          range: range
        };
      }

      elements.forEach(function (element, i) {
        if (i === 0) {
          if (element.type === 'String') {
            if (element.range[0] === op.range[0]) {
              // This string is not interpolated, it's part of the string interpolation.
              if (element.data === '' && element.raw.length > quote.length) {
                // CoffeeScript includes the `#` in the raw value of a leading
                // empty quasi string, but it shouldn't be there.
                element = buildFirstQuasi();
              }
              quasis.push(element);
              return;
            }
          }
        }

        if (element.type === 'Quasi') {
          quasis.push(element);
        } else {
          if (quasis.length === 0) {
            // This element is interpolated and is first, i.e. "#{a}".
            quasis.push(buildFirstQuasi());
            expressions.push(element);
          } else if (/^"(.*?)"$/.test(element.data)) {
            quasis.push(buildQuasiWithString(element.range, element.raw));
          } else if (quasis.length < expressions.length + 1) {
            var lastInterpolationEnd = findPrevToken(element.range[0], lex.SourceType.INTERPOLATION_END);
            var lastInterpolationStart = findPrevToken(element.range[0], lex.SourceType.INTERPOLATION_START);
            quasis.push(buildQuasi([lastInterpolationEnd.end, lastInterpolationStart.start]));
            expressions.push(element);
          } else {
            expressions.push(element);
          }
        }
      });

      if (quasis.length < expressions.length + 1) {
        quasis.push(buildLastQuasi());
      }

      op.quasis = quasis;
      op.expressions = expressions;
      delete op.left;
      delete op.right;
      return op;
    }

    /**
     * @param expression converted base
     * @param prop CS node to convertNode
     * @param loc CS location data for original base
     */
    function accessOpForProperty(expression, prop, loc) {
      switch (type(prop)) {
        case 'Access':
          {
            var member = convertChild(prop.name);
            var accessTokenIndex = context.sourceTokens.indexOfTokenStartingAtSourceIndex(member.range[0]);
            var accessToken = accessTokenIndex && context.sourceTokens.tokenAtIndex(accessTokenIndex);

            if (prop.soak && accessToken && accessToken.type === lex.SourceType.EXISTENCE) {
              accessTokenIndex = accessTokenIndex.next();
              accessToken = accessTokenIndex && context.sourceTokens.tokenAtIndex(accessTokenIndex);
            }

            if (accessToken && accessToken.type === lex.SourceType.PROTO) {
              return makeNode(context, prop.soak ? 'SoakedProtoMemberAccessOp' : 'ProtoMemberAccessOp', mergeLocations(loc, prop.locationData), {
                expression: expression
              });
            }

            return makeNode(context, prop.soak ? 'SoakedMemberAccessOp' : 'MemberAccessOp', mergeLocations(loc, prop.locationData), {
              expression: expression,
              member: member
            });
          }

        case 'Index':
          return makeNode(context, prop.soak ? 'SoakedDynamicMemberAccessOp' : 'DynamicMemberAccessOp', mergeLocations(loc, prop.locationData), {
            expression: expression,
            indexingExpr: convertNode(prop.index, [].concat(toConsumableArray(ancestors), [node, prop]))
          });

        case 'Slice':
          return makeNode(context, prop.soak ? 'SoakedSlice' : 'Slice', mergeLocations(loc, prop.locationData), {
            expression: expression,
            left: convertChild(prop.range.from),
            right: convertChild(prop.range.to),
            isInclusive: !prop.range.exclusive
          });

        default:
          throw new Error('unknown property type: ' + type(prop) + '\n' + JSON.stringify(prop, null, 2));
      }
    }

    function binaryOperatorNodeType(operator) {
      switch (operator) {
        case '===':
          return 'EQOp';

        case '!==':
          return 'NEQOp';

        case '&&':
          return 'LogicalAndOp';

        case '||':
          return 'LogicalOrOp';

        case '+':
          return 'PlusOp';

        case '-':
          return 'SubtractOp';

        case '*':
          return 'MultiplyOp';

        case '/':
          return 'DivideOp';

        case '%':
          return 'RemOp';

        case '%%':
          return 'ModuloOp';

        case '&':
          return 'BitAndOp';

        case '|':
          return 'BitOrOp';

        case '^':
          return 'BitXorOp';

        case '<':
          return 'LTOp';

        case '>':
          return 'GTOp';

        case '<=':
          return 'LTEOp';

        case '>=':
          return 'GTEOp';

        case 'in':
          return 'OfOp';

        case '?':
          return 'ExistsOp';

        case 'instanceof':
          return 'InstanceofOp';

        case '<<':
          return 'LeftShiftOp';

        case '>>':
          return 'SignedRightShiftOp';

        case '>>>':
          return 'UnsignedRightShiftOp';

        case '**':
          return 'ExpOp';

        case '//':
          return 'FloorDivideOp';

        default:
          return null;
      }
    }

    function convertOperator(op) {
      var nodeType = void 0;

      if (op.second) {
        nodeType = binaryOperatorNodeType(op.operator);

        if (!nodeType) {
          throw new Error('unknown binary operator: ' + op.operator);
        }

        var result = makeNode(context, nodeType, op.locationData, {
          left: convertNode(op.first, [].concat(toConsumableArray(ancestors), [op])),
          right: convertNode(op.second, [].concat(toConsumableArray(ancestors), [op]))
        });
        if (result.type === 'InstanceofOp' || result.type === 'OfOp') {
          var lastTokenIndexOfLeft = context.sourceTokens.indexOfTokenEndingAtSourceIndex(result.left.range[1]);
          var firstTokenIndexOfRight = context.sourceTokens.indexOfTokenStartingAtSourceIndex(result.right.range[0]);
          var isNot = false;

          for (var i = lastTokenIndexOfLeft.next(); i !== firstTokenIndexOfRight; i = i.next()) {
            var token = context.sourceTokens.tokenAtIndex(i);
            if (token.type === lex.SourceType.OPERATOR || token.type === lex.SourceType.RELATION) {
              isNot = source.slice(token.start, token.start + 'not'.length) === 'not';
              break;
            }
          }

          result.isNot = isNot;
        }
        return result;
      } else {
        switch (op.operator) {
          case '+':
            nodeType = 'UnaryPlusOp';
            break;

          case '-':
            nodeType = 'UnaryNegateOp';
            break;

          case 'typeof':
            nodeType = 'TypeofOp';
            break;

          case '!':
            nodeType = 'LogicalNotOp';
            break;

          case '~':
            nodeType = 'BitNotOp';
            break;

          case '--':
            nodeType = op.flip ? 'PostDecrementOp' : 'PreDecrementOp';
            break;

          case '++':
            nodeType = op.flip ? 'PostIncrementOp' : 'PreIncrementOp';
            break;

          case 'delete':
            nodeType = 'DeleteOp';
            break;

          case 'new':
            // Parentheses-less "new".
            return makeNode(context, 'NewOp', op.locationData, {
              ctor: convertChild(op.first),
              arguments: []
            });

          case 'yield':
            {
              if (type(op.first) === 'Return') {
                return makeNode(context, 'YieldReturn', op.locationData, {
                  expression: convertChild(op.first.expression)
                });
              } else {
                return makeNode(context, 'Yield', op.locationData, {
                  expression: convertChild(op.first)
                });
              }
            }

          case 'yield*':
            return makeNode(context, 'YieldFrom', op.locationData, {
              expression: convertChild(op.first)
            });

          default:
            throw new Error('unknown unary operator: ' + op.operator);
        }

        return makeNode(context, nodeType, op.locationData, {
          expression: convertNode(op.first, [].concat(toConsumableArray(ancestors), [op]))
        });
      }
    }
  }

  function augmentDoFunctionWithArgs(csDoNode, doResult, func, csFuncNode) {
    func.parameters = func.parameters.map(function (param, i) {
      var arg = doResult.arguments[i];

      // If there's a parameter with no default, CoffeeScript will insert a fake
      // arg with the same value and location.
      if (arg.type === 'Identifier' && arg.data === param.data && arg.range[0] === param.range[0] && arg.range[1] === param.range[1]) {
        return param;
      }

      return makeNode(context, 'DefaultParam', locationContainingNodes(csDoNode.args[i], csFuncNode.params[i]), {
        param: param,
        default: arg
      });
    });
  }
}

exports.parse = parse$1;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"babylon":62,"coffee-lex":72,"coffee-lex/dist/SourceType":71,"decaffeinate-coffeescript":179,"decaffeinate-coffeescript/lib/coffee-script/nodes":182,"lines-and-columns":206,"util":375}],189:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var decaffeinateCoffeescript = require('decaffeinate-coffeescript');
var addVariableDeclarations = _interopDefault(require('add-variable-declarations'));
var MagicString = _interopDefault(require('magic-string'));
var asi = _interopDefault(require('automatic-semicolon-insertion'));
var buildConfig = _interopDefault(require('ast-processor-babylon-config'));
var babylon = require('babylon');
var esnext = require('esnext');
var LinesAndColumns = _interopDefault(require('lines-and-columns'));
var repeat = _interopDefault(require('repeating'));
var coffeeLex = require('coffee-lex');
require('util');
var decaffeinateParser = require('decaffeinate-parser');
var path = require('path');
var fs = require('fs');

// tslint:disable-next-line:no-any
// tslint:disable-next-line:no-any
function logger(name) {
    if (isLoggingEnabled(name)) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return console.log.apply(console, [name].concat(args));
        };
    } else {
        return function () {};
    }
}
function isLoggingEnabled(name) {
    return !!process.env["DEBUG:" + name] || !!process.env['DEBUG:*'];
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};





var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var AddVariableDeclarationsStage = function () {
  function AddVariableDeclarationsStage() {
    classCallCheck(this, AddVariableDeclarationsStage);
  }

  createClass(AddVariableDeclarationsStage, null, [{
    key: 'run',
    value: function run(content) {
      var log = logger(this.name);
      log(content);

      var editor = new MagicString(content);
      addVariableDeclarations(content, editor);
      return {
        code: editor.toString()
      };
    }
  }]);
  return AddVariableDeclarationsStage;
}();

var BABYLON_PLUGINS = ['flow', 'jsx', 'asyncFunctions', 'asyncGenerators', 'classConstructorCall', 'classProperties', 'decorators', 'doExpressions', 'exponentiationOperator', 'exportExtensions', 'functionBind', 'functionSent', 'objectRestSpread', 'trailingFunctionCommas'];

var SemicolonsStage = function () {
  function SemicolonsStage() {
    classCallCheck(this, SemicolonsStage);
  }

  createClass(SemicolonsStage, null, [{
    key: 'run',
    value: function run(content) {
      var log = logger(this.name);
      log(content);

      var editor = new MagicString(content);
      var ast = babylon.parse(content, {
        sourceType: 'module',
        plugins: BABYLON_PLUGINS,
        allowReturnOutsideFunction: true
      });
      var config = buildConfig(content, ast);

      asi(config);

      config.insertions.forEach(function (_ref) {
        var index = _ref.index,
            content = _ref.content;
        return editor.appendLeft(index, content);
      });
      config.removals.forEach(function (_ref2) {
        var start = _ref2.start,
            end = _ref2.end;
        return editor.remove(start, end);
      });

      return {
        code: editor.toString()
      };
    }
  }]);
  return SemicolonsStage;
}();

var EsnextStage = function () {
  function EsnextStage() {
    classCallCheck(this, EsnextStage);
  }

  createClass(EsnextStage, null, [{
    key: 'run',
    value: function run(content, options) {
      var log = logger(this.name);
      log(content);
      var plugins = esnext.allPlugins;
      if (options.keepCommonJS) {
        plugins = plugins.filter(function (plugin) {
          return plugin.name !== 'modules.commonjs';
        });
      }

      var _convert = esnext.convert(content, {
        plugins: plugins,
        'declarations.block-scope': {
          disableConst: function disableConst(_ref) {
            var node = _ref.node,
                parent = _ref.parent;

            if (options.preferConst) {
              return false;
            }
            return (
              // Only use `const` for top-level variables…
              parent && parent.type !== 'Program' ||
              // … as the only variable in its declaration …
              node.declarations.length !== 1 ||
              // … without any sort of destructuring …
              node.declarations[0].id.type !== 'Identifier' ||
              // … starting with a capital letter.
              !/^[$_]?[A-Z]+$/.test(node.declarations[0].id.name)
            );
          }
        }
      }),
          code = _convert.code;

      return { code: code };
    }
  }]);
  return EsnextStage;
}();

function printTable(table) {
  var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ' ';

  var widths = [];
  table.rows.forEach(function (row) {
    row.forEach(function (cell, i) {
      if (widths.length <= i) {
        widths[i] = cell.length;
      } else if (widths[i] < cell.length) {
        widths[i] = cell.length;
      }
    });
  });
  var output = '';
  table.rows.forEach(function (row) {
    row.forEach(function (cell, i) {
      var column = table.columns[i];
      if (column.align === 'left') {
        output += cell;
      } else if (column.align === 'right') {
        output += repeat(' ', widths[i] - cell.length) + cell;
      }
      if (i < row.length - 1) {
        output += buffer;
      }
    });
    output += '\n';
  });
  return output;
}

var PatchError = function (_Error) {
  inherits(PatchError, _Error);

  function PatchError(message, source, start, end, error) {
    classCallCheck(this, PatchError);

    var _this = possibleConstructorReturn(this, (PatchError.__proto__ || Object.getPrototypeOf(PatchError)).call(this, message));

    _this.message = message;
    _this.source = source;
    _this.start = start;
    _this.end = end;
    _this.error = error;
    return _this;
  }

  createClass(PatchError, [{
    key: 'toString',
    value: function toString() {
      return this.message;
    }

    /**
     * Due to babel's inability to simulate extending native types, we have our
     * own method for determining whether an object is an instance of
     * `PatchError`.
     *
     * @see http://stackoverflow.com/a/33837088/549363
     */

  }], [{
    key: 'detect',
    value: function detect(error) {
      return error instanceof Error && 'source' in error && 'start' in error && 'end' in error;
    }
  }, {
    key: 'prettyPrint',
    value: function prettyPrint(error) {
      var source = error.source,
          start = error.start,
          end = error.end,
          message = error.message;

      start = Math.min(Math.max(start, 0), source.length);
      end = Math.min(Math.max(end, start), source.length);
      var lineMap = new LinesAndColumns(source);
      var startLoc = lineMap.locationForIndex(start);
      var endLoc = lineMap.locationForIndex(end);

      if (!startLoc || !endLoc) {
        throw new Error('unable to find locations for range: [' + start + ', ' + end + ')');
      }

      var displayStartLine = Math.max(0, startLoc.line - 2);
      var displayEndLine = endLoc.line + 2;

      var rows = [];

      for (var line = displayStartLine; line <= displayEndLine; line++) {
        var startOfLine = lineMap.indexForLocation({ line: line, column: 0 });
        var endOfLine = lineMap.indexForLocation({ line: line + 1, column: 0 });
        if (startOfLine === null) {
          break;
        }
        if (endOfLine === null) {
          endOfLine = source.length;
        }
        var lineSource = trimRight(source.slice(startOfLine, endOfLine));
        if (startLoc.line !== endLoc.line) {
          if (line >= startLoc.line && line <= endLoc.line) {
            rows.push(['>', line + 1 + ' |', lineSource]);
          } else {
            rows.push(['', line + 1 + ' |', lineSource]);
          }
        } else if (line === startLoc.line) {
          var highlightLength = Math.max(endLoc.column - startLoc.column, 1);
          rows.push(['>', line + 1 + ' |', lineSource], ['', '|', repeat(' ', startLoc.column) + repeat('^', highlightLength)]);
        } else {
          rows.push(['', line + 1 + ' |', lineSource]);
        }
      }

      var columns = [{ id: 'marker', align: 'right' }, { id: 'line', align: 'right' }, { id: 'source', align: 'left' }];

      return message + '\n' + printTable({ rows: rows, columns: columns });
    }
  }]);
  return PatchError;
}(Error);

function trimRight(string) {
  return string.replace(/\s+$/, '');
}

var detectIndent = require('detect-indent');
var DEFAULT_INDENT = '  ';
function determineIndent(source) {
    var indent = detectIndent(source);
    if (indent.type === 'space' && indent.amount % 2 === 1) {
        return DEFAULT_INDENT;
    }
    return indent.indent || DEFAULT_INDENT;
}

/**
 * Finds the start of the line for the character at offset.
 */
/**
 * Finds the start of the line for the character at offset.
 */function getStartOfLine(source, offset) {
  var lfIndex = source.lastIndexOf('\n', offset - 1);
  if (lfIndex < 0) {
    return 0;
  }
  return lfIndex + 1;
}

/**
 * Gets the indent string for the line containing offset.
 */
function getIndent(source, offset) {
    var startOfLine = getStartOfLine(source, offset);
    var indentOffset = startOfLine;
    var indentCharacter;
    switch (source[indentOffset]) {
        case ' ':
        case '\t':
            indentCharacter = source[indentOffset];
            break;
        default:
            return '';
    }
    while (source[indentOffset] === indentCharacter) {
        indentOffset++;
    }
    return source.slice(startOfLine, indentOffset);
}

/**
 * Adjust an indent in source at a specific offset by an amount.
 */
function adjustIndent(source, offset, adjustment) {
    var currentIndent = getIndent(source, offset);
    var determinedIndent = determineIndent(source);
    if (adjustment > 0) {
        while (adjustment--) {
            currentIndent += determinedIndent;
        }
    } else if (adjustment < 0) {
        currentIndent = currentIndent.slice(determinedIndent.length * -adjustment);
    }
    return currentIndent;
}

/**
 * Determines whether the node is a boolean, optionally with the given value.
 */


/**
 * Determines whether a node is a member access operation.
 */


/**
 * Determines whether a node is a static member access, e.g. `a.b`.
 */


/**
 * Determines whether a node is a dynamic member access, e.g. `a[b]`.
 */


/**
 * Determines whether a node represents a function, i.e. `->` or `=>`.
 */
function isFunction(node) {
  var allowBound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  return node.type === 'Function' || node.type === 'GeneratorFunction' || allowBound && (node.type === 'BoundFunction' || node.type === 'BoundGeneratorFunction');
}

/**
 * Determines  whether a node is the body of a function.
 *
 * @example
 *
 *   -> 1  # the literal `1` is the function body
 *
 *   ->
 *     2   # the block containing `2` as a statement is the function body
 */


/**
 * Determines whether the node is a conditional (i.e. `if` or `unless`).
 */


/**
 * Determines whether a node represents a `for` loop.
 */


/**
 * Determines whether a node represents a `while` loop.
 */


/**
 * Determines whether a node is the true-part or false-part of a conditional.
 */












var NON_SEMANTIC_SOURCE_TOKEN_TYPES = [coffeeLex.SourceType.COMMENT, coffeeLex.SourceType.HERECOMMENT, coffeeLex.SourceType.NEWLINE];

/**
 * This isn't a great name because newlines do have semantic meaning in
 * CoffeeScript, but it's close enough.
 */
function isSemanticToken(token) {
  return NON_SEMANTIC_SOURCE_TOKEN_TYPES.indexOf(token.type) < 0;
}

/**
 * Traverses an AST node, calling a callback for each node in the hierarchy in
 * source order.
 */
function traverse(node, callback) {
  var descended = false;

  function descend(parent) {
    descended = true;

    childPropertyNames(parent).forEach(function (property) {
      var value = parent[property];
      if (Array.isArray(value)) {
        value.forEach(function (child) {
          child.parentNode = parent;
          traverse(child, callback);
        });
      } else if (value) {
        value.parentNode = parent;
        traverse(value, callback);
      }
    });
  }

  var shouldDescend = callback(node, descend, childPropertyNames(node).length === 0);

  if (!descended && shouldDescend !== false) {
    descend(node);
  }
}

var ORDER = {
  ArrayInitialiser: ['members'],
  AssignOp: ['assignee', 'expression'],
  BareSuperFunctionApplication: [],
  BitAndOp: ['left', 'right'],
  BitNotOp: ['expression'],
  BitOrOp: ['left', 'right'],
  BitXorOp: ['left', 'right'],
  Block: ['statements'],
  Bool: [],
  BoundFunction: ['parameters', 'body'],
  BoundGeneratorFunction: ['parameters', 'body'],
  Break: [],
  ChainedComparisonOp: ['operands'],
  Class: ['nameAssignee', 'parent', 'body'],
  ClassProtoAssignOp: ['assignee', 'expression'],
  CompoundAssignOp: ['assignee', 'expression'],
  Conditional: ['condition', 'consequent', 'alternate'],
  Constructor: ['assignee', 'expression'],
  Continue: [],
  DefaultParam: ['param', 'default'],
  DeleteOp: ['expression'],
  DivideOp: ['left', 'right'],
  DoOp: ['expression'],
  DynamicMemberAccessOp: ['expression', 'indexingExpr'],
  EQOp: ['left', 'right'],
  ExistsOp: ['left', 'right'],
  Expansion: [],
  ExpOp: ['left', 'right'],
  ExtendsOp: ['left', 'right'],
  Float: [],
  FloorDivideOp: ['left', 'right'],
  ForIn: ['keyAssignee', 'valAssignee', 'target', 'step', 'filter', 'body'],
  ForOf: ['keyAssignee', 'valAssignee', 'target', 'filter', 'body'],
  Function: ['parameters', 'body'],
  FunctionApplication: ['function', 'arguments'],
  GeneratorFunction: ['parameters', 'body'],
  GTEOp: ['left', 'right'],
  GTOp: ['left', 'right'],
  Heregex: ['quasis', 'expressions'],
  Identifier: [],
  InOp: ['left', 'right'],
  InstanceofOp: ['left', 'right'],
  Int: [],
  JavaScript: [],
  LTEOp: ['left', 'right'],
  LTOp: ['left', 'right'],
  LeftShiftOp: ['left', 'right'],
  LogicalAndOp: ['left', 'right'],
  LogicalNotOp: ['expression'],
  LogicalOrOp: ['left', 'right'],
  Loop: ['body'],
  MemberAccessOp: ['expression', 'member'],
  ModuloOp: ['left', 'right'],
  MultiplyOp: ['left', 'right'],
  NEQOp: ['left', 'right'],
  NewOp: ['ctor', 'arguments'],
  Null: [],
  ObjectInitialiser: ['members'],
  ObjectInitialiserMember: ['key', 'expression'],
  OfOp: ['left', 'right'],
  PlusOp: ['left', 'right'],
  PostDecrementOp: ['expression'],
  PostIncrementOp: ['expression'],
  PreDecrementOp: ['expression'],
  PreIncrementOp: ['expression'],
  Program: ['body'],
  ProtoMemberAccessOp: ['expression'],
  Quasi: [],
  Range: ['left', 'right'],
  Regex: [],
  RemOp: ['left', 'right'],
  Rest: ['expression'],
  Return: ['expression'],
  SeqOp: ['left', 'right'],
  SignedRightShiftOp: ['left', 'right'],
  Slice: ['expression', 'left', 'right'],
  SoakedDynamicMemberAccessOp: ['expression', 'indexingExpr'],
  SoakedFunctionApplication: ['function', 'arguments'],
  SoakedMemberAccessOp: ['expression', 'member'],
  SoakedNewOp: ['ctor', 'arguments'],
  SoakedProtoMemberAccessOp: ['expression'],
  SoakedSlice: ['expression', 'left', 'right'],
  Spread: ['expression'],
  String: ['quasis', 'expressions'],
  SubtractOp: ['left', 'right'],
  Super: [],
  Switch: ['expression', 'cases', 'alternate'],
  SwitchCase: ['conditions', 'consequent'],
  This: [],
  Throw: ['expression'],
  Try: ['body', 'catchAssignee', 'catchBody', 'finallyBody'],
  TypeofOp: ['expression'],
  UnaryExistsOp: ['expression'],
  UnaryNegateOp: ['expression'],
  UnaryPlusOp: ['expression'],
  Undefined: [],
  UnsignedRightShiftOp: ['left', 'right'],
  While: ['condition', 'guard', 'body'],
  Yield: ['expression'],
  YieldFrom: ['expression'],
  YieldReturn: ['expression']
};

function childPropertyNames(node) {
  var names = ORDER[node.type];

  if (!names) {
    throw new Error('cannot traverse unknown node type: ' + node.type);
  }

  return names;
}

var NodePatcher = function () {
  function NodePatcher(_ref) {
    var _this = this;

    var node = _ref.node,
        context = _ref.context,
        editor = _ref.editor,
        options = _ref.options;
    classCallCheck(this, NodePatcher);
    this.adjustedIndentLevel = 0;
    this.yielding = false;

    this.log = logger(this.constructor.name);

    this.node = node;
    this.context = context;
    this.editor = editor;
    this.options = options;

    this.withPrettyErrors(function () {
      return _this.setupLocationInformation();
    });
  }

  /**
   * Allow patcher classes to override the class used to patch their children.
   */


  createClass(NodePatcher, [{
    key: 'setupLocationInformation',


    /**
     * @private
     */
    value: function setupLocationInformation() {
      var node = this.node,
          context = this.context;

      /**
       * `contentStart` and `contentEnd` is the exclusive range within the original source that
       * composes this patcher's node. For example, here's the contentStart and contentEnd of
       * `a + b` in the expression below:
       *
       *   console.log(a + b)
       *               ^    ^
       */

      this.contentStart = node.range[0];
      this.contentEnd = node.range[1];

      if (this.shouldTrimContentRange()) {
        this.trimContentRange();
      }

      var tokens$$1 = context.sourceTokens;
      var firstSourceTokenIndex = tokens$$1.indexOfTokenStartingAtSourceIndex(this.contentStart);
      var lastSourceTokenIndex = tokens$$1.indexOfTokenEndingAtSourceIndex(this.contentEnd);

      if (!firstSourceTokenIndex || !lastSourceTokenIndex) {
        if (node.type === 'Program') {
          // Just an empty program.
          return;
        }

        throw this.error('cannot find first or last token in ' + node.type + ' node');
      }

      this.contentStartTokenIndex = firstSourceTokenIndex;
      this.contentEndTokenIndex = lastSourceTokenIndex;

      var outerStartTokenIndex = firstSourceTokenIndex;
      var outerEndTokenIndex = lastSourceTokenIndex;

      var innerStartTokenIndex = firstSourceTokenIndex;
      var innerEndTokenIndex = lastSourceTokenIndex;

      for (;;) {
        var previousSurroundingTokenIndex = tokens$$1.lastIndexOfTokenMatchingPredicate(isSemanticToken, outerStartTokenIndex.previous());
        var nextSurroundingTokenIndex = tokens$$1.indexOfTokenMatchingPredicate(isSemanticToken, outerEndTokenIndex.next());

        if (!previousSurroundingTokenIndex || !nextSurroundingTokenIndex) {
          break;
        }

        var previousSurroundingToken = tokens$$1.tokenAtIndex(previousSurroundingTokenIndex);
        var nextSurroundingToken = tokens$$1.tokenAtIndex(nextSurroundingTokenIndex);

        if (!previousSurroundingToken || previousSurroundingToken.type !== coffeeLex.SourceType.LPAREN && previousSurroundingToken.type !== coffeeLex.SourceType.CALL_START) {
          break;
        }

        if (!nextSurroundingToken || nextSurroundingToken.type !== coffeeLex.SourceType.RPAREN && nextSurroundingToken.type !== coffeeLex.SourceType.CALL_END) {
          break;
        }

        if (innerStartTokenIndex === firstSourceTokenIndex) {
          innerStartTokenIndex = previousSurroundingTokenIndex;
        }

        if (innerEndTokenIndex === lastSourceTokenIndex) {
          innerEndTokenIndex = nextSurroundingTokenIndex;
        }

        outerStartTokenIndex = previousSurroundingTokenIndex;
        outerEndTokenIndex = nextSurroundingTokenIndex;
      }

      this.innerStartTokenIndex = innerStartTokenIndex;
      this.innerEndTokenIndex = innerEndTokenIndex;

      this.outerStartTokenIndex = outerStartTokenIndex;
      this.outerEndTokenIndex = outerEndTokenIndex;

      /**
       * `innerStart`, `innerEnd`, `outerStart` and `outerEnd` refer to the
       * positions around surrounding parentheses. In most nodes they are the same
       * as `contentStart` and `contentEnd`. For example:
       *
       *              innerStart
       *                  |
       *       outerStart | contentStart
       *                | | |
       *                ▼ ▼ ▼
       *            1 * ((  2 + 3  ))
       *                         ▲ ▲ ▲
       *                         | | |
       *                contentEnd | outerEnd
       *                           |
       *                        innerEnd
       */
      if (innerStartTokenIndex === firstSourceTokenIndex) {
        this.innerStart = this.contentStart;
      } else {
        this.innerStart = tokens$$1.tokenAtIndex(innerStartTokenIndex).end;
      }
      if (innerEndTokenIndex === lastSourceTokenIndex) {
        this.innerEnd = this.contentEnd;
      } else {
        this.innerEnd = tokens$$1.tokenAtIndex(innerEndTokenIndex).start;
      }
      this.outerStart = tokens$$1.tokenAtIndex(outerStartTokenIndex).start;
      this.outerEnd = tokens$$1.tokenAtIndex(outerEndTokenIndex).end;
    }

    /**
     * Called to trim the range of content for this node. Override in subclasses
     * to customize its behavior, or override `shouldTrimContentRange` to enable
     * or disable it.
     */

  }, {
    key: 'trimContentRange',
    value: function trimContentRange() {
      var context = this.context;

      for (;;) {
        var startChar = context.source[this.contentStart];

        if (startChar === ' ' || startChar === '\t') {
          this.contentStart++;
        } else {
          break;
        }
      }

      for (;;) {
        var lastChar = context.source[this.contentEnd - 1];

        if (lastChar === ' ' || lastChar === '\t') {
          this.contentEnd--;
        } else {
          break;
        }
      }
    }

    /**
     * Decides whether to trim the content range of this node.
     */

  }, {
    key: 'shouldTrimContentRange',
    value: function shouldTrimContentRange() {
      return false;
    }

    /**
     * Called when the patcher tree is complete so we can do any processing that
     * requires communication with other patchers.
     */

  }, {
    key: 'initialize',
    value: function initialize() {}

    /**
     * Calls methods on `editor` to transform the source code represented by
     * `node` from CoffeeScript to JavaScript. By default this method delegates
     * to other patcher methods which can be overridden individually.
     */

  }, {
    key: 'patch',
    value: function patch() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.withPrettyErrors(function () {
        if (_this2._repeatableOptions !== undefined) {
          _this2._repeatCode = _this2.patchAsRepeatableExpression(_this2._repeatableOptions, options);
        } else if (_this2.forcedToPatchAsExpression()) {
          _this2.patchAsForcedExpression(options);
          _this2.commitDeferredSuffix();
        } else if (_this2.willPatchAsExpression()) {
          _this2.patchAsExpression(options);
          _this2.commitDeferredSuffix();
        } else {
          _this2.patchAsStatement(options);
          _this2.commitDeferredSuffix();
        }
      });
    }

    /**
     * Alternative to patch that patches the expression in a way that the result
     * can be referenced later, then returns the code to reference it.
     *
     * This is a shorthand for the simplest use of the repeatable protocol. In
     * more advanced cases (such as repeating code that is deep within the AST),
     * setRequiresRepeatableExpression can be called before the node is patched
     * and getRepeatCode can be called any time after.
     *
     * The actual implementation for making the node repeatable should be in
     * patchAsRepeatableExpression.
     */

  }, {
    key: 'patchRepeatable',
    value: function patchRepeatable() {
      var repeatableOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.setRequiresRepeatableExpression(repeatableOptions);
      this.patch();
      return this.getRepeatCode();
    }

    /**
     * Patch the given expression and get the underlying generated code. This is
     * more robust than calling patch and slice directly, since it also includes
     * code inserted at contentStart (which normally isn't picked up by slice
     * because it's inserted to the left of the index boundary). To accomplish
     * this, we look at the range from contentStart - 1 to contentStart before and
     * after patching and include anything new that was added.
     */

  }, {
    key: 'patchAndGetCode',
    value: function patchAndGetCode() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this.captureCodeForPatchOperation(function () {
        return _this3.patch(options);
      });
    }
  }, {
    key: 'captureCodeForPatchOperation',
    value: function captureCodeForPatchOperation(patchFn) {
      var sliceStart = this.contentStart > 0 ? this.contentStart - 1 : 0;
      // Occasionally, sliceStart will be illegal because it will be in a range
      // that has been removed or overwritten. If that's the case, subtract 1 from
      // sliceStart until we find something that works.
      var beforeCode = null;
      while (beforeCode === null) {
        try {
          beforeCode = this.slice(sliceStart, this.contentStart);
        } catch (e) {
          // Assume that this is because the index is an invalid start. It looks
          // like there isn't a robust way to detect this case exactly, so just
          // try a lower start for any error.
          sliceStart -= 1;
          if (sliceStart < 0) {
            throw this.error('Could not find a valid index to slice for patch operation.');
          }
        }
      }
      patchFn();
      var code = this.slice(sliceStart, this.contentEnd);
      var startIndex = 0;
      while (startIndex < beforeCode.length && startIndex < code.length && beforeCode[startIndex] === code[startIndex]) {
        startIndex++;
      }
      return code.substr(startIndex);
    }

    /**
     * Catch errors and throw them again annotated with the current node.
     */

  }, {
    key: 'withPrettyErrors',
    value: function withPrettyErrors(body) {
      try {
        body();
      } catch (err) {
        if (!PatchError.detect(err)) {
          throw this.error(err.message, this.contentStart, this.contentEnd, err);
        } else {
          throw err;
        }
      }
    }

    /**
     * Internal patching method that should patch the current node as an
     * expression and also, if necessary, alter it in a way that it can
     *
     * The return value of this function should be a code snippet that references
     * the result of this expression without any further side-effects.
     *
     * In simple cases, such as identifiers, subclasses can override isRepeatable
     * to declare themselves as already repeatable. In more advanced cases,
     * subclasses can override this method to provide custom behavior.
     *
     * This function is also responsible for committing the deferred suffix if
     * necessary.
     *
     * @protected
     */

  }, {
    key: 'patchAsRepeatableExpression',
    value: function patchAsRepeatableExpression() {
      var _this4 = this;

      var repeatableOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var patchOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.isRepeatable()) {
        return this.captureCodeForPatchOperation(function () {
          _this4.patchAsForcedExpression(patchOptions);
          _this4.commitDeferredSuffix();
        });
      } else {
        // Can't repeat it, so we assign it to a free variable and return that,
        // i.e. `a + b` → `(ref = a + b)`.
        if (repeatableOptions.parens) {
          this.insert(this.innerStart, '(');
        }
        var ref = this.claimFreeBinding(repeatableOptions.ref);
        this.insert(this.innerStart, ref + ' = ');
        this.patchAsForcedExpression(patchOptions);
        this.commitDeferredSuffix();
        if (repeatableOptions.parens) {
          this.insert(this.innerEnd, ')');
        }
        return ref;
      }
    }

    /**
     * Override this to patch the node as an expression.
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      throw this.error('\'patchAsExpression\' must be overridden in subclasses');
    }

    /**
     * Override this to patch the node as a statement.
     */

  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var addParens = this.statementShouldAddParens();
      if (addParens) {
        this.insert(this.outerStart, '(');
      }
      this.patchAsExpression(options);
      if (addParens) {
        this.insert(this.outerEnd, ')');
      }
    }

    /**
     * Override this to patch the node as an expression that would not normally be
     * an expression, often by wrapping it in an immediately invoked function
     * expression (IIFE).
     */

  }, {
    key: 'patchAsForcedExpression',
    value: function patchAsForcedExpression() {
      this.patchAsExpression();
    }

    /**
     * Insert content at the specified index.
     */

  }, {
    key: 'insert',
    value: function insert(index, content) {
      if (typeof index !== 'number') {
        throw new Error('cannot insert ' + JSON.stringify(content) + ' at non-numeric index ' + index);
      }
      this.log('INSERT', index, JSON.stringify(content), 'BEFORE', JSON.stringify(this.context.source.slice(index, index + 8)));

      this.adjustBoundsToInclude(index);
      this.editor.appendLeft(index, content);
    }

    /**
     * Insert content at the specified index, before any content normally
     * specified with `insert`. Note that this should be used sparingly. In almost
     * every case, the correct behavior is to do all patching operations in order
     * and always use `insert`. However, in some cases (like a constructor that
     * needs the patched contents of the methods below it), we need to do patching
     * out of order, so it's ok to use `prependLeft` to ensure that the code ends
     * up before the later values.
     */

  }, {
    key: 'prependLeft',
    value: function prependLeft(index, content) {
      if (typeof index !== 'number') {
        throw new Error('cannot insert ' + JSON.stringify(content) + ' at non-numeric index ' + index);
      }
      this.log('PREPEND LEFT', index, JSON.stringify(content), 'BEFORE', JSON.stringify(this.context.source.slice(index, index + 8)));

      this.adjustBoundsToInclude(index);
      this.editor.prependLeft(index, content);
    }
  }, {
    key: 'allowPatchingOuterBounds',
    value: function allowPatchingOuterBounds() {
      return false;
    }

    /**
     * @protected
     */

  }, {
    key: 'getEditingBounds',
    value: function getEditingBounds() {
      var boundingPatcher = this.getBoundingPatcher();
      // When we're a function arg, there isn't a great patcher to use to
      // determine our bounds (we're allowed to patch from the previous
      // comma/paren to the next comma/paren), so loosen the restriction to the
      // entire function.
      if (boundingPatcher.parent && (this.isNodeFunctionApplication(boundingPatcher.parent.node) || boundingPatcher.parent.node.type === 'ArrayInitialiser')) {
        boundingPatcher = boundingPatcher.parent;
      }
      if (this.allowPatchingOuterBounds()) {
        return [boundingPatcher.outerStart, boundingPatcher.outerEnd];
      } else {
        return [boundingPatcher.innerStart, boundingPatcher.innerEnd];
      }
    }

    /**
     * @protected
     */

  }, {
    key: 'isIndexEditable',
    value: function isIndexEditable(index) {
      var _getEditingBounds = this.getEditingBounds(),
          _getEditingBounds2 = slicedToArray(_getEditingBounds, 2),
          start = _getEditingBounds2[0],
          end = _getEditingBounds2[1];

      return index >= start && index <= end;
    }

    /**
     * @protected
     */

  }, {
    key: 'assertEditableIndex',
    value: function assertEditableIndex(index) {
      if (!this.isIndexEditable(index)) {
        var _getEditingBounds3 = this.getEditingBounds(),
            _getEditingBounds4 = slicedToArray(_getEditingBounds3, 2),
            start = _getEditingBounds4[0],
            end = _getEditingBounds4[1];

        throw this.error('cannot edit index ' + index + ' because it is not editable (i.e. outside [' + start + ', ' + end + '))', start, end);
      }
    }

    /**
     * When editing outside a node's bounds we expand the bounds to fit, if
     * possible. Note that if a node or a node's parent is wrapped in parentheses
     * we cannot adjust the bounds beyond the inside of the parentheses.
     */

  }, {
    key: 'adjustBoundsToInclude',
    value: function adjustBoundsToInclude(index) {
      this.assertEditableIndex(index);

      if (index < this.innerStart) {
        this.log('Moving `innerStart` from', this.innerStart, 'to', index);
        this.innerStart = index;
      }

      if (index > this.innerEnd) {
        this.log('Moving `innerEnd` from', this.innerEnd, 'to', index);
        this.innerEnd = index;
      }

      if (index < this.outerStart) {
        this.log('Moving `outerStart` from', this.outerStart, 'to', index);
        this.outerStart = index;
      }

      if (index > this.outerEnd) {
        this.log('Moving `outerEnd` from', this.outerEnd, 'to', index);
        this.outerEnd = index;
      }

      if (this.parent) {
        this.parent.adjustBoundsToInclude(index);
      }
    }

    /**
     * Replace the content between the start and end indexes with new content.
     */

  }, {
    key: 'overwrite',
    value: function overwrite(start, end, content) {
      if (typeof start !== 'number' || typeof end !== 'number') {
        throw new Error('cannot overwrite non-numeric range [' + start + ', ' + end + ') ' + ('with ' + JSON.stringify(content)));
      }
      this.log('OVERWRITE', '[' + start + ', ' + end + ')', JSON.stringify(this.context.source.slice(start, end)), '→', JSON.stringify(content));
      this.editor.overwrite(start, end, content);
    }

    /**
     * Remove the content between the start and end indexes.
     */

  }, {
    key: 'remove',
    value: function remove(start, end) {
      if (typeof start !== 'number' || typeof end !== 'number') {
        throw new Error('cannot remove non-numeric range [' + start + ', ' + end + ')');
      }
      this.log('REMOVE', '[' + start + ', ' + end + ')', JSON.stringify(this.context.source.slice(start, end)));
      this.editor.remove(start, end);
    }

    /**
     * Moves content in a range to another index.
     */

  }, {
    key: 'move',
    value: function move(start, end, index) {
      if (typeof start !== 'number' || typeof end !== 'number') {
        throw this.error('cannot remove non-numeric range [' + start + ', ' + end + ')');
      }
      if (typeof index !== 'number') {
        throw this.error('cannot move to non-numeric index: ' + index);
      }
      this.log('MOVE', '[' + start + ', ' + end + ') \u2192 ' + index, JSON.stringify(this.context.source.slice(start, end)), 'BEFORE', JSON.stringify(this.context.source.slice(index, index + 8)));
      this.editor.move(start, end, index);
    }

    /**
     * Get the current content between the start and end indexes.
     */

  }, {
    key: 'slice',
    value: function slice(start, end) {
      // magic-string treats 0 as the end of the string, which we don't want to do.
      if (end === 0) {
        return '';
      }
      return this.editor.slice(start, end);
    }

    /**
     * Determines whether this node starts with a string.
     */

  }, {
    key: 'startsWith',
    value: function startsWith(string) {
      return this.context.source.slice(this.contentStart, this.contentStart + string.length) === string;
    }

    /**
     * Determines whether this node ends with a string.
     */

  }, {
    key: 'endsWith',
    value: function endsWith(string) {
      return this.context.source.slice(this.contentEnd - string.length, this.contentEnd) === string;
    }

    /**
     * Tells us to force this patcher to generate an expression, or else throw.
     */

  }, {
    key: 'setRequiresExpression',
    value: function setRequiresExpression() {
      this.setExpression(true);
    }

    /**
     * Tells us to try to patch as an expression, returning whether it can.
     */

  }, {
    key: 'setExpression',
    value: function setExpression() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (force) {
        if (!this.canPatchAsExpression()) {
          throw this.error('cannot represent ' + this.node.type + ' as an expression');
        }
      } else if (!this.prefersToPatchAsExpression()) {
        return false;
      }
      this._expression = true;
      return true;
    }

    /**
     * Override this to express whether the patcher prefers to be represented as
     * an expression. By default it's simply an alias for `canPatchAsExpression`.
     */

  }, {
    key: 'prefersToPatchAsExpression',
    value: function prefersToPatchAsExpression() {
      return this.canPatchAsExpression();
    }

    /**
     * Override this if a node cannot be represented as an expression.
     */

  }, {
    key: 'canPatchAsExpression',
    value: function canPatchAsExpression() {
      return true;
    }

    /**
     * Gets whether this patcher is working on a statement or an expression.
     */

  }, {
    key: 'willPatchAsExpression',
    value: function willPatchAsExpression() {
      return this._expression;
    }

    /**
     * Gets whether this patcher was forced to patch its node as an expression.
     */

  }, {
    key: 'forcedToPatchAsExpression',
    value: function forcedToPatchAsExpression() {
      return this.willPatchAsExpression() && !this.prefersToPatchAsExpression();
    }

    /**
     * Marks this node as an assignee. Nested assignees, like destructure
     * operations, should override this method and propagate it to the children.
     */

  }, {
    key: 'setAssignee',
    value: function setAssignee() {
      this._assignee = true;
    }

    /**
     * Checks if this node has been marked as an assignee. This is particularly
     * useful for distinguishing rest from spread operations.
     */

  }, {
    key: 'isAssignee',
    value: function isAssignee() {
      return this._assignee;
    }

    /**
     * Gets whether this patcher's node implicitly returns.
     */

  }, {
    key: 'implicitlyReturns',
    value: function implicitlyReturns() {
      return this._implicitlyReturns || false;
    }

    /**
     * Causes the node to be returned from its function.
     */

  }, {
    key: 'setImplicitlyReturns',
    value: function setImplicitlyReturns() {
      this._implicitlyReturns = true;
    }

    /**
     * Gets the ancestor that will decide the current implicit return behavior.
     * That ancestor will then have implicitReturnWillBreak,
     * patchImplicitReturnStart, and patchImplicitReturnEnd methods that describe
     * how to handle expressions in an implicit return position (usually they are
     * just returned, but in the case of loop IIFEs, they will be added to a
     * list).
     */

  }, {
    key: 'implicitReturnPatcher',
    value: function implicitReturnPatcher() {
      if (this.canHandleImplicitReturn()) {
        return this;
      } else {
        return this.parent.implicitReturnPatcher();
      }
    }

    /**
     * Subclasses should return true to declare themselves as the "handler" in an
     * implicit return situation.
     */

  }, {
    key: 'canHandleImplicitReturn',
    value: function canHandleImplicitReturn() {
      return false;
    }

    /**
     * Determines whether the current patcher (which has already declared that it
     * can be an implicit return patcher) will generate code that stops execution
     * in the current block. In the normal case of a return statement, this is
     * true, but in loop IIFEs, there might be e.g. an assignment, which means
     * that the control flow won't necessarily stop.
     */

  }, {
    key: 'implicitReturnWillBreak',
    value: function implicitReturnWillBreak() {
      return true;
    }

    /**
     * Patch the beginning of an implicitly-returned descendant. Unlike most
     * statements, implicitly-returned statements will not have their surrounding
     * parens removed, so the implicit return patching may need to remove
     * surrounding parens.
     */

  }, {
    key: 'patchImplicitReturnStart',
    value: function patchImplicitReturnStart(patcher) {
      patcher.setRequiresExpression();
      this.insert(patcher.outerStart, 'return ');
    }

    /**
     * Patch the end of an implicitly-returned descendant.
     */

  }, {
    key: 'patchImplicitReturnEnd',
    value: function patchImplicitReturnEnd(patcher) {} // eslint-disable-line no-unused-vars
    // Nothing to do.


    /**
     * Gets whether this patcher's node returns explicitly from its function.
     */

  }, {
    key: 'explicitlyReturns',
    value: function explicitlyReturns() {
      return this._returns || false;
    }

    /**
     * Marks this patcher's as containing a node that explicitly returns.
     */

  }, {
    key: 'setExplicitlyReturns',
    value: function setExplicitlyReturns() {
      this._returns = true;
      if (this.parent) {
        this.parent.setExplicitlyReturns();
      }
    }

    /**
     * Mark that this node should have the given suffix appended at the end of
     * patching. For example, this allows a child node to indicate that this node
     * should end with a close-paren, and to do so in a way that respects patching
     * order (doesn't add the close-paren too early).
     */

  }, {
    key: 'appendDeferredSuffix',
    value: function appendDeferredSuffix(suffix) {
      if (!this._deferredSuffix) {
        this._deferredSuffix = '';
      }
      this._deferredSuffix += suffix;
    }

    /**
     * Internal method that should be called at the end of patching to actually
     * place the deferred suffix in the right place.
     *
     * @protected
     */

  }, {
    key: 'commitDeferredSuffix',
    value: function commitDeferredSuffix() {
      if (this._deferredSuffix) {
        this.insert(this.innerEnd, this._deferredSuffix);
      }
    }

    /**
     * Determines whether this patcher's node needs a semicolon after it. This
     * should be overridden in subclasses as appropriate.
     */

  }, {
    key: 'statementNeedsSemicolon',
    value: function statementNeedsSemicolon() {
      return true;
    }

    /**
     * Determines whether, when appearing as a statement, this patcher's node
     * needs to be surrounded by parentheses.
     *
     * Subclasses should override this and, typically, delegate to their leftmost
     * child patcher. Subclasses may return `false` when they will insert text at
     * the start of the node.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return false;
    }

    /**
     * Determines whether this patcher's node should add parentheses when used in
     * a statement context.
     */

  }, {
    key: 'statementShouldAddParens',
    value: function statementShouldAddParens() {
      return this.statementNeedsParens() && !this.isSurroundedByParentheses();
    }

    /**
     * Gets the tokens for the whole program.
     */

  }, {
    key: 'getProgramSourceTokens',
    value: function getProgramSourceTokens() {
      return this.context.sourceTokens;
    }

    /**
     * Gets the index of the token starting at a particular source index.
     */

  }, {
    key: 'indexOfSourceTokenStartingAtSourceIndex',
    value: function indexOfSourceTokenStartingAtSourceIndex(index) {
      return this.getProgramSourceTokens().indexOfTokenStartingAtSourceIndex(index);
    }

    /**
     * Gets the index of the token between left and right patchers that matches
     * a predicate function.
     */

  }, {
    key: 'indexOfSourceTokenBetweenPatchersMatching',
    value: function indexOfSourceTokenBetweenPatchersMatching(left, right, predicate) {
      return this.indexOfSourceTokenBetweenSourceIndicesMatching(left.outerEnd, right.outerStart, predicate);
    }

    /**
     * Gets the index of the token between source locations that matches a
     * predicate function.
     */

  }, {
    key: 'indexOfSourceTokenBetweenSourceIndicesMatching',
    value: function indexOfSourceTokenBetweenSourceIndicesMatching(left, right, predicate) {
      var tokenList = this.getProgramSourceTokens();
      return tokenList.indexOfTokenMatchingPredicate(function (token) {
        return token.start >= left && token.start <= right && predicate(token);
      }, tokenList.indexOfTokenNearSourceIndex(left), tokenList.indexOfTokenNearSourceIndex(right).next());
    }

    /**
     * Gets the token at a particular index.
     */

  }, {
    key: 'sourceTokenAtIndex',
    value: function sourceTokenAtIndex(index) {
      return this.getProgramSourceTokens().tokenAtIndex(index);
    }

    /**
     * Gets the source encompassed by the given token.
     */

  }, {
    key: 'sourceOfToken',
    value: function sourceOfToken(token) {
      return this.context.source.slice(token.start, token.end);
    }

    /**
     * Gets the first token in the content of this node.
     */

  }, {
    key: 'firstToken',
    value: function firstToken() {
      return this.sourceTokenAtIndex(this.contentStartTokenIndex);
    }

    /**
     * Gets the last token in the content of this node.
     */

  }, {
    key: 'lastToken',
    value: function lastToken() {
      return this.sourceTokenAtIndex(this.contentEndTokenIndex);
    }

    /**
     * Gets the token after the end of this node, or null if there is none.
     */

  }, {
    key: 'nextSemanticToken',
    value: function nextSemanticToken() {
      return this.getFirstSemanticToken(this.contentEnd, this.editor.original.length);
    }

    /**
     * Gets the original source of this patcher's node.
     */

  }, {
    key: 'getOriginalSource',
    value: function getOriginalSource() {
      return this.context.source.slice(this.contentStart, this.contentEnd);
    }

    /**
     * Determines whether this patcher's node spanned multiple lines.
     */

  }, {
    key: 'isMultiline',
    value: function isMultiline() {
      return (/\n/.test(this.getOriginalSource())
      );
    }

    /**
     * Gets the patched source of this patcher's node.
     */

  }, {
    key: 'getPatchedSource',
    value: function getPatchedSource() {
      return this.slice(this.contentStart, this.contentEnd);
    }

    /**
     * Gets the index of a token after `contentStart` with the matching type, ignoring
     * non-semantic types by default.
     */

  }, {
    key: 'indexOfSourceTokenAfterSourceTokenIndex',
    value: function indexOfSourceTokenAfterSourceTokenIndex(start, type) {
      var predicate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : isSemanticToken;

      var index = this.getProgramSourceTokens().indexOfTokenMatchingPredicate(predicate, start.next());
      if (!index) {
        return null;
      }
      var token = this.sourceTokenAtIndex(index);
      if (!token || token.type !== type) {
        return null;
      }
      return index;
    }

    /**
     * Determines whether this patcher's node is followed by a particular token.
     */

  }, {
    key: 'hasSourceTokenAfter',
    value: function hasSourceTokenAfter(type) {
      var predicate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : isSemanticToken;

      return this.indexOfSourceTokenAfterSourceTokenIndex(this.outerEndTokenIndex, type, predicate) !== null;
    }

    /**
     * Determines whether this patcher's node is surrounded by parentheses.
     * Also check if these parents are matching, to avoid false positives on things like `(a) && (b)`
     */

  }, {
    key: 'isSurroundedByParentheses',
    value: function isSurroundedByParentheses() {
      var beforeToken = this.sourceTokenAtIndex(this.outerStartTokenIndex);
      var afterToken = this.sourceTokenAtIndex(this.outerEndTokenIndex);

      if (!beforeToken || !afterToken) {
        return false;
      }

      var leftTokenType = coffeeLex.SourceType.LPAREN;
      var rightTokenType = coffeeLex.SourceType.RPAREN;

      if (beforeToken.type === coffeeLex.SourceType.LPAREN && afterToken.type === coffeeLex.SourceType.RPAREN) {
        // nothing
      } else if (beforeToken.type === coffeeLex.SourceType.CALL_START && afterToken.type === coffeeLex.SourceType.CALL_END) {
        leftTokenType = coffeeLex.SourceType.CALL_START;
        rightTokenType = coffeeLex.SourceType.CALL_END;
      } else {
        return false;
      }

      var parenRange = this.getProgramSourceTokens().rangeOfMatchingTokensContainingTokenIndex(leftTokenType, rightTokenType, this.outerStartTokenIndex);
      if (!parenRange) return false;
      var rparenIndex = parenRange[1].previous();
      var rparen = this.sourceTokenAtIndex(rparenIndex);
      return rparen === afterToken;
    }
  }, {
    key: 'surroundInParens',
    value: function surroundInParens() {
      if (!this.isSurroundedByParentheses()) {
        this.insert(this.outerStart, '(');
        this.insert(this.outerEnd, ')');
      }
    }
  }, {
    key: 'getBoundingPatcher',
    value: function getBoundingPatcher() {
      var _this5 = this;

      if (this.isSurroundedByParentheses()) {
        return this;
      } else if (this.parent) {
        if (this.isNodeFunctionApplication(this.parent.node) && this.parent.node.arguments.some(function (arg) {
          return arg === _this5.node;
        })) {
          return this;
        } else if (this.parent.node.type === 'ArrayInitialiser') {
          return this;
        } else if (this.parent.node.type === 'ObjectInitialiser') {
          return this;
        }
        return this.parent.getBoundingPatcher();
      } else {
        return this;
      }
    }
  }, {
    key: 'isNodeFunctionApplication',
    value: function isNodeFunctionApplication(node) {
      return node.type === 'FunctionApplication' || node.type === 'SoakedFunctionApplication' || node.type === 'NewOp';
    }

    /**
     * Determines whether this patcher's node can be negated without prepending
     * a `!`, which turns it into a unary operator node.
     */

  }, {
    key: 'canHandleNegationInternally',
    value: function canHandleNegationInternally() {
      return false;
    }

    /**
     * Negates this patcher's node when patching. Note that we add the `!` inside
     * any parens, since it's generally unsafe to insert code outside our
     * enclosing parens, and we need to handle the non-parenthesized case anyway.
     * Subclasses that need to worry about precedence (e.g. binary operators)
     * should override this method and do something more appropriate.
     */

  }, {
    key: 'negate',
    value: function negate() {
      this.insert(this.contentStart, '!');
    }

    /**
     * Gets the indent string for the line that starts this patcher's node.
     */

  }, {
    key: 'getIndent',
    value: function getIndent() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return adjustIndent(this.context.source, this.contentStart, this.getAdjustedIndentLevel() + offset);
    }

    /**
     * Force the indentation level of this node, adjusting it forward or backward
     * if necessary. This also sets the "adjusted indent" level, so that later
     * calls to getIndent will return this value.
     */

  }, {
    key: 'setIndent',
    value: function setIndent(indentStr) {
      var currentIndent = this.getIndent();
      var indentLength = this.getProgramIndentString().length;
      var currentIndentLevel = currentIndent.length / indentLength;
      var desiredIndentLevel = indentStr.length / indentLength;
      this.indent(desiredIndentLevel - currentIndentLevel);
    }

    /**
     * Get the amount the adjusted indent level differs from the original level.
     */

  }, {
    key: 'getAdjustedIndentLevel',
    value: function getAdjustedIndentLevel() {
      return this.adjustedIndentLevel + (this.parent ? this.parent.getAdjustedIndentLevel() : 0);
    }

    /**
     * Gets the indent string used for each indent in this program.
     */

  }, {
    key: 'getProgramIndentString',
    value: function getProgramIndentString() {
      return this.parent.getProgramIndentString();
    }

    /**
     * Indent this node a number of times. To unindent, pass a negative number.
     *
     * Note that because this method inserts indents immediately before the first
     * non-whitespace character of each line in the node's source, it should be
     * called *before* any other editing is done to the node's source to ensure
     * that strings inserted before child nodes appear after the indent, not
     * before.
     */

  }, {
    key: 'indent',
    value: function indent() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$skipFirstLine = _ref2.skipFirstLine,
          skipFirstLine = _ref2$skipFirstLine === undefined ? false : _ref2$skipFirstLine;

      if (offset === 0) {
        return;
      }

      this.adjustedIndentLevel += offset;
      var indentString = this.getProgramIndentString();
      var indentToChange = repeat(indentString, Math.abs(offset));
      var start = this.outerStart;
      var end = this.outerEnd;
      var source = this.context.source;

      // See if there are already non-whitespace characters before the start. If
      // so, skip the start to the next line, since we don't want to put
      // indentation in the middle of a line.

      if (skipFirstLine || !this.isFirstNodeInLine()) {
        while (start < end && source[start] !== '\n') {
          start++;
        }
      }

      var hasIndentedThisLine = false;
      for (var i = start; i < end; i++) {
        switch (source[i]) {
          case '\n':
            hasIndentedThisLine = false;
            break;

          case ' ':
          case '\t':
            break;

          default:
            if (!hasIndentedThisLine) {
              if (offset > 0) {
                this.insert(i, indentToChange);
              } else if (source.slice(i - indentToChange.length, i) === indentToChange) {
                this.remove(i - indentToChange.length, i);
              } else {
                // Ignore this case: we're trying to unindent a line that doesn't
                // start with enough indentation, or doesn't start with the right
                // type of indentation, e.g. it starts with spaces when the
                // program indent string is a tab. This can happen when a file
                // uses inconsistent indentation in different parts. We only
                // expect this to come up in the main stage, so getting
                // indentation wrong means ugly JS code that's still correct.
                this.log('Warning: Ignoring an unindent operation because the line ' + 'did not start with the proper indentation.');
              }
              hasIndentedThisLine = true;
            }
            break;
        }
      }
    }
  }, {
    key: 'isFirstNodeInLine',
    value: function isFirstNodeInLine() {
      var startingPoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.outerStart;
      var source = this.context.source;

      for (var i = startingPoint - 1; i >= 0 && source[i] !== '\n'; i--) {
        if (source[i] !== '\t' && source[i] !== ' ') {
          return false;
        }
      }
      return true;
    }

    /**
     * Gets the index ending the line following this patcher's node.
     *
     * @private
     */

  }, {
    key: 'getEndOfLine',
    value: function getEndOfLine() {
      var source = this.context.source;

      for (var i = this.outerEnd - '\n'.length; i < source.length; i++) {
        if (source[i] === '\n') {
          return i;
        }
      }
      return source.length;
    }

    /**
     * Appends the given content on a new line after the end of the current line.
     */

  }, {
    key: 'appendLineAfter',
    value: function appendLineAfter(content) {
      var indentOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      var boundingPatcher = this.getBoundingPatcher();
      var endOfLine = this.getEndOfLine();
      this.insert(Math.min(endOfLine, boundingPatcher.innerEnd), '\n' + this.getIndent(indentOffset) + content);
    }

    /**
     * Appends the given content at the end of the current line.
     */

  }, {
    key: 'appendToEndOfLine',
    value: function appendToEndOfLine(content) {
      var boundingPatcher = this.getBoundingPatcher();
      var endOfLine = this.getEndOfLine();
      this.insert(Math.min(endOfLine, boundingPatcher.innerEnd), content);
    }

    /**
     * Generate an error referring to a particular section of the source.
     */

  }, {
    key: 'error',
    value: function error(message) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.contentStart;
      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.contentEnd;

      var _error = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var patcherError = new PatchError(message, this.context.source, start, end, _error);
      if (_error) {
        patcherError.stack = _error.stack;
      }
      return patcherError;
    }

    /**
     * Register a helper to be reused in several places.
     */

  }, {
    key: 'registerHelper',
    value: function registerHelper(name, code) {
      return this.parent.registerHelper(name, code);
    }

    /**
     * Determines whether this node can be repeated without side-effects. Most
     * nodes are not repeatable, so that is the default. Subclasses should
     * override this to indicate whether they are repeatable without any changes.
     */

  }, {
    key: 'isRepeatable',
    value: function isRepeatable() {
      return false;
    }

    /**
     * Indicate to this patcher that patching should be done in a way that makes
     * it possible to reference the value afterward with no additional
     * side-effects.
     */

  }, {
    key: 'setRequiresRepeatableExpression',
    value: function setRequiresRepeatableExpression() {
      var repeatableOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this._repeatableOptions = repeatableOptions;
    }

    /**
     * Check if this expression has been marked as repeatable. Generally this
     * should only be used for advanced cases, like transferring the repeat code
     * result from one patcher to another.
     */

  }, {
    key: 'isSetAsRepeatableExpression',
    value: function isSetAsRepeatableExpression() {
      return Boolean(this._repeatableOptions);
    }

    /**
     * Get the code snippet computed from patchAsRepeatableExpression that can be
     * used to refer to the result of this expression without further
     * side-effects.
     */

  }, {
    key: 'getRepeatCode',
    value: function getRepeatCode() {
      if (this._repeatCode === undefined) {
        throw new Error('Must patch as a repeatable expression to access repeat code.');
      }
      return this._repeatCode;
    }

    /**
     * Explicitly set the repeatable result. Generally this should only be used
     * for advanced cases, like transferring the repeat code result from one
     * patcher to another.
     */

  }, {
    key: 'overrideRepeatCode',
    value: function overrideRepeatCode(repeatCode) {
      this._repeatCode = repeatCode;
    }

    /**
     * Claim a binding that is unique in the current scope.
     */

  }, {
    key: 'claimFreeBinding',
    value: function claimFreeBinding() {
      var ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      return this.node.scope.claimFreeBinding(this.node, ref);
    }

    /**
     * Determines whether all the possible code paths in this node are present.
     */

  }, {
    key: 'allCodePathsPresent',
    value: function allCodePathsPresent() {
      return true;
    }

    /**
     * Gets the first "interesting token" in the indexed range (default range is `this` + parent)
     */

  }, {
    key: 'getFirstSemanticToken',
    value: function getFirstSemanticToken() {
      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.contentStart;
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.parent.contentEnd;

      var nextSemanticIdx = this.indexOfSourceTokenBetweenSourceIndicesMatching(from, to, isSemanticToken);
      return nextSemanticIdx && this.sourceTokenAtIndex(nextSemanticIdx);
    }

    /**
     * Determine if we need to do a `typeof` check in a conditional for this
     * value, to guard against the case where this node is a variable that doesn't
     * exist. IdentifierPatcher overrides this to check the current scope.
     */

  }, {
    key: 'mayBeUnboundReference',
    value: function mayBeUnboundReference() {
      return false;
    }
  }, {
    key: 'patchInIIFE',
    value: function patchInIIFE(innerPatchFn) {
      if (this.yielding) {
        this.insert(this.innerStart, 'yield* (function*() {');
      } else {
        this.insert(this.innerStart, '(() => {');
      }
      innerPatchFn();
      if (this.yielding) {
        if (this.referencesArguments()) {
          this.insert(this.innerEnd, '}).apply(this, arguments)');
        } else {
          this.insert(this.innerEnd, '}).call(this)');
        }
      } else {
        this.insert(this.innerEnd, '})()');
      }
    }
  }, {
    key: 'yields',
    value: function yields() {
      this.yielding = true;
      if (this.parent && !isFunction(this.parent.node)) {
        this.parent.yields();
      }
    }

    /**
     * @private
     */

  }, {
    key: 'referencesArguments',
    value: function referencesArguments() {
      var result = false;

      traverse(this.node, function (node) {
        if (result || isFunction(node)) {
          return false;
        }

        if (node.type === 'Identifier' && node.data === 'arguments') {
          result = true;
        }
      });

      return result;
    }
  }], [{
    key: 'patcherClassForChildNode',
    value: function patcherClassForChildNode() {
      return null;
    }

    /**
     * Allow patcher classes that would patch a node to chose a different class.
     */

  }, {
    key: 'patcherClassOverrideForNode',
    value: function patcherClassOverrideForNode(node) {
      // eslint-disable-line no-unused-vars
      return null;
    }
  }]);
  return NodePatcher;
}();

var ExpansionPatcher = function (_NodePatcher) {
  inherits(ExpansionPatcher, _NodePatcher);

  function ExpansionPatcher() {
    classCallCheck(this, ExpansionPatcher);
    return possibleConstructorReturn(this, (ExpansionPatcher.__proto__ || Object.getPrototypeOf(ExpansionPatcher)).apply(this, arguments));
  }

  createClass(ExpansionPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      // Any code handling expansions should process them without calling patch.
      // If patch ends up being called, then that means that we've hit an
      // unsupported case that's trying to treat this node as a normal expression.
      throw this.error('expansions (e.g. `[a, ..., b] = c`) are not supported yet in all ' + 'cases, see https://github.com/decaffeinate/decaffeinate/issues/268');
    }
  }]);
  return ExpansionPatcher;
}(NodePatcher);

var ArrayInitialiserPatcher = function (_NodePatcher) {
  inherits(ArrayInitialiserPatcher, _NodePatcher);

  function ArrayInitialiserPatcher(patcherContext, members) {
    classCallCheck(this, ArrayInitialiserPatcher);

    var _this = possibleConstructorReturn(this, (ArrayInitialiserPatcher.__proto__ || Object.getPrototypeOf(ArrayInitialiserPatcher)).call(this, patcherContext));

    _this.members = members;
    return _this;
  }

  createClass(ArrayInitialiserPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.members.forEach(function (member) {
        return member.setRequiresExpression();
      });
    }
  }, {
    key: 'setAssignee',
    value: function setAssignee() {
      this.members.forEach(function (member) {
        return member.setAssignee();
      });
      get(ArrayInitialiserPatcher.prototype.__proto__ || Object.getPrototypeOf(ArrayInitialiserPatcher.prototype), 'setAssignee', this).call(this);
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _this2 = this;

      this.members.forEach(function (member, i, members) {
        var isLast = i === members.length - 1;

        // An expansion in a final position is a no-op, so just remove it.
        if (isLast && member instanceof ExpansionPatcher) {
          _this2.remove(members[i - 1].outerEnd, member.outerEnd);
          return;
        }

        var needsComma = !isLast && !member.hasSourceTokenAfter(coffeeLex.SourceType.COMMA);
        member.patch();
        if (needsComma) {
          _this2.insert(member.outerEnd, ',');
        }
      });
    }
  }]);
  return ArrayInitialiserPatcher;
}(NodePatcher);

var ConditionalPatcher = function (_NodePatcher) {
  inherits(ConditionalPatcher, _NodePatcher);

  function ConditionalPatcher(patcherContext, condition, consequent, alternate) {
    classCallCheck(this, ConditionalPatcher);

    var _this = possibleConstructorReturn(this, (ConditionalPatcher.__proto__ || Object.getPrototypeOf(ConditionalPatcher)).call(this, patcherContext));

    _this.negated = false;

    _this.condition = condition;
    _this.consequent = consequent;
    _this.alternate = alternate;
    return _this;
  }

  createClass(ConditionalPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.condition.setRequiresExpression();
    }
  }, {
    key: 'prefersToPatchAsExpression',
    value: function prefersToPatchAsExpression() {
      var consequent = this.consequent,
          alternate = this.alternate;

      if (!consequent || !alternate) {
        return false;
      }
      return consequent.prefersToPatchAsExpression() && alternate.prefersToPatchAsExpression();
    }
  }, {
    key: 'setExpression',
    value: function setExpression() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      var willPatchAsExpression = get(ConditionalPatcher.prototype.__proto__ || Object.getPrototypeOf(ConditionalPatcher.prototype), 'setExpression', this).call(this, force);
      if (willPatchAsExpression && this.willPatchAsTernary()) {
        if (this.consequent) {
          this.consequent.setRequiresExpression();
        }
        if (this.alternate) {
          this.alternate.setRequiresExpression();
        }
      }
    }
  }, {
    key: 'negate',
    value: function negate() {
      this.negated = !this.negated;
    }
  }, {
    key: 'willPatchAsTernary',
    value: function willPatchAsTernary() {
      return this.prefersToPatchAsExpression() || this.forcedToPatchAsExpression() && (!this.consequent || this.consequent.prefersToPatchAsExpression()) && (!this.alternate || this.alternate.prefersToPatchAsExpression());
    }

    /**
     * @private
     */

  }, {
    key: 'willPatchAsIIFE',
    value: function willPatchAsIIFE() {
      return !this.willPatchAsTernary() && this.forcedToPatchAsExpression();
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          needsParens = _ref.needsParens;

      var addParens = this.negated || needsParens && !this.isSurroundedByParentheses();

      // `if a then b` → `a then b`
      //  ^^^
      this.overwrite(this.contentStart, this.condition.outerStart, '' + (this.negated ? '!' : '') + (addParens ? '(' : ''));

      if (this.node.isUnless) {
        this.condition.negate();
      }

      this.condition.patch();

      var thenTokenIndex = this.getThenTokenIndex();
      if (thenTokenIndex) {
        var thenToken = this.sourceTokenAtIndex(thenTokenIndex);
        // `a then b` → `a ? b`
        //    ^^^^         ^
        this.overwrite(thenToken.start, thenToken.end, '?');
      } else {
        // `a b` → `a ? b`
        //           ^^
        this.insert(this.condition.outerEnd, ' ?');
      }

      var elseTokenIndex = this.getElseSourceTokenIndex();
      var elseToken = elseTokenIndex && this.sourceTokenAtIndex(elseTokenIndex);

      var consequent = this.consequent,
          alternate = this.alternate;

      if (consequent && alternate) {
        consequent.patch();
        // `a ? b else c` → `a ? b : c`
        this.overwrite(elseToken.start, elseToken.end, ':');
        alternate.patch();
      } else if (consequent && !alternate) {
        consequent.patch();
        // `a ? b` → `a ? b : undefined`
        if (elseToken !== null) {
          this.overwrite(elseToken.start, elseToken.end, ' : undefined');
        } else {
          this.insert(this.consequent.outerEnd, ' : undefined');
        }
      } else if (alternate) {
        this.overwrite(elseToken.start, elseToken.end, 'undefined :');
        alternate.patch();
      }

      if (addParens) {
        this.insert(this.contentEnd, ')');
      }
    }
  }, {
    key: 'patchAsForcedExpression',
    value: function patchAsForcedExpression() {
      if (this.willPatchAsTernary()) {
        // We didn't want to be an expression because we don't have an alternate,
        // which means that the alternate of a generated ternary would be
        // `undefined`, which is ugly (i.e. `if a then b` → `a ? b : undefined`).
        // TODO: Generate a `do` expression instead? (i.e. `do { if (a) { b; } }`)
        this.patchAsExpression();
      } else if (this.willPatchAsIIFE()) {
        this.patchAsIIFE();
      }
    }
  }, {
    key: 'patchAsIIFE',
    value: function patchAsIIFE() {
      var _this2 = this;

      if (this.negated) {
        this.insert(this.innerStart, '!');
      }

      // We're only patched as an expression due to a parent instructing us to,
      // and the indent level is more logically the indent level of our parent.
      var baseIndent = this.parent.getIndent(0);
      var conditionIndent = this.parent.getIndent(1);
      if (this.consequent) {
        this.consequent.setShouldPatchInline(false);
        this.consequent.setImplicitlyReturns();
      }
      if (this.alternate) {
        this.alternate.setShouldPatchInline(false);
        this.alternate.setImplicitlyReturns();
      }
      this.patchInIIFE(function () {
        _this2.insert(_this2.innerStart, '\n' + conditionIndent);
        _this2.patchAsStatement();
        _this2.insert(_this2.innerEnd, '\n' + baseIndent);
      });
    }
  }, {
    key: 'canHandleImplicitReturn',
    value: function canHandleImplicitReturn() {
      return this.willPatchAsIIFE();
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      this.patchConditionForStatement();
      this.patchConsequentForStatement();
      this.patchAlternateForStatement();
    }

    /**
     * @private
     */

  }, {
    key: 'patchConditionForStatement',
    value: function patchConditionForStatement() {
      // `unless a` → `if a`
      //  ^^^^^^        ^^
      var ifToken = this.sourceTokenAtIndex(this.getIfSourceTokenIndex());
      this.overwrite(ifToken.start, ifToken.end, 'if');

      var conditionHasParentheses = this.condition.isSurroundedByParentheses();
      if (!conditionHasParentheses) {
        // `if a` → `if (a`
        //              ^
        this.insert(this.condition.outerStart, '(');
      }
      if (this.node.isUnless) {
        this.condition.negate();
      }
      this.condition.patch({ needsParens: false });
      if (!conditionHasParentheses) {
        // `if (a` → `if (a)`
        //                  ^
        this.insert(this.condition.outerEnd, ')');
      }

      var thenTokenIndex = this.getThenTokenIndex();
      if (thenTokenIndex) {
        var thenToken = this.sourceTokenAtIndex(thenTokenIndex);
        // `if (a) then b` → `if (a) b`
        //         ^^^^^
        this.remove(thenToken.start, this.consequent.outerStart);
      }
    }

    /**
     * @private
     */

  }, {
    key: 'patchConsequentForStatement',
    value: function patchConsequentForStatement() {
      this.insert(this.condition.outerEnd, ' {');

      if (this.alternate) {
        var elseTokenIndex = this.getElseSourceTokenIndex();
        var elseToken = this.sourceTokenAtIndex(elseTokenIndex);
        var rightBracePosition = elseToken.start;
        if (this.consequent !== null) {
          this.consequent.patch({ leftBrace: false, rightBrace: false });
        }
        this.insert(rightBracePosition, '} ');
      } else {
        if (this.consequent !== null) {
          this.consequent.patch({ leftBrace: false });
        } else {
          this.insert(this.condition.outerEnd, '} ');
        }
      }
    }

    /**
     * @private
     */

  }, {
    key: 'patchAlternateForStatement',
    value: function patchAlternateForStatement() {
      var elseTokenIndex = this.getElseSourceTokenIndex();
      if (this.alternate) {
        var ifToken = this.sourceTokenAtIndex(elseTokenIndex.next());
        var isElseIf = ifToken ? ifToken.type === coffeeLex.SourceType.IF : false;
        if (isElseIf) {
          // Let the nested ConditionalPatcher handle braces.
          this.alternate.patch({ leftBrace: false, rightBrace: false });
        } else {
          var elseToken = this.sourceTokenAtIndex(elseTokenIndex);
          var leftBracePosition = elseToken.end;
          this.insert(leftBracePosition, ' {');
          this.alternate.patch({ leftBrace: false });
        }
      } else if (elseTokenIndex !== null) {
        var _elseToken = this.sourceTokenAtIndex(elseTokenIndex);
        this.insert(_elseToken.end, ' {}');
      }
    }

    /**
     * If we ended up as a statement, then we know our children are set as
     * implicit return nodes, so no need to turn the conditional into an
     * expression for implicit return purposes.
     */

  }, {
    key: 'implicitlyReturns',
    value: function implicitlyReturns() {
      return get(ConditionalPatcher.prototype.__proto__ || Object.getPrototypeOf(ConditionalPatcher.prototype), 'implicitlyReturns', this).call(this) && this.willPatchAsExpression();
    }
  }, {
    key: 'setImplicitlyReturns',
    value: function setImplicitlyReturns() {
      get(ConditionalPatcher.prototype.__proto__ || Object.getPrototypeOf(ConditionalPatcher.prototype), 'setImplicitlyReturns', this).call(this);
      if (this.consequent) {
        this.consequent.setImplicitlyReturns();
      }
      if (this.alternate) {
        this.alternate.setImplicitlyReturns();
      }
    }

    /**
     * Conditionals do not need semicolons when used as statements.
     */

  }, {
    key: 'statementNeedsSemicolon',
    value: function statementNeedsSemicolon() {
      return false;
    }

    /**
     * Gets the index of the token representing the `if` at the start.
     *
     * @private
     */

  }, {
    key: 'getIfSourceTokenIndex',
    value: function getIfSourceTokenIndex() {
      var ifTokenIndex = this.indexOfSourceTokenStartingAtSourceIndex(this.contentStart);
      if (!ifTokenIndex) {
        throw this.error('expected IF token at start of conditional');
      }
      var ifToken = this.sourceTokenAtIndex(ifTokenIndex);
      if (ifToken.type !== coffeeLex.SourceType.IF) {
        throw this.error('expected IF token at start of conditional, but got ' + coffeeLex.SourceType[ifToken.type]);
      }
      return ifTokenIndex;
    }
    /**
     * Gets the index of the token representing the `else` between consequent and
     * alternate.
     *
     * @private
     */

  }, {
    key: 'getElseSourceTokenIndex',
    value: function getElseSourceTokenIndex() {
      var elseTokenIndex = this.indexOfSourceTokenBetweenSourceIndicesMatching(this.consequent !== null ? this.consequent.outerEnd : this.condition.outerEnd, this.alternate !== null ? this.alternate.outerStart : this.outerEnd, function (token) {
        return token.type === coffeeLex.SourceType.ELSE;
      });
      if (this.alternate !== null && !elseTokenIndex) {
        throw this.error('expected ELSE token between consequent and alternate', this.consequent.outerEnd, this.alternate.outerStart);
      }
      return elseTokenIndex;
    }

    /**
     * Gets the index of the token representing the `then` between condition and
     * consequent.
     *
     * @private
     */

  }, {
    key: 'getThenTokenIndex',
    value: function getThenTokenIndex() {
      if (this.consequent === null) {
        return null;
      }
      return this.indexOfSourceTokenBetweenPatchersMatching(this.condition, this.consequent, function (token) {
        return token.type === coffeeLex.SourceType.THEN;
      });
    }

    /**
     * Conditionals have all code paths if there is an `else` and both the
     * consequent and alternate have all their code paths.
     */

  }, {
    key: 'allCodePathsPresent',
    value: function allCodePathsPresent() {
      if (!this.consequent || !this.alternate) {
        return false;
      }

      return this.consequent.allCodePathsPresent() && this.alternate.allCodePathsPresent();
    }
  }]);
  return ConditionalPatcher;
}(NodePatcher);

var DefaultParamPatcher = function (_NodePatcher) {
  inherits(DefaultParamPatcher, _NodePatcher);

  function DefaultParamPatcher(patcherContext, param, value) {
    classCallCheck(this, DefaultParamPatcher);

    var _this = possibleConstructorReturn(this, (DefaultParamPatcher.__proto__ || Object.getPrototypeOf(DefaultParamPatcher)).call(this, patcherContext));

    _this.param = param;
    _this.value = value;
    return _this;
  }

  createClass(DefaultParamPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.param.setRequiresExpression();
      this.value.setRequiresExpression();
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.param.patch();
      this.value.patch();
    }
  }]);
  return DefaultParamPatcher;
}(NodePatcher);

var FunctionApplicationPatcher = function (_NodePatcher) {
  inherits(FunctionApplicationPatcher, _NodePatcher);

  function FunctionApplicationPatcher(patcherContext, fn, args) {
    classCallCheck(this, FunctionApplicationPatcher);

    var _this = possibleConstructorReturn(this, (FunctionApplicationPatcher.__proto__ || Object.getPrototypeOf(FunctionApplicationPatcher)).call(this, patcherContext));

    _this.fn = fn;
    _this.args = args;
    return _this;
  }

  createClass(FunctionApplicationPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.fn.setRequiresExpression();
      this.args.forEach(function (arg) {
        return arg.setRequiresExpression();
      });
    }

    /**
     * Note that we don't need to worry about implicit function applications,
     * since the normalize stage would have already added parens.
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _this2 = this;

      var args = this.args,
          outerEndTokenIndex = this.outerEndTokenIndex;


      this.fn.patch();

      args.forEach(function (arg, i) {
        arg.patch();
        var isLast = i === args.length - 1;
        var commaTokenIndex = _this2.indexOfSourceTokenAfterSourceTokenIndex(arg.outerEndTokenIndex, coffeeLex.SourceType.COMMA, isSemanticToken);
        // Ignore commas after the end of the function call.
        if (commaTokenIndex && commaTokenIndex.compare(outerEndTokenIndex) <= 0) {
          commaTokenIndex = null;
        }
        var commaToken = commaTokenIndex && _this2.sourceTokenAtIndex(commaTokenIndex);
        if (isLast && commaToken) {
          _this2.remove(arg.outerEnd, commaToken.end);
        } else if (!isLast && !commaToken) {
          _this2.insert(arg.outerEnd, ',');
        }
      });
    }

    /**
     * Probably can't happen, but just for completeness.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return this.fn.statementShouldAddParens();
    }
  }]);
  return FunctionApplicationPatcher;
}(NodePatcher);

var FunctionPatcher = function (_NodePatcher) {
  inherits(FunctionPatcher, _NodePatcher);

  function FunctionPatcher(patcherContext, parameters, body) {
    classCallCheck(this, FunctionPatcher);

    var _this = possibleConstructorReturn(this, (FunctionPatcher.__proto__ || Object.getPrototypeOf(FunctionPatcher)).call(this, patcherContext));

    _this.parameters = parameters;
    _this.body = body;
    return _this;
  }

  createClass(FunctionPatcher, [{
    key: 'initialize',
    value: function initialize() {
      if (this.body && !this.implicitReturnsDisabled()) {
        this.body.setImplicitlyReturns();
      }
      this.parameters.forEach(function (param) {
        param.setAssignee();
        param.setRequiresExpression();
      });
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _this2 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$method = _ref.method,
          method = _ref$method === undefined ? false : _ref$method;

      this.patchFunctionStart({ method: method });
      this.parameters.forEach(function (parameter, i) {
        var isLast = i === _this2.parameters.length - 1;
        var needsComma = !isLast && !parameter.hasSourceTokenAfter(coffeeLex.SourceType.COMMA);
        parameter.patch();
        if (needsComma) {
          _this2.insert(parameter.outerEnd, ',');
        }
      });
      this.patchFunctionBody({ method: method });
    }
  }, {
    key: 'patchFunctionStart',
    value: function patchFunctionStart(_ref2) {
      var _ref2$method = _ref2.method,
          method = _ref2$method === undefined ? false : _ref2$method;

      var arrow = this.getArrowToken();

      if (!method) {
        this.insert(this.contentStart, 'function');
      }

      if (!this.hasParamStart()) {
        this.insert(this.contentStart, '() ');
      }

      this.overwrite(arrow.start, arrow.end, '{');
    }
  }, {
    key: 'patchFunctionBody',
    value: function patchFunctionBody() {
      if (this.body) {
        if (this.isSurroundedByParentheses()) {
          this.body.patch({ leftBrace: false, rightBrace: false });
          this.insert(this.innerEnd, this.body.inline() ? ' }' : '}');
        } else if (this.isEndOfFunctionCall()) {
          this.body.patch({ leftBrace: false, rightBrace: false });
          this.placeCloseBraceBeforeFunctionCallEnd();
        } else {
          this.body.patch({ leftBrace: false });
        }
      } else {
        // No body, so BlockPatcher can't insert it for us.
        this.insert(this.innerEnd, '}');
      }
    }
  }, {
    key: 'isEndOfFunctionCall',
    value: function isEndOfFunctionCall() {
      return this.parent instanceof FunctionApplicationPatcher && this.parent.args[this.parent.args.length - 1] === this;
    }

    /**
     * If we're the last argument to a function, place the } just before the
     * close-paren. There will always be a close-paren because all implicit
     * parentheses were added in the normalize stage.
     *
     * However, if the close-paren is at the end of our line, it usually looks
     * better to put the }) on the next line instead.
     */

  }, {
    key: 'placeCloseBraceBeforeFunctionCallEnd',
    value: function placeCloseBraceBeforeFunctionCallEnd() {
      var closeParenIndex = this.parent.indexOfSourceTokenBetweenSourceIndicesMatching(this.contentEnd, this.parent.contentEnd, function (token) {
        return token.type === coffeeLex.SourceType.CALL_END || token.type === coffeeLex.SourceType.RPAREN;
      });
      var closeParen = this.sourceTokenAtIndex(closeParenIndex);
      var shouldMoveCloseParen = !this.body.inline() && !this.slice(this.contentEnd, closeParen.start).includes('\n');
      if (shouldMoveCloseParen) {
        this.appendLineAfter('}', -1);
      } else {
        this.insert(closeParen.start, this.body.inline() ? ' }' : '}');
      }
    }
  }, {
    key: 'getArrowToken',
    value: function getArrowToken() {
      var arrowIndex = this.contentStartTokenIndex;
      if (this.hasParamStart()) {
        var parenRange = this.getProgramSourceTokens().rangeOfMatchingTokensContainingTokenIndex(coffeeLex.SourceType.LPAREN, coffeeLex.SourceType.RPAREN, this.contentStartTokenIndex);
        var rparenIndex = parenRange[1].previous();
        arrowIndex = this.indexOfSourceTokenAfterSourceTokenIndex(rparenIndex, coffeeLex.SourceType.FUNCTION);
      }
      var arrow = this.sourceTokenAtIndex(arrowIndex);
      var expectedArrowType = this.expectedArrowType();
      var actualArrowType = this.sourceOfToken(arrow);
      if (actualArrowType !== expectedArrowType) {
        throw this.error('expected \'' + expectedArrowType + '\' but found ' + actualArrowType, arrow.start, arrow.end);
      }
      return arrow;
    }
  }, {
    key: 'expectedArrowType',
    value: function expectedArrowType() {
      return '->';
    }
  }, {
    key: 'hasParamStart',
    value: function hasParamStart() {
      return this.sourceTokenAtIndex(this.contentStartTokenIndex).type === coffeeLex.SourceType.LPAREN;
    }
  }, {
    key: 'canHandleImplicitReturn',
    value: function canHandleImplicitReturn() {
      return true;
    }
  }, {
    key: 'setExplicitlyReturns',
    value: function setExplicitlyReturns() {}
    // Stop propagation of return info at functions.


    /**
     * Call before initialization to prevent this function from implicitly
     * returning its last statement.
     */

  }, {
    key: 'disableImplicitReturns',
    value: function disableImplicitReturns() {
      this._implicitReturnsDisabled = true;
    }

    /**
     * Determines whether this function has implicit returns disabled.
     */

  }, {
    key: 'implicitReturnsDisabled',
    value: function implicitReturnsDisabled() {
      return this._implicitReturnsDisabled;
    }

    /**
     * Functions in CoffeeScript are always anonymous and therefore need parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return true;
    }
  }, {
    key: 'containsSuperCall',
    value: function containsSuperCall() {
      var foundSuper = false;
      traverse(this.node, function (child) {
        if (foundSuper) {
          // Already found it, skip this one.
          return false;
        } else if (child.type === 'Super') {
          // Found it.
          foundSuper = true;
        } else if (child.type === 'Class') {
          // Don't go into other classes.
          return false;
        }
      });
      return foundSuper;
    }
  }]);
  return FunctionPatcher;
}(NodePatcher);

var PassthroughPatcher = function (_NodePatcher) {
  inherits(PassthroughPatcher, _NodePatcher);

  function PassthroughPatcher(patcherContext) {
    classCallCheck(this, PassthroughPatcher);

    var _this = possibleConstructorReturn(this, (PassthroughPatcher.__proto__ || Object.getPrototypeOf(PassthroughPatcher)).call(this, patcherContext));

    for (var _len = arguments.length, children = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      children[_key - 1] = arguments[_key];
    }

    _this.children = children;
    return _this;
  }

  createClass(PassthroughPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.children.forEach(function (child) {
        if (Array.isArray(child)) {
          child.forEach(function (child) {
            return child && child.patch();
          });
        } else if (child) {
          child.patch();
        }
      });
    }
  }, {
    key: 'isRepeatable',
    value: function isRepeatable() {
      return true;
    }
  }]);
  return PassthroughPatcher;
}(NodePatcher);

var IdentifierPatcher = function (_PassthroughPatcher) {
  inherits(IdentifierPatcher, _PassthroughPatcher);

  function IdentifierPatcher() {
    classCallCheck(this, IdentifierPatcher);
    return possibleConstructorReturn(this, (IdentifierPatcher.__proto__ || Object.getPrototypeOf(IdentifierPatcher)).apply(this, arguments));
  }

  createClass(IdentifierPatcher, [{
    key: 'isRepeatable',
    value: function isRepeatable() {
      return true;
    }

    /**
     * Determine if this identifier might refer to a non-existent variable. In
     * that case, some code paths need to emit a `typeof` check to ensure that
     * we don't crash if this variable hasn't been declared.
     */

  }, {
    key: 'mayBeUnboundReference',
    value: function mayBeUnboundReference() {
      return !this.node.scope.hasBinding(this.node.data);
    }
  }]);
  return IdentifierPatcher;
}(PassthroughPatcher);

var DoOpPatcher = function (_NodePatcher) {
  inherits(DoOpPatcher, _NodePatcher);

  function DoOpPatcher(patcherContext, expression) {
    classCallCheck(this, DoOpPatcher);

    var _this = possibleConstructorReturn(this, (DoOpPatcher.__proto__ || Object.getPrototypeOf(DoOpPatcher)).call(this, patcherContext));

    _this.expression = expression;
    return _this;
  }

  createClass(DoOpPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.expression.setRequiresExpression();
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _this2 = this;

      var doTokenIndex = this.getDoTokenIndex();
      var doToken = this.sourceTokenAtIndex(doTokenIndex);
      var nextToken = this.sourceTokenAtIndex(doTokenIndex.next());
      this.remove(doToken.start, nextToken.start);

      var addParens = !this.isSurroundedByParentheses() && !(this.expression instanceof IdentifierPatcher);

      if (addParens) {
        this.insert(this.outerStart, '(');
      }

      this.expression.patch();

      if (addParens) {
        this.insert(this.outerEnd, ')');
      }

      var args = [];
      if (this.hasDoFunction()) {
        var func = this.getDoFunction();
        func.parameters.forEach(function (param) {
          if (param instanceof DefaultParamPatcher) {
            var valueSource = param.value.getPatchedSource();
            _this2.remove(param.param.outerEnd, param.value.outerEnd);
            args.push(valueSource);
          } else {
            args.push(param.getPatchedSource());
          }
        });
      }
      this.insert(this.innerEnd, '(' + args.join(', ') + ')');
    }

    /**
     * Determine whether there is a "do function"--that is, a function where we
     * should change default params to arguments to the do call.
     */

  }, {
    key: 'hasDoFunction',
    value: function hasDoFunction() {
      return this.expression instanceof FunctionPatcher || this.expression instanceof AssignOpPatcher && this.expression.expression instanceof FunctionPatcher;
    }
  }, {
    key: 'getDoFunction',
    value: function getDoFunction() {
      if (this.expression instanceof FunctionPatcher) {
        return this.expression;
      } else if (this.expression instanceof AssignOpPatcher && this.expression.expression instanceof FunctionPatcher) {
        return this.expression.expression;
      } else {
        throw this.error('Should only call getDoFunction if hasDoFunction is true.');
      }
    }

    /**
     * @private
     */

  }, {
    key: 'getDoTokenIndex',
    value: function getDoTokenIndex() {
      var index = this.contentStartTokenIndex;
      var token = this.sourceTokenAtIndex(index);
      if (!token || token.type !== coffeeLex.SourceType.DO) {
        throw this.error('expected \'do\' at start of expression');
      }
      return index;
    }
  }]);
  return DoOpPatcher;
}(NodePatcher);

var DynamicMemberAccessOpPatcher = function (_NodePatcher) {
  inherits(DynamicMemberAccessOpPatcher, _NodePatcher);

  function DynamicMemberAccessOpPatcher(patcherContext, expression, indexingExpr) {
    classCallCheck(this, DynamicMemberAccessOpPatcher);

    var _this = possibleConstructorReturn(this, (DynamicMemberAccessOpPatcher.__proto__ || Object.getPrototypeOf(DynamicMemberAccessOpPatcher)).call(this, patcherContext));

    _this.expression = expression;
    _this.indexingExpr = indexingExpr;
    return _this;
  }

  createClass(DynamicMemberAccessOpPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.expression.setRequiresExpression();
      this.indexingExpr.setRequiresExpression();
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.expression.patch();
      this.indexingExpr.patch();
    }

    /**
     * We can make dynamic member access repeatable by making both parts
     * repeatable if they aren't already. We do that by giving them names and
     * referring to those names in a new dynamic member access. We cannot simply
     * save the value of the member access because this could be used as the LHS
     * of an assignment.
     */

  }, {
    key: 'patchAsRepeatableExpression',
    value: function patchAsRepeatableExpression() {
      var repeatableOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var patchOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (repeatableOptions.isForAssignment) {
        this.expression.setRequiresRepeatableExpression({ isForAssignment: true, parens: true, ref: 'base' });
        this.indexingExpr.setRequiresRepeatableExpression({ ref: 'name' });
        this.patchAsExpression();
        this.commitDeferredSuffix();
        return this.expression.getRepeatCode() + '[' + this.indexingExpr.getRepeatCode() + ']';
      } else {
        return get(DynamicMemberAccessOpPatcher.prototype.__proto__ || Object.getPrototypeOf(DynamicMemberAccessOpPatcher.prototype), 'patchAsRepeatableExpression', this).call(this, repeatableOptions, patchOptions);
      }
    }

    /**
     * CoffeeScript considers dynamic member access repeatable if both parts
     * are themselves repeatable. So, for example, `a[0]` is repeatable because
     * both `a` and `0` are repeatable, but `a()[0]` and `a[b()]` are not.
     */

  }, {
    key: 'isRepeatable',
    value: function isRepeatable() {
      return this.expression.isRepeatable() && this.indexingExpr.isRepeatable();
    }

    /**
     * If `BASE` needs parens, then `BASE[INDEX]` needs parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return this.expression.statementShouldAddParens();
    }
  }]);
  return DynamicMemberAccessOpPatcher;
}(NodePatcher);

var MemberAccessOpPatcher = function (_NodePatcher) {
  inherits(MemberAccessOpPatcher, _NodePatcher);

  function MemberAccessOpPatcher(patcherContext, expression, member) {
    classCallCheck(this, MemberAccessOpPatcher);

    var _this = possibleConstructorReturn(this, (MemberAccessOpPatcher.__proto__ || Object.getPrototypeOf(MemberAccessOpPatcher)).call(this, patcherContext));

    _this.expression = expression;
    _this.member = member;
    _this._skipImplicitDotCreation = false;
    return _this;
  }

  createClass(MemberAccessOpPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.expression.setRequiresExpression();
    }
  }, {
    key: 'setSkipImplicitDotCreation',
    value: function setSkipImplicitDotCreation() {
      this._skipImplicitDotCreation = true;
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      if (this.lhsNeedsParens()) {
        this.insert(this.expression.outerStart, '(');
      }
      this.expression.patch();
      if (this.lhsNeedsParens()) {
        this.insert(this.expression.outerEnd, ')');
      }
      if (this.hasImplicitOperator() && !this._skipImplicitDotCreation) {
        // `@a` → `@.a`
        //          ^
        this.insert(this.expression.outerEnd, '.');
      }
    }

    /**
     * We can make member accesses repeatable by making the base expression
     * repeatable if it isn't already.
     */

  }, {
    key: 'patchAsRepeatableExpression',
    value: function patchAsRepeatableExpression() {
      var repeatableOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var patchOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // eslint-disable-line no-unused-vars
      if (repeatableOptions.isForAssignment) {
        this.expression.setRequiresRepeatableExpression({ isForAssignment: true, parens: true, ref: 'base' });
        this.patchAsExpression();
        this.commitDeferredSuffix();
        return this.expression.getRepeatCode() + '.' + this.getFullMemberName();
      } else {
        return get(MemberAccessOpPatcher.prototype.__proto__ || Object.getPrototypeOf(MemberAccessOpPatcher.prototype), 'patchAsRepeatableExpression', this).call(this, repeatableOptions, patchOptions);
      }
    }
  }, {
    key: 'hasImplicitOperator',
    value: function hasImplicitOperator() {
      return !this.getMemberOperatorSourceToken();
    }
  }, {
    key: 'getMemberOperatorSourceToken',
    value: function getMemberOperatorSourceToken() {
      var dotIndex = this.indexOfSourceTokenBetweenSourceIndicesMatching(this.expression.outerEnd, this.outerEnd - 1, function (token) {
        return token.type === coffeeLex.SourceType.DOT;
      });

      if (!dotIndex) {
        var firstIndex = this.contentStartTokenIndex;
        var firstToken = this.sourceTokenAtIndex(firstIndex);
        if (firstToken.type === coffeeLex.SourceType.AT) {
          // e.g. `@a`, so it's okay that there's no dot
          return null;
        }

        throw this.error('cannot find \'.\' in member access');
      }

      // e.g. `a.b`
      return this.sourceTokenAtIndex(dotIndex);
    }
  }, {
    key: 'getMemberName',
    value: function getMemberName() {
      return this.node.member.data;
    }
  }, {
    key: 'getFullMemberName',
    value: function getFullMemberName() {
      return this.getMemberName();
    }
  }, {
    key: 'getMemberNameSourceToken',
    value: function getMemberNameSourceToken() {
      var tokens$$1 = this.context.sourceTokens;
      var index = tokens$$1.lastIndexOfTokenMatchingPredicate(function (token) {
        return token.type === coffeeLex.SourceType.IDENTIFIER;
      }, this.contentEndTokenIndex);
      if (!index || index.isBefore(this.contentStartTokenIndex)) {
        throw this.error('unable to find member name token in access');
      }
      return tokens$$1.tokenAtIndex(index);
    }

    /**
     * Member access is repeatable (in CoffeeScript) if the expression we're
     * accessing a member of is also repeatable. Technically speaking even this is
     * not safe since member access can have side-effects via getters and setters,
     * but this is the way the official CoffeeScript compiler works so we follow
     * suit.
     */

  }, {
    key: 'isRepeatable',
    value: function isRepeatable() {
      return this.expression.isRepeatable();
    }

    /**
     * If `BASE` needs parens, then `BASE.MEMBER` needs parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return this.expression.statementShouldAddParens();
    }
  }, {
    key: 'lhsNeedsParens',
    value: function lhsNeedsParens() {
      return this.expression.node.type === 'Int';
    }
  }]);
  return MemberAccessOpPatcher;
}(NodePatcher);

/**
 * Handles construction of objects with `new`.
 */

var NewOpPatcher = function (_FunctionApplicationP) {
  inherits(NewOpPatcher, _FunctionApplicationP);

  function NewOpPatcher() {
    classCallCheck(this, NewOpPatcher);
    return possibleConstructorReturn(this, (NewOpPatcher.__proto__ || Object.getPrototypeOf(NewOpPatcher)).apply(this, arguments));
  }

  return NewOpPatcher;
}(FunctionApplicationPatcher);

/**
 * Handles bound functions that cannot become arrow functions.
 */

var ManuallyBoundFunctionPatcher = function (_FunctionPatcher) {
  inherits(ManuallyBoundFunctionPatcher, _FunctionPatcher);

  function ManuallyBoundFunctionPatcher() {
    classCallCheck(this, ManuallyBoundFunctionPatcher);
    return possibleConstructorReturn(this, (ManuallyBoundFunctionPatcher.__proto__ || Object.getPrototypeOf(ManuallyBoundFunctionPatcher)).apply(this, arguments));
  }

  createClass(ManuallyBoundFunctionPatcher, [{
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.insert(this.innerStart, '(');
      get(ManuallyBoundFunctionPatcher.prototype.__proto__ || Object.getPrototypeOf(ManuallyBoundFunctionPatcher.prototype), 'patchAsExpression', this).call(this, options);
      this.insert(this.innerEnd, '.bind(this))');
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var needsParens = this.parent instanceof NewOpPatcher;

      if (needsParens) {
        this.insert(this.innerStart, '(');
      }

      get(ManuallyBoundFunctionPatcher.prototype.__proto__ || Object.getPrototypeOf(ManuallyBoundFunctionPatcher.prototype), 'patchAsExpression', this).call(this, options);
      // If we're instructed to patch as a method, then it won't be legal to add
      // `.bind(this)`, so skip that step. Calling code is expected to bind us
      // some other way. In practice, this happens when patching class methods;
      // code will be added to the constructor to bind the method properly.
      if (!options.method) {
        this.insert(this.innerEnd, '.bind(this)');
      }

      if (needsParens) {
        this.insert(this.innerEnd, ')');
      }
    }
  }, {
    key: 'expectedArrowType',
    value: function expectedArrowType() {
      return '=>';
    }
  }]);
  return ManuallyBoundFunctionPatcher;
}(FunctionPatcher);

var SharedBlockPatcher = function (_NodePatcher) {
  inherits(SharedBlockPatcher, _NodePatcher);

  function SharedBlockPatcher(patcherContext, statements) {
    classCallCheck(this, SharedBlockPatcher);

    var _this = possibleConstructorReturn(this, (SharedBlockPatcher.__proto__ || Object.getPrototypeOf(SharedBlockPatcher)).call(this, patcherContext));

    _this.statements = statements;
    _this.shouldPatchInline = null;
    return _this;
  }

  /**
   * Insert statements somewhere in this block.
   */


  createClass(SharedBlockPatcher, [{
    key: 'insertStatementsAtIndex',
    value: function insertStatementsAtIndex(statements, index) {
      var _this2 = this;

      var separator = this.inline() ? '; ' : ';\n';
      if (index === this.statements.length) {
        (function () {
          var lastStatement = _this2.statements[_this2.statements.length - 1];
          var terminatorTokenIndex = _this2.context.sourceTokens.indexOfTokenMatchingPredicate(function (token) {
            return token.type === coffeeLex.SourceType.NEWLINE || token.type === coffeeLex.SourceType.SEMICOLON;
          }, lastStatement.outerEndTokenIndex);
          var insertionPoint = terminatorTokenIndex ? _this2.sourceTokenAtIndex(terminatorTokenIndex).start : lastStatement.outerEnd;
          insertionPoint = Math.min(insertionPoint, _this2.getBoundingPatcher().innerEnd);
          var indent = lastStatement.getIndent();
          statements.forEach(function (line) {
            var sep = line.trim().startsWith('//') ? '\n' : separator;
            _this2.insert(insertionPoint, '' + sep + indent + line);
          });
        })();
      } else {
        (function () {
          var statementToInsertBefore = _this2.statements[index];
          var insertionPoint = statementToInsertBefore.outerStart;
          var indent = statementToInsertBefore.getIndent();
          statements.forEach(function (line) {
            var sep = line.trim().startsWith('//') ? '\n' : separator;
            _this2.insert(insertionPoint, '' + line + sep + indent);
          });
        })();
      }
    }

    /**
     * Insert a statement before the current block. Since blocks can be patched in
     * a number of ways, this needs to handle a few cases:
     * - If it's completely inline, we don't deal with any indentation and just
     *   put a semicolon-separated statement before the start.
     * - If it's a normal non-inline block, we insert the statement beforehand
     *   with the given indentation. However, `this.outerStart` is the first
     *   non-whitespace character of the first line, so it's already indented, so
     *   if we want to add a line with *less* indentation, it's a lot more tricky.
     *   We handle this by walking backward to the previous newline and inserting
     *   a new line from there. This allows the prepended line to have whatever
     *   indentation level we want.
     * - In some cases, such as nontrivial loop expressions with an inline body,
     *   the source CoffeeScript is inline, but we want the result to be
     *   non-inline, so we need to be a lot more careful. The normal non-inline
     *   strategy won't work because there's no newline to walk back to in the
     *   source CoffeeScript, so the strategy is to instead always insert at
     *   `this.outerStart`. That means that the indentation for the actual body
     *   needs to be done later, just before the body itself is patched. See the
     *   uses of shouldConvertInlineBodyToNonInline in LoopPatcher for an example.
     */

  }, {
    key: 'insertLineBefore',
    value: function insertLineBefore(statement) {
      var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getIndent();

      if (this.inline()) {
        this.insert(this.outerStart, statement + '; ');
      } else if (this.node.inline) {
        this.insert(this.outerStart, '' + indent + statement + ';\n');
      } else {
        var insertIndex = this.outerStart;
        while (insertIndex > 0 && this.context.source[insertIndex] !== '\n') {
          insertIndex--;
        }
        this.insert(insertIndex, '\n' + indent + statement + ';');
      }
    }
  }, {
    key: 'insertLineAfter',
    value: function insertLineAfter(statement, indent) {
      if (this.inline()) {
        this.insert(this.outerEnd, '; ' + statement);
      } else {
        this.insert(this.outerEnd, '\n' + indent + statement + ';');
      }
    }

    /**
     * Gets whether this patcher's block is inline (on the same line as the node
     * that contains it) or not.
     */

  }, {
    key: 'inline',
    value: function inline() {
      if (this.shouldPatchInline !== null) {
        return this.shouldPatchInline;
      }
      return this.node.inline;
    }
  }]);
  return SharedBlockPatcher;
}(NodePatcher);

var ReturnPatcher = function (_NodePatcher) {
  inherits(ReturnPatcher, _NodePatcher);

  function ReturnPatcher(patcherContext, expression) {
    classCallCheck(this, ReturnPatcher);

    var _this = possibleConstructorReturn(this, (ReturnPatcher.__proto__ || Object.getPrototypeOf(ReturnPatcher)).call(this, patcherContext));

    _this.expression = expression;
    return _this;
  }

  createClass(ReturnPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.setExplicitlyReturns();
      if (this.expression !== null) {
        this.expression.setRequiresExpression();
      }
    }

    /**
     * Return statements cannot be expressions.
     */

  }, {
    key: 'canPatchAsExpression',
    value: function canPatchAsExpression() {
      return false;
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      if (this.expression) {
        this.expression.patch();
      }
    }
  }]);
  return ReturnPatcher;
}(NodePatcher);

var BlockPatcher = function (_SharedBlockPatcher) {
  inherits(BlockPatcher, _SharedBlockPatcher);

  function BlockPatcher() {
    classCallCheck(this, BlockPatcher);
    return possibleConstructorReturn(this, (BlockPatcher.__proto__ || Object.getPrototypeOf(BlockPatcher)).apply(this, arguments));
  }

  createClass(BlockPatcher, [{
    key: 'canPatchAsExpression',
    value: function canPatchAsExpression() {
      return this.statements.every(function (statement) {
        return statement.prefersToPatchAsExpression();
      });
    }
  }, {
    key: 'setExpression',
    value: function setExpression() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      var willPatchAsExpression = get(BlockPatcher.prototype.__proto__ || Object.getPrototypeOf(BlockPatcher.prototype), 'setExpression', this).call(this, force);
      if (willPatchAsExpression && this.prefersToPatchAsExpression()) {
        this.statements.forEach(function (statement) {
          return statement.setExpression();
        });
      }
    }
  }, {
    key: 'setImplicitlyReturns',
    value: function setImplicitlyReturns() {
      // A block can have no statements if it only had a block comment.
      if (this.statements.length > 0) {
        this.statements[this.statements.length - 1].setImplicitlyReturns();
      }
    }

    /**
     * Force the patcher to treat the block as inline (semicolon-separated
     * statements) or not (newline-separated statements).
     */

  }, {
    key: 'setShouldPatchInline',
    value: function setShouldPatchInline(shouldPatchInline) {
      this.shouldPatchInline = shouldPatchInline;
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var _this2 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$leftBrace = _ref.leftBrace,
          leftBrace = _ref$leftBrace === undefined ? true : _ref$leftBrace,
          _ref$rightBrace = _ref.rightBrace,
          rightBrace = _ref$rightBrace === undefined ? true : _ref$rightBrace;

      if (leftBrace) {
        this.insert(this.innerStart, '{');
      }

      var constructor = null;
      this.statements.forEach(function (statement, i, statements) {
        if (i === statements.length - 1 && _this2.parent instanceof FunctionPatcher) {
          if (statement instanceof ReturnPatcher && !statement.expression) {
            _this2.removeFinalEmptyReturn(statement);
            return;
          }
        }
        // If we see a constructor (which only happens when this is a class
        // block), defer it until the end. Its patching may need other class
        // keys to already be patched so that it can generate method binding
        // statements within the constructor.
        // Check against the 'Constructor' node type instead of doing
        // `instanceof` to avoid a circular import issue.
        if (statement.node.type === 'Constructor') {
          if (constructor) {
            throw _this2.error('Unexpectedly found two constructors in the same block.');
          }
          constructor = statement;
        } else {
          _this2.patchInnerStatement(statement);
        }
      });
      if (constructor) {
        this.patchInnerStatement(constructor);
      }

      if (rightBrace) {
        if (this.inline()) {
          this.insert(this.innerEnd, ' }');
        } else {
          this.appendLineAfter('}', -1);
        }
      }
    }
  }, {
    key: 'patchInnerStatement',
    value: function patchInnerStatement(statement) {
      var hasImplicitReturn = statement.implicitlyReturns() && !statement.explicitlyReturns();

      if (statement.isSurroundedByParentheses() && !statement.statementNeedsParens() && !hasImplicitReturn) {
        this.remove(statement.outerStart, statement.innerStart);
        this.remove(statement.innerEnd, statement.outerEnd);
      }

      var implicitReturnPatcher = hasImplicitReturn ? this.implicitReturnPatcher() : null;
      if (implicitReturnPatcher) {
        implicitReturnPatcher.patchImplicitReturnStart(statement);
      }
      statement.patch();
      if (implicitReturnPatcher) {
        implicitReturnPatcher.patchImplicitReturnEnd(statement);
      }
      if (statement.statementNeedsSemicolon()) {
        this.insert(statement.outerEnd, ';');
      }
    }

    /**
     * Remove an unnecessary empty return at the end of a function. Ideally, we
     * want to remove the whole line, but that's only safe if the `return` is on a
     * line by itself. Otherwise, there might be bugs like code being pulled into
     * a comment on the previous line.
     */

  }, {
    key: 'removeFinalEmptyReturn',
    value: function removeFinalEmptyReturn(statement) {
      var previousToken = this.sourceTokenAtIndex(statement.contentStartTokenIndex.previous());
      var nextToken = this.sourceTokenAtIndex(statement.contentEndTokenIndex.next());

      if (previousToken && previousToken.type === coffeeLex.SourceType.NEWLINE && (!nextToken || nextToken.type === coffeeLex.SourceType.NEWLINE)) {
        this.remove(previousToken.start, statement.outerEnd);
      } else if (previousToken && previousToken.type === coffeeLex.SourceType.SEMICOLON) {
        this.remove(previousToken.start, statement.outerEnd);
      } else {
        this.remove(statement.outerStart, statement.outerEnd);
      }
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _this3 = this;

      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$leftBrace = _ref2.leftBrace,
          leftBrace = _ref2$leftBrace === undefined ? this.statements.length > 1 : _ref2$leftBrace,
          _ref2$rightBrace = _ref2.rightBrace,
          rightBrace = _ref2$rightBrace === undefined ? this.statements.length > 1 : _ref2$rightBrace;

      if (leftBrace) {
        this.insert(this.innerStart, '(');
      }
      if (this.statements.length === 0) {
        this.insert(this.contentStart, 'undefined');
      } else {
        this.statements.forEach(function (statement, i, statements) {
          statement.patch();
          if (i !== statements.length - 1) {
            var semicolonTokenIndex = _this3.getSemicolonSourceTokenBetween(statement, statements[i + 1]);
            if (semicolonTokenIndex) {
              var semicolonToken = _this3.sourceTokenAtIndex(semicolonTokenIndex);
              _this3.overwrite(semicolonToken.start, semicolonToken.end, ',');
            } else {
              _this3.insert(statement.outerEnd, ',');
            }
          }
        });
      }
      if (rightBrace) {
        this.insert(this.innerEnd, ')');
      }
    }

    /**
     * @private
     */

  }, {
    key: 'getSemicolonSourceTokenBetween',
    value: function getSemicolonSourceTokenBetween(left, right) {
      return this.indexOfSourceTokenBetweenPatchersMatching(left, right, function (token) {
        return token.type === coffeeLex.SourceType.SEMICOLON;
      });
    }

    /**
     * Blocks only exit via the last statement, so we check its code paths.
     */

  }, {
    key: 'allCodePathsPresent',
    value: function allCodePathsPresent() {
      return this.statements[this.statements.length - 1].allCodePathsPresent();
    }
  }]);
  return BlockPatcher;
}(SharedBlockPatcher);

/**
 * Determine if this is a block has an object initializer as its leftmost node.
 * That means that in its JS form, the expression will start with a `{`
 * character and need to be wrapped in parens when used in a JS arrow function.
 */
function blockStartsWithObjectInitialiser(patcher) {
  if (!(patcher instanceof BlockPatcher) || patcher.statements.length !== 1) {
    return false;
  }
  var statement = patcher.statements[0];
  var foundInitialObject = false;
  traverse(statement.node, function (child) {
    if (foundInitialObject) {
      // Already found.
      return false;
    }
    if (child.type === 'ObjectInitialiser' && child.range[0] === statement.contentStart) {
      foundInitialObject = true;
      return false;
    }
  });
  return foundInitialObject;
}

/**
 * Handles bound functions, i.e. "fat arrows".
 */

var BoundFunctionPatcher = function (_FunctionPatcher) {
  inherits(BoundFunctionPatcher, _FunctionPatcher);

  function BoundFunctionPatcher() {
    classCallCheck(this, BoundFunctionPatcher);
    return possibleConstructorReturn(this, (BoundFunctionPatcher.__proto__ || Object.getPrototypeOf(BoundFunctionPatcher)).apply(this, arguments));
  }

  createClass(BoundFunctionPatcher, [{
    key: 'initialize',
    value: function initialize() {
      get(BoundFunctionPatcher.prototype.__proto__ || Object.getPrototypeOf(BoundFunctionPatcher.prototype), 'initialize', this).call(this);
      if (this.hasInlineBody()) {
        this.body.setExpression();
      }
    }

    /**
     * Use a slightly-modified version of the regular `FunctionPatcher` when
     * we can't use arrow functions.
     */

  }, {
    key: 'patchAsStatement',


    // There's no difference between statement and expression arrow functions.
    value: function patchAsStatement() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.patchAsExpression(options);
    }
  }, {
    key: 'patchFunctionStart',
    value: function patchFunctionStart() {
      var arrow = this.getArrowToken();

      if (!this.hasParamStart()) {
        this.insert(this.contentStart, '() ');
      } else if (!this.parameterListNeedsParentheses()) {
        var _parameters = slicedToArray(this.parameters, 1),
            param = _parameters[0];

        if (param.isSurroundedByParentheses()) {
          this.remove(param.outerStart, param.contentStart);
          this.remove(param.contentEnd, param.outerEnd);
        }
      }

      if (!this.willPatchBodyInline()) {
        this.insert(arrow.end, ' {');
      }
    }
  }, {
    key: 'parameterListNeedsParentheses',
    value: function parameterListNeedsParentheses() {
      var parameters = this.parameters;

      if (parameters.length !== 1) {
        return true;
      }

      var _parameters2 = slicedToArray(parameters, 1),
          param = _parameters2[0];

      return !(param instanceof IdentifierPatcher);
    }
  }, {
    key: 'patchFunctionBody',
    value: function patchFunctionBody() {
      if (this.body) {
        if (!this.willPatchBodyInline()) {
          if (this.isEndOfFunctionCall()) {
            this.body.patch({ leftBrace: false, rightBrace: false });
            this.placeCloseBraceBeforeFunctionCallEnd();
          } else {
            this.body.patch({ leftBrace: false });
          }
        } else {
          var needsParens = blockStartsWithObjectInitialiser(this.body) && !this.body.isSurroundedByParentheses();
          if (needsParens) {
            this.insert(this.body.innerStart, '(');
          }
          this.body.patch();
          if (needsParens) {
            this.insert(this.body.innerEnd, ')');
          }
        }
      } else {
        // No body, so BlockPatcher can't insert it for us.
        this.insert(this.innerEnd, '}');
      }
    }
  }, {
    key: 'expectedArrowType',
    value: function expectedArrowType() {
      return '=>';
    }
  }, {
    key: 'willPatchBodyInline',
    value: function willPatchBodyInline() {
      return this.body ? this.body.willPatchAsExpression() : false;
    }
  }, {
    key: 'hasInlineBody',
    value: function hasInlineBody() {
      return this.body ? this.body.inline() : false;
    }

    /**
     * Bound functions already start with a paren or a param identifier, and so
     * are safe to start a statement.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return false;
    }
  }], [{
    key: 'patcherClassOverrideForNode',
    value: function patcherClassOverrideForNode(node) {
      var referencesArguments = false;

      traverse(node, function (child) {
        if (referencesArguments) {
          // We already found a reference, so skip this.
          return false;
        } else if (child.type === 'Identifier' && child.data === 'arguments') {
          referencesArguments = true;
        } else if (child !== node && isFunction(child)) {
          // Don't descend into other functions.
          return false;
        }
      });

      if (referencesArguments || node.parentNode && node.parentNode.type === 'NewOp') {
        return ManuallyBoundFunctionPatcher;
      } else {
        return null;
      }
    }
  }]);
  return BoundFunctionPatcher;
}(FunctionPatcher);

var BoundGeneratorFunctionPatcher = function (_ManuallyBoundFunctio) {
  inherits(BoundGeneratorFunctionPatcher, _ManuallyBoundFunctio);

  function BoundGeneratorFunctionPatcher() {
    classCallCheck(this, BoundGeneratorFunctionPatcher);
    return possibleConstructorReturn(this, (BoundGeneratorFunctionPatcher.__proto__ || Object.getPrototypeOf(BoundGeneratorFunctionPatcher)).apply(this, arguments));
  }

  createClass(BoundGeneratorFunctionPatcher, [{
    key: 'patchFunctionStart',
    value: function patchFunctionStart(_ref) {
      var _ref$method = _ref.method,
          method = _ref$method === undefined ? false : _ref$method;

      var arrow = this.getArrowToken();

      if (!method) {
        this.insert(this.contentStart, 'function*');
      }

      if (!this.hasParamStart()) {
        this.insert(this.contentStart, '() ');
      }

      this.overwrite(arrow.start, arrow.end, '{');
    }
  }]);
  return BoundGeneratorFunctionPatcher;
}(ManuallyBoundFunctionPatcher);

/**
 * Handles generator functions, i.e. produced by embedding `yield` statements.
 */

var GeneratorFunctionPatcher = function (_FunctionPatcher) {
  inherits(GeneratorFunctionPatcher, _FunctionPatcher);

  function GeneratorFunctionPatcher() {
    classCallCheck(this, GeneratorFunctionPatcher);
    return possibleConstructorReturn(this, (GeneratorFunctionPatcher.__proto__ || Object.getPrototypeOf(GeneratorFunctionPatcher)).apply(this, arguments));
  }

  createClass(GeneratorFunctionPatcher, [{
    key: 'patchFunctionStart',
    value: function patchFunctionStart(_ref) {
      var _ref$method = _ref.method,
          method = _ref$method === undefined ? false : _ref$method;

      var arrow = this.getArrowToken();

      if (!method) {
        this.insert(this.contentStart, 'function*');
      }

      if (!this.hasParamStart()) {
        this.insert(this.contentStart, '() ');
      }

      this.overwrite(arrow.start, arrow.end, '{');
    }
  }]);
  return GeneratorFunctionPatcher;
}(FunctionPatcher);

/**
 * Inserts string escape characters before certain characters/strings to be
 * escaped.
 *
 * The skipPattern parameter describes which already-escaped characters to skip
 * over. For normal strings, if we see any backslash, we skip it and the next
 * character, but for heregexes, we only skip a backslash followed by
 * whitespace.
 */
function escape(patcher, skipPattern, escapeStrings, start, end) {
  var source = patcher.original;

  var _loop = function _loop(_i) {
    if (skipPattern.test(source.slice(_i, end))) {
      _i++;
    } else if (escapeStrings.some(function (str) {
      return source.slice(_i, _i + str.length) === str;
    })) {
      patcher.appendRight(_i, '\\');
    }
    i = _i;
  };

  for (var i = start; i < end; i++) {
    _loop(i);
  }
}

function isAlreadyEscaped(i, start, patcher) {
  var numLeadingBackslashes = 0;
  while (i - numLeadingBackslashes - 1 >= start && patcher.context.source[i - numLeadingBackslashes - 1] === '\\') {
    numLeadingBackslashes++;
  }
  return numLeadingBackslashes % 2 === 1;
}

function exportSpecialWhitespaceInRange(start, end, patcher) {
  for (var i = start; i < end; i++) {
    var unicodeSequence = null;
    if (patcher.context.source[i] === '\u2028') {
      unicodeSequence = 'u2028';
    } else if (patcher.context.source[i] === '\u2029') {
      unicodeSequence = 'u2029';
    } else {
      continue;
    }

    if (isAlreadyEscaped(i, start, patcher)) {
      patcher.overwrite(i, i + 1, unicodeSequence);
    } else {
      patcher.overwrite(i, i + 1, '\\' + unicodeSequence);
    }
  }
}

var InterpolatedPatcher = function (_NodePatcher) {
  inherits(InterpolatedPatcher, _NodePatcher);

  function InterpolatedPatcher(patcherContext, quasis, expressions) {
    classCallCheck(this, InterpolatedPatcher);

    var _this = possibleConstructorReturn(this, (InterpolatedPatcher.__proto__ || Object.getPrototypeOf(InterpolatedPatcher)).call(this, patcherContext));

    _this.quasis = quasis;
    _this.expressions = expressions;
    return _this;
  }

  createClass(InterpolatedPatcher, [{
    key: 'initialize',
    value: function initialize() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.expressions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var expression = _step.value;

          expression.setRequiresExpression();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: 'patchInterpolations',
    value: function patchInterpolations() {
      for (var i = 0; i < this.expressions.length; i++) {
        var interpolationStart = this.getInterpolationStartTokenAtIndex(i);
        this.overwrite(interpolationStart.start, interpolationStart.start + 1, '$');
        this.expressions[i].patch();
      }
    }
  }, {
    key: 'getInterpolationStartTokenAtIndex',
    value: function getInterpolationStartTokenAtIndex(index) {
      var interpolationStartIndex = this.indexOfSourceTokenBetweenPatchersMatching(this.quasis[index], this.expressions[index], function (token) {
        return token.type === coffeeLex.SourceType.INTERPOLATION_START;
      });
      if (!interpolationStartIndex) {
        this.error('Cannot find interpolation start for string interpolation.');
      }
      var interpolationStart = this.sourceTokenAtIndex(interpolationStartIndex);
      if (!interpolationStart || this.slice(interpolationStart.start, interpolationStart.start + 1) !== '#') {
        this.error("Cannot find '#' in interpolation start.");
      }
      return interpolationStart;
    }

    /**
     * Handle "padding" characters: characters like leading whitespace that should
     * be removed according to the lexing rules. In addition to STRING_PADDING
     * tokens, which indicate that the range should be removed, there are also
     * STRING_LINE_SEPARATOR tokens that indicate that the newlines should be
     * replaced with a space.
     *
     * To preserve the formatting of multiline strings a little better, newline
     * characters are escaped rather than removed.
     *
     * Also change any \u2028 and \u2029 characters we see into their unicode
     * escape form.
     */

  }, {
    key: 'processContents',
    value: function processContents() {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.quasis[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var quasi = _step2.value;

          var tokens$$1 = this.getProgramSourceTokens().slice(quasi.contentStartTokenIndex, quasi.contentEndTokenIndex.next()).toArray();
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = tokens$$1[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var token = _step3.value;

              if (token.type === coffeeLex.SourceType.STRING_PADDING) {
                var paddingCode = this.slice(token.start, token.end);
                var numNewlines = (paddingCode.match(/\n/g) || []).length;
                this.overwrite(token.start, token.end, repeat('\\\n', numNewlines));
              } else if (token.type === coffeeLex.SourceType.STRING_LINE_SEPARATOR) {
                this.insert(token.start, ' \\');
              } else if (token.type === coffeeLex.SourceType.STRING_CONTENT) {
                exportSpecialWhitespaceInRange(token.start, token.end, this);
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'escapeQuasis',
    value: function escapeQuasis(skipPattern, escapeStrings) {
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this.quasis[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var quasi = _step4.value;

          var tokens$$1 = this.getProgramSourceTokens().slice(quasi.contentStartTokenIndex, quasi.contentEndTokenIndex.next()).toArray();
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = tokens$$1[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var token = _step5.value;

              if (token.type === coffeeLex.SourceType.STRING_CONTENT) {
                escape(this.editor, skipPattern, escapeStrings, token.start, token.end);
              }
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5.return) {
                _iterator5.return();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
  }, {
    key: 'isRepeatable',
    value: function isRepeatable() {
      return this.expressions.every(function (patcher) {
        return patcher.isRepeatable();
      });
    }
  }]);
  return InterpolatedPatcher;
}(NodePatcher);

/**
 * Patcher to handle all types of strings, whether or not they have
 * interpolations and whether or not they are multiline.
 */

var StringPatcher = function (_InterpolatedPatcher) {
  inherits(StringPatcher, _InterpolatedPatcher);

  function StringPatcher() {
    classCallCheck(this, StringPatcher);
    return possibleConstructorReturn(this, (StringPatcher.__proto__ || Object.getPrototypeOf(StringPatcher)).apply(this, arguments));
  }

  createClass(StringPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var shouldBecomeTemplateLiteral = this.shouldBecomeTemplateLiteral();

      var escapeStrings = [];
      var openQuoteToken = this.firstToken();
      var closeQuoteToken = this.lastToken();

      if (shouldBecomeTemplateLiteral) {
        escapeStrings.push('`');
        escapeStrings.push('${');
        this.overwrite(openQuoteToken.start, openQuoteToken.end, '`');
        this.overwrite(closeQuoteToken.start, closeQuoteToken.end, '`');
      } else if (openQuoteToken.type === coffeeLex.SourceType.TSSTRING_START) {
        escapeStrings.push('\'');
        this.overwrite(openQuoteToken.start, openQuoteToken.end, '\'');
        this.overwrite(closeQuoteToken.start, closeQuoteToken.end, '\'');
      } else if (openQuoteToken.type === coffeeLex.SourceType.TDSTRING_START) {
        escapeStrings.push('"');
        this.overwrite(openQuoteToken.start, openQuoteToken.end, '"');
        this.overwrite(closeQuoteToken.start, closeQuoteToken.end, '"');
      }

      this.patchInterpolations();
      this.processContents();
      if (escapeStrings.length > 0) {
        this.escapeQuasis(/^\\/, escapeStrings);
      }
    }
  }, {
    key: 'shouldBecomeTemplateLiteral',
    value: function shouldBecomeTemplateLiteral() {
      return this.expressions.length > 0 || this.node.raw.indexOf('\n') > -1;
    }
  }]);
  return StringPatcher;
}(InterpolatedPatcher);

/**
 * Handles object properties.
 */
var ObjectBodyMemberPatcher = function (_NodePatcher) {
  inherits(ObjectBodyMemberPatcher, _NodePatcher);

  function ObjectBodyMemberPatcher(patcherContext, key, expression) {
    classCallCheck(this, ObjectBodyMemberPatcher);

    var _this = possibleConstructorReturn(this, (ObjectBodyMemberPatcher.__proto__ || Object.getPrototypeOf(ObjectBodyMemberPatcher)).call(this, patcherContext));

    _this.key = key;
    _this.expression = expression;
    return _this;
  }

  createClass(ObjectBodyMemberPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.key.setRequiresExpression();
      this.expression.setRequiresExpression();
    }

    /**
     * KEY : EXPRESSION
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this.isMethod()) {
        this.patchAsMethod(options);
      } else {
        this.patchAsProperty(options);
      }
    }
  }, {
    key: 'patchAsMethod',
    value: function patchAsMethod() {
      if (this.isGeneratorMethod()) {
        this.insert(this.key.outerStart, '*');
      }
      this.patchKey();
      // `{ ['hi there']: ->` → `{ ['hi there']->`
      //                ^^
      this.remove(this.key.outerEnd, this.expression.outerStart);
      // The function expression might be surrounded by parens, so remove them if
      // necessary.
      this.remove(this.expression.outerStart, this.expression.contentStart);
      this.remove(this.expression.contentEnd, this.expression.outerEnd);
      this.patchExpression();
    }
  }, {
    key: 'patchAsProperty',
    value: function patchAsProperty() {
      this.patchKey();
      this.patchExpression();
    }
  }, {
    key: 'patchKey',
    value: function patchKey() {
      var computedKeyPatcher = this.getComputedKeyPatcher();
      if (computedKeyPatcher !== null) {
        // Since we're replacing an expression like `"#{foo}"` with just `foo`,
        // the outer string expression might be marked as repeatable, in which case
        // we should delegate that to the inner expression.
        var shouldPropagateRepeatable = this.key.isSetAsRepeatableExpression();
        if (shouldPropagateRepeatable) {
          computedKeyPatcher.setRequiresRepeatableExpression();
        }
        this.overwrite(this.key.outerStart, computedKeyPatcher.outerStart, '[');
        computedKeyPatcher.patch();
        this.overwrite(computedKeyPatcher.outerEnd, this.key.outerEnd, ']');
        if (shouldPropagateRepeatable) {
          this.key.overrideRepeatCode(computedKeyPatcher.getRepeatCode());
        }
      } else {
        var needsBrackets = !(this.key instanceof StringPatcher && !this.key.shouldBecomeTemplateLiteral()) && !(this.key instanceof IdentifierPatcher) && this.key.node.type !== 'Int' && this.key.node.type !== 'Float';
        if (needsBrackets) {
          this.insert(this.key.outerStart, '[');
        }
        this.key.patch();
        if (needsBrackets) {
          this.insert(this.key.outerEnd, ']');
        }
      }
    }

    /**
     * As a special case, transform {"#{a.b}": c} to {[a.b]: c}, since a template
     * literal is the best way to do computed keys in CoffeeScript. This method
     * gets the patcher for that computed key node, if any.
     */

  }, {
    key: 'getComputedKeyPatcher',
    value: function getComputedKeyPatcher() {
      if (this.key instanceof StringPatcher && this.key.quasis.length === 2 && this.key.expressions.length === 1 && this.key.quasis[0].node.data === '' && this.key.quasis[1].node.data === '') {
        return this.key.expressions[0];
      }
      return null;
    }
  }, {
    key: 'patchExpression',
    value: function patchExpression() {
      this.expression.patch({ method: this.isMethod() });
    }

    /**
     * In normal object bodies, we can use method syntax for normal arrow
     * functions and for normal generator functions. If we need to explicitly add
     * `.bind(this)`, then we won't be able to use the method form. But for
     * classes, since the binding is done in the constructor, we can still use
     * method syntax, so ClassAssignOpPatcher overrides this method for that case.
     * We also allow ClassBoundMethodFunctionPatcher since that only comes up in
     * the class case.
     *
     * @protected
     */

  }, {
    key: 'isMethod',
    value: function isMethod() {
      return this.expression instanceof FunctionPatcher && !(this.expression instanceof ManuallyBoundFunctionPatcher) && !(this.expression instanceof BoundFunctionPatcher);
    }

    /**
     * Note that we include BoundGeneratorFunctionPatcher, even though the object
     * case doesn't treat it as a method, since the class case should use a
     * generator method.
     *
     * @protected
     */

  }, {
    key: 'isGeneratorMethod',
    value: function isGeneratorMethod() {
      return this.expression instanceof GeneratorFunctionPatcher || this.expression instanceof BoundGeneratorFunctionPatcher;
    }
  }]);
  return ObjectBodyMemberPatcher;
}(NodePatcher);

var ThisPatcher = function (_NodePatcher) {
  inherits(ThisPatcher, _NodePatcher);

  function ThisPatcher() {
    classCallCheck(this, ThisPatcher);
    return possibleConstructorReturn(this, (ThisPatcher.__proto__ || Object.getPrototypeOf(ThisPatcher)).apply(this, arguments));
  }

  createClass(ThisPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      if (this.isShorthandThis()) {
        this.overwrite(this.contentStart, this.contentEnd, 'this');
      }
    }
  }, {
    key: 'isShorthandThis',
    value: function isShorthandThis() {
      return this.getOriginalSource() === '@';
    }
  }, {
    key: 'isRepeatable',
    value: function isRepeatable() {
      return true;
    }
  }]);
  return ThisPatcher;
}(NodePatcher);

/**
 * Handles object properties.
 */

var ObjectInitialiserMemberPatcher = function (_ObjectBodyMemberPatc) {
  inherits(ObjectInitialiserMemberPatcher, _ObjectBodyMemberPatc);

  function ObjectInitialiserMemberPatcher() {
    classCallCheck(this, ObjectInitialiserMemberPatcher);
    return possibleConstructorReturn(this, (ObjectInitialiserMemberPatcher.__proto__ || Object.getPrototypeOf(ObjectInitialiserMemberPatcher)).apply(this, arguments));
  }

  createClass(ObjectInitialiserMemberPatcher, [{
    key: 'patchAsProperty',
    value: function patchAsProperty() {
      if (this.key.node === this.expression.node) {
        this.patchAsShorthand({
          expand: this.key.node.type !== 'Identifier'
        });
      } else {
        get(ObjectInitialiserMemberPatcher.prototype.__proto__ || Object.getPrototypeOf(ObjectInitialiserMemberPatcher.prototype), 'patchAsProperty', this).call(this);
      }
    }

    /**
     * @private
     */

  }, {
    key: 'patchAsShorthand',
    value: function patchAsShorthand() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$expand = _ref.expand,
          expand = _ref$expand === undefined ? false : _ref$expand;

      var key = this.key;

      if (key instanceof MemberAccessOpPatcher) {
        key.patch();
        // e.g. `{ @name }`
        var memberAccessKey = key;
        if (!(memberAccessKey.expression instanceof ThisPatcher)) {
          throw this.error('expected property key member access on \'this\', e.g. \'@name\'');
        }
        // `{ @name }` → `{ name: @name }`
        //                  ^^^^^^
        this.insert(memberAccessKey.outerStart, memberAccessKey.getMemberName() + ': ');
      } else if (expand) {
        var isComputed = key instanceof StringPatcher && key.shouldBecomeTemplateLiteral();

        if (isComputed) {
          // `{ `a = ${1 + 1}` }` → `{ [`a = ${1 + 1}` }`
          //                           ^
          this.insert(key.outerStart, '[');
        }

        var valueCode = key.patchRepeatable();

        if (isComputed) {
          this.insert(key.outerEnd, ']');
        }

        // `{ a } → { a: a }`
        //             ^^^
        this.insert(key.outerEnd, ': ' + valueCode);
      }
    }
  }]);
  return ObjectInitialiserMemberPatcher;
}(ObjectBodyMemberPatcher);

/**
 * Handles object literals.
 */

var ObjectInitialiserPatcher = function (_NodePatcher) {
  inherits(ObjectInitialiserPatcher, _NodePatcher);

  function ObjectInitialiserPatcher(patcherContext, members) {
    classCallCheck(this, ObjectInitialiserPatcher);

    var _this = possibleConstructorReturn(this, (ObjectInitialiserPatcher.__proto__ || Object.getPrototypeOf(ObjectInitialiserPatcher)).call(this, patcherContext));

    _this.members = members;
    return _this;
  }

  createClass(ObjectInitialiserPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.members.forEach(function (member) {
        return member.setRequiresExpression();
      });
    }
  }, {
    key: 'setAssignee',
    value: function setAssignee() {
      this.members.forEach(function (member) {
        return member.expression.setAssignee();
      });
      get(ObjectInitialiserPatcher.prototype.__proto__ || Object.getPrototypeOf(ObjectInitialiserPatcher.prototype), 'setAssignee', this).call(this);
    }
  }, {
    key: 'setExpression',
    value: function setExpression(force) {
      if (this.isImplicitObject()) {
        var _getOpenCurlyInfo = this.getOpenCurlyInfo(),
            curlyBraceInsertionPosition = _getOpenCurlyInfo.curlyBraceInsertionPosition;

        this.adjustBoundsToInclude(curlyBraceInsertionPosition);
      }
      get(ObjectInitialiserPatcher.prototype.__proto__ || Object.getPrototypeOf(ObjectInitialiserPatcher.prototype), 'setExpression', this).call(this, force);
    }

    /**
     * Objects as expressions are very similar to their CoffeeScript equivalents.
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var implicitObject = this.isImplicitObject();
      if (implicitObject) {
        var _getOpenCurlyInfo2 = this.getOpenCurlyInfo(),
            curlyBraceInsertionPosition = _getOpenCurlyInfo2.curlyBraceInsertionPosition,
            textToInsert = _getOpenCurlyInfo2.textToInsert,
            shouldIndent = _getOpenCurlyInfo2.shouldIndent;

        this.insert(curlyBraceInsertionPosition, textToInsert);
        if (shouldIndent) {
          this.indent();
        }
      }
      this.patchMembers();
      if (implicitObject) {
        if (this.shouldExpandCurlyBraces() && !this.isSurroundedByParentheses()) {
          this.appendLineAfter('}', -1);
        } else {
          this.insert(this.innerEnd, '}');
        }
      }
    }
  }, {
    key: 'getOpenCurlyInfo',
    value: function getOpenCurlyInfo() {
      var curlyBraceInsertionPosition = this.innerStart;
      var textToInsert = '{';
      var shouldIndent = false;
      if (this.shouldExpandCurlyBraces()) {
        if (this.implicitlyReturns() && !this.isSurroundedByParentheses()) {
          textToInsert = '{\n' + this.getIndent();
          shouldIndent = true;
        } else {
          var tokenIndexBeforeOuterStartTokenIndex = this.outerStartTokenIndex;
          if (!this.isSurroundedByParentheses()) {
            tokenIndexBeforeOuterStartTokenIndex = tokenIndexBeforeOuterStartTokenIndex.previous();
          }

          if (tokenIndexBeforeOuterStartTokenIndex) {
            var precedingTokenIndex = this.context.sourceTokens.lastIndexOfTokenMatchingPredicate(isSemanticToken, tokenIndexBeforeOuterStartTokenIndex);
            if (precedingTokenIndex) {
              var precedingToken = this.sourceTokenAtIndex(precedingTokenIndex);
              curlyBraceInsertionPosition = precedingToken.end;
              var precedingTokenText = this.sourceOfToken(precedingToken);
              var lastCharOfToken = precedingTokenText[precedingTokenText.length - 1];
              var needsSpace = lastCharOfToken === ':' || lastCharOfToken === '=' || lastCharOfToken === ',';
              if (needsSpace) {
                textToInsert = ' {';
              }
            }
          }
        }
      }
      return { curlyBraceInsertionPosition: curlyBraceInsertionPosition, textToInsert: textToInsert, shouldIndent: shouldIndent };
    }

    /**
     * Objects as statements need to be wrapped in parentheses, or else they'll be
     * confused with blocks. That is, this is not an object [1]:
     *
     *   { a: 0 };
     *
     * But this is fine:
     *
     *   ({ a: 0 });
     *
     * [1]: It is actually valid code, though. It's a block with a labeled
     * statement `a` with a single expression statement, being the literal 0.
     */

  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var needsParentheses = !this.isSurroundedByParentheses();
      var implicitObject = this.isImplicitObject();
      if (needsParentheses) {
        this.insert(this.contentStart, '(');
      }
      if (implicitObject) {
        if (this.shouldExpandCurlyBraces() && !this.isSurroundedByParentheses()) {
          this.insert(this.innerStart, '{\n' + this.getIndent());
          this.indent();
        } else {
          this.insert(this.innerStart, '{');
        }
      }
      this.patchMembers();
      if (implicitObject) {
        if (this.shouldExpandCurlyBraces() && !this.isSurroundedByParentheses()) {
          this.appendLineAfter('}', -1);
        } else {
          this.insert(this.innerEnd, '}');
        }
      }
      if (needsParentheses) {
        this.insert(this.contentEnd, ')');
      }
    }

    /**
     * @private
     */

  }, {
    key: 'shouldExpandCurlyBraces',
    value: function shouldExpandCurlyBraces() {
      return this.isMultiline() || this.parent instanceof ObjectInitialiserMemberPatcher && this.parent.parent.isMultiline();
    }

    /**
     * @private
     */

  }, {
    key: 'patchMembers',
    value: function patchMembers() {
      var _this2 = this;

      this.members.forEach(function (member, i, members) {
        member.patch();
        if (i !== members.length - 1) {
          if (!member.hasSourceTokenAfter(coffeeLex.SourceType.COMMA)) {
            _this2.insert(member.outerEnd, ',');
          }
        }
      });
    }

    /**
     * Determines whether this object is implicit, i.e. it lacks braces.
     *
     *   a: b      # true
     *   { a: b }  # false
     */

  }, {
    key: 'isImplicitObject',
    value: function isImplicitObject() {
      var tokens$$1 = this.context.sourceTokens;
      var indexOfFirstToken = tokens$$1.indexOfTokenStartingAtSourceIndex(this.contentStart);
      return tokens$$1.tokenAtIndex(indexOfFirstToken).type !== coffeeLex.SourceType.LBRACE;
    }

    /**
     * Starting a statement with an object always requires parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return true;
    }
  }]);
  return ObjectInitialiserPatcher;
}(NodePatcher);

/**
 * Handles array or string slicing, e.g. `names[i..]`.
 */

var SlicePatcher = function (_NodePatcher) {
  inherits(SlicePatcher, _NodePatcher);

  /**
   * `node` is of type `Slice`.
   */
  function SlicePatcher(patcherContext, expression, left, right) {
    classCallCheck(this, SlicePatcher);

    var _this = possibleConstructorReturn(this, (SlicePatcher.__proto__ || Object.getPrototypeOf(SlicePatcher)).call(this, patcherContext));

    _this.expression = expression;
    _this.left = left;
    _this.right = right;
    return _this;
  }

  createClass(SlicePatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.expression.setRequiresExpression();
      if (this.left) {
        this.left.setRequiresExpression();
      }
      if (this.right) {
        this.right.setRequiresExpression();
      }
    }

    /**
     * EXPRESSION '[' LEFT? ( .. | ... ) RIGHT? ']'
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.expression.patch();
      var indexStart = this.getIndexStartSourceToken();
      // `a[0..1]` → `a.slice(0..1]`
      //   ^           ^^^^^^^
      this.overwrite(this.expression.outerEnd, indexStart.end, '.slice(');
      if (this.left) {
        this.left.patch();
      } else if (this.right) {
        // `a.slice(..1]` → `a.slice(0..1]`
        //                           ^
        this.insert(indexStart.end, '0');
      }
      var slice = this.getSliceSourceToken();
      var right = this.right;
      if (right) {
        if (this.isInclusive()) {
          if (right.node.raw === '-1') {
            this.remove(slice.start, right.outerEnd);
          } else if (right.node.type === 'Int') {
            this.overwrite(slice.start, right.outerEnd, ', ' + (right.node.data + 1));
          } else {
            // `a.slice(0..1]` → `a.slice(0, +1]`
            //           ^^                ^^^
            this.overwrite(slice.start, slice.end, ', +');
            // Don't put two `+` operations immediately next to each other, since
            // otherwise it will become a `++`. Checking if the CoffeeScript code
            // starts with `+` should be easy and correct in this case.
            if (this.slice(right.contentStart, right.contentStart + 1) === '+') {
              this.insert(slice.end, ' ');
            }
            right.patch();
            this.insert(right.outerEnd, ' + 1 || undefined');
          }
        } else {
          // `a.slice(0..1]` → `a.slice(0, 1]`
          //           ^^                ^^
          this.overwrite(slice.start, slice.end, ', ');
          right.patch();
        }
      } else {
        // `a.slice(0..]` → `a.slice(0]`
        //           ^^
        this.overwrite(slice.start, slice.end, '');
      }
      var indexEnd = this.getIndexEndSourceToken();
      // `a.slice(0, 1]` → `a.slice(0, 1)`
      //              ^                 ^
      this.overwrite(indexEnd.start, indexEnd.end, ')');
    }

    /**
     * Given the RHS of a splice expression, return the code for it. This only
     * happens in a context where our expression will go away, so children can be
     * patched as necessary.
     */

  }, {
    key: 'getSpliceCode',
    value: function getSpliceCode(expressionCode) {
      var _this2 = this;

      var spliceStart = this.captureCodeForPatchOperation(function () {
        return _this2.patchAsSpliceExpressionStart();
      });
      return spliceStart + ', ...[].concat(' + expressionCode + '))';
    }

    /**
     * Patch into the first part of a splice expression. For example,
     *
     * a[b...c]
     *
     * becomes
     *
     * a.splice(b, c - b
     *
     * The enclosing assignment operator patcher will do the rest.
     */

  }, {
    key: 'patchAsSpliceExpressionStart',
    value: function patchAsSpliceExpressionStart() {
      this.expression.patch();
      var indexStart = this.getIndexStartSourceToken();
      // `a[b..c]` → `a.splice(b..c]`
      //   ^           ^^^^^^^^
      this.overwrite(this.expression.outerEnd, indexStart.end, '.splice(');
      var leftCode = void 0;
      if (this.left) {
        leftCode = this.left.patchRepeatable();
      } else {
        // `a.splice(..c]` → `a.splice(0..c]`
        //                             ^
        this.insert(indexStart.end, '0');
        leftCode = '0';
      }
      var slice = this.getSliceSourceToken();
      var right = this.right;
      if (right) {
        // `a.splice(b..c]` → `a.splice(b, c]`
        //                               ^^
        this.overwrite(slice.start, slice.end, ', ');
        right.patch();
        if (leftCode !== '0') {
          // `a.splice(b, c]` → `a.splice(b, c - b]`
          //                                  ^^^^
          this.insert(right.outerEnd, ' - ' + leftCode);
        }
        if (this.isInclusive()) {
          // `a.splice(b, c - b]` → `a.splice(b, c - b + 1]`
          //                                          ^^^^
          this.insert(right.outerEnd, ' + 1');
        }
      } else {
        // `a.splice(b..]` → `a.splice(b, 9e9]`
        //            ^^                ^^^^^
        this.overwrite(slice.start, slice.end, ', 9e9');
      }
      var indexEnd = this.getIndexEndSourceToken();
      // `a.splice(b, c - b + 1]` → `a.splice(b, c - b + 1`
      //                       ^
      this.remove(indexEnd.start, indexEnd.end);
    }

    /**
     * @private
     */

  }, {
    key: 'isInclusive',
    value: function isInclusive() {
      var slice = this.getSliceSourceToken();
      return slice.end - slice.start === '..'.length;
    }

    /**
     * @private
     */

  }, {
    key: 'getIndexStartSourceToken',
    value: function getIndexStartSourceToken() {
      var tokens$$1 = this.context.sourceTokens;
      var index = tokens$$1.indexOfTokenMatchingPredicate(function (token) {
        return token.type === coffeeLex.SourceType.LBRACKET;
      }, this.expression.outerEndTokenIndex);
      if (!index || index.isAfter(this.contentEndTokenIndex)) {
        throw this.error('could not find INDEX_START after slice expression');
      }
      return tokens$$1.tokenAtIndex(index);
    }

    /**
     * @private
     */

  }, {
    key: 'getSliceSourceToken',
    value: function getSliceSourceToken() {
      var tokens$$1 = this.context.sourceTokens;
      var source = this.context.source;

      var index = tokens$$1.indexOfTokenMatchingPredicate(function (token) {
        if (token.type !== coffeeLex.SourceType.RANGE) {
          return false;
        }
        var operator = source.slice(token.start, token.end);
        return operator === '...' || operator === '..';
      }, this.left ? this.left.outerEndTokenIndex : this.expression.outerEndTokenIndex);
      if (!index || index.isAfter(this.contentEndTokenIndex)) {
        throw this.error('could not find \'..\' or \'...\' in slice');
      }
      return tokens$$1.tokenAtIndex(index);
    }

    /**
     * @private
     */

  }, {
    key: 'getIndexEndSourceToken',
    value: function getIndexEndSourceToken() {
      var tokens$$1 = this.context.sourceTokens;
      var index = tokens$$1.lastIndexOfTokenMatchingPredicate(function (token) {
        return token.type === coffeeLex.SourceType.RBRACKET;
      }, this.outerEndTokenIndex);
      if (!index || index.isBefore(this.contentStartTokenIndex)) {
        throw this.error('could not find \']\' ending slice');
      }
      return tokens$$1.tokenAtIndex(index);
    }

    /**
     * If `BASE` needs parens then `BASE[0..1]` needs parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return this.expression.statementShouldAddParens();
    }
  }]);
  return SlicePatcher;
}(NodePatcher);

/**
 * Handles spread operations, e.g. `a(b...)` or `[a...]`.
 */
var SpreadPatcher = function (_NodePatcher) {
  inherits(SpreadPatcher, _NodePatcher);

  function SpreadPatcher(patcherContext, expression) {
    classCallCheck(this, SpreadPatcher);

    var _this = possibleConstructorReturn(this, (SpreadPatcher.__proto__ || Object.getPrototypeOf(SpreadPatcher)).call(this, patcherContext));

    _this.expression = expression;
    return _this;
  }

  createClass(SpreadPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.expression.setRequiresExpression();
    }
  }, {
    key: 'setAssignee',
    value: function setAssignee() {
      this.expression.setAssignee();
      get(SpreadPatcher.prototype.__proto__ || Object.getPrototypeOf(SpreadPatcher.prototype), 'setAssignee', this).call(this);
    }

    /**
     * We need to move the `...` from the right to the left and wrap the
     * expression in Array.from, since CS allows array-like objects and JS
     * requires iterables.
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var needsArrayFrom = this.needsArrayFrom();

      // `a...` → `...Array.from(a...`
      //           ^^^^^^^^^^^^^^
      this.insert(this.expression.outerStart, '...');
      if (needsArrayFrom) {
        this.insert(this.expression.outerStart, 'Array.from(');
      }
      this.expression.patch();

      // `...Array.from(a...` → `...Array.from(a`
      //                 ^^^
      this.remove(this.expression.outerEnd, this.contentEnd);
      if (needsArrayFrom) {
        // Replicate a bug in CoffeeScript where you're allowed to pass null or
        // undefined when the argument spread is the only argument.
        if (this.parent instanceof FunctionApplicationPatcher && this.parent.args.length === 1 && this.parent.args[0] === this) {
          this.insert(this.contentEnd, ' || []');
        }
        // `...Array.from(a` → `...Array.from(a)`
        //                                     ^
        this.insert(this.contentEnd, ')');
      }
    }
  }, {
    key: 'needsArrayFrom',
    value: function needsArrayFrom() {
      // Rest operations should never use Array.from.
      if (this.isAssignee()) {
        return false;
      }
      // Spreading over arguments is always safe.
      if (this.expression.node.type === 'Identifier' && this.expression.node.data === 'arguments') {
        return false;
      }
      return true;
    }
  }]);
  return SpreadPatcher;
}(NodePatcher);

/**
 * Determine if the given assignee (array destructure, object destructure, rest,
 * etc.) can be translated to JavaScript directly. If not, we'll need to expand
 * the assignee into repeated assignments.
 *
 * Notably, we cannot patch default values (assignment operations) to JavaScript
 * since CS falls back to the default if the value is undefined or null, while
 * JS falls back to the default if the value only if the value is undefined.
 */
function canPatchAssigneeToJavaScript(node) {
  var isTopLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if (['Identifier', 'MemberAccessOp', 'SoakedMemberAccessOp', 'ProtoMemberAccessOp', 'DynamicMemberAccessOp', 'SoakedDynamicMemberAccessOp', 'SoakedProtoMemberAccessOp'].indexOf(node.type) > -1) {
    return true;
  }
  if (node.type === 'ArrayInitialiser') {
    // Nested array destructures can't convert cleanly because we need to wrap
    // them in Array.from.
    if (!isTopLevel) {
      return false;
    }
    // Empty destructure operations need to result in zero assignments, and thus
    // not call Array.from at all.
    if (node.members.length === 0) {
      return false;
    }
    return node.members.every(function (member, i) {
      var isFinalExpansion = i === node.members.length - 1 && ['Spread', 'Rest', 'Expansion'].indexOf(member.type) > -1;
      var isValidFinalExpansion = isFinalExpansion && (member.type === 'Expansion' || canPatchAssigneeToJavaScript(member.expression));
      return isValidFinalExpansion || canPatchAssigneeToJavaScript(member, false);
    });
  }
  if (node.type === 'ObjectInitialiser') {
    // JS empty destructure crashes if the RHS is undefined or null, so more
    // precisely copy the behavior for empty destructures.
    if (node.members.length === 0) {
      return false;
    }
    return node.members.every(function (node) {
      return canPatchAssigneeToJavaScript(node, false);
    });
  }
  if (node.type === 'ObjectInitialiserMember') {
    return canPatchAssigneeToJavaScript(node.expression, false);
  }
  return false;
}

/**
 * Given a main stage patcher, determine if it assigns a function to a class
 * prototype. This means that a super call within the function needs access to
 * the enclosing function.
 */
function extractPrototypeAssignPatchers(patcher) {
  if (!(patcher instanceof AssignOpPatcher) || !(patcher.expression instanceof FunctionPatcher) || !(patcher.assignee instanceof MemberAccessOpPatcher || patcher.assignee instanceof DynamicMemberAccessOpPatcher) || !(patcher.assignee.expression instanceof MemberAccessOpPatcher) || patcher.assignee.expression.member.node.data !== 'prototype') {
    return null;
  }
  return {
    classRefPatcher: patcher.assignee.expression.expression,
    methodAccessPatcher: patcher.assignee
  };
}

var MULTI_ASSIGN_SINGLE_LINE_MAX_LENGTH = 100;

var AssignOpPatcher = function (_NodePatcher) {
  inherits(AssignOpPatcher, _NodePatcher);

  function AssignOpPatcher(patcherContext, assignee, expression) {
    classCallCheck(this, AssignOpPatcher);

    var _this = possibleConstructorReturn(this, (AssignOpPatcher.__proto__ || Object.getPrototypeOf(AssignOpPatcher)).call(this, patcherContext));

    _this.negated = false;

    _this.assignee = assignee;
    _this.expression = expression;
    return _this;
  }

  createClass(AssignOpPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.assignee.setAssignee();
      this.assignee.setRequiresExpression();
      this.expression.setRequiresExpression();
    }
  }, {
    key: 'negate',
    value: function negate() {
      this.negated = !this.negated;
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.markProtoAssignmentRepeatableIfNecessary();
      var shouldAddParens = this.negated || !this.isSurroundedByParentheses() && !(this.parent instanceof ReturnPatcher || this.parent instanceof DoOpPatcher || this.parent instanceof ConditionalPatcher && this.parent.condition === this && !this.parent.willPatchAsTernary()) && !this.implicitlyReturns();
      if (this.negated) {
        this.insert(this.innerStart, '!');
      }
      if (shouldAddParens) {
        this.insert(this.innerStart, '(');
      }

      if (canPatchAssigneeToJavaScript(this.assignee.node)) {
        this.patchSimpleAssignment();
      } else {
        var assignments = [];

        // In an expression context, the result should always be the value of the
        // RHS, so we need to make it repeatable if it's not.
        var expressionCode = void 0;
        if (this.expression.isRepeatable()) {
          expressionCode = this.expression.patchAndGetCode();
        } else {
          var fullExpression = this.expression.patchAndGetCode();
          expressionCode = this.claimFreeBinding();
          assignments.push(expressionCode + ' = ' + fullExpression);
        }
        assignments.push.apply(assignments, toConsumableArray(this.generateAssignments(this.assignee, expressionCode, true)));
        assignments.push('' + expressionCode);

        this.overwrite(this.contentStart, this.contentEnd, assignments.join(', '));
      }

      if (shouldAddParens) {
        this.appendDeferredSuffix(')');
      }
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      this.markProtoAssignmentRepeatableIfNecessary();
      if (canPatchAssigneeToJavaScript(this.assignee.node)) {
        var shouldAddParens = this.assignee.statementShouldAddParens();
        if (shouldAddParens) {
          this.insert(this.contentStart, '(');
        }
        this.patchSimpleAssignment();
        if (shouldAddParens) {
          this.insert(this.contentEnd, ')');
        }
      } else {
        var assignments = this.generateAssignments(this.assignee, this.expression.patchAndGetCode(), this.expression.isRepeatable());
        this.overwriteWithAssignments(assignments);
      }
    }
  }, {
    key: 'patchSimpleAssignment',
    value: function patchSimpleAssignment() {
      var needsArrayFrom = this.assignee instanceof ArrayInitialiserPatcher;
      this.assignee.patch();
      if (needsArrayFrom) {
        this.insert(this.expression.outerStart, 'Array.from(');
      }

      if (needsArrayFrom) {
        if (this.willPatchAsExpression()) {
          var expressionRepeatCode = this.expression.patchRepeatable();
          this.insert(this.expression.outerEnd, '), ' + expressionRepeatCode);
        } else {
          this.expression.patch();
          this.insert(this.expression.outerEnd, ')');
        }
      } else {
        this.expression.patch();
      }
    }
  }, {
    key: 'overwriteWithAssignments',
    value: function overwriteWithAssignments(assignments) {
      var assignmentCode = assignments.join(', ');
      if (assignmentCode.length > MULTI_ASSIGN_SINGLE_LINE_MAX_LENGTH) {
        assignmentCode = assignments.join(',\n' + this.getIndent(1));
      }
      if (assignmentCode.startsWith('{')) {
        assignmentCode = '(' + assignmentCode + ')';
      }
      this.overwrite(this.contentStart, this.contentEnd, assignmentCode);
    }

    /**
     * Recursively walk a CoffeeScript assignee to generate a sequence of
     * JavaScript assignments.
     *
     * patcher is a patcher for the assignee.
     * ref is a code snippet, not necessarily repeatable, that can be used to
     *   reference the value being assigned.
     * refIsRepeatable says whether ref may be used more than once. If not, we
     *   sometimes generate an extra assignment to make it repeatable.
     */

  }, {
    key: 'generateAssignments',
    value: function generateAssignments(patcher, ref, refIsRepeatable) {
      if (canPatchAssigneeToJavaScript(patcher.node)) {
        var assigneeCode = patcher.patchAndGetCode();
        if (patcher instanceof ArrayInitialiserPatcher) {
          return [assigneeCode + ' = Array.from(' + ref + ')'];
        } else {
          return [assigneeCode + ' = ' + ref];
        }
      } else if (patcher instanceof ExpansionPatcher) {
        // Expansions don't produce assignments.
        return [];
      } else if (patcher instanceof SpreadPatcher) {
        // Calling code seeing a spread patcher should provide an expression for
        // the resolved array.
        return this.generateAssignments(patcher.expression, ref, refIsRepeatable);
      } else if (patcher instanceof ArrayInitialiserPatcher) {
        if (!refIsRepeatable) {
          var arrReference = this.claimFreeBinding('array');
          return [arrReference + ' = ' + ref].concat(toConsumableArray(this.generateAssignments(patcher, arrReference, true)));
        }

        var assignees = patcher.members;
        var hasSeenExpansion = void 0;
        var assignments = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = assignees.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = slicedToArray(_step.value, 2),
                i = _step$value[0],
                assignee = _step$value[1];

            var valueCode = void 0;
            if (assignee instanceof ExpansionPatcher || assignee instanceof SpreadPatcher) {
              hasSeenExpansion = true;
              valueCode = ref + '.slice(' + i + ', ' + ref + '.length - ' + (assignees.length - i - 1) + ')';
            } else if (hasSeenExpansion) {
              valueCode = ref + '[' + ref + '.length - ' + (assignees.length - i) + ']';
            } else {
              valueCode = ref + '[' + i + ']';
            }
            assignments.push.apply(assignments, toConsumableArray(this.generateAssignments(assignee, valueCode, false)));
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return assignments;
      } else if (patcher instanceof ObjectInitialiserPatcher) {
        if (!refIsRepeatable) {
          var objReference = this.claimFreeBinding('obj');
          return [objReference + ' = ' + ref].concat(toConsumableArray(this.generateAssignments(patcher, objReference, true)));
        }

        var _assignments = [];
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = patcher.members[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var member = _step2.value;

            if (member instanceof ObjectInitialiserMemberPatcher) {
              var _valueCode = '' + ref + this.accessFieldForObjectDestructure(member.key);
              _assignments.push.apply(_assignments, toConsumableArray(this.generateAssignments(member.expression, _valueCode, false)));
            } else if (member instanceof AssignOpPatcher) {
              // Assignments like {a = b} = c end up as an assign op.
              var _valueCode2 = '' + ref + this.accessFieldForObjectDestructure(member.assignee);
              _assignments.push.apply(_assignments, toConsumableArray(this.generateAssignments(member, _valueCode2, false)));
            } else {
              throw this.error('Unexpected object initializer member: ' + patcher.node.type);
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        return _assignments;
      } else if (patcher instanceof SlicePatcher) {
        return [patcher.getSpliceCode(ref)];
      } else if (patcher instanceof AssignOpPatcher) {
        if (!refIsRepeatable) {
          var valReference = this.claimFreeBinding('val');
          return [valReference + ' = ' + ref].concat(toConsumableArray(this.generateAssignments(patcher, valReference, true)));
        }
        var defaultCode = patcher.expression.patchAndGetCode();
        return this.generateAssignments(patcher.assignee, ref + ' != null ? ' + ref + ' : ' + defaultCode, false);
      } else {
        throw this.error('Invalid assignee type: ' + patcher.node.type);
      }
    }
  }, {
    key: 'accessFieldForObjectDestructure',
    value: function accessFieldForObjectDestructure(patcher) {
      if (patcher instanceof IdentifierPatcher) {
        return '.' + patcher.node.data;
      } else if (patcher instanceof MemberAccessOpPatcher && patcher.expression instanceof ThisPatcher) {
        return '.' + patcher.node.member.data;
      } else if (patcher instanceof StringPatcher) {
        return '[' + patcher.patchAndGetCode() + ']';
      } else {
        throw this.error('Unexpected object destructure expression: ' + patcher.node.type);
      }
    }

    /**
     * If this is an assignment of the form `A.prototype.b = -> super`, we need to
     * mark the `A` expression, and possibly the indexed value, as repeatable so
     * that the super transform can make use of it.
     */

  }, {
    key: 'markProtoAssignmentRepeatableIfNecessary',
    value: function markProtoAssignmentRepeatableIfNecessary() {
      if (!(this.expression instanceof FunctionPatcher && this.expression.containsSuperCall())) {
        return null;
      }
      var prototypeAssignPatchers = extractPrototypeAssignPatchers(this);
      if (!prototypeAssignPatchers) {
        return null;
      }
      var classRefPatcher = prototypeAssignPatchers.classRefPatcher,
          methodAccessPatcher = prototypeAssignPatchers.methodAccessPatcher;

      classRefPatcher.setRequiresRepeatableExpression({
        parens: true,
        ref: 'cls'
      });
      if (methodAccessPatcher instanceof DynamicMemberAccessOpPatcher) {
        methodAccessPatcher.indexingExpr.setRequiresRepeatableExpression({
          ref: 'method'
        });
      }
    }
  }]);
  return AssignOpPatcher;
}(NodePatcher);

var BinaryOpPatcher = function (_NodePatcher) {
  inherits(BinaryOpPatcher, _NodePatcher);

  function BinaryOpPatcher(patcherContext, left, right) {
    classCallCheck(this, BinaryOpPatcher);

    var _this = possibleConstructorReturn(this, (BinaryOpPatcher.__proto__ || Object.getPrototypeOf(BinaryOpPatcher)).call(this, patcherContext));

    _this.binaryOpNegated = false;

    _this.left = left;
    _this.right = right;
    return _this;
  }
  // Avoid conflicting with the `negated` flag in some subclasses that have
  // special behavior.


  createClass(BinaryOpPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.left.setRequiresExpression();
      if (!this.rhsMayBeStatement()) {
        this.right.setRequiresExpression();
      }
    }

    /**
     * Subclasses can override to avoid setting the RHS as an expression by default.
     */

  }, {
    key: 'rhsMayBeStatement',
    value: function rhsMayBeStatement() {
      return false;
    }
  }, {
    key: 'negate',
    value: function negate() {
      this.binaryOpNegated = !this.binaryOpNegated;
    }

    /**
     * LEFT OP RIGHT
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$needsParens = _ref.needsParens,
          needsParens = _ref$needsParens === undefined ? false : _ref$needsParens;

      var addParens = needsParens && !this.isSurroundedByParentheses() || this.binaryOpNegated;
      if (this.binaryOpNegated) {
        this.insert(this.innerStart, '!');
      }
      if (addParens) {
        this.insert(this.innerStart, '(');
      }
      if (this.left instanceof BinaryOpPatcher) {
        this.left.patch({ needsParens: this.getOperator() !== this.left.getOperator() });
      } else {
        this.left.patch({ needsParens: true });
      }
      this.patchOperator();
      if (this.right instanceof BinaryOpPatcher) {
        this.right.patch({ needsParens: this.getOperator() !== this.right.getOperator() });
      } else {
        this.right.patch({ needsParens: true });
      }
      if (addParens) {
        this.insert(this.innerEnd, ')');
      }
    }
  }, {
    key: 'patchOperator',
    value: function patchOperator() {
      // override point for subclasses
    }
  }, {
    key: 'getOperator',
    value: function getOperator() {
      return this.sourceOfToken(this.getOperatorToken());
    }
  }, {
    key: 'getOperatorToken',
    value: function getOperatorToken() {
      var operatorTokenIndex = this.indexOfSourceTokenBetweenPatchersMatching(this.left, this.right, this.operatorTokenPredicate());
      if (!operatorTokenIndex) {
        throw this.error('expected operator between binary operands');
      }
      return this.sourceTokenAtIndex(operatorTokenIndex);
    }
  }, {
    key: 'operatorTokenPredicate',
    value: function operatorTokenPredicate() {
      return function (token) {
        return token.type === coffeeLex.SourceType.OPERATOR || token.type === coffeeLex.SourceType.EXISTENCE;
      };
    }

    /**
     * IF `LEFT` needs parens then `LEFT + RIGHT` needs parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return this.left.statementShouldAddParens();
    }
  }]);
  return BinaryOpPatcher;
}(NodePatcher);

var BoolPatcher = function (_NodePatcher) {
  inherits(BoolPatcher, _NodePatcher);

  function BoolPatcher() {
    classCallCheck(this, BoolPatcher);
    return possibleConstructorReturn(this, (BoolPatcher.__proto__ || Object.getPrototypeOf(BoolPatcher)).apply(this, arguments));
  }

  createClass(BoolPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      switch (this.getOriginalSource()) {
        case 'off':
        case 'no':
          this.overwrite(this.contentStart, this.contentEnd, 'false');
          break;

        case 'on':
        case 'yes':
          this.overwrite(this.contentStart, this.contentEnd, 'true');
          break;
      }
    }
  }]);
  return BoolPatcher;
}(NodePatcher);

function getCompareOperator(operator, negated) {
    switch (operator) {
        case '==':
        case 'is':
            return negated ? '!==' : '===';
        case '!=':
        case 'isnt':
            return negated ? '===' : '!==';
        case '<':
            return negated ? '>=' : '<';
        case '>':
            return negated ? '<=' : '>';
        case '<=':
            return negated ? '>' : '<=';
        case '>=':
            return negated ? '<' : '>=';
        default:
            throw this.error("unsupported equality/inequality type: " + operator);
    }
}

/**
 * Determine if this operator is unsafe to convert under the getCompareOperator
 * algorithm. For example, `a < b` can't be negated to `a >= b` because it would
 * be incorrect if either variable is `NaN`.
 */
/**
 * Determine if this operator is unsafe to convert under the getCompareOperator
 * algorithm. For example, `a < b` can't be negated to `a >= b` because it would
 * be incorrect if either variable is `NaN`.
 */function isCompareOpNegationUnsafe(operator) {
  return ['<', '>', '<=', '>='].indexOf(operator) > -1;
}

/**
 * Handles constructs of the form `a < b < c < … < z`.
 */
var ChainedComparisonOpPatcher = function (_NodePatcher) {
  inherits(ChainedComparisonOpPatcher, _NodePatcher);

  /**
   * `node` should have type `ChainedComparisonOp`.
   */
  function ChainedComparisonOpPatcher(patcherContext, operands) {
    classCallCheck(this, ChainedComparisonOpPatcher);

    var _this = possibleConstructorReturn(this, (ChainedComparisonOpPatcher.__proto__ || Object.getPrototypeOf(ChainedComparisonOpPatcher)).call(this, patcherContext));

    _this.operands = operands;
    _this.negated = false;
    return _this;
  }

  createClass(ChainedComparisonOpPatcher, [{
    key: 'initialize',
    value: function initialize() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.operands[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var operand = _step.value;

          operand.setRequiresExpression();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var negateEntireExpression = this.shouldNegateEntireExpression();
      if (negateEntireExpression) {
        this.insert(this.contentStart, '!(');
      }

      var middle = this.getMiddleOperands();
      var negated = !negateEntireExpression && this.negated;
      var logicalOperator = negated ? '||' : '&&';

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = middle[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var operand = _step2.value;

          operand.setRequiresRepeatableExpression({ parens: true, ref: 'middle' });
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.operands.entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _step3$value = slicedToArray(_step3.value, 2),
              i = _step3$value[0],
              _operand = _step3$value[1];

          _operand.patch();

          var operator = this.node.operators[i];

          if (operator) {
            var replacement = getCompareOperator(operator.operator, negated);

            if (operator.operator !== replacement) {
              this.overwrite(operator.token.start, operator.token.end, replacement);
            }
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = middle[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var _operand2 = _step4.value;

          // `a < b < c` → `a < b && b < c`
          //                     ^^^^^
          this.insert(_operand2.outerEnd, ' ' + logicalOperator + ' ' + _operand2.getRepeatCode());
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      if (negateEntireExpression) {
        this.insert(this.contentEnd, ')');
      }
    }

    /**
     * If any negation is unsafe, just wrap the whole thing in parens with a !
     * operator. That's easier and arguably nicer-looking than trying to
     * intelligently negate the subexpressions accounting for unsafe negations.
     */

  }, {
    key: 'shouldNegateEntireExpression',
    value: function shouldNegateEntireExpression() {
      return this.negated && this.node.operators.some(function (operator) {
        return isCompareOpNegationUnsafe(operator.operator);
      }) && !this.options.looseComparisonNegation;
    }

    /**
     * @private
     */

  }, {
    key: 'getMiddleOperands',
    value: function getMiddleOperands() {
      return this.operands.slice(1, -1);
    }
  }, {
    key: 'negate',
    value: function negate() {
      this.negated = !this.negated;
    }

    /**
     * Forward the request to the first operand.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return this.operands[0].statementShouldAddParens();
    }
  }]);
  return ChainedComparisonOpPatcher;
}(NodePatcher);

var ClassBoundMethodFunctionPatcher = function (_FunctionPatcher) {
  inherits(ClassBoundMethodFunctionPatcher, _FunctionPatcher);

  function ClassBoundMethodFunctionPatcher() {
    classCallCheck(this, ClassBoundMethodFunctionPatcher);
    return possibleConstructorReturn(this, (ClassBoundMethodFunctionPatcher.__proto__ || Object.getPrototypeOf(ClassBoundMethodFunctionPatcher)).apply(this, arguments));
  }

  createClass(ClassBoundMethodFunctionPatcher, [{
    key: 'expectedArrowType',
    value: function expectedArrowType() {
      return '=>';
    }
  }]);
  return ClassBoundMethodFunctionPatcher;
}(FunctionPatcher);

var ClassAssignOpPatcher = function (_ObjectBodyMemberPatc) {
  inherits(ClassAssignOpPatcher, _ObjectBodyMemberPatc);

  function ClassAssignOpPatcher() {
    classCallCheck(this, ClassAssignOpPatcher);
    return possibleConstructorReturn(this, (ClassAssignOpPatcher.__proto__ || Object.getPrototypeOf(ClassAssignOpPatcher)).apply(this, arguments));
  }

  createClass(ClassAssignOpPatcher, [{
    key: 'statementNeedsSemicolon',


    /**
     * Don't put semicolons after methods.
     */
    value: function statementNeedsSemicolon() {
      return !this.isMethod();
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.markKeyRepeatableIfNecessary();
      get(ClassAssignOpPatcher.prototype.__proto__ || Object.getPrototypeOf(ClassAssignOpPatcher.prototype), 'patchAsExpression', this).call(this);
      if (this.isStaticMethod()) {
        // `this.a: ->` → `static a: ->`
        //  ^^^^^          ^^^^^^^
        var memberNameToken = this.key.getMemberNameSourceToken();
        this.overwrite(this.key.outerStart, memberNameToken.start, 'static ');
      }
    }

    /**
     * If the method name is computed, we'll need to repeat it for any super call
     * that we do, so mark it as repeatable now.
     */

  }, {
    key: 'markKeyRepeatableIfNecessary',
    value: function markKeyRepeatableIfNecessary() {
      if (this.expression instanceof FunctionPatcher && this.expression.containsSuperCall()) {
        this.key.setRequiresRepeatableExpression();
      }
    }

    /**
     * @protected
     */

  }, {
    key: 'patchKey',
    value: function patchKey() {
      if (this.key instanceof MemberAccessOpPatcher) {
        // Do nothing; this case is handled elsewhere.
      } else {
        get(ClassAssignOpPatcher.prototype.__proto__ || Object.getPrototypeOf(ClassAssignOpPatcher.prototype), 'patchKey', this).call(this);
      }
    }

    /**
     * @protected
     */

  }, {
    key: 'patchAsProperty',
    value: function patchAsProperty() {
      // `name: null` → `name = null`
      //      ^^             ^^^
      var colonIndex = this.indexOfSourceTokenBetweenPatchersMatching(this.key, this.expression, function (token) {
        return token.type === coffeeLex.SourceType.COLON;
      });
      if (!colonIndex) {
        throw this.error('expected a colon between the key and expression of a class property');
      }
      var colonToken = this.sourceTokenAtIndex(colonIndex);
      this.overwrite(colonToken.start, colonToken.end, ' =');
      this.patchExpression();
    }

    /**
     * Determines if this class assignment matches the known patterns for static
     * methods in CoffeeScript, i.e.
     *
     *   class A
     *     this.a: ->
     *     @b: ->
     *     A.c: ->
     *
     * @protected
     */

  }, {
    key: 'isStaticMethod',
    value: function isStaticMethod() {
      if (!(this.key instanceof MemberAccessOpPatcher)) {
        return false;
      }

      var memberObject = this.key.expression;
      if (memberObject instanceof ThisPatcher) {
        return true;
      }

      var className = this.parent.parent.nameAssignee;
      return className instanceof IdentifierPatcher && memberObject instanceof IdentifierPatcher && className.node.data === className.node.data;
    }
  }, {
    key: 'isBoundInstanceMethod',
    value: function isBoundInstanceMethod() {
      return !this.isStaticMethod() && (this.expression.node.type === 'BoundFunction' || this.expression.node.type === 'BoundGeneratorFunction');
    }

    /**
     * For classes, unlike in objects, manually bound methods can use regular
     * method syntax because the bind happens in the constructor.
     *
     * @protected
     */

  }, {
    key: 'isMethod',
    value: function isMethod() {
      return this.expression instanceof ManuallyBoundFunctionPatcher || get(ClassAssignOpPatcher.prototype.__proto__ || Object.getPrototypeOf(ClassAssignOpPatcher.prototype), 'isMethod', this).call(this);
    }
  }], [{
    key: 'patcherClassForChildNode',
    value: function patcherClassForChildNode(node, property) {
      if (property === 'expression' && node.type === 'BoundFunction') {
        return ClassBoundMethodFunctionPatcher;
      }
      return null;
    }
  }]);
  return ClassAssignOpPatcher;
}(ObjectBodyMemberPatcher);

/**
 * A code snippet that can be placed at the top of a constructor to allow the
 * constructor to use `this` before `super`, at least when run through babel.
 *
 * This makes use of two techniques:
 * - babel does a static analysis check to make sure that all `this` accesses
 *   at least have a chance of happening after the first `super` call. We can
 *   wrap a super call in an `if (false)` at the top to silence this check
 *   without changing the runtime behavior (and later super calls will still
 *   work).
 * - babel compiles `this` usages in constructors to a separate variable,
 *   usually called `_this`, which gets assigned in the `super` line. However,
 *   the assignment to `_this` only happens when `super` actually runs, so it
 *   will normally be undefined before the `super` call. We can make `_this`
 *   resolve to `this` before the constructor by running `eval('_this = this;')`
 *   to escape babel's rewriting. However, the variable is not always called
 *   `_this`. We can still get the right variable name, though, but making an
 *   arrow function using `this`, calling `toString`, and parsing the variable
 *   name from it.
 */
var babelConstructorWorkaroundLines = ['{', '  // Hack: trick babel into allowing this before super.', '  if (false) { super(); }', '  let thisFn = (() => { this }).toString();', "  let thisName = thisFn.slice(thisFn.indexOf('{') + 1, thisFn.indexOf(';')).trim();", '  eval(`${thisName} = this;`);', '}'];

function getBindingCodeForMethod(method) {
  var accessCode = void 0;
  if (method.key instanceof IdentifierPatcher) {
    accessCode = '.' + method.key.node.data;
  } else {
    accessCode = '[' + method.key.getRepeatCode() + ']';
  }
  return 'this' + accessCode + ' = this' + accessCode + '.bind(this)';
}

/**
 * Remove indentation shared by all lines and remove leading and trailing
 * newlines.
 */
function stripSharedIndent(source) {
    var lines = source.split('\n');
    var commonIndent = getCommonIndent(lines);
    lines = lines.map(function (line) {
        if (line.startsWith(commonIndent)) {
            return line.substr(commonIndent.length);
        }
        if (/^\s*$/.test(line)) {
            return '';
        }
        return line;
    });
    while (lines.length > 0 && lines[0].length === 0) {
        lines.shift();
    }
    while (lines.length > 0 && lines[lines.length - 1].length === 0) {
        lines.pop();
    }
    return lines.join('\n');
}
function getCommonIndent(lines) {
    var commonIndent = null;
    for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
        var line = lines_1[_i];
        var indent = getIndent(line, 0);
        if (indent === line) {
            continue;
        }
        if (commonIndent === null) {
            commonIndent = indent;
        } else {
            for (var i = 0; i < commonIndent.length; i++) {
                if (i >= indent.length || indent[i] !== commonIndent[i]) {
                    commonIndent = commonIndent.substr(0, i);
                    break;
                }
            }
        }
    }
    return commonIndent === null ? '' : commonIndent;
}

function getInvalidConstructorErrorMessage(firstSentence) {
    return stripSharedIndent("\n    " + firstSentence + "\n    \n    JavaScript requires all subclass constructors to call `super` and to do so\n    before the first use of `this`, so the following cases cannot be converted\n    automatically:\n    * Constructors in subclasses that use `this` before `super`.\n    * Constructors in subclasses that omit the `super` call.\n    * Subclasses that use `=>` method syntax to automatically bind methods.\n    \n    To convert these cases to JavaScript anyway, run decaffeinate with\n    --allow-invalid-constructors. You will then need to fix these cases after the\n    conversion to JavaScript. Alternatively, you may want to first edit your\n    CoffeeScript code to avoid the above cases, so that decaffeinate can run without\n    this error message.\n    \n    If you are using Babel or TypeScript, you can run decaffeinate with\n    --enable-babel-constructor-workaround to generate Babel-specific code to allow\n    constructors that don't call `super`. Note that this approach is fragile and\n    may break in future versions of Babel/TypeScript.\n  ");
}

var ConstructorPatcher = function (_ObjectBodyMemberPatc) {
  inherits(ConstructorPatcher, _ObjectBodyMemberPatc);

  function ConstructorPatcher(patcherContext, assignee, expression) {
    classCallCheck(this, ConstructorPatcher);

    // Constructor methods do not have implicit returns.
    var _this = possibleConstructorReturn(this, (ConstructorPatcher.__proto__ || Object.getPrototypeOf(ConstructorPatcher)).call(this, patcherContext, assignee, expression));

    expression.disableImplicitReturns();
    return _this;
  }

  createClass(ConstructorPatcher, [{
    key: 'patch',
    value: function patch() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.checkForConstructorErrors();

      if (this.expression.body) {
        var linesToInsert = this.getLinesToInsert();
        this.expression.body.insertStatementsAtIndex(linesToInsert, 0);
        get(ConstructorPatcher.prototype.__proto__ || Object.getPrototypeOf(ConstructorPatcher.prototype), 'patch', this).call(this, options);
      } else {
        get(ConstructorPatcher.prototype.__proto__ || Object.getPrototypeOf(ConstructorPatcher.prototype), 'patch', this).call(this, options);
        var _linesToInsert = this.getLinesToInsert();
        if (_linesToInsert.length > 0) {
          (function () {
            // As a special case, if there's no function body but we still want to
            // generate bindings, overwrite the function body with the desired
            // contents, since it's sort of hard to insert contents in the middle of
            // the generated {}.
            var indent = _this2.getIndent();
            var bodyIndent = _this2.getIndent(1);
            var arrowToken = _this2.expression.getArrowToken();

            var fullLines = _linesToInsert.map(function (line) {
              return '' + bodyIndent + line + '\n';
            });
            var bodyCode = '{\n' + fullLines.join('') + indent + '}';
            _this2.overwrite(arrowToken.start, _this2.expression.outerEnd, bodyCode);
          })();
        }
      }
    }
  }, {
    key: 'getLinesToInsert',
    value: function getLinesToInsert() {
      var lines = [];
      if (this.shouldAddBabelWorkaround()) {
        lines = lines.concat(babelConstructorWorkaroundLines);
      }
      lines = lines.concat(this.getBindings());
      return lines;
    }

    /**
     * Give an up-front error if this is a subclass that either omits the `super`
     * call or uses `this` before `super`.
     */

  }, {
    key: 'checkForConstructorErrors',
    value: function checkForConstructorErrors() {
      if (this.options.allowInvalidConstructors || this.options.enableBabelConstructorWorkaround) {
        return;
      }

      var errorMessage = this.getInvalidConstructorMessage();
      if (errorMessage) {
        throw this.error(getInvalidConstructorErrorMessage(errorMessage));
      }
    }
  }, {
    key: 'shouldAddBabelWorkaround',
    value: function shouldAddBabelWorkaround() {
      return this.options.enableBabelConstructorWorkaround && this.getInvalidConstructorMessage() !== null;
    }

    /**
     * Return a string with an error if this constructor is invalid (generally one
     * that uses this before super). Otherwise return null.
     */

  }, {
    key: 'getInvalidConstructorMessage',
    value: function getInvalidConstructorMessage() {
      if (!this.isSubclass()) {
        return null;
      }

      // Any bindings would ideally go before the super call, so if there are any,
      // we'll need this before super.
      if (this.getBindings().length > 0) {
        return 'Cannot automatically convert a subclass that uses bound methods.';
      }

      var superIndex = this.getIndexOfSuperStatement();
      var thisIndex = this.getIndexOfFirstThisStatement();

      if (superIndex === -1) {
        return 'Cannot automatically convert a subclass with a constructor that does not call super.';
      }
      if (thisIndex >= 0 && thisIndex <= superIndex) {
        return 'Cannot automatically convert a subclass with a constructor that uses `this` before `super`.';
      }
      return null;
    }
  }, {
    key: 'getBindings',
    value: function getBindings() {
      if (!this._bindings) {
        var boundMethods = this.parent.boundInstanceMethods();
        var bindings = boundMethods.map(getBindingCodeForMethod);
        this._bindings = bindings;
      }
      return this._bindings;
    }
  }, {
    key: 'isSubclass',
    value: function isSubclass() {
      var enclosingClass = this.parent.parent;
      if (!(enclosingClass instanceof ClassPatcher)) {
        throw this.error('Expected grandparent of ConstructorPatcher to be ClassPatcher.');
      }
      return enclosingClass.isSubclass();
    }
  }, {
    key: 'getIndexOfSuperStatement',
    value: function getIndexOfSuperStatement() {
      if (!this.expression.body) {
        return -1;
      }
      var statements = this.expression.body.statements;

      var _loop = function _loop(i) {
        var callsSuper = false;
        traverse(statements[i].node, function (child) {
          if (callsSuper) {
            // Already found it, skip this one.
            return false;
          } else if (child.type === 'Super') {
            // Found it.
            callsSuper = true;
          } else if (child.type === 'Class') {
            // Don't go into other classes.
            return false;
          }
        });
        if (callsSuper) {
          return {
            v: i
          };
        }
      };

      for (var i = 0; i < statements.length; i++) {
        var _ret2 = _loop(i);

        if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
      }
      return -1;
    }
  }, {
    key: 'getIndexOfFirstThisStatement',
    value: function getIndexOfFirstThisStatement() {
      if (!this.expression.body) {
        return -1;
      }
      var statements = this.expression.body.statements;

      var _loop2 = function _loop2(i) {
        var usesThis = false;
        traverse(statements[i].node, function (child) {
          if (usesThis) {
            // Already found it, skip this one.
            return false;
          } else if (child.type === 'This') {
            // Found it.
            usesThis = true;
          } else if (child.type === 'Class' || isFunction(child)) {
            // Don't go into other classes or functions.
            return false;
          }
        });
        if (usesThis) {
          return {
            v: i
          };
        }
      };

      for (var i = 0; i < statements.length; i++) {
        var _ret3 = _loop2(i);

        if ((typeof _ret3 === 'undefined' ? 'undefined' : _typeof(_ret3)) === "object") return _ret3.v;
      }
      return -1;
    }

    /**
     * Don't put semicolons after class constructors.
     */

  }, {
    key: 'statementNeedsSemicolon',
    value: function statementNeedsSemicolon() {
      return false;
    }
  }]);
  return ConstructorPatcher;
}(ObjectBodyMemberPatcher);

var ClassBlockPatcher = function (_BlockPatcher) {
  inherits(ClassBlockPatcher, _BlockPatcher);

  function ClassBlockPatcher() {
    classCallCheck(this, ClassBlockPatcher);
    return possibleConstructorReturn(this, (ClassBlockPatcher.__proto__ || Object.getPrototypeOf(ClassBlockPatcher)).apply(this, arguments));
  }

  createClass(ClassBlockPatcher, [{
    key: 'patch',
    value: function patch() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.boundInstanceMethods()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var boundMethod = _step.value;

          boundMethod.key.setRequiresRepeatableExpression();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      get(ClassBlockPatcher.prototype.__proto__ || Object.getPrototypeOf(ClassBlockPatcher.prototype), 'patch', this).call(this, options);

      if (!this.hasConstructor()) {
        var boundMethods = this.boundInstanceMethods();
        if (boundMethods.length > 0) {
          (function () {
            var isSubclass = _this2.getClassPatcher().isSubclass();
            if (isSubclass && !_this2.shouldAllowInvalidConstructors()) {
              throw _this2.error(getInvalidConstructorErrorMessage('Cannot automatically convert a subclass that uses bound methods.'));
            }

            var source = _this2.context.source;

            var insertionPoint = _this2.statements[0].outerStart;
            var methodIndent = adjustIndent(source, insertionPoint, 0);
            var methodBodyIndent = adjustIndent(source, insertionPoint, 1);
            var constructor = '';
            if (isSubclass) {
              constructor += 'constructor(...args) {\n';
              if (_this2.shouldEnableBabelWorkaround()) {
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                  for (var _iterator2 = babelConstructorWorkaroundLines[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var line = _step2.value;

                    constructor += '' + methodBodyIndent + line + '\n';
                  }
                } catch (err) {
                  _didIteratorError2 = true;
                  _iteratorError2 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                      _iterator2.return();
                    }
                  } finally {
                    if (_didIteratorError2) {
                      throw _iteratorError2;
                    }
                  }
                }
              }
            } else {
              constructor += 'constructor() {\n';
            }
            boundMethods.forEach(function (method) {
              constructor += '' + methodBodyIndent + getBindingCodeForMethod(method) + ';\n';
            });
            if (isSubclass) {
              constructor += methodBodyIndent + 'super(...args)\n';
            }
            constructor += methodIndent + '}\n\n' + methodIndent;
            _this2.prependLeft(insertionPoint, constructor);
          })();
        }
      }
    }
  }, {
    key: 'shouldAllowInvalidConstructors',
    value: function shouldAllowInvalidConstructors() {
      return this.options.allowInvalidConstructors || this.options.enableBabelConstructorWorkaround;
    }
  }, {
    key: 'shouldEnableBabelWorkaround',
    value: function shouldEnableBabelWorkaround() {
      return this.options.enableBabelConstructorWorkaround;
    }
  }, {
    key: 'getClassPatcher',
    value: function getClassPatcher() {
      return this.parent;
    }
  }, {
    key: 'canPatchAsExpression',
    value: function canPatchAsExpression() {
      return false;
    }
  }, {
    key: 'hasConstructor',
    value: function hasConstructor() {
      return this.statements.some(function (statement) {
        return statement instanceof ConstructorPatcher;
      });
    }
  }, {
    key: 'boundInstanceMethods',
    value: function boundInstanceMethods() {
      return this.statements.filter(function (statement) {
        if (statement instanceof ClassAssignOpPatcher) {
          return statement.isBoundInstanceMethod();
        } else {
          return false;
        }
      });
    }
  }], [{
    key: 'patcherClassForChildNode',
    value: function patcherClassForChildNode(node, property) {
      if (property === 'statements' && node.type === 'AssignOp') {
        return ClassAssignOpPatcher;
      }
    }
  }]);
  return ClassBlockPatcher;
}(BlockPatcher);

// Taken from various constants in the CoffeeScript lexer:
// https://github.com/jashkenas/coffeescript/blob/master/src/lexer.coffee
var JS_KEYWORDS = ['true', 'false', 'null', 'this', 'new', 'delete', 'typeof', 'in', 'instanceof', 'return', 'throw', 'break', 'continue', 'debugger', 'yield', 'if', 'else', 'switch', 'for', 'while', 'do', 'try', 'catch', 'finally', 'class', 'extends', 'super', 'import', 'export', 'default'];
var COFFEE_KEYWORDS = ['undefined', 'Infinity', 'NaN', 'then', 'unless', 'until', 'loop', 'of', 'by', 'when'];
var COFFEE_ALIASES = ['and', 'or', 'is', 'isnt', 'not', 'yes', 'no', 'on', 'off'];
var RESERVED = ['case', 'default', 'function', 'var', 'void', 'with', 'const', 'let', 'enum', 'export', 'import', 'native', 'implements', 'interface', 'package', 'private', 'protected', 'public', 'static'];
var STRICT_PROSCRIBED = ['arguments', 'eval'];
var JS_FORBIDDEN = new Set(JS_KEYWORDS.concat(RESERVED, STRICT_PROSCRIBED));
var RESERVED_WORDS = new Set(JS_KEYWORDS.concat(COFFEE_KEYWORDS, COFFEE_ALIASES, RESERVED, STRICT_PROSCRIBED, [
// Mentioned in https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Future_reserved_keywords
'await']));
/**
 * Determine if the given string is a reserved word in either CoffeeScript or
 * JavaScript, useful to avoid generating variables with these names. Sometimes
 * we generate CoffeeScript and sometimes JavaScript, so just avoid names that
 * are reserved in either language.
 */
function isReservedWord(name) {
    return RESERVED_WORDS.has(name);
}
/**
 * Determine if the given name should not be used as a JavaScript variable,
 * conforming to CoffeeScript's equivalent implementation.
 */
function isForbiddenJsName(name) {
    return JS_FORBIDDEN.has(name);
}

var ClassPatcher = function (_NodePatcher) {
  inherits(ClassPatcher, _NodePatcher);

  function ClassPatcher(patcherContext, nameAssignee, parent, body) {
    classCallCheck(this, ClassPatcher);

    var _this = possibleConstructorReturn(this, (ClassPatcher.__proto__ || Object.getPrototypeOf(ClassPatcher)).call(this, patcherContext));

    _this.nameAssignee = nameAssignee;
    _this.superclass = parent;
    _this.body = body;
    return _this;
  }

  createClass(ClassPatcher, [{
    key: 'initialize',
    value: function initialize() {
      if (this.nameAssignee) {
        this.nameAssignee.setRequiresExpression();
      }
      if (this.superclass) {
        this.superclass.setRequiresExpression();
      }
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var hasParens = this.isSurroundedByParentheses();
      var anonymous = this.isAnonymous();
      if (anonymous && !hasParens) {
        // `class` → `(class`
        //            ^
        this.insert(this.innerStart, '(');
      }

      this.patchAsExpression();

      if (anonymous && !hasParens) {
        // `(class` → `(class)`
        //                   ^
        this.insert(this.innerEnd, ')');
      }
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var needsAssignment = this.nameAssignee && (this.isNamespaced() || this.isNameAlreadyDeclared() || this.willPatchAsExpression());
      var needsParens = needsAssignment && this.willPatchAsExpression() && !this.isSurroundedByParentheses();
      if (needsParens) {
        this.insert(this.contentStart, '(');
      }
      if (needsAssignment) {
        var classToken = this.getClassToken();
        // `class A.B` → `A.B`
        //  ^^^^^^
        this.remove(classToken.start, this.nameAssignee.outerStart);
        var name = this.getName();
        if (name) {
          // `A.B` → `A.B = class B`
          //             ^^^^^^^^^^
          this.insert(this.nameAssignee.outerEnd, ' = class ' + this.getName());
        } else {
          // `A[0]` → `A[0] = class`
          //               ^^^^^^^^
          this.insert(this.nameAssignee.outerEnd, ' = class');
        }
      }
      if (this.nameAssignee) {
        this.nameAssignee.patch();
      }
      if (this.superclass) {
        this.superclass.patch();
      }
      if (!this.body) {
        // `class A` → `class A {}`
        //                     ^^^
        this.insert(this.innerEnd, ' {}');
      } else {
        // `class A` → `class A {`
        //                     ^^
        this.insert(this.getBraceInsertionOffset(), ' {');
        this.body.patch({ leftBrace: false });
      }
      if (needsParens) {
        this.insert(this.contentEnd, ')');
      }
    }
  }, {
    key: 'statementNeedsSemicolon',
    value: function statementNeedsSemicolon() {
      return this.isAnonymous() || this.isNamespaced();
    }

    /**
     * Classes, like functions, only need parens as statements when anonymous.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return this.isAnonymous();
    }

    /**
     * @private
     */

  }, {
    key: 'getClassToken',
    value: function getClassToken() {
      var tokens$$1 = this.context.sourceTokens;
      var classSourceToken = tokens$$1.tokenAtIndex(this.contentStartTokenIndex);
      if (classSourceToken.type !== coffeeLex.SourceType.CLASS) {
        throw this.error('expected CLASS token but found ' + coffeeLex.SourceType[classSourceToken.type], classSourceToken.start, classSourceToken.end);
      }
      return classSourceToken;
    }

    /**
     * @private
     */

  }, {
    key: 'isAnonymous',
    value: function isAnonymous() {
      return this.nameAssignee === null;
    }

    /**
     * @private
     */

  }, {
    key: 'isNamespaced',
    value: function isNamespaced() {
      return !this.isAnonymous() && !(this.nameAssignee instanceof IdentifierPatcher);
    }

    /**
     * Determine if the name of this class already has a declaration earlier. If
     * so, we want to emit an assignment-style class instead of a class
     * declaration.
     */

  }, {
    key: 'isNameAlreadyDeclared',
    value: function isNameAlreadyDeclared() {
      var name = this.getName();
      return name && this.node.scope.getBinding(name) !== this.nameAssignee.node;
    }

    /**
     * @private
     */

  }, {
    key: 'getName',
    value: function getName() {
      var nameAssignee = this.nameAssignee;

      var name = void 0;
      if (nameAssignee instanceof IdentifierPatcher) {
        name = nameAssignee.node.data;
      } else if (nameAssignee instanceof MemberAccessOpPatcher) {
        name = nameAssignee.node.member.data;
      } else {
        name = null;
      }
      if (name !== null && isForbiddenJsName(name)) {
        name = '_' + name;
      }
      return name;
    }
  }, {
    key: 'isSubclass',
    value: function isSubclass() {
      return this.superclass !== null;
    }

    /**
     * @private
     */

  }, {
    key: 'getBraceInsertionOffset',
    value: function getBraceInsertionOffset() {
      if (this.superclass) {
        return this.superclass.outerEnd;
      }

      if (this.nameAssignee) {
        return this.nameAssignee.outerEnd;
      }

      return this.getClassToken().end;
    }
  }], [{
    key: 'patcherClassForChildNode',
    value: function patcherClassForChildNode(node, property) {
      if (property === 'body') {
        return ClassBlockPatcher;
      }
      return null;
    }
  }]);
  return ClassPatcher;
}(NodePatcher);

/**
 * Determine if there are any soak operations within this subtree of the AST.
 */
function nodeContainsSoakOperation(searchNode) {
  var foundSoak = false;
  traverse(searchNode, function (node) {
    if (foundSoak) {
      return false;
    }
    if (node.type === 'SoakedDynamicMemberAccessOp' || node.type === 'SoakedFunctionApplication' || node.type === 'SoakedMemberAccessOp') {
      foundSoak = true;
    }
  });
  return foundSoak;
}

var CompoundAssignOpPatcher = function (_AssignOpPatcher) {
  inherits(CompoundAssignOpPatcher, _AssignOpPatcher);

  function CompoundAssignOpPatcher() {
    classCallCheck(this, CompoundAssignOpPatcher);
    return possibleConstructorReturn(this, (CompoundAssignOpPatcher.__proto__ || Object.getPrototypeOf(CompoundAssignOpPatcher)).apply(this, arguments));
  }

  createClass(CompoundAssignOpPatcher, [{
    key: 'getOperatorToken',
    value: function getOperatorToken() {
      var operatorIndex = this.indexOfSourceTokenBetweenPatchersMatching(this.assignee, this.expression, function (token) {
        return token.type === coffeeLex.SourceType.OPERATOR;
      });
      if (!operatorIndex) {
        throw this.error('expected OPERATOR token between assignee and expression', this.assignee.outerEnd, this.expression.outerStart);
      }
      return this.sourceTokenAtIndex(operatorIndex);
    }

    /**
     * If `LHS` needs parens then `LHS += RHS` needs parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return this.assignee.statementShouldAddParens();
    }

    /**
     * If the left-hand side of the assignment has a soak operation, then there
     * may be a __guard__ call surrounding the whole thing, so we can't patch
     * statement code, so instead run the expression code path.
     */

  }, {
    key: 'lhsHasSoakOperation',
    value: function lhsHasSoakOperation() {
      return nodeContainsSoakOperation(this.assignee.node);
    }
  }]);
  return CompoundAssignOpPatcher;
}(AssignOpPatcher);

/**
 * Handles equality and inequality comparisons.
 */

var EqualityPatcher = function (_BinaryOpPatcher) {
  inherits(EqualityPatcher, _BinaryOpPatcher);

  function EqualityPatcher() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, EqualityPatcher);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = EqualityPatcher.__proto__ || Object.getPrototypeOf(EqualityPatcher)).call.apply(_ref, [this].concat(args))), _this), _this.negated = false, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(EqualityPatcher, [{
    key: 'patchOperator',
    value: function patchOperator() {
      var compareToken = this.getCompareToken();
      this.overwrite(compareToken.start, compareToken.end, this.getCompareOperator());
    }
  }, {
    key: 'getCompareOperator',
    value: function getCompareOperator$$1() {
      var token = this.getCompareToken();

      return getCompareOperator(this.sourceOfToken(token), this.negated);
    }

    /**
     * @private
     */

  }, {
    key: 'getCompareToken',
    value: function getCompareToken() {
      var left = this.left,
          right = this.right;

      var compareTokenIndex = this.indexOfSourceTokenBetweenPatchersMatching(left, right, function (token) {
        return token.type === coffeeLex.SourceType.OPERATOR;
      });

      if (!compareTokenIndex) {
        throw this.error('expected OPERATOR token but none was found', left.outerEnd, right.outerStart);
      }

      return this.sourceTokenAtIndex(compareTokenIndex);
    }

    /**
     * Flips negated flag but doesn't edit anything immediately so that we can
     * use the correct operator in `patch`. If the negation is unsafe, fall back
     * to the superclass default behavior of just adding ! to the front.
     */

  }, {
    key: 'negate',
    value: function negate() {
      if (isCompareOpNegationUnsafe(this.sourceOfToken(this.getCompareToken())) && !this.options.looseComparisonNegation) {
        return get(EqualityPatcher.prototype.__proto__ || Object.getPrototypeOf(EqualityPatcher.prototype), 'negate', this).call(this);
      }
      this.negated = !this.negated;
    }
  }]);
  return EqualityPatcher;
}(BinaryOpPatcher);

/**
 * Handles exponentiation, i.e. `a ** b`.
 */

var ExpOpPatcher = function (_BinaryOpPatcher) {
  inherits(ExpOpPatcher, _BinaryOpPatcher);

  function ExpOpPatcher() {
    classCallCheck(this, ExpOpPatcher);
    return possibleConstructorReturn(this, (ExpOpPatcher.__proto__ || Object.getPrototypeOf(ExpOpPatcher)).apply(this, arguments));
  }

  createClass(ExpOpPatcher, [{
    key: 'patchAsExpression',

    /**
     * LEFT '**' RIGHT
     */
    value: function patchAsExpression() {
      // `a ** b` → `Math.pow(a ** b`
      //             ^^^^^^^^^
      this.insert(this.contentStart, 'Math.pow(');

      this.left.patch();

      // `Math.pow(a ** b` → `Math.pow(a, b`
      //            ^^^^                ^^
      this.overwrite(this.left.outerEnd, this.right.outerStart, ', ');

      this.right.patch();

      // `Math.pow(a, b` → `Math.pow(a, b)`
      //                                 ^
      this.insert(this.contentEnd, ')');
    }

    /**
     * We'll always start with `Math.pow` so we don't need parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return false;
    }
  }]);
  return ExpOpPatcher;
}(BinaryOpPatcher);

var ExistsOpCompoundAssignOpPatcher = function (_CompoundAssignOpPatc) {
  inherits(ExistsOpCompoundAssignOpPatcher, _CompoundAssignOpPatc);

  function ExistsOpCompoundAssignOpPatcher() {
    classCallCheck(this, ExistsOpCompoundAssignOpPatcher);
    return possibleConstructorReturn(this, (ExistsOpCompoundAssignOpPatcher.__proto__ || Object.getPrototypeOf(ExistsOpCompoundAssignOpPatcher)).apply(this, arguments));
  }

  createClass(ExistsOpCompoundAssignOpPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$needsParens = _ref.needsParens,
          needsParens = _ref$needsParens === undefined ? false : _ref$needsParens;

      var shouldAddParens = needsParens && !this.isSurroundedByParentheses();
      if (shouldAddParens) {
        this.insert(this.outerStart, '(');
      }

      var assigneeAgain = void 0;
      if (this.needsTypeofCheck()) {
        // `a ?= b` → `typeof a ?= b`
        //             ^^^^^^^
        this.insert(this.assignee.outerStart, 'typeof ');
        assigneeAgain = this.assignee.patchRepeatable({ isForAssignment: true });
        // `typeof a ? b` → `typeof a !== 'undefined' && a !== null ? a ?= b`
        //                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        this.insert(this.assignee.outerEnd, ' !== \'undefined\' && ' + assigneeAgain + ' !== null ? ' + assigneeAgain);
      } else {
        assigneeAgain = this.assignee.patchRepeatable({ isForAssignment: true });
        // `a.b ?= b` → `a.b != null ? a.b ?= b`
        //                  ^^^^^^^^^^^^^^
        this.insert(this.assignee.outerEnd, ' != null ? ' + assigneeAgain);
      }

      var operator = this.getOperatorToken();
      // `a.b != null ? a.b ?= b` → `a.b != null ? a.b : (a.b = b`
      //                    ^^                         ^^^^^^^^
      this.overwrite(operator.start, operator.end, ': (' + assigneeAgain + ' =');
      this.expression.patch();
      // `a.b != null ? a.b : (a.b = b` → `a.b != null ? a.b : (a.b = b)`
      //                                                               ^
      this.insert(this.expression.outerEnd, ')');

      if (shouldAddParens) {
        this.insert(this.outerEnd, ')');
      }
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this.lhsHasSoakOperation(options)) {
        this.patchAsExpression();
        return;
      }

      var assigneeAgain = void 0;
      if (this.needsTypeofCheck()) {
        // `a ?= b` → `if (typeof a ?= b`
        //             ^^^^^^^^^^^
        this.insert(this.assignee.outerStart, 'if (typeof ');
        assigneeAgain = this.assignee.patchRepeatable({ isForAssignment: true });
        // `if (typeof a ?= b` → `if (typeof a === 'undefined' || a === null) { ?= b`
        //                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        this.insert(this.assignee.outerEnd, ' === \'undefined\' || ' + assigneeAgain + ' === null) {');
      } else {
        // `a.b ?= b` → `if (a.b ?= b`
        //               ^^^^
        this.insert(this.assignee.outerStart, 'if (');
        assigneeAgain = this.assignee.patchRepeatable({ isForAssignment: true });
        // `if (a.b ?= b` → `if (a.b == null) { ?= b`
        //                          ^^^^^^^^^^^
        this.insert(this.assignee.outerEnd, ' == null) {');
      }

      var operator = this.getOperatorToken();
      // `if (a.b == null) { ?= b` → `if (a.b == null) { a.b = b`
      //                     ^^                          ^^^^^
      this.overwrite(operator.start, operator.end, assigneeAgain + ' =');
      this.expression.patch();
      // `if (a.b == null) { a.b = b` → `if (a.b == null) { a.b = b; }`
      //                                                           ^^^
      this.insert(this.expression.outerEnd, '; }');
    }

    /**
     * Determine if we need to do `typeof a !== undefined && a !== null` rather
     * than just `a != null`. We need to emit the more defensive version if the
     * variable might not be declared.
     */

  }, {
    key: 'needsTypeofCheck',
    value: function needsTypeofCheck() {
      return this.assignee.mayBeUnboundReference();
    }

    /**
     * We'll always start with an `if` so we don't need parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return false;
    }
  }]);
  return ExistsOpCompoundAssignOpPatcher;
}(CompoundAssignOpPatcher);

var ExistsOpPatcher = function (_BinaryOpPatcher) {
  inherits(ExistsOpPatcher, _BinaryOpPatcher);

  function ExistsOpPatcher() {
    classCallCheck(this, ExistsOpPatcher);
    return possibleConstructorReturn(this, (ExistsOpPatcher.__proto__ || Object.getPrototypeOf(ExistsOpPatcher)).apply(this, arguments));
  }

  createClass(ExistsOpPatcher, [{
    key: 'rhsMayBeStatement',

    /**
     * If we are a statement, the RHS should be patched as a statement.
     */
    value: function rhsMayBeStatement() {
      return true;
    }
  }, {
    key: 'setExpression',
    value: function setExpression(force) {
      this.right.setRequiresExpression();
      get(ExistsOpPatcher.prototype.__proto__ || Object.getPrototypeOf(ExistsOpPatcher.prototype), 'setExpression', this).call(this, force);
    }

    /**
     * LEFT '?' RIGHT → `LEFT != null ? LEFT : RIGHT`
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var needsTypeofCheck = this.left.mayBeUnboundReference();
      if (needsTypeofCheck) {
        // `a ? b` → `typeof a ? b`
        //            ^^^^^^^
        this.insert(this.contentStart, 'typeof ');
        var leftAgain = this.left.patchRepeatable({ parens: true, ref: 'left' });
        // `typeof a ? b` → `typeof a !== 'undefined' && a !== null ? a : b`
        //          ^^^              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        this.overwrite(this.left.outerEnd, this.right.outerStart, ' !== \'undefined\' && ' + leftAgain + ' !== null ? ' + leftAgain + ' : ');
      } else {
        var _leftAgain = this.left.patchRepeatable({ parens: true, ref: 'left' });
        // `a.b ? c` → `a.b != null ? a.b : c`
        //     ^^^         ^^^^^^^^^^^^^^^^^
        this.overwrite(this.left.outerEnd, this.right.outerStart, ' != null ? ' + _leftAgain + ' : ');
      }
      this.right.patch();
    }

    /**
     * LEFT '?' RIGHT → `if (LEFT == null) { RIGHT }`
     */

  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var needsTypeofCheck = this.left.mayBeUnboundReference();
      // `a ? b` → `if (a ? b`
      //            ^^^
      this.insert(this.contentStart, 'if (');
      if (needsTypeofCheck) {
        var leftAgain = this.left.patchRepeatable();
        // `if (a ? b` → `if (typeof a ? b`
        //                    ^^^^^^^
        this.insert(this.contentStart, 'typeof ');
        // `if (typeof a ? b` → `if (typeof a === 'undefined' || a === null) { b`
        //              ^^^                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        this.overwrite(this.left.outerEnd, this.right.outerStart, ' === \'undefined\' || ' + leftAgain + ' === null) { ');
      } else {
        this.left.patch();
        // `if (a.b ? b.c` → `if (a.b == null) { b.c`
        //         ^^^               ^^^^^^^^^^^^
        this.overwrite(this.left.outerEnd, this.right.outerStart, ' == null) { ');
      }

      this.right.patch();
      // `if (a.b == null) { b.c` → `if (a.b == null) { b.c }`
      //                                                   ^^
      this.insert(this.innerEnd, ' }');
    }

    /**
     * We'll always start with an `if` so we don't need parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return false;
    }
  }]);
  return ExistsOpPatcher;
}(BinaryOpPatcher);

var EXTENDS_HELPER = '\nfunction __extends__(child, parent) {\n  Object.getOwnPropertyNames(parent).forEach(\n    name => child[name] = parent[name]\n  );\n  child.prototype = Object.create(parent.prototype);\n  child.__super__ = parent.prototype;\n  return child;\n}\n';

/**
 * Handles `extends` infix operator.
 */

var ExtendsOpPatcher = function (_BinaryOpPatcher) {
  inherits(ExtendsOpPatcher, _BinaryOpPatcher);

  function ExtendsOpPatcher() {
    classCallCheck(this, ExtendsOpPatcher);
    return possibleConstructorReturn(this, (ExtendsOpPatcher.__proto__ || Object.getPrototypeOf(ExtendsOpPatcher)).apply(this, arguments));
  }

  createClass(ExtendsOpPatcher, [{
    key: 'patchAsExpression',

    /**
     * CHILD extends PARENT
     */
    value: function patchAsExpression() {
      var helper = this.registerHelper('__extends__', EXTENDS_HELPER);
      this.insert(this.left.outerStart, helper + '(');
      this.left.patch();
      this.overwrite(this.left.outerEnd, this.right.outerStart, ', ');
      this.right.patch();
      this.insert(this.right.outerEnd, ')');
    }

    /**
     * We always prefix with `__extends__`, so no need for parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return false;
    }
  }]);
  return ExtendsOpPatcher;
}(BinaryOpPatcher);

var FloorDivideOpPatcher = function (_BinaryOpPatcher) {
  inherits(FloorDivideOpPatcher, _BinaryOpPatcher);

  function FloorDivideOpPatcher() {
    classCallCheck(this, FloorDivideOpPatcher);
    return possibleConstructorReturn(this, (FloorDivideOpPatcher.__proto__ || Object.getPrototypeOf(FloorDivideOpPatcher)).apply(this, arguments));
  }

  createClass(FloorDivideOpPatcher, [{
    key: 'patchAsExpression',

    /**
     * LEFT '//' RIGHT
     */
    value: function patchAsExpression() {
      var operator = this.getOperatorToken();

      // `a // b` → `Math.floor(a // b`
      //             ^^^^^^^^^^^
      this.insert(this.contentStart, 'Math.floor(');

      this.left.patch({ needsParens: true });

      // `Math.floor(a // b)` → `Math.floor(a / b)`
      //               ^^                     ^
      this.overwrite(operator.start, operator.end, '/');

      this.right.patch({ needsParens: true });

      // `Math.floor(a // b` → `Math.floor(a // b)`
      //                                         ^
      this.insert(this.contentEnd, ')');
    }

    /**
     * We always prefix with `Math.floor`, so no need for parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return false;
    }
  }]);
  return FloorDivideOpPatcher;
}(BinaryOpPatcher);

var LoopPatcher = function (_NodePatcher) {
  inherits(LoopPatcher, _NodePatcher);

  function LoopPatcher(patcherContext, body) {
    classCallCheck(this, LoopPatcher);

    var _this = possibleConstructorReturn(this, (LoopPatcher.__proto__ || Object.getPrototypeOf(LoopPatcher)).call(this, patcherContext));

    _this.body = body;
    return _this;
  }

  createClass(LoopPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _this2 = this;

      // We're only patched as an expression due to a parent instructing us to,
      // and the indent level is more logically the indent level of our parent.
      var baseIndent = this.parent.getIndent(0);
      var iifeBodyIndent = this.getLoopIndent();
      this.body.setShouldPatchInline(false);
      this.body.setImplicitlyReturns();
      this.body.setIndent(this.getLoopBodyIndent());
      var resultBinding = this.getResultArrayBinding();
      this.patchInIIFE(function () {
        _this2.insert(_this2.innerStart, '\n' + iifeBodyIndent + resultBinding + ' = [];\n' + iifeBodyIndent);
        _this2.patchAsStatement();
        _this2.insert(_this2.innerEnd, '\n' + iifeBodyIndent + 'return ' + resultBinding + ';\n' + baseIndent);
      });
    }

    /**
     * The first of three meaningful indentation levels for where we might want to
     * insert code.
     *
     * As an example, in this code:
     * a((() => {
     *   for (let i = 0; i < b.length; i++) {
     *     let val = b[i];
     *     if (val) {
     *       c;
     *     }
     *   )
     * })())
     *
     * - `getLoopIndent` returns the indentation of the `for`.
     * - `getOuterLoopBodyIndent` returns the indentation of the `if`.
     * - `getLoopBodyIndent` returns the indentation of `c`.
     *
     * However, these levels may change based on whether the loop has a condition,
     * and whether the loop is being formatted as an IIFE or as a regular loop
     * statement.
     *
     * We need to be especially careful about when to actually set the indentation
     * of existing code, since doing that too much can confuse magic-string. The
     * only code that actually is adjusted is the loop body (but only when it's
     * not an inline body), and this is done relatively early on in all cases.
     */

  }, {
    key: 'getLoopIndent',
    value: function getLoopIndent() {
      if (this.willPatchAsExpression()) {
        return this.parent.getIndent(1);
      } else {
        return this.getIndent();
      }
    }

    /**
     * @see getLoopIndent.
     */

  }, {
    key: 'getOuterLoopBodyIndent',
    value: function getOuterLoopBodyIndent() {
      return this.getLoopIndent() + this.getProgramIndentString();
    }

    /**
     * @see getLoopIndent.
     */

  }, {
    key: 'getLoopBodyIndent',
    value: function getLoopBodyIndent() {
      throw this.error('\'getLoopBodyIndent\' must be overridden in subclasses');
    }

    /**
     * IIFE-style loop expressions should always be multi-line, even if the loop
     * body in CoffeeScript is inline. This means we need to use a different
     * patching strategy where we insert a newline in the proper place before
     * generating code around the body, then we need to directly create the
     * indentation just before patching the body.
     */

  }, {
    key: 'patchPossibleNewlineAfterLoopHeader',
    value: function patchPossibleNewlineAfterLoopHeader(loopHeaderEndIndex) {
      if (this.shouldConvertInlineBodyToNonInline()) {
        this.overwrite(loopHeaderEndIndex, this.body.contentStart, '\n');
      }
    }
  }, {
    key: 'patchBodyWithPossibleItemVariable',
    value: function patchBodyWithPossibleItemVariable() {
      if (this.shouldConvertInlineBodyToNonInline()) {
        this.body.insert(this.body.outerStart, this.getLoopBodyIndent());
      }

      if (this.willPatchAsExpression() && !this.allBodyCodePathsPresent()) {
        var itemBinding = this.getResultArrayElementBinding();
        this.body.insertStatementsAtIndex(['let ' + itemBinding], 0);
        this.body.patch({ leftBrace: false, rightBrace: false });
        this.body.insertStatementsAtIndex([this.getResultArrayBinding() + '.push(' + itemBinding + ')'], this.body.statements.length);
      } else {
        this.body.patch({ leftBrace: false, rightBrace: false });
      }
    }
  }, {
    key: 'shouldConvertInlineBodyToNonInline',
    value: function shouldConvertInlineBodyToNonInline() {
      return this.willPatchAsExpression() && this.body.node.inline;
    }
  }, {
    key: 'canHandleImplicitReturn',
    value: function canHandleImplicitReturn() {
      return this.willPatchAsIIFE();
    }
  }, {
    key: 'willPatchAsIIFE',
    value: function willPatchAsIIFE() {
      throw this.error('\'willPatchAsIIFE\' must be overridden in subclasses');
    }

    /**
     * Most implicit returns cause program flow to break by using a `return`
     * statement, but we don't do that since we're just collecting values in
     * an array. This allows descendants who care about this to adjust their
     * behavior accordingly.
     */

  }, {
    key: 'implicitReturnWillBreak',
    value: function implicitReturnWillBreak() {
      return false;
    }

    /**
     * If this loop is used as an expression, then we need to collect all the
     * values of the statements in implicit-return position. If all the code paths
     * in our body are present, we can just add `result.push(…)` to all
     * implicit-return position statements. If not, we want those code paths to
     * result in adding `undefined` to the resulting array. The way we do that is
     * by creating an `item` local variable that we set in each code path, and
     * when the code exits through a missing code path (i.e. `if false then b`)
     * then `item` will naturally have the value `undefined` which we then push
     * at the end of the loop body.
     */

  }, {
    key: 'patchImplicitReturnStart',
    value: function patchImplicitReturnStart(patcher) {
      // Control flow statements like break and continue should be skipped.
      // Unlike some other control flow statements, CoffeeScript does not allow
      // them to be wrapped in parens, so we don't need to remove any parens here.
      if (!patcher.canPatchAsExpression()) {
        return;
      }
      patcher.setRequiresExpression();
      if (this.allBodyCodePathsPresent()) {
        // `a + b` → `result.push(a + b`
        //            ^^^^^^^^^^^^
        this.insert(patcher.outerStart, this.getResultArrayBinding() + '.push(');
      } else {
        // `a + b` → `item = a + b`
        //            ^^^^^^^
        this.insert(patcher.outerStart, this.getResultArrayElementBinding() + ' = ');
      }
    }

    /**
     * @see patchImplicitReturnStart
     */

  }, {
    key: 'patchImplicitReturnEnd',
    value: function patchImplicitReturnEnd(patcher) {
      if (!patcher.canPatchAsExpression()) {
        return;
      }
      if (this.allBodyCodePathsPresent()) {
        this.insert(patcher.outerEnd, ')');
      }
    }
  }, {
    key: 'allBodyCodePathsPresent',
    value: function allBodyCodePathsPresent() {
      if (this._allBodyCodePathsPresent === undefined) {
        this._allBodyCodePathsPresent = this.body.allCodePathsPresent();
      }
      return this._allBodyCodePathsPresent;
    }

    /**
     * @private
     */

  }, {
    key: 'getResultArrayBinding',
    value: function getResultArrayBinding() {
      if (!this._resultArrayBinding) {
        this._resultArrayBinding = this.claimFreeBinding('result');
      }
      return this._resultArrayBinding;
    }

    /**
     * @private
     */

  }, {
    key: 'getResultArrayElementBinding',
    value: function getResultArrayElementBinding() {
      if (!this._resultArrayElementBinding) {
        this._resultArrayElementBinding = this.claimFreeBinding('item');
      }
      return this._resultArrayElementBinding;
    }
  }, {
    key: 'statementNeedsSemicolon',
    value: function statementNeedsSemicolon() {
      return false;
    }
  }]);
  return LoopPatcher;
}(NodePatcher);

var ForPatcher = function (_LoopPatcher) {
  inherits(ForPatcher, _LoopPatcher);

  function ForPatcher(patcherContext, keyAssignee, valAssignee, target, filter, body) {
    classCallCheck(this, ForPatcher);

    var _this = possibleConstructorReturn(this, (ForPatcher.__proto__ || Object.getPrototypeOf(ForPatcher)).call(this, patcherContext, body));

    _this.keyAssignee = keyAssignee;
    _this.valAssignee = valAssignee;
    _this.target = target;
    _this.filter = filter;
    return _this;
  }

  createClass(ForPatcher, [{
    key: 'initialize',
    value: function initialize() {
      if (this.keyAssignee) {
        this.keyAssignee.setAssignee();
        this.keyAssignee.setRequiresExpression();
      }
      if (this.valAssignee) {
        this.valAssignee.setAssignee();
        this.valAssignee.setRequiresExpression();
      }
      this.target.setRequiresExpression();
      if (this.filter) {
        this.filter.setRequiresExpression();
      }
    }
  }, {
    key: 'getFilterCode',
    value: function getFilterCode() {
      var filter = this.filter;
      if (!filter) {
        return null;
      }
      if (!this._filterCode) {
        this._filterCode = filter.patchAndGetCode({ needsParens: false });
      }
      return this._filterCode;
    }
  }, {
    key: 'getLoopBodyIndent',
    value: function getLoopBodyIndent() {
      if (this.filter) {
        return this.getOuterLoopBodyIndent() + this.getProgramIndentString();
      } else {
        return this.getOuterLoopBodyIndent();
      }
    }
  }, {
    key: 'patchBodyAndFilter',
    value: function patchBodyAndFilter() {
      var body = this.body,
          filter = this.filter;


      if (filter) {
        this.body.insertLineBefore('if (' + this.getFilterCode() + ') {', this.getOuterLoopBodyIndent());
        this.patchBodyWithPossibleItemVariable();
        body.insertLineAfter('}', this.getOuterLoopBodyIndent());
        body.insertLineAfter('}', this.getLoopIndent());
      } else {
        this.patchBodyWithPossibleItemVariable();
        body.insertLineAfter('}', this.getLoopIndent());
      }
    }
  }, {
    key: 'getRelationToken',
    value: function getRelationToken() {
      var tokenIndex = this.indexOfSourceTokenBetweenPatchersMatching(this.keyAssignee || this.valAssignee, this.target, function (token) {
        return token.type === coffeeLex.SourceType.RELATION;
      });
      if (!tokenIndex) {
        throw this.error('cannot find relation keyword in \'for\' loop');
      }
      return this.sourceTokenAtIndex(tokenIndex);
    }

    /**
     * @protected
     */

  }, {
    key: 'getIndexBinding',
    value: function getIndexBinding() {
      if (!this._indexBinding) {
        this._indexBinding = this.computeIndexBinding();
      }
      return this._indexBinding;
    }

    /**
     * @protected
     */

  }, {
    key: 'computeIndexBinding',
    value: function computeIndexBinding() {
      var keyAssignee = this.keyAssignee;
      if (keyAssignee) {
        if (!(keyAssignee instanceof IdentifierPatcher)) {
          // CoffeeScript requires that the index be an identifier, not a pattern
          // matching expression, so this should never happen.
          throw keyAssignee.error('expected loop index to be an identifier');
        }
        return this.slice(keyAssignee.contentStart, keyAssignee.contentEnd);
      } else {
        return this.claimFreeBinding(this.indexBindingCandidates());
      }
    }

    /**
     * @protected
     */

  }, {
    key: 'indexBindingCandidates',
    value: function indexBindingCandidates() {
      return ['i', 'j', 'k'];
    }

    /**
     * @protected
     */

  }, {
    key: 'removeThenToken',
    value: function removeThenToken() {
      var index = this.indexOfSourceTokenBetweenSourceIndicesMatching(this.getLoopHeaderEnd(), this.body.outerStart, function (token) {
        return token.type === coffeeLex.SourceType.THEN;
      });
      if (index) {
        var thenToken = this.sourceTokenAtIndex(index);
        var nextToken = this.sourceTokenAtIndex(index.next());
        this.remove(thenToken.start, nextToken.start);
      }
    }

    /**
     * Get the last known index of the loop header, just before the `then` token
     * or the body. This can be overridden to account for additional loop header
     * elements.
     */

  }, {
    key: 'getLoopHeaderEnd',
    value: function getLoopHeaderEnd() {
      return Math.max(this.filter ? this.filter.outerEnd : -1, this.target.outerEnd);
    }
  }, {
    key: 'getTargetCode',
    value: function getTargetCode() {
      this.computeTargetCodeIfNecessary();
      return this._targetCode;
    }
  }, {
    key: 'getTargetReference',
    value: function getTargetReference() {
      this.computeTargetCodeIfNecessary();
      return this._targetReference;
    }
  }, {
    key: 'computeTargetCodeIfNecessary',
    value: function computeTargetCodeIfNecessary() {
      if (!this._targetReference || !this._targetCode) {
        this._targetCode = this.target.patchAndGetCode();
        if (this.requiresExtractingTarget()) {
          this._targetReference = this.claimFreeBinding(this.targetBindingCandidate());
        } else {
          this._targetReference = this._targetCode;
        }
      }
    }
  }]);
  return ForPatcher;
}(LoopPatcher);

var RANGE_HELPER = 'function __range__(left, right, inclusive) {\n  let range = [];\n  let ascending = left < right;\n  let end = !inclusive ? right : ascending ? right + 1 : right - 1;\n  for (let i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\n    range.push(i);\n  }\n  return range;\n}';

var MAXIMUM_LITERAL_RANGE_ELEMENTS = 21;

var RangePatcher = function (_BinaryOpPatcher) {
  inherits(RangePatcher, _BinaryOpPatcher);

  function RangePatcher() {
    classCallCheck(this, RangePatcher);
    return possibleConstructorReturn(this, (RangePatcher.__proto__ || Object.getPrototypeOf(RangePatcher)).apply(this, arguments));
  }

  createClass(RangePatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      if (this.canBecomeLiteralArray()) {
        this.patchAsLiteralArray();
      } else {
        this.patchAsIIFE();
      }
    }

    /**
     * @private
     */

  }, {
    key: 'patchAsLiteralArray',
    value: function patchAsLiteralArray() {
      var start = this.left.node.data;
      var end = this.right.node.data;
      var inclusive = this.isInclusive();
      var ascending = start < end;

      if (inclusive) {
        end += ascending ? 1 : -1;
      }

      var list = '';

      for (var i = start; ascending ? i < end : i > end; ascending ? i++ : i--) {
        var isLast = ascending ? i === end - 1 : i === end + 1;
        if (isLast) {
          list += '' + i;
        } else {
          list += i + ', ';
        }
      }

      // `[0..2]` → `[0, 1, 2]`
      //  ^^^^^^     ^^^^^^^^^
      this.overwrite(this.contentStart, this.contentEnd, '[' + list + ']');
    }

    /**
     * @private
     */

  }, {
    key: 'patchAsIIFE',
    value: function patchAsIIFE() {
      var helper = this.registerHelper('__range__', RANGE_HELPER);

      // `[a..b]` → `__range__(a..b]`
      //  ^          ^^^^^^^^^^
      this.overwrite(this.contentStart, this.left.outerStart, helper + '(');

      this.left.patch();

      // `__range__(a..b]` → `__range__(a, b]`
      //             ^^                  ^^
      this.overwrite(this.left.outerEnd, this.right.outerStart, ', ');

      this.right.patch();

      // `__range__(a, b]` → `__range__(a, b, true)`
      //                ^                   ^^^^^^
      this.overwrite(this.right.outerEnd, this.contentEnd, ', ' + this.isInclusive() + ')');
    }

    /**
     * @private
     */

  }, {
    key: 'canBecomeLiteralArray',
    value: function canBecomeLiteralArray() {
      var range = this.getLiteralRange();

      if (!range) {
        return false;
      }

      var _range = slicedToArray(range, 2),
          first = _range[0],
          last = _range[1];

      return Math.abs(last - first) <= MAXIMUM_LITERAL_RANGE_ELEMENTS;
    }

    /**
     * @private
     */

  }, {
    key: 'getLiteralRange',
    value: function getLiteralRange() {
      var left = this.left.node;
      var right = this.right.node;

      if (left.type !== 'Int' || right.type !== 'Int') {
        return false;
      }

      var first = left.data;
      var last = right.data;
      if (first < last) {
        return [first, last + (this.isInclusive() ? 1 : 0)];
      } else {
        return [first, last - (this.isInclusive() ? 1 : 0)];
      }
    }

    /**
     * @private
     */

  }, {
    key: 'isInclusive',
    value: function isInclusive() {
      return this.node.isInclusive;
    }
  }]);
  return RangePatcher;
}(BinaryOpPatcher);

/**
 * Gets the number of usages of the given name in the given node.
 */
function countVariableUsages(node, name) {
  var numUsages = 0;
  traverse(node, function (child) {
    if (child.type === 'Identifier' && child.data === name) {
      numUsages += 1;
    }
  });
  return numUsages;
}

var UP = 'UP';
var DOWN = 'DOWN';
var UNKNOWN = 'UNKNOWN';

var ForInPatcher = function (_ForPatcher) {
  inherits(ForInPatcher, _ForPatcher);

  function ForInPatcher(patcherContext, keyAssignee, valAssignee, target, step, filter, body) {
    classCallCheck(this, ForInPatcher);

    var _this = possibleConstructorReturn(this, (ForInPatcher.__proto__ || Object.getPrototypeOf(ForInPatcher)).call(this, patcherContext, keyAssignee, valAssignee, target, filter, body));

    _this.step = step;
    return _this;
  }

  createClass(ForInPatcher, [{
    key: 'initialize',
    value: function initialize() {
      get(ForInPatcher.prototype.__proto__ || Object.getPrototypeOf(ForInPatcher.prototype), 'initialize', this).call(this);
      if (this.step) {
        this.step.setRequiresExpression();
      }
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      // When possible, we want to transform the loop into a use of `map`, but
      // there are some cases when we can't. Use the more general approach of a
      // statement loop within an IIFE if that's the case.
      if (!this.canPatchAsMapExpression()) {
        return get(ForInPatcher.prototype.__proto__ || Object.getPrototypeOf(ForInPatcher.prototype), 'patchAsExpression', this).call(this);
      }
      this.removeThenToken();

      var assigneeCode = this.getValueBinding();
      if (this.keyAssignee) {
        assigneeCode += ', ' + this.getIndexBinding();
      }

      // for a in b when c d  ->  b when c d
      // ("then" was removed above).
      this.remove(this.contentStart, this.target.outerStart);

      if (this.shouldWrapMapExpressionTargetInArrayFrom()) {
        this.insert(this.target.contentStart, 'Array.from(');
      }
      this.target.patch();
      if (this.shouldWrapMapExpressionTargetInArrayFrom()) {
        this.insert(this.target.contentEnd, ')');
      }

      if (this.filter !== null) {
        // b when c d  ->  b.filter((a) => c d
        this.overwrite(this.target.outerEnd, this.filter.outerStart, '.filter((' + assigneeCode + ') => ');
        this.filter.patch();
        // b.filter((a) => c d  ->  b.filter((a) => c).map((a) => d
        this.insert(this.filter.outerEnd, ').map((' + assigneeCode + ') =>');
      } else {
        // b d  ->  b.map((a) => d
        this.insert(this.target.outerEnd, '.map((' + assigneeCode + ') =>');
      }
      this.patchBodyForExpressionLoop();
      // b.filter((a) => c).map((a) => d  ->  b.filter((a) => c).map((a) => d)
      this.insert(this.body.outerEnd, ')');
    }
  }, {
    key: 'patchBodyForExpressionLoop',
    value: function patchBodyForExpressionLoop() {
      this.body.setRequiresExpression();
      var bodyNeedsParens = blockStartsWithObjectInitialiser(this.body) && !this.body.isSurroundedByParentheses();
      if (bodyNeedsParens) {
        var insertPoint = this.filter ? this.filter.outerEnd : this.target.outerEnd;
        // Handle both inline and multiline cases by either skipping the existing
        // space or adding one.
        if (this.slice(insertPoint, insertPoint + 1) === ' ') {
          this.body.insert(insertPoint + 1, '(');
        } else {
          this.body.insert(insertPoint, ' (');
        }
      }
      this.body.patch();
      if (bodyNeedsParens) {
        this.body.insert(this.body.outerEnd, ')');
      }
    }
  }, {
    key: 'canPatchAsMapExpression',
    value: function canPatchAsMapExpression() {
      if (!this.canAssigneesBecomeParams()) {
        return false;
      }
      if (this.step !== null) {
        return false;
      }
      if (!this.body.canPatchAsExpression()) {
        return false;
      }
      // The high-level approach of a.filter(...).map((x, i) => ...) doesn't work,
      // since the filter will change the indexes, so we specifically exclude that
      // case.
      if (this.filter !== null && this.keyAssignee !== null) {
        return false;
      }
      return true;
    }
  }, {
    key: 'canAssigneesBecomeParams',
    value: function canAssigneesBecomeParams() {
      var assignees = [this.valAssignee, this.keyAssignee].filter(function (assignee) {
        return assignee;
      });
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = assignees[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var assignee = _step.value;

          if (!(assignee instanceof IdentifierPatcher)) {
            return false;
          }
          var name = assignee.node.data;
          // Find the enclosing function or program node for the binding so we can
          // find all usages of this variable.
          var assignmentNode = this.node.scope.getBinding(name);
          if (!assignmentNode) {
            throw this.error('Expected loop assignee to have a binding in its scope.');
          }
          var containerNode = assignmentNode.scope.containerNode;
          // If the number of usages in the enclosing function is more than the
          // number of usages in the loop, then there must be some external usages,
          // so we can't safely change this to a parameter.
          if (countVariableUsages(containerNode, name) !== countVariableUsages(this.node, name)) {
            return false;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return true;
    }
  }, {
    key: 'willPatchAsIIFE',
    value: function willPatchAsIIFE() {
      return this.willPatchAsExpression() && !this.canPatchAsMapExpression();
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      if (!this.body.inline()) {
        this.body.setIndent(this.getLoopBodyIndent());
      }

      if (this.shouldPatchAsForOf()) {
        this.getFilterCode();
        this.patchForOfLoop();
      } else {
        // Run for the side-effect of patching and slicing the value.
        this.getValueBinding();
        this.getFilterCode();

        this.patchForLoopHeader();
        this.patchForLoopBody();
      }
    }

    /**
     * As long as we aren't using the loop index or a step, we prefer to use JS
     * for-of loops.
     */

  }, {
    key: 'shouldPatchAsForOf',
    value: function shouldPatchAsForOf() {
      return !this.shouldPatchAsInitTestUpdateLoop() && this.step === null && this.keyAssignee === null;
    }
  }, {
    key: 'getValueBinding',
    value: function getValueBinding() {
      if (!this._valueBinding) {
        if (this.valAssignee) {
          this._valueBinding = this.valAssignee.patchAndGetCode();
        } else if (this.shouldPatchAsInitTestUpdateLoop()) {
          this._valueBinding = this.claimFreeBinding(this.indexBindingCandidates());
        } else {
          this._valueBinding = this.claimFreeBinding('value');
        }
      }
      return this._valueBinding;
    }

    /**
     * @protected
     */

  }, {
    key: 'computeIndexBinding',
    value: function computeIndexBinding() {
      if (this.shouldPatchAsInitTestUpdateLoop()) {
        return this.getValueBinding();
      } else {
        return get(ForInPatcher.prototype.__proto__ || Object.getPrototypeOf(ForInPatcher.prototype), 'computeIndexBinding', this).call(this);
      }
    }
  }, {
    key: 'patchForLoopHeader',
    value: function patchForLoopHeader() {
      if (this.requiresExtractingTarget()) {
        this.insert(this.innerStart, this.getTargetReference() + ' = ' + this.getTargetCode() + '\n' + this.getLoopIndent());
      }
      var firstHeaderPatcher = this.valAssignee || this.target;
      var lastHeaderPatcher = this.getLastHeaderPatcher();
      this.overwrite(firstHeaderPatcher.outerStart, lastHeaderPatcher.outerEnd, '(' + this.getInitCode() + '; ' + this.getTestCode() + '; ' + this.getUpdateCode() + ') {');
    }
  }, {
    key: 'getLastHeaderPatcher',
    value: function getLastHeaderPatcher() {
      return [this.step, this.filter, this.target].filter(function (patcher) {
        return patcher;
      }).reduce(function (last, patcher) {
        return patcher.contentEnd > last.contentEnd ? patcher : last;
      });
    }
  }, {
    key: 'patchForLoopBody',
    value: function patchForLoopBody() {
      this.removeThenToken();
      this.patchPossibleNewlineAfterLoopHeader(this.getLastHeaderPatcher().outerEnd);

      if (!this.shouldPatchAsInitTestUpdateLoop() && this.valAssignee) {
        var valueAssignment = this.getValueBinding() + ' = ' + this.getTargetReference() + '[' + this.getIndexBinding() + ']';
        if (this.valAssignee.statementNeedsParens()) {
          valueAssignment = '(' + valueAssignment + ')';
        }
        this.body.insertLineBefore(valueAssignment, this.getOuterLoopBodyIndent());
      }
      this.patchBodyAndFilter();
    }

    /**
     * Special case for patching for-of case for when the loop is simple enough
     * that for-of works. Note that for-of has slightly different semantics
     * because it uses the iterator protocol rather than CoffeeScript's notion of
     * an array-like object, so this transform sacrifices 100% correctness in
     * favor of cleaner code.
     */

  }, {
    key: 'patchForOfLoop',
    value: function patchForOfLoop() {
      // Save the filter code and remove if it it's there.
      this.getFilterCode();
      if (this.filter) {
        this.remove(this.target.outerEnd, this.filter.outerEnd);
      }

      if (this.valAssignee) {
        var relationToken = this.getRelationToken();
        this.valAssignee.patch();
        this.insert(this.valAssignee.outerStart, '(');
        this.overwrite(relationToken.start, relationToken.end, 'of');
      } else {
        // Handle loops like `for [0..2]`
        var valueBinding = this.getValueBinding();
        this.insert(this.target.outerStart, '(let ' + valueBinding + ' of ');
      }

      if (this.shouldWrapForOfStatementTargetInArrayFrom()) {
        this.insert(this.target.outerStart, 'Array.from(');
      }
      this.target.patch();
      if (this.shouldWrapForOfStatementTargetInArrayFrom()) {
        this.insert(this.target.outerEnd, ')');
      }
      this.insert(this.target.outerEnd, ') {');
      this.removeThenToken();
      this.patchBodyAndFilter();
    }
  }, {
    key: 'getLoopHeaderEnd',
    value: function getLoopHeaderEnd() {
      return Math.max(this.step ? this.step.outerEnd : -1, get(ForInPatcher.prototype.__proto__ || Object.getPrototypeOf(ForInPatcher.prototype), 'getLoopHeaderEnd', this).call(this));
    }
  }, {
    key: 'requiresExtractingTarget',
    value: function requiresExtractingTarget() {
      return !this.shouldPatchAsInitTestUpdateLoop() && !this.target.isRepeatable() && !this.shouldPatchAsForOf();
    }
  }, {
    key: 'targetBindingCandidate',
    value: function targetBindingCandidate() {
      return 'iterable';
    }
  }, {
    key: 'getInitCode',
    value: function getInitCode() {
      var step = this.getStep();
      if (this.shouldPatchAsInitTestUpdateLoop()) {
        var assignments = [];
        if (this.shouldExtractStart()) {
          assignments.push(this.getStartReference() + ' = ' + this.getStartCode());
        }
        assignments.push(this.getIndexBinding() + ' = ' + this.getStartReference());
        if (!this.isEndFixed()) {
          assignments.push(this.getEndReference() + ' = ' + this.getEndCode());
        }
        if (!step.isLiteral) {
          assignments.push(step.update + ' = ' + step.init);
        }
        if (this.getIndexDirection() === UNKNOWN) {
          assignments.push(this.getAscReference() + ' = ' + this.getAscCode());
        }
        return assignments.join(', ');
      } else {
        var direction = this.getIndexDirection();
        var descInit = this.getTargetReference() + '.length - 1';

        var _assignments = [];
        if (!step.isLiteral) {
          _assignments.push(step.update + ' = ' + step.init);
        }
        if (direction === DOWN) {
          _assignments.push(this.getIndexBinding() + ' = ' + descInit);
        } else if (direction === UP) {
          _assignments.push(this.getIndexBinding() + ' = 0');
        } else {
          _assignments.push(this.getAscReference() + ' = ' + this.getAscCode());
          _assignments.push(this.getIndexBinding() + ' = ' + this.getAscReference() + ' ? 0 : ' + descInit);
        }
        return _assignments.join(', ');
      }
    }
  }, {
    key: 'getTestCode',
    value: function getTestCode() {
      var direction = this.getIndexDirection();
      if (this.shouldPatchAsInitTestUpdateLoop()) {
        var inclusive = this.target.isInclusive();
        var gt = inclusive ? '>=' : '>';
        var lt = inclusive ? '<=' : '<';
        var index = this.getIndexBinding();
        var end = this.getEndReference();

        if (direction === DOWN) {
          return index + ' ' + gt + ' ' + end;
        } else if (direction === UP) {
          return index + ' ' + lt + ' ' + end;
        } else {
          return this.getAscReference() + ' ? ' + index + ' ' + lt + ' ' + end + ' : ' + index + ' ' + gt + ' ' + end;
        }
      } else {
        var downComparison = this.getIndexBinding() + ' >= 0';
        var upComparison = this.getIndexBinding() + ' < ' + this.getTargetReference() + '.length';
        if (direction === DOWN) {
          return downComparison;
        } else if (direction === UP) {
          return upComparison;
        } else {
          return this.getAscReference() + ' ? ' + upComparison + ' : ' + downComparison;
        }
      }
    }
  }, {
    key: 'getUpdateCode',
    value: function getUpdateCode() {
      var index = this.getIndexBinding();
      var step = this.getStep();

      // If step is a variable, we always just add it, since its value determines
      // whether we go forward or backward.
      if (step.number === null) {
        return index + ' += ' + step.update;
      }

      var direction = this.getIndexDirection();
      var incCode = step.number === 1 ? '++' : ' += ' + step.update;
      var decCode = step.number === 1 ? '--' : ' -= ' + step.update;

      if (direction === DOWN) {
        return '' + index + decCode;
      } else if (direction === UP) {
        return '' + index + incCode;
      } else {
        return this.getAscReference() + ' ? ' + index + incCode + ' : ' + index + decCode;
      }
    }
  }, {
    key: 'getStartReference',
    value: function getStartReference() {
      if (!this.shouldExtractStart()) {
        return this.getStartCode();
      }
      if (!this._startReference) {
        this._startReference = this.claimFreeBinding('start');
      }
      return this._startReference;
    }
  }, {
    key: 'isStartFixed',
    value: function isStartFixed() {
      return this.target.left.node.type === 'Int' || this.target.left.node.type === 'Float';
    }

    /**
     * In many cases, we can just initialize the index to the start without an
     * intermediate variable. We only need to save a variable if it's not
     * repeatable and we need to use it to compute the direction.
     */

  }, {
    key: 'shouldExtractStart',
    value: function shouldExtractStart() {
      return !this.target.left.isRepeatable() && this.getIndexDirection() === UNKNOWN && this.getStep().isVirtual;
    }
  }, {
    key: 'getStartCode',
    value: function getStartCode() {
      if (!this._startCode) {
        this._startCode = this.target.left.patchAndGetCode();
      }
      return this._startCode;
    }
  }, {
    key: 'getEndReference',
    value: function getEndReference() {
      if (this.isEndFixed()) {
        return this.getEndCode();
      }
      if (!this._endReference) {
        this._endReference = this.claimFreeBinding('end');
      }
      return this._endReference;
    }
  }, {
    key: 'isEndFixed',
    value: function isEndFixed() {
      return this.target.right.node.type === 'Int' || this.target.right.node.type === 'Float';
    }
  }, {
    key: 'getEndCode',
    value: function getEndCode() {
      if (!this._endCode) {
        this._endCode = this.target.right.patchAndGetCode();
      }
      return this._endCode;
    }
  }, {
    key: 'getAscReference',
    value: function getAscReference() {
      if (!this._ascReference) {
        this._ascReference = this.claimFreeBinding('asc');
      }
      return this._ascReference;
    }

    /**
     * Return the code snippet to determine whether the loop counts up or down, in
     * the event that it needs to be computed at runtime.
     */

  }, {
    key: 'getAscCode',
    value: function getAscCode() {
      var step = this.getStep();
      if (step.isVirtual) {
        if (!this.shouldPatchAsInitTestUpdateLoop()) {
          throw new Error('Should not be getting asc code when the target is not a range and ' + 'the step is unspecified.');
        }
        return this.getStartReference() + ' <= ' + this.getEndReference();
      } else {
        return step.update + ' > 0';
      }
    }
  }, {
    key: 'getStep',
    value: function getStep() {
      if (this._step === undefined) {
        this._step = new Step(this.step);
      }
      return this._step;
    }

    /**
     * Determine if we should patch in a way where the loop variable is updated in
     * a C-style for loop. This happens when looping over a range (e.g.
     * `for i of [a...b]`, and in fact we must patch in the style when looping
     * over ranges since CoffeeScript code might depend on the variable being one
     * past the end after the loop runs to completion.
     *
     * For more complicated cases, we need to dynamically compute what direction
     * to iterate in.
     */

  }, {
    key: 'shouldPatchAsInitTestUpdateLoop',
    value: function shouldPatchAsInitTestUpdateLoop() {
      return this.target instanceof RangePatcher;
    }
  }, {
    key: 'shouldWrapMapExpressionTargetInArrayFrom',
    value: function shouldWrapMapExpressionTargetInArrayFrom() {
      return !this.options.looseForExpressions && !this.isTargetAlreadyArray();
    }
  }, {
    key: 'shouldWrapForOfStatementTargetInArrayFrom',
    value: function shouldWrapForOfStatementTargetInArrayFrom() {
      return !this.options.looseForOf && !this.isTargetAlreadyArray();
    }

    /**
     * Determine if the loop target is statically known to be an array. If so,
     * then there's no need to use Array.from to convert from an array-like object
     * to an array.
     */

  }, {
    key: 'isTargetAlreadyArray',
    value: function isTargetAlreadyArray() {
      return this.target instanceof RangePatcher || this.target instanceof ArrayInitialiserPatcher;
    }

    /**
     * Determines whether this `for…in` loop has an explicit `by` step.
     */

  }, {
    key: 'hasExplicitStep',
    value: function hasExplicitStep() {
      return !this.getStep().isVirtual;
    }

    /**
     * Determines the direction of index iteration, either UP, DOWN, or UNKNOWN.
     * UNKNOWN means that we cannot statically determine the direction.
     */

  }, {
    key: 'getIndexDirection',
    value: function getIndexDirection() {
      var step = this.getStep();
      if (this.shouldPatchAsInitTestUpdateLoop()) {
        if (!step.isVirtual && step.isLiteral) {
          return step.negated ? DOWN : UP;
        } else if (this.hasFixedRange()) {
          var left = this.target.left.node.data;
          var right = this.target.right.node.data;
          return left > right ? DOWN : UP;
        } else {
          return UNKNOWN;
        }
      } else {
        if (step.isLiteral) {
          return step.negated ? DOWN : UP;
        } else {
          return UNKNOWN;
        }
      }
    }

    /**
     * Are we looping over a range with fixed (static) start/end?
     *
     * @example
     *
     *   for [0..3]
     *   for [7.0..10.0]
     */

  }, {
    key: 'hasFixedRange',
    value: function hasFixedRange() {
      return this.target instanceof RangePatcher && this.isStartFixed() && this.isEndFixed();
    }
  }]);
  return ForInPatcher;
}(ForPatcher);

var Step = function Step(patcher) {
  classCallCheck(this, Step);

  var negated = false;
  var root = patcher;
  var apply = function apply(patcher) {
    if (patcher.node.type === 'UnaryNegateOp') {
      negated = !negated;
      apply(patcher.expression);
    } else {
      root = patcher;
    }
  };
  if (patcher) {
    apply(patcher);
    this.isLiteral = root.node.type === 'Int' || root.node.type === 'Float';
    this.init = patcher.patchAndGetCode();
    if (this.isLiteral) {
      this.update = root.slice(root.contentStart, root.contentEnd);
      this.number = root.node.data;
    } else {
      this.update = root.claimFreeBinding('step');
      this.number = null;
    }
  } else {
    this.isLiteral = true;
    this.init = '1';
    this.update = '1';
    this.number = 1;
  }
  this.negated = negated;
  this.isVirtual = !patcher;
};

var ForOfPatcher = function (_ForPatcher) {
  inherits(ForOfPatcher, _ForPatcher);

  function ForOfPatcher() {
    classCallCheck(this, ForOfPatcher);
    return possibleConstructorReturn(this, (ForOfPatcher.__proto__ || Object.getPrototypeOf(ForOfPatcher)).apply(this, arguments));
  }

  createClass(ForOfPatcher, [{
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      if (!this.body.inline()) {
        this.body.setIndent(this.getLoopBodyIndent());
      }

      var keyAssignee = this.keyAssignee;

      // Save the filter code and remove if it it's there.

      this.getFilterCode();
      if (this.filter) {
        this.remove(this.target.outerEnd, this.filter.outerEnd);
      }

      this.removeOwnTokenIfExists();

      var shouldExtractTarget = this.requiresExtractingTarget();
      if (shouldExtractTarget) {
        this.insert(this.innerStart, this.getTargetReference() + ' = ' + this.getTargetCode() + '\n' + this.getLoopIndent());
      }

      var keyBinding = this.getIndexBinding();
      this.insert(keyAssignee.outerStart, '(');

      // Patch the target. Also get a reference in case we need it.
      var targetReference = this.getTargetReference();

      var valAssignee = this.valAssignee;


      var valueAssignment = null;
      if (valAssignee) {
        valAssignee.patch();
        var valAssigneeString = this.slice(valAssignee.contentStart, valAssignee.contentEnd);
        // `for (k, v of o` → `for (k of o`
        //        ^^^
        this.remove(keyAssignee.outerEnd, valAssignee.outerEnd);

        valueAssignment = valAssigneeString + ' = ' + this.getTargetReference() + '[' + keyBinding + ']';

        if (valAssignee.statementNeedsParens()) {
          valueAssignment = '(' + valueAssignment + ')';
        }
      }

      var relationToken = this.getRelationToken();
      if (this.node.isOwn) {
        if (shouldExtractTarget) {
          this.overwrite(relationToken.end, this.target.outerEnd, ' Object.keys(' + targetReference + ' || {})) {');
        } else {
          // `for (k of o` → `for (k of Object.keys(o`
          //                            ^^^^^^^^^^^^
          this.insert(this.target.outerStart, 'Object.keys(');

          // `for (k of Object.keys(o` → `for (k of Object.keys(o || {})) {`
          //                                                     ^^^^^^^^^^
          this.insert(this.target.outerEnd, ' || {})) {');
        }
      } else {
        if (shouldExtractTarget) {
          this.overwrite(relationToken.start, this.target.outerEnd, 'in ' + targetReference + ') {');
        } else {
          // `for (k of o` → `for (k in o`
          //         ^^              ^^
          this.overwrite(relationToken.start, relationToken.end, 'in');

          // `for (k in o` → `for (k in o) {`
          //                             ^^^
          this.insert(this.target.outerEnd, ') {');
        }
      }

      this.removeThenToken();
      this.patchPossibleNewlineAfterLoopHeader(this.target.outerEnd);
      if (valueAssignment !== null) {
        this.body.insertLineBefore(valueAssignment, this.getOuterLoopBodyIndent());
      }
      this.patchBodyAndFilter();
    }
  }, {
    key: 'removeOwnTokenIfExists',
    value: function removeOwnTokenIfExists() {
      if (this.node.isOwn) {
        var ownIndex = this.indexOfSourceTokenAfterSourceTokenIndex(this.contentStartTokenIndex, coffeeLex.SourceType.OWN);
        var ownToken = this.sourceTokenAtIndex(ownIndex);
        this.remove(ownToken.start, this.keyAssignee.outerStart);
      }
    }
  }, {
    key: 'requiresExtractingTarget',
    value: function requiresExtractingTarget() {
      return !this.target.isRepeatable() && this.valAssignee;
    }
  }, {
    key: 'targetBindingCandidate',
    value: function targetBindingCandidate() {
      return 'object';
    }
  }, {
    key: 'indexBindingCandidates',
    value: function indexBindingCandidates() {
      return ['key'];
    }
  }, {
    key: 'willPatchAsIIFE',
    value: function willPatchAsIIFE() {
      return this.willPatchAsExpression();
    }
  }]);
  return ForOfPatcher;
}(ForPatcher);

var CLOSE_TOKEN_BASE_LENGTH = 3;

var HeregexPatcher = function (_InterpolatedPatcher) {
  inherits(HeregexPatcher, _InterpolatedPatcher);

  function HeregexPatcher() {
    classCallCheck(this, HeregexPatcher);
    return possibleConstructorReturn(this, (HeregexPatcher.__proto__ || Object.getPrototypeOf(HeregexPatcher)).apply(this, arguments));
  }

  createClass(HeregexPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var openToken = this.firstToken();
      var closeToken = this.lastToken();

      this.overwrite(openToken.start, openToken.end, 'new RegExp(`');
      if (closeToken.end - closeToken.start > CLOSE_TOKEN_BASE_LENGTH) {
        // If the close token has flags, e.g. ///gi, keep the flags as a string literal.
        this.overwrite(closeToken.start, closeToken.start + CLOSE_TOKEN_BASE_LENGTH, '`, \'');
        this.insert(closeToken.end, '\')');
      } else {
        // Otherwise, don't specify flags.
        this.overwrite(closeToken.start, closeToken.end, '`)');
      }

      this.patchInterpolations();
      this.processContents();
      this.escapeQuasis(/^\\\s/, ['`', '${', '\\']);
    }
  }]);
  return HeregexPatcher;
}(InterpolatedPatcher);

var IncrementDecrementPatcher = function (_NodePatcher) {
  inherits(IncrementDecrementPatcher, _NodePatcher);

  function IncrementDecrementPatcher(patcherContext, expression) {
    classCallCheck(this, IncrementDecrementPatcher);

    var _this = possibleConstructorReturn(this, (IncrementDecrementPatcher.__proto__ || Object.getPrototypeOf(IncrementDecrementPatcher)).call(this, patcherContext));

    _this.expression = expression;
    return _this;
  }

  createClass(IncrementDecrementPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.expression.setRequiresExpression();
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.expression.patch();
    }
  }, {
    key: 'isRepeatable',
    value: function isRepeatable() {
      return false;
    }
  }]);
  return IncrementDecrementPatcher;
}(NodePatcher);

/**
 * Handles `in` operators, e.g. `a in b` and `a not in b`.
 */

var InOpPatcher = function (_BinaryOpPatcher) {
  inherits(InOpPatcher, _BinaryOpPatcher);

  /**
   * `node` is of type `InOp`.
   */
  function InOpPatcher(patcherContext, left, right) {
    classCallCheck(this, InOpPatcher);

    var _this = possibleConstructorReturn(this, (InOpPatcher.__proto__ || Object.getPrototypeOf(InOpPatcher)).call(this, patcherContext, left, right));

    _this.negated = patcherContext.node.isNot;
    return _this;
  }

  createClass(InOpPatcher, [{
    key: 'negate',
    value: function negate() {
      this.negated = !this.negated;
    }
  }, {
    key: 'operatorTokenPredicate',
    value: function operatorTokenPredicate() {
      return function (token) {
        return token.type === coffeeLex.SourceType.RELATION;
      };
    }

    /**
     * LEFT 'in' RIGHT
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var rightCode = this.right.patchAndGetCode();
      if (this.shouldWrapInArrayFrom()) {
        rightCode = 'Array.from(' + rightCode + ')';
      } else if (this.rhsNeedsParens()) {
        rightCode = '(' + rightCode + ')';
      }

      // `a in b` → `a`
      //   ^^^^^
      this.remove(this.left.outerEnd, this.right.outerEnd);

      if (this.negated) {
        // `a` → `!a`
        //        ^
        this.insert(this.left.outerStart, '!');
      }

      // `!a` → `!b.includes(a`
      //          ^^^^^^^^^^^
      this.insert(this.left.outerStart, rightCode + '.includes(');

      this.left.patch();

      // `!b.includes(a` → `!b.includes(a)`
      //                                 ^
      this.insert(this.left.outerEnd, ')');
    }
  }, {
    key: 'shouldWrapInArrayFrom',
    value: function shouldWrapInArrayFrom() {
      if (this.options.looseIncludes) {
        return false;
      }
      return !(this.right instanceof ArrayInitialiserPatcher);
    }
  }, {
    key: 'rhsNeedsParens',
    value: function rhsNeedsParens() {
      // In typical cases, when converting `a in b` to `b.includes(a)`, parens
      // won't be necessary around the `b`, but to be safe, only skip the parens
      // in a specific set of known-good cases.
      return !(this.right instanceof IdentifierPatcher) && !(this.right instanceof MemberAccessOpPatcher) && !(this.right instanceof DynamicMemberAccessOpPatcher) && !(this.right instanceof FunctionApplicationPatcher) && !(this.right instanceof ArrayInitialiserPatcher) && !(this.right instanceof StringPatcher);
    }

    /**
     * Method invocations don't need parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return false;
    }
  }]);
  return InOpPatcher;
}(BinaryOpPatcher);

/**
 * Handles `instanceof` operator, e.g. `a instanceof b`.
 */
var NegatableBinaryOpPatcher = function (_BinaryOpPatcher) {
  inherits(NegatableBinaryOpPatcher, _BinaryOpPatcher);

  function NegatableBinaryOpPatcher(patcherContext, left, right) {
    classCallCheck(this, NegatableBinaryOpPatcher);

    var _this = possibleConstructorReturn(this, (NegatableBinaryOpPatcher.__proto__ || Object.getPrototypeOf(NegatableBinaryOpPatcher)).call(this, patcherContext, left, right));

    _this.negated = patcherContext.node.isNot;
    return _this;
  }

  createClass(NegatableBinaryOpPatcher, [{
    key: 'negate',
    value: function negate() {
      this.negated = !this.negated;
    }
  }, {
    key: 'javaScriptOperator',
    value: function javaScriptOperator() {
      throw new Error('\'javaScriptOperator\' should be implemented in subclass');
    }

    /**
     * LEFT 'not'? OP RIGHT
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var negated = this.negated;

      if (negated) {
        // `a not instanceof b` → `!(a not instanceof b`
        //                         ^^
        this.insert(this.innerStart, '!(');
      }

      // Patch LEFT and RIGHT.
      get(NegatableBinaryOpPatcher.prototype.__proto__ || Object.getPrototypeOf(NegatableBinaryOpPatcher.prototype), 'patchAsExpression', this).call(this);

      if (negated) {
        // `!(a not instanceof b` → `!(a not instanceof b)`
        //                                               ^
        this.insert(this.innerEnd, ')');
      }

      // `!(a not instanceof b)` → `!(a instanceof b)`
      //      ^^^^^^^^^^^^^^            ^^^^^^^^^^
      var token = this.getOperatorToken();
      this.overwrite(token.start, token.end, this.javaScriptOperator());
    }

    /**
     * It may be wrapped due to negation, so don't double-wrap.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      if (this.negated) {
        return false;
      } else {
        return get(NegatableBinaryOpPatcher.prototype.__proto__ || Object.getPrototypeOf(NegatableBinaryOpPatcher.prototype), 'statementNeedsParens', this).call(this);
      }
    }
  }]);
  return NegatableBinaryOpPatcher;
}(BinaryOpPatcher);

/**
 * Handles `instanceof` operator, e.g. `a instanceof b`.
 */

var InstanceofOpPatcher = function (_NegatableBinaryOpPat) {
  inherits(InstanceofOpPatcher, _NegatableBinaryOpPat);

  function InstanceofOpPatcher() {
    classCallCheck(this, InstanceofOpPatcher);
    return possibleConstructorReturn(this, (InstanceofOpPatcher.__proto__ || Object.getPrototypeOf(InstanceofOpPatcher)).apply(this, arguments));
  }

  createClass(InstanceofOpPatcher, [{
    key: 'javaScriptOperator',
    value: function javaScriptOperator() {
      return 'instanceof';
    }
  }]);
  return InstanceofOpPatcher;
}(NegatableBinaryOpPatcher);

/**
 * Handles embedded JavaScript.
 */

var JavaScriptPatcher = function (_NodePatcher) {
  inherits(JavaScriptPatcher, _NodePatcher);

  function JavaScriptPatcher() {
    classCallCheck(this, JavaScriptPatcher);
    return possibleConstructorReturn(this, (JavaScriptPatcher.__proto__ || Object.getPrototypeOf(JavaScriptPatcher)).apply(this, arguments));
  }

  createClass(JavaScriptPatcher, [{
    key: 'patchAsExpression',

    /**
     * All we have to do is strip off the backticks.
     */
    value: function patchAsExpression() {
      // '`void 0`' → 'void 0`'
      //  ^
      this.remove(this.contentStart, this.contentStart + '`'.length);
      // 'void 0`' → 'void 0'
      //        ^
      this.remove(this.contentEnd - '`'.length, this.contentEnd);
    }
  }]);
  return JavaScriptPatcher;
}(NodePatcher);

var UnaryOpPatcher = function (_NodePatcher) {
  inherits(UnaryOpPatcher, _NodePatcher);

  function UnaryOpPatcher(patcherContext, expression) {
    classCallCheck(this, UnaryOpPatcher);

    var _this = possibleConstructorReturn(this, (UnaryOpPatcher.__proto__ || Object.getPrototypeOf(UnaryOpPatcher)).call(this, patcherContext));

    _this.expression = expression;
    return _this;
  }

  createClass(UnaryOpPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.expression.setRequiresExpression();
    }

    /**
     * OP EXPRESSION
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.expression.patch({ needsParens: true });
    }

    /**
     * If `EXPRESSION` needs parens then `EXPRESSION OP` needs parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return this.expression.statementShouldAddParens();
    }
  }]);
  return UnaryOpPatcher;
}(NodePatcher);

var LogicalNotOpPatcher = function (_UnaryOpPatcher) {
  inherits(LogicalNotOpPatcher, _UnaryOpPatcher);

  function LogicalNotOpPatcher() {
    classCallCheck(this, LogicalNotOpPatcher);
    return possibleConstructorReturn(this, (LogicalNotOpPatcher.__proto__ || Object.getPrototypeOf(LogicalNotOpPatcher)).apply(this, arguments));
  }

  createClass(LogicalNotOpPatcher, [{
    key: 'isRepeatable',

    /**
     * Though it's possible that `!` could trigger a `valueOf` call to arbitrary
     * code, CoffeeScript ignores that possibility and so do we.
     */
    value: function isRepeatable() {
      return this.expression.isRepeatable();
    }

    /**
     * ( `!` | `not` ) EXPRESSION
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this.expression.canHandleNegationInternally()) {
        this.expression.negate();
        this.remove(this.contentStart, this.expression.outerStart);
      } else {
        this.overwrite(this.contentStart, this.expression.outerStart, '!');
      }
      get(LogicalNotOpPatcher.prototype.__proto__ || Object.getPrototypeOf(LogicalNotOpPatcher.prototype), 'patchAsExpression', this).call(this, options);
    }
  }]);
  return LogicalNotOpPatcher;
}(UnaryOpPatcher);

var LogicalOpCompoundAssignOpPatcher = function (_CompoundAssignOpPatc) {
  inherits(LogicalOpCompoundAssignOpPatcher, _CompoundAssignOpPatc);

  function LogicalOpCompoundAssignOpPatcher() {
    classCallCheck(this, LogicalOpCompoundAssignOpPatcher);
    return possibleConstructorReturn(this, (LogicalOpCompoundAssignOpPatcher.__proto__ || Object.getPrototypeOf(LogicalOpCompoundAssignOpPatcher)).apply(this, arguments));
  }

  createClass(LogicalOpCompoundAssignOpPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$needsParens = _ref.needsParens,
          needsParens = _ref$needsParens === undefined ? false : _ref$needsParens;

      var shouldAddParens = needsParens && !this.isSurroundedByParentheses();
      if (shouldAddParens) {
        this.insert(this.outerStart, '(');
      }

      var operator = this.getOperatorToken();

      // `a &&= b` → `a && b`
      //    ^^^         ^^
      this.overwrite(operator.start, operator.end, this.isOrOp() ? '||' : '&&');

      var assigneeAgain = this.assignee.patchRepeatable({ isForAssignment: true });

      // `a && b` → `a && (a = b`
      //                  ^^^^^
      this.insert(this.expression.outerStart, '(' + assigneeAgain + ' = ');

      this.expression.patch();

      // `a && (a = b` → `a && (a = b)`
      //                             ^
      this.insert(this.expression.outerEnd, ')');

      if (shouldAddParens) {
        this.insert(this.outerEnd, ')');
      }
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this.lhsHasSoakOperation()) {
        this.patchAsExpression(options);
        return;
      }

      // `a &&= b` → `if (a &&= b`
      //              ^^^^
      this.insert(this.contentStart, 'if (');

      if (this.isOrOp()) {
        this.assignee.negate();
      }

      var assigneeAgain = this.assignee.patchRepeatable({ isForAssignment: true });

      // `if (a &&= b` → `if (a) { a = b`
      //       ^^^^^           ^^^^^^^^
      this.overwrite(this.assignee.outerEnd, this.expression.outerStart, ') { ' + assigneeAgain + ' = ');

      this.expression.patch();

      // `if (a) { a = b` → `if (a) { a = b }`
      //                                   ^^
      this.insert(this.expression.outerEnd, ' }');
    }

    /**
     * @private
     */

  }, {
    key: 'isOrOp',
    value: function isOrOp() {
      var operator = this.getOperatorToken();
      var op = this.sourceOfToken(operator);
      // There could be a space in the middle of the operator, like `or =` or
      // `|| =`, and "op" will just be the first token in that case. So just check
      // the start of the operator.
      return op.substr(0, 2) === '||' || op.substr(0, 2) === 'or';
    }

    /**
     * We always start with an `if` statement, so no parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return false;
    }
  }]);
  return LogicalOpCompoundAssignOpPatcher;
}(CompoundAssignOpPatcher);

/**
 * Handles logical AND and logical OR.
 *
 * This class is primarily responsible for rewriting `and` to `&&` and `or` to
 * `||`. It also applies De Morgan's laws [1] in the event of negation, such as
 * when used as the condition of an `unless` expression:
 *
 *   a unless b && c  # equivalent to `a if !b || !c`
 *
 * [1]: https://en.wikipedia.org/wiki/De_Morgan%27s_laws
 */
var LogicalOpPatcher = function (_BinaryOpPatcher) {
  inherits(LogicalOpPatcher, _BinaryOpPatcher);

  /**
   * `node` is expected to be either `LogicalAndOp` or `LogicalOrOp`.
   */
  function LogicalOpPatcher(patcherContext, left, right) {
    classCallCheck(this, LogicalOpPatcher);

    var _this = possibleConstructorReturn(this, (LogicalOpPatcher.__proto__ || Object.getPrototypeOf(LogicalOpPatcher)).call(this, patcherContext));

    _this.negated = false;

    _this.left = left;
    _this.right = right;
    return _this;
  }

  createClass(LogicalOpPatcher, [{
    key: 'patchOperator',
    value: function patchOperator() {
      var operatorToken = this.getOperatorToken();
      this.overwrite(operatorToken.start, operatorToken.end, this.getOperator());
    }

    /**
     * Apply De Morgan's law.
     *
     * @private
     */

  }, {
    key: 'getOperator',
    value: function getOperator() {
      var operatorToken = this.getOperatorToken();
      var operator = this.context.source.slice(operatorToken.start, operatorToken.end);
      if (operator === 'and') {
        operator = '&&';
      } else if (operator === 'or') {
        operator = '||';
      }
      if (this.negated) {
        return operator === '&&' ? '||' : '&&';
      } else {
        return operator;
      }
    }
  }, {
    key: 'negate',
    value: function negate() {
      this.negated = !this.negated;
      this.left.negate();
      this.right.negate();
    }
  }]);
  return LogicalOpPatcher;
}(BinaryOpPatcher);

var MOD_HELPER = 'function __mod__(a, b) {\n  a = +a;\n  b = +b;\n  return (a % b + b) % b;\n}';

function registerModHelper(patcher) {
  return patcher.registerHelper('__mod__', MOD_HELPER);
}

var ModuloOpPatcher = function (_BinaryOpPatcher) {
  inherits(ModuloOpPatcher, _BinaryOpPatcher);

  /**
   * `node` is of type `ModuloOp`.
   */
  function ModuloOpPatcher(patcherContext, left, right) {
    classCallCheck(this, ModuloOpPatcher);
    return possibleConstructorReturn(this, (ModuloOpPatcher.__proto__ || Object.getPrototypeOf(ModuloOpPatcher)).call(this, patcherContext, left, right));
  }

  createClass(ModuloOpPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var helper = registerModHelper(this);

      // `a %% b` → `__mod__(a %% b`
      //             ^^^^^^^^
      this.insert(this.left.outerStart, helper + '(');

      this.left.patch();

      // `__mod__(a %% b` → `__mod__(a, b`
      //           ^^^^               ^^
      this.overwrite(this.left.outerEnd, this.right.outerStart, ', ');

      this.right.patch();

      // `__mod__(a, b` → `__mod__(a, b)`
      //                               ^
      this.insert(this.right.outerEnd, ')');
    }

    /**
     * We always prefix with `__mod__` so no parens needed.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return false;
    }
  }]);
  return ModuloOpPatcher;
}(BinaryOpPatcher);

var ModuloOpCompoundAssignOpPatcher = function (_CompoundAssignOpPatc) {
  inherits(ModuloOpCompoundAssignOpPatcher, _CompoundAssignOpPatc);

  function ModuloOpCompoundAssignOpPatcher() {
    classCallCheck(this, ModuloOpCompoundAssignOpPatcher);
    return possibleConstructorReturn(this, (ModuloOpCompoundAssignOpPatcher.__proto__ || Object.getPrototypeOf(ModuloOpCompoundAssignOpPatcher)).apply(this, arguments));
  }

  createClass(ModuloOpCompoundAssignOpPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$needsParens = _ref.needsParens,
          needsParens = _ref$needsParens === undefined ? false : _ref$needsParens;

      var helper = registerModHelper(this);

      var shouldAddParens = needsParens && !this.isSurroundedByParentheses();
      if (shouldAddParens) {
        this.insert(this.outerStart, '(');
      }

      var assigneeAgain = this.assignee.patchRepeatable({ isForAssignment: true });

      // `a %%= b` → `a %%= __mod__(a, b`
      //               ^^^^^^^^^^^^^^^^
      this.overwrite(this.assignee.outerEnd, this.expression.outerStart, ' = ' + helper + '(' + assigneeAgain + ', ');

      this.expression.patch();

      // `a %%= __mod__(a, b` → `a %%= __mod__(a, b)`
      //                                           ^
      this.insert(this.expression.outerEnd, ')');

      if (shouldAddParens) {
        this.insert(this.outerEnd, ')');
      }
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      this.patchAsExpression();
    }
  }]);
  return ModuloOpCompoundAssignOpPatcher;
}(CompoundAssignOpPatcher);

/**
 * Handles `of` operators, e.g. `a of b` and `a not of b`.
 */

var OfOpPatcher = function (_NegatableBinaryOpPat) {
  inherits(OfOpPatcher, _NegatableBinaryOpPat);

  function OfOpPatcher() {
    classCallCheck(this, OfOpPatcher);
    return possibleConstructorReturn(this, (OfOpPatcher.__proto__ || Object.getPrototypeOf(OfOpPatcher)).apply(this, arguments));
  }

  createClass(OfOpPatcher, [{
    key: 'operatorTokenPredicate',
    value: function operatorTokenPredicate() {
      return function (token) {
        return token.type === coffeeLex.SourceType.RELATION;
      };
    }
  }, {
    key: 'javaScriptOperator',
    value: function javaScriptOperator() {
      return 'in';
    }
  }]);
  return OfOpPatcher;
}(NegatableBinaryOpPatcher);

/**
 * Generates a blank object with no prototype.
 */
function blank() {
  return Object.create(null);
}

var ProgramPatcher$2 = function (_NodePatcher) {
  inherits(ProgramPatcher, _NodePatcher);

  function ProgramPatcher(patcherContext, body) {
    classCallCheck(this, ProgramPatcher);

    var _this = possibleConstructorReturn(this, (ProgramPatcher.__proto__ || Object.getPrototypeOf(ProgramPatcher)).call(this, patcherContext));

    _this.body = body;

    _this.helpers = blank();
    _this._indentString = null;
    return _this;
  }

  createClass(ProgramPatcher, [{
    key: 'shouldTrimContentRange',
    value: function shouldTrimContentRange() {
      return true;
    }

    /**
     * Register a helper to be reused in several places.
     *
     * FIXME: Pick a different name than what is in scope.
     */

  }, {
    key: 'registerHelper',
    value: function registerHelper(name, code) {
      code = code.trim();
      if (name in this.helpers) {
        if (this.helpers[name] !== code) {
          throw new Error('BUG: cannot override helper \'' + name + '\'');
        }
      } else {
        this.helpers[name] = code;
      }
      return name;
    }
  }, {
    key: 'patchHelpers',
    value: function patchHelpers() {
      for (var helper in this.helpers) {
        this.editor.append('\n' + this.helpers[helper]);
      }
    }

    /**
     * Gets the indent string used for each indent in this program.
     */

  }, {
    key: 'getProgramIndentString',
    value: function getProgramIndentString() {
      if (!this._indentString) {
        this._indentString = determineIndent(this.context.source);
      }
      return this._indentString;
    }
  }]);
  return ProgramPatcher;
}(NodePatcher);

var BLOCK_COMMENT_DELIMITER = '###';

var ProgramPatcher = function (_SharedProgramPatcher) {
  inherits(ProgramPatcher, _SharedProgramPatcher);

  function ProgramPatcher() {
    classCallCheck(this, ProgramPatcher);
    return possibleConstructorReturn(this, (ProgramPatcher.__proto__ || Object.getPrototypeOf(ProgramPatcher)).apply(this, arguments));
  }

  createClass(ProgramPatcher, [{
    key: 'canPatchAsExpression',
    value: function canPatchAsExpression() {
      return false;
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      this.patchComments();
      if (this.body) {
        this.body.patch({ leftBrace: false, rightBrace: false });
      }
      this.patchContinuations();
      this.patchHelpers();
    }

    /**
     * Removes continuation tokens (i.e. '\' at the end of a line).
     *
     * @private
     */

  }, {
    key: 'patchContinuations',
    value: function patchContinuations() {
      var _this2 = this;

      this.getProgramSourceTokens().forEach(function (token) {
        if (token.type === coffeeLex.SourceType.CONTINUATION) {
          try {
            _this2.remove(token.start, token.end);
          } catch (e) {
            _this2.log('Warning: Ignoring a continuation token because it could not be ' + 'removed. Most likely, this is because its range has already ' + 'been overwritten.');
          }
        }
      });
    }

    /**
     * Replaces CoffeeScript style comments with JavaScript style comments.
     *
     * @private
     */

  }, {
    key: 'patchComments',
    value: function patchComments() {
      var _this3 = this;

      var source = this.context.source;

      this.getProgramSourceTokens().forEach(function (token) {
        if (token.type === coffeeLex.SourceType.COMMENT) {
          if (token.start === 0 && source[1] === '!') {
            _this3.patchShebangComment(token);
          } else {
            _this3.patchLineComment(token);
          }
        } else if (token.type === coffeeLex.SourceType.HERECOMMENT) {
          _this3.patchBlockComment(token);
        }
      });
    }

    /**
     * Patches a block comment.
     *
     * @private
     */

  }, {
    key: 'patchBlockComment',
    value: function patchBlockComment(comment) {
      var _this4 = this;

      var start = comment.start,
          end = comment.end;

      this.overwrite(start, start + BLOCK_COMMENT_DELIMITER.length, '/*');

      var atStartOfLine = false;
      var lastStartOfLine = null;
      var lineUpAsterisks = true;
      var isMultiline = false;
      var source = this.context.source;

      var expectedIndent = getIndent(source, start);
      var leadingHashIndexes = [];

      for (var index = start + BLOCK_COMMENT_DELIMITER.length; index < end - BLOCK_COMMENT_DELIMITER.length; index++) {
        switch (source[index]) {
          case '\n':
            isMultiline = true;
            atStartOfLine = true;
            lastStartOfLine = index + '\n'.length;
            break;

          case ' ':
          case '\t':
            break;

          case '#':
            if (atStartOfLine) {
              leadingHashIndexes.push(index);
              atStartOfLine = false;
              if (source.slice(lastStartOfLine, index) !== expectedIndent) {
                lineUpAsterisks = false;
              }
            }
            break;

          default:
            if (atStartOfLine) {
              atStartOfLine = false;
              lineUpAsterisks = false;
            }
            break;
        }
      }

      leadingHashIndexes.forEach(function (index) {
        _this4.overwrite(index, index + '#'.length, lineUpAsterisks ? ' *' : '*');
      });

      this.overwrite(end - BLOCK_COMMENT_DELIMITER.length, end, isMultiline && lineUpAsterisks ? ' */' : '*/');
    }

    /**
     * Patches a single-line comment.
     *
     * @private
     */

  }, {
    key: 'patchLineComment',
    value: function patchLineComment(comment) {
      var start = comment.start;

      this.overwrite(start, start + '#'.length, '//');
    }

    /**
     * Patches a shebang comment.
     *
     * @private
     */

  }, {
    key: 'patchShebangComment',
    value: function patchShebangComment(comment) {
      var start = comment.start,
          end = comment.end;

      var commentBody = this.slice(start, end);
      var coffeeIndex = commentBody.indexOf('coffee');

      if (coffeeIndex >= 0) {
        this.overwrite(start + coffeeIndex, start + coffeeIndex + 'coffee'.length, 'node');
      }
    }

    /**
     * Serve as the implicit return patcher for anyone not included in a function.
     */

  }, {
    key: 'canHandleImplicitReturn',
    value: function canHandleImplicitReturn() {
      return true;
    }
  }]);
  return ProgramPatcher;
}(ProgramPatcher$2);

var RegexPatcher = function (_NodePatcher) {
  inherits(RegexPatcher, _NodePatcher);

  function RegexPatcher() {
    classCallCheck(this, RegexPatcher);
    return possibleConstructorReturn(this, (RegexPatcher.__proto__ || Object.getPrototypeOf(RegexPatcher)).apply(this, arguments));
  }

  createClass(RegexPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      exportSpecialWhitespaceInRange(this.contentStart + 1, this.contentEnd - 1, this);
    }
  }]);
  return RegexPatcher;
}(NodePatcher);

var RestPatcher = function (_SpreadPatcher) {
  inherits(RestPatcher, _SpreadPatcher);

  function RestPatcher() {
    classCallCheck(this, RestPatcher);
    return possibleConstructorReturn(this, (RestPatcher.__proto__ || Object.getPrototypeOf(RestPatcher)).apply(this, arguments));
  }

  return RestPatcher;
}(SpreadPatcher);

/**
 * Handles sequence expressions/statements, e.g `a; b`.
 */
var SeqOpPatcher = function (_NodePatcher) {
  inherits(SeqOpPatcher, _NodePatcher);

  function SeqOpPatcher(patcherContext, left, right) {
    classCallCheck(this, SeqOpPatcher);

    var _this = possibleConstructorReturn(this, (SeqOpPatcher.__proto__ || Object.getPrototypeOf(SeqOpPatcher)).call(this, patcherContext));

    _this.negated = false;

    _this.left = left;
    _this.right = right;
    return _this;
  }

  createClass(SeqOpPatcher, [{
    key: 'negate',
    value: function negate() {
      this.negated = !this.negated;
    }

    /**
     * LEFT ';' RIGHT
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.left.setRequiresExpression();
      this.right.setRequiresExpression();

      if (this.negated) {
        this.insert(this.innerStart, '!(');
      }
      this.left.patch();

      var token = this.getOperatorToken();

      if (token.type === coffeeLex.SourceType.SEMICOLON) {
        // `a; b` → `a, b`
        //   ^        ^
        this.overwrite(token.start, token.end, ',');
      } else if (token.type === coffeeLex.SourceType.NEWLINE) {
        this.insert(this.left.outerEnd, ',');
      }

      this.right.patch();
      if (this.negated) {
        this.insert(this.innerEnd, ')');
      }
    }

    /**
     * If we're patching as a statement, we can just keep the semicolon or newline.
     */

  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      this.left.patch();
      this.right.patch();
    }
  }, {
    key: 'getOperatorToken',
    value: function getOperatorToken() {
      var operatorTokenIndex = this.indexOfSourceTokenBetweenPatchersMatching(this.left, this.right, function (token) {
        return token.type === coffeeLex.SourceType.SEMICOLON || token.type === coffeeLex.SourceType.NEWLINE;
      });
      if (!operatorTokenIndex) {
        throw this.error('expected operator between binary operands');
      }
      return this.sourceTokenAtIndex(operatorTokenIndex);
    }
  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return this.left.statementShouldAddParens();
    }
  }]);
  return SeqOpPatcher;
}(NodePatcher);

/**
 * Handles `while` loops, e.g.
 *
 *   while a
 *     b
 */

var WhilePatcher = function (_LoopPatcher) {
  inherits(WhilePatcher, _LoopPatcher);

  function WhilePatcher(patcherContext, condition, guard, body) {
    classCallCheck(this, WhilePatcher);

    var _this = possibleConstructorReturn(this, (WhilePatcher.__proto__ || Object.getPrototypeOf(WhilePatcher)).call(this, patcherContext, body));

    _this.condition = condition;
    _this.guard = guard;
    return _this;
  }

  createClass(WhilePatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.condition.setRequiresExpression();
      if (this.guard !== null) {
        this.guard.setRequiresExpression();
      }
    }

    /**
     * ( 'while' | 'until' ) CONDITION ('when' GUARD)? 'then' BODY
     * ( 'while' | 'until' ) CONDITION ('when' GUARD)? NEWLINE INDENT BODY
     */

  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      if (!this.body.inline()) {
        this.body.setIndent(this.getLoopBodyIndent());
      }

      // `until a` → `while a`
      //  ^^^^^       ^^^^^
      var whileToken = this.sourceTokenAtIndex(this.getWhileTokenIndex());

      this.overwrite(whileToken.start, whileToken.end, 'while');

      var conditionNeedsParens = !this.condition.isSurroundedByParentheses();
      if (conditionNeedsParens) {
        // `while a` → `while (a`
        //                    ^
        this.insert(this.condition.outerStart, '(');
      }

      if (this.node.isUntil) {
        this.condition.negate();
      }
      this.condition.patch({ needsParens: false });

      if (this.guard) {
        var guardNeedsParens = !this.guard.isSurroundedByParentheses();
        if (this.body.inline()) {
          // `while (a when b` → `while (a) { if (b`
          //          ^^^^^^              ^^^^^^^^
          this.overwrite(this.condition.outerEnd, this.guard.outerStart, (conditionNeedsParens ? ')' : '') + ' { if ' + (guardNeedsParens ? '(' : ''));
        } else {
          // `while (a when b` → `while (a) {\n  if (b`
          //          ^^^^^^              ^^^^^^^^^^^
          this.overwrite(this.condition.outerEnd, this.guard.outerStart, (conditionNeedsParens ? ')' : '') + ' {\n' + this.getOuterLoopBodyIndent() + 'if ' + (guardNeedsParens ? '(' : ''));
        }
        this.guard.patch({ needsParens: false });

        // `while (a) {\n  if (b` → `while (a) {\n  if (b) {`
        //                                               ^^^
        this.insert(this.guard.outerEnd, (guardNeedsParens ? ')' : '') + ' {');
      } else {
        // `while (a` → `while (a) {`
        //                       ^^^
        this.insert(this.condition.outerEnd, (conditionNeedsParens ? ')' : '') + ' {');
      }

      var thenIndex = this.getThenTokenIndex();
      if (thenIndex) {
        var thenToken = this.sourceTokenAtIndex(thenIndex);
        var nextToken = this.sourceTokenAtIndex(thenIndex.next());
        this.remove(thenToken.start, nextToken.start);
      }

      this.patchPossibleNewlineAfterLoopHeader(this.guard ? this.guard.outerEnd : this.condition.outerEnd);
      this.patchBodyWithPossibleItemVariable();

      if (this.guard) {
        // Close the guard's `if` consequent block.
        this.body.insertLineAfter('}', this.getOuterLoopBodyIndent());
      }

      // Close the `while` body block.
      this.body.insertLineAfter('}', this.getLoopIndent());
    }

    /**
     * @private
     */

  }, {
    key: 'getWhileTokenIndex',
    value: function getWhileTokenIndex() {
      var whileTokenIndex = this.contentStartTokenIndex;
      var whileToken = this.sourceTokenAtIndex(whileTokenIndex);
      if (!whileToken || whileToken.type !== coffeeLex.SourceType.WHILE) {
        throw this.error('could not get first token of \'while\' loop');
      }
      return whileTokenIndex;
    }

    /**
     * @private
     */

  }, {
    key: 'getThenTokenIndex',
    value: function getThenTokenIndex() {
      var whileTokenIndex = this.getWhileTokenIndex();
      if (!whileTokenIndex) {
        throw this.error('could not get first token of \'while\' loop');
      }

      // `while a then …`
      return this.indexOfSourceTokenBetweenPatchersMatching(this.guard || this.condition, this.body, function (token) {
        return token.type === coffeeLex.SourceType.THEN;
      });
    }
  }, {
    key: 'getLoopBodyIndent',
    value: function getLoopBodyIndent() {
      if (this.guard) {
        return this.getOuterLoopBodyIndent() + this.getProgramIndentString();
      } else {
        return this.getOuterLoopBodyIndent();
      }
    }
  }, {
    key: 'willPatchAsIIFE',
    value: function willPatchAsIIFE() {
      return this.willPatchAsExpression();
    }
  }]);
  return WhilePatcher;
}(LoopPatcher);

/**
 * Given a main stage patcher, determine from the AST if it needs to be wrapped
 * in parens when transformed into a JS ternary.
 *
 * Be defensive by listing all known common cases where this is correct, and
 * requiring parens in all other cases. That way, any missed cases result in
 * slightly ugly code rather than incorrect code.
 */
function ternaryNeedsParens(patcher) {
  var parent = patcher.parent;

  return !(patcher.isSurroundedByParentheses() || parent instanceof FunctionApplicationPatcher && patcher !== parent.fn || parent instanceof DynamicMemberAccessOpPatcher && patcher === parent.indexingExpr || parent instanceof ConditionalPatcher && !parent.node.isUnless && patcher === parent.condition && !parent.willPatchAsTernary() || parent instanceof WhilePatcher && !parent.node.isUntil && patcher === parent.condition || parent instanceof InOpPatcher || parent instanceof AssignOpPatcher && patcher === parent.expression ||
  // This function is called for soak operations, so outer soak operations
  // will insert a __guard__ helper and thus won't need additional parens.
  parent instanceof SoakedMemberAccessOpPatcher && patcher === parent.expression || parent instanceof SoakedDynamicMemberAccessOpPatcher && patcher === parent.expression || parent instanceof SoakedFunctionApplicationPatcher && patcher === parent.fn);
}

var GUARD_HELPER$1 = 'function __guard__(value, transform) {\n  return (typeof value !== \'undefined\' && value !== null) ? transform(value) : undefined;\n}';

var SoakedMemberAccessOpPatcher = function (_MemberAccessOpPatche) {
  inherits(SoakedMemberAccessOpPatcher, _MemberAccessOpPatche);

  function SoakedMemberAccessOpPatcher(patcherContext, expression) {
    classCallCheck(this, SoakedMemberAccessOpPatcher);

    var _this = possibleConstructorReturn(this, (SoakedMemberAccessOpPatcher.__proto__ || Object.getPrototypeOf(SoakedMemberAccessOpPatcher)).call(this, patcherContext, expression));

    _this._shouldSkipSoakPatch = false;
    return _this;
  }

  createClass(SoakedMemberAccessOpPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      if (!this._shouldSkipSoakPatch) {
        if (this.shouldPatchAsConditional()) {
          this.patchAsConditional();
        } else {
          this.patchAsGuardCall();
        }
      } else {
        this.expression.patch();
      }
    }
  }, {
    key: 'shouldPatchAsConditional',
    value: function shouldPatchAsConditional() {
      return this.expression.isRepeatable() && !nodeContainsSoakOperation(this.expression.node);
    }
  }, {
    key: 'patchAsConditional',
    value: function patchAsConditional() {
      var soakContainer = findSoakContainer(this);
      var memberNameToken = this.getMemberNameSourceToken();
      var expressionCode = this.expression.patchRepeatable();

      var conditionCode = void 0;
      if (this.expression.mayBeUnboundReference()) {
        conditionCode = 'typeof ' + expressionCode + ' !== \'undefined\' && ' + expressionCode + ' !== null';
      } else {
        conditionCode = expressionCode + ' != null';
      }

      this.overwrite(this.expression.outerEnd, memberNameToken.start, '.');
      if (soakContainer.willPatchAsExpression()) {
        var containerNeedsParens = ternaryNeedsParens(soakContainer);
        if (containerNeedsParens) {
          soakContainer.insert(soakContainer.contentStart, '(');
        }
        soakContainer.insert(soakContainer.contentStart, conditionCode + ' ? ');
        soakContainer.appendDeferredSuffix(' : undefined');
        if (containerNeedsParens) {
          soakContainer.appendDeferredSuffix(')');
        }
      } else {
        soakContainer.insert(soakContainer.contentStart, 'if (' + conditionCode + ') {\n' + soakContainer.getIndent(1));
        soakContainer.appendDeferredSuffix('\n' + soakContainer.getIndent() + '}');
      }
    }
  }, {
    key: 'patchAsGuardCall',
    value: function patchAsGuardCall() {
      this.registerHelper('__guard__', GUARD_HELPER$1);

      var soakContainer = findSoakContainer(this);
      var varName = soakContainer.claimFreeBinding('x');
      var prefix = this.slice(soakContainer.contentStart, this.contentStart);

      if (prefix.length > 0) {
        this.remove(soakContainer.contentStart, this.contentStart);
      }

      var memberNameToken = this.getMemberNameSourceToken();
      this.overwrite(this.expression.outerEnd, memberNameToken.start, ', ' + varName + ' => ' + prefix + varName + '.');

      soakContainer.insert(soakContainer.contentStart, '__guard__(');
      soakContainer.appendDeferredSuffix(')');

      this.expression.patch();
    }
  }, {
    key: 'setShouldSkipSoakPatch',
    value: function setShouldSkipSoakPatch() {
      this._shouldSkipSoakPatch = true;
    }

    /**
     * There isn't an implicit-dot syntax like @a for soaked access.
     */

  }, {
    key: 'hasImplicitOperator',
    value: function hasImplicitOperator() {
      return false;
    }
  }]);
  return SoakedMemberAccessOpPatcher;
}(MemberAccessOpPatcher);

var GUARD_FUNC_HELPER = 'function __guardFunc__(func, transform) {\n  return typeof func === \'function\' ? transform(func) : undefined;\n}';

/**
 * Special guard function so that the calling code can properly specify the
 * proper `this` value in the call.
 *
 * Note that this method is slightly incorrect in that it's more defensive than
 * `a.b?()`; it does a null check on `a`, when CoffeeScript code would crash on
 * null/undefined `a`. This may be possible to correct in the future, but there
 * are a few reasons it's useful in the current implementation:
 * - The implementation of soak chaining requires that soak operations do
 *   nothing if their leftmost value is undefined, e.g. that `a?.b?.c` can be
 *   correctly rewritten as `(a?.b)?.c`. Soaked method-style function
 *   application is a counterexample, though: `a?.b.c?()` cannot be rewritten as
 *   `(a?.b).c?()`, since the second one crashes if `a` is null. So, instead, we
 *   effectively treat it as `(a?.b)?.c?()`, which again isn't 100% correct, but
 *   will properly guard on `a` being null/undefined.
 * - We'd need a function like this anyway to transform code like `a?.b?()`, so
 *   this avoids the need to have two slightly different functions to handle
 *   this case which is already fairly obscure.
 */
var GUARD_METHOD_HELPER = 'function __guardMethod__(obj, methodName, transform) {\n  if (typeof obj !== \'undefined\' && obj !== null && typeof obj[methodName] === \'function\') {\n    return transform(obj, methodName);\n  } else {\n    return undefined;\n  }\n}';

var SoakedFunctionApplicationPatcher = function (_FunctionApplicationP) {
  inherits(SoakedFunctionApplicationPatcher, _FunctionApplicationP);

  function SoakedFunctionApplicationPatcher() {
    classCallCheck(this, SoakedFunctionApplicationPatcher);
    return possibleConstructorReturn(this, (SoakedFunctionApplicationPatcher.__proto__ || Object.getPrototypeOf(SoakedFunctionApplicationPatcher)).apply(this, arguments));
  }

  createClass(SoakedFunctionApplicationPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      if (this.shouldPatchAsConditional()) {
        this.patchAsConditional();
      } else {
        if (this.fn instanceof MemberAccessOpPatcher) {
          this.patchMethodCall(this.fn);
        } else if (this.fn instanceof DynamicMemberAccessOpPatcher) {
          this.patchDynamicMethodCall(this.fn);
        } else {
          this.patchNonMethodCall();
        }
        get(SoakedFunctionApplicationPatcher.prototype.__proto__ || Object.getPrototypeOf(SoakedFunctionApplicationPatcher.prototype), 'patchAsExpression', this).call(this);
      }
    }
  }, {
    key: 'shouldPatchAsConditional',
    value: function shouldPatchAsConditional() {
      return this.fn.isRepeatable() && !nodeContainsSoakOperation(this.fn.node);
    }
  }, {
    key: 'patchAsConditional',
    value: function patchAsConditional() {
      var soakContainer = findSoakContainer(this);
      this.fn.setRequiresRepeatableExpression();
      get(SoakedFunctionApplicationPatcher.prototype.__proto__ || Object.getPrototypeOf(SoakedFunctionApplicationPatcher.prototype), 'patchAsExpression', this).call(this);
      var fnCode = this.fn.getRepeatCode();

      var conditionCode = 'typeof ' + fnCode + ' === \'function\'';

      var callStartToken = this.getCallStartToken();
      this.remove(this.fn.outerEnd, callStartToken.start);
      if (soakContainer.willPatchAsExpression()) {
        var containerNeedsParens = ternaryNeedsParens(soakContainer);
        if (containerNeedsParens) {
          soakContainer.insert(soakContainer.contentStart, '(');
        }
        soakContainer.insert(soakContainer.contentStart, conditionCode + ' ? ');
        soakContainer.appendDeferredSuffix(' : undefined');
        if (containerNeedsParens) {
          soakContainer.appendDeferredSuffix(')');
        }
      } else {
        soakContainer.insert(soakContainer.contentStart, 'if (' + conditionCode + ') {\n' + soakContainer.getIndent(1));
        soakContainer.appendDeferredSuffix('\n' + soakContainer.getIndent() + '}');
      }
    }

    /**
     * Change a.b?() to __guardMethod__(a, 'b', o => o.b())
     */

  }, {
    key: 'patchMethodCall',
    value: function patchMethodCall(fn) {
      var memberName = fn.getMemberName();
      if (fn.hasImplicitOperator()) {
        fn.setSkipImplicitDotCreation();
      }

      this.registerHelper('__guardMethod__', GUARD_METHOD_HELPER);
      if (fn instanceof SoakedMemberAccessOpPatcher) {
        fn.setShouldSkipSoakPatch();
      }

      var callStartToken = this.getCallStartToken();
      var soakContainer = findSoakContainer(this);
      var varName = soakContainer.claimFreeBinding('o');
      var prefix = this.slice(soakContainer.contentStart, this.fn.outerStart);
      if (prefix.length > 0) {
        this.remove(soakContainer.contentStart, this.fn.outerStart);
      }
      // Since memberName is always a valid identifier, we can put it in a string
      // literal without worrying about escaping.
      this.overwrite(fn.expression.outerEnd, callStartToken.end, ', \'' + memberName + '\', ' + varName + ' => ' + prefix + varName + '.' + memberName + '(');
      soakContainer.insert(soakContainer.contentStart, '__guardMethod__(');
      soakContainer.appendDeferredSuffix(')');
    }

    /**
     * Change a[b]?() to __guardMethod__(a, b, (o, m) => o[m]())
     */

  }, {
    key: 'patchDynamicMethodCall',
    value: function patchDynamicMethodCall(fn) {
      var expression = fn.expression,
          indexingExpr = fn.indexingExpr;


      this.registerHelper('__guardMethod__', GUARD_METHOD_HELPER);
      if (fn instanceof SoakedDynamicMemberAccessOpPatcher) {
        fn.setShouldSkipSoakPatch();
      }

      var callStartToken = this.getCallStartToken();
      var soakContainer = findSoakContainer(this);
      var objVarName = soakContainer.claimFreeBinding('o');
      var methodVarName = soakContainer.claimFreeBinding('m');
      var prefix = this.slice(soakContainer.contentStart, this.fn.outerStart);
      if (prefix.length > 0) {
        this.remove(soakContainer.contentStart, this.fn.outerStart);
      }
      this.overwrite(expression.outerEnd, indexingExpr.outerStart, ', ');
      this.overwrite(indexingExpr.outerEnd, callStartToken.end, ', (' + objVarName + ', ' + methodVarName + ') => ' + prefix + objVarName + '[' + methodVarName + '](');
      soakContainer.insert(soakContainer.contentStart, '__guardMethod__(');
      soakContainer.appendDeferredSuffix(')');
    }
  }, {
    key: 'patchNonMethodCall',
    value: function patchNonMethodCall() {
      this.registerHelper('__guardFunc__', GUARD_FUNC_HELPER);
      var callStartToken = this.getCallStartToken();
      var soakContainer = findSoakContainer(this);
      var varName = soakContainer.claimFreeBinding('f');
      var prefix = this.slice(soakContainer.contentStart, this.fn.outerStart);
      if (prefix.length > 0) {
        this.remove(soakContainer.contentStart, this.fn.outerStart);
      }
      this.overwrite(this.fn.outerEnd, callStartToken.end, ', ' + varName + ' => ' + prefix + varName + '(');
      soakContainer.insert(soakContainer.contentStart, '__guardFunc__(');
      soakContainer.appendDeferredSuffix(')');
    }
  }, {
    key: 'getCallStartToken',
    value: function getCallStartToken() {
      var tokens$$1 = this.context.sourceTokens;
      var index = tokens$$1.indexOfTokenMatchingPredicate(function (token) {
        return token.type === coffeeLex.SourceType.CALL_START;
      }, this.fn.outerEndTokenIndex);
      if (!index || index.isAfter(this.contentEndTokenIndex)) {
        throw this.error('unable to find open-paren for function call');
      }
      return tokens$$1.tokenAtIndex(index);
    }
  }]);
  return SoakedFunctionApplicationPatcher;
}(FunctionApplicationPatcher);

/**
 * Find the enclosing node defining the "soak range" for a given soak operation.
 * For example, in the expression `a(b?.c.d())`, returns the `b?.c.d()` node,
 * since that's the chain of operations that will be skipped if `b` is null or
 * undefined.
 */
function findSoakContainer(patcher) {
  var result = patcher;
  while (canParentHandleSoak(result)) {
    result = result.parent;
  }
  return result;
}

/**
 * Determine if this "soak range" can be expanded outward.
 *
 * In determining the soak range, we also stop when we see other soak
 * operations. For example, in `a?.b?.c`, `a?.b` is used as the soak container
 * for the first soak, which works because the second soak operation will
 * "take over"; if `a` is null or undefined, then `a?.b` will be undefined, so
 * the entire thing will evaluate to undefined. This requires all soak
 * operations to do a null check on their leftmost value, which is why we need
 * to make __guardMethod__ do a null check on the object arg.
 */
function canParentHandleSoak(patcher) {
  if (patcher.parent === null) {
    return false;
  }
  if (patcher.isSurroundedByParentheses()) {
    return false;
  }
  // If we are currently the `a?.b` in an expression like `a?.b.c?()`, we don't
  // want to expand any further, since method-style soaked function application
  // is a special case and the `.c?(` will be patched. In this case, the `a?.b`
  // is what we should set as our soak container, since the method-style soak
  // implementation will "take over" from that point.
  if ((patcher.parent instanceof MemberAccessOpPatcher || patcher.parent instanceof DynamicMemberAccessOpPatcher) && patcher.parent.parent !== null && patcher.parent.parent instanceof SoakedFunctionApplicationPatcher && patcher.parent.parent.fn === patcher.parent) {
    return false;
  }
  if (patcher.parent instanceof MemberAccessOpPatcher && !(patcher.parent instanceof SoakedMemberAccessOpPatcher)) {
    return true;
  }
  if (patcher.parent instanceof DynamicMemberAccessOpPatcher && !(patcher.parent instanceof SoakedDynamicMemberAccessOpPatcher) && patcher.parent.expression === patcher) {
    return true;
  }
  if (patcher.parent instanceof FunctionApplicationPatcher && !(patcher.parent instanceof SoakedFunctionApplicationPatcher) && patcher.parent.fn === patcher) {
    return true;
  }
  if (patcher.parent instanceof AssignOpPatcher && patcher.parent.assignee === patcher) {
    return true;
  }
  if (['PostIncrementOp', 'PostDecrementOp', 'PreIncrementOp', 'PreDecrementOp', 'DeleteOp'].indexOf(patcher.parent.node.type) >= 0) {
    return true;
  }
  if ([].indexOf(patcher.parent.node.type) >= 0) {
    throw patcher.parent.error('Expressions like `++a?.b`, `--a?.b`, and `delete a?.b` are not supported yet.');
  }
  return false;
}

var GUARD_HELPER = 'function __guard__(value, transform) {\n  return (typeof value !== \'undefined\' && value !== null) ? transform(value) : undefined;\n}';

var SoakedDynamicMemberAccessOpPatcher = function (_DynamicMemberAccessO) {
  inherits(SoakedDynamicMemberAccessOpPatcher, _DynamicMemberAccessO);

  function SoakedDynamicMemberAccessOpPatcher(patcherContext, expression, indexingExpr) {
    classCallCheck(this, SoakedDynamicMemberAccessOpPatcher);

    var _this = possibleConstructorReturn(this, (SoakedDynamicMemberAccessOpPatcher.__proto__ || Object.getPrototypeOf(SoakedDynamicMemberAccessOpPatcher)).call(this, patcherContext, expression, indexingExpr));

    _this._shouldSkipSoakPatch = false;
    return _this;
  }

  createClass(SoakedDynamicMemberAccessOpPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      if (!this._shouldSkipSoakPatch) {
        if (this.shouldPatchAsConditional()) {
          this.patchAsConditional();
        } else {
          this.patchAsGuardCall();
        }
      } else {
        this.expression.patch();
        this.indexingExpr.patch();
      }
    }
  }, {
    key: 'shouldPatchAsConditional',
    value: function shouldPatchAsConditional() {
      return this.expression.isRepeatable() && !nodeContainsSoakOperation(this.expression.node);
    }
  }, {
    key: 'patchAsConditional',
    value: function patchAsConditional() {
      var soakContainer = findSoakContainer(this);
      var expressionCode = this.expression.patchRepeatable();

      var conditionCode = void 0;
      if (this.expression.mayBeUnboundReference()) {
        conditionCode = 'typeof ' + expressionCode + ' !== \'undefined\' && ' + expressionCode + ' !== null';
      } else {
        conditionCode = expressionCode + ' != null';
      }

      this.overwrite(this.expression.outerEnd, this.indexingExpr.outerStart, '[');
      this.indexingExpr.patch();
      if (soakContainer.willPatchAsExpression()) {
        var containerNeedsParens = ternaryNeedsParens(soakContainer);
        if (containerNeedsParens) {
          soakContainer.insert(soakContainer.contentStart, '(');
        }
        soakContainer.insert(soakContainer.contentStart, conditionCode + ' ? ');
        soakContainer.appendDeferredSuffix(' : undefined');
        if (containerNeedsParens) {
          soakContainer.appendDeferredSuffix(')');
        }
      } else {
        soakContainer.insert(soakContainer.contentStart, 'if (' + conditionCode + ') {\n' + soakContainer.getIndent(1));
        soakContainer.appendDeferredSuffix('\n' + soakContainer.getIndent() + '}');
      }
    }
  }, {
    key: 'patchAsGuardCall',
    value: function patchAsGuardCall() {
      this.registerHelper('__guard__', GUARD_HELPER);
      var soakContainer = findSoakContainer(this);
      var varName = soakContainer.claimFreeBinding('x');
      var prefix = this.slice(soakContainer.contentStart, this.contentStart);
      if (prefix.length > 0) {
        this.remove(soakContainer.contentStart, this.contentStart);
      }
      this.overwrite(this.expression.outerEnd, this.indexingExpr.outerStart, ', ' + varName + ' => ' + prefix + varName + '[');
      soakContainer.insert(soakContainer.contentStart, '__guard__(');
      soakContainer.appendDeferredSuffix(')');

      this.expression.patch();
      this.indexingExpr.patch();
    }
  }, {
    key: 'setShouldSkipSoakPatch',
    value: function setShouldSkipSoakPatch() {
      this._shouldSkipSoakPatch = true;
    }
  }]);
  return SoakedDynamicMemberAccessOpPatcher;
}(DynamicMemberAccessOpPatcher);

var SoakedNewOpPatcher = function (_SoakedFunctionApplic) {
  inherits(SoakedNewOpPatcher, _SoakedFunctionApplic);

  function SoakedNewOpPatcher() {
    classCallCheck(this, SoakedNewOpPatcher);
    return possibleConstructorReturn(this, (SoakedNewOpPatcher.__proto__ || Object.getPrototypeOf(SoakedNewOpPatcher)).apply(this, arguments));
  }

  createClass(SoakedNewOpPatcher, [{
    key: 'patchMethodCall',

    /**
     * Since `new` makes a new `this`, don't bother with the `guardMethod` variant.
     */
    value: function patchMethodCall() {
      this.patchNonMethodCall();
    }

    /**
     * Since `new` makes a new `this`, don't bother with the `guardMethod` variant.
     */

  }, {
    key: 'patchDynamicMethodCall',
    value: function patchDynamicMethodCall() {
      this.patchNonMethodCall();
    }
  }]);
  return SoakedNewOpPatcher;
}(SoakedFunctionApplicationPatcher);

/**
 * Handles soaked array or string slicing, e.g. `names?[i..]`.
 */
var GUARD_HELPER$2 = 'function __guard__(value, transform) {\n  return (typeof value !== \'undefined\' && value !== null) ? transform(value) : undefined;\n}';

var SoakedSlicePatcher = function (_SlicePatcher) {
  inherits(SoakedSlicePatcher, _SlicePatcher);

  function SoakedSlicePatcher() {
    classCallCheck(this, SoakedSlicePatcher);
    return possibleConstructorReturn(this, (SoakedSlicePatcher.__proto__ || Object.getPrototypeOf(SoakedSlicePatcher)).apply(this, arguments));
  }

  createClass(SoakedSlicePatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.registerHelper('__guard__', GUARD_HELPER$2);

      var soakContainer = findSoakContainer(this);
      var varName = soakContainer.claimFreeBinding('x');
      var prefix = this.slice(soakContainer.contentStart, this.contentStart);

      if (prefix.length > 0) {
        this.remove(soakContainer.contentStart, this.contentStart);
      }

      this.insert(this.expression.outerEnd, ', ' + varName + ' => ' + prefix + varName);

      soakContainer.insert(soakContainer.contentStart, '__guard__(');

      get(SoakedSlicePatcher.prototype.__proto__ || Object.getPrototypeOf(SoakedSlicePatcher.prototype), 'patchAsExpression', this).call(this);
      soakContainer.appendDeferredSuffix(')');
    }

    /**
     * For a soaked splice operation, we are the soak container.
     */

  }, {
    key: 'getSpliceCode',
    value: function getSpliceCode(expressionCode) {
      var _this2 = this;

      var spliceStart = this.captureCodeForPatchOperation(function () {
        _this2.registerHelper('__guard__', GUARD_HELPER$2);
        var varName = _this2.claimFreeBinding('x');
        _this2.insert(_this2.expression.outerEnd, ', ' + varName + ' => ' + varName);
        _this2.patchAsSpliceExpressionStart();
      });
      return '__guard__(' + spliceStart + ', ...[].concat(' + expressionCode + ')))';
    }
  }]);
  return SoakedSlicePatcher;
}(SlicePatcher);

/**
 * Transform CS super to JS super. For constructors, we can keep the form
 * `super(a, b, c)`, but for methods, we need to insert the method name, e.g.
 * `super.foo(a, b, c)`. However, there are some cases where CS allows super
 * calls but JS doesn't, so in those cases, we find the class and method name
 * using CS's algorithm and insert a more direct prototype method call.
 */
var SuperPatcher = function (_NodePatcher) {
  inherits(SuperPatcher, _NodePatcher);

  function SuperPatcher() {
    classCallCheck(this, SuperPatcher);
    return possibleConstructorReturn(this, (SuperPatcher.__proto__ || Object.getPrototypeOf(SuperPatcher)).apply(this, arguments));
  }

  createClass(SuperPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _getEnclosingMethodIn = this.getEnclosingMethodInfo(),
          classCode = _getEnclosingMethodIn.classCode,
          accessCode = _getEnclosingMethodIn.accessCode;

      if (this.canConvertToJsSuper()) {
        if (accessCode) {
          this.insert(this.contentEnd, accessCode);
        }
      } else {
        if (!accessCode) {
          throw this.error('Cannot handle a super call in an inner function in a constructor. ' + 'Please either rewrite your CoffeeScript code to not use this ' + 'construct or file a bug to discuss ways that decaffeinate could ' + 'handle this case.');
        }
        if (!classCode) {
          throw this.error('Complex super calls within anonymous classes are not yet supported.');
        }
        var openParenToken = this.getFollowingOpenParenToken();
        this.overwrite(this.contentStart, openParenToken.end, classCode + '.prototype.__proto__' + accessCode + '.call(this, ');
      }
    }

    /**
     * @private
     */

  }, {
    key: 'getEnclosingMethodInfo',
    value: function getEnclosingMethodInfo() {
      var methodAssignment = this.getEnclosingMethodAssignment();
      if (methodAssignment instanceof ClassAssignOpPatcher) {
        var _accessCode = void 0;
        if (methodAssignment.isStaticMethod()) {
          _accessCode = '.' + methodAssignment.key.node.member.data;
        } else {
          if (methodAssignment.key instanceof IdentifierPatcher) {
            _accessCode = '.' + methodAssignment.key.node.data;
          } else {
            _accessCode = '[' + methodAssignment.key.getRepeatCode() + ']';
          }
        }
        return {
          classCode: this.getEnclosingClassName(methodAssignment),
          accessCode: _accessCode
        };
      } else if (methodAssignment instanceof ConstructorPatcher) {
        return {
          classCode: this.getEnclosingClassName(methodAssignment),
          accessCode: null
        };
      } else {
        var methodInfo = this.getPrototypeAssignInfo(methodAssignment);
        if (!methodInfo) {
          throw this.error('Expected a valid method assignment from getEnclosingMethodAssignment.');
        }
        return methodInfo;
      }
    }

    /**
     * @private
     */

  }, {
    key: 'getEnclosingClassName',
    value: function getEnclosingClassName(patcher) {
      var parent = patcher.parent;

      while (parent) {
        if (parent instanceof ClassPatcher) {
          // Note that this may be null if this is an anonymous class. In that
          // case, it's still possible, but harder, to generate code that lets us
          // reference the current class.
          return parent.getName();
        }
        parent = parent.parent;
      }
      throw this.error('Expected super expression to be in a class body.');
    }

    /**
     * @private
     */

  }, {
    key: 'getEnclosingMethodAssignment',
    value: function getEnclosingMethodAssignment() {
      var parent = this.parent;

      while (parent) {
        if (parent instanceof ClassAssignOpPatcher || parent instanceof ConstructorPatcher || this.getPrototypeAssignInfo(parent) !== null) {
          return parent;
        }
        parent = parent.parent;
      }
      throw this.error('super called in a context where we cannot determine the class and method name.');
    }

    /**
     * Extract the 'A' and 'b' from a node like `A.prototype.b = -> c`, if it
     * matches that form. Return null otherwise.
     *
     * @private
     */

  }, {
    key: 'getPrototypeAssignInfo',
    value: function getPrototypeAssignInfo(patcher) {
      var prototypeAssignPatchers = extractPrototypeAssignPatchers(patcher);
      if (!prototypeAssignPatchers) {
        return null;
      }
      var classRefPatcher = prototypeAssignPatchers.classRefPatcher,
          methodAccessPatcher = prototypeAssignPatchers.methodAccessPatcher;

      if (methodAccessPatcher instanceof MemberAccessOpPatcher) {
        return {
          classCode: classRefPatcher.getRepeatCode(),
          accessCode: '.' + methodAccessPatcher.member.node.data
        };
      } else if (methodAccessPatcher instanceof DynamicMemberAccessOpPatcher) {
        return {
          classCode: classRefPatcher.getRepeatCode(),
          accessCode: '[' + methodAccessPatcher.indexingExpr.getRepeatCode() + ']'
        };
      } else {
        throw this.error('Expected the method access patcher to be either ' + 'MemberAccessOpPatcher or DynamicMemberAccessOpPatcher.');
      }
    }

    /**
     * JavaScript super is more limited than CoffeeScript super, so in some cases
     * we need to write out an expanded version that uses the method on the
     * prototype. In particular:
     *
     * - CoffeeScript allows method assignments like `A::b = -> super`, and is
     *   able to determine the class and method name from code written like this.
     * - CoffeeScript allows `super` from nested methods (which end up compiling
     *   to use whatever `arguments` is relevant at that point in code if the
     *   `super` is written without args).
     *
     * @private
     */

  }, {
    key: 'canConvertToJsSuper',
    value: function canConvertToJsSuper() {
      var methodAssignment = this.getEnclosingMethodAssignment();
      if (methodAssignment instanceof ConstructorPatcher || methodAssignment instanceof ClassAssignOpPatcher) {
        return methodAssignment.expression === this.getEnclosingFunction();
      }
      return false;
    }

    /**
     * @private
     */

  }, {
    key: 'getEnclosingFunction',
    value: function getEnclosingFunction() {
      var parent = this.parent;

      while (parent) {
        if (parent instanceof FunctionPatcher) {
          return parent;
        }
        parent = parent.parent;
      }
      throw this.error('super called outside of a function.');
    }

    /**
     * @private
     */

  }, {
    key: 'getFollowingOpenParenToken',
    value: function getFollowingOpenParenToken() {
      var openParenTokenIndex = this.indexOfSourceTokenAfterSourceTokenIndex(this.contentEndTokenIndex, coffeeLex.SourceType.CALL_START);
      if (!openParenTokenIndex) {
        throw this.error('Expected open-paren after super.');
      }
      return this.sourceTokenAtIndex(openParenTokenIndex);
    }
  }]);
  return SuperPatcher;
}(NodePatcher);

var BreakPatcher = function (_NodePatcher) {
  inherits(BreakPatcher, _NodePatcher);

  function BreakPatcher() {
    classCallCheck(this, BreakPatcher);
    return possibleConstructorReturn(this, (BreakPatcher.__proto__ || Object.getPrototypeOf(BreakPatcher)).apply(this, arguments));
  }

  createClass(BreakPatcher, [{
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      // nothing to do
    }
  }, {
    key: 'canPatchAsExpression',
    value: function canPatchAsExpression() {
      return false;
    }
  }]);
  return BreakPatcher;
}(NodePatcher);

var SwitchCasePatcher = function (_NodePatcher) {
  inherits(SwitchCasePatcher, _NodePatcher);

  function SwitchCasePatcher(patcherContext, conditions, consequent) {
    classCallCheck(this, SwitchCasePatcher);

    var _this = possibleConstructorReturn(this, (SwitchCasePatcher.__proto__ || Object.getPrototypeOf(SwitchCasePatcher)).call(this, patcherContext));

    _this.conditions = conditions;
    _this.consequent = consequent;
    _this.negated = false;
    return _this;
  }

  createClass(SwitchCasePatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.conditions.forEach(function (condition) {
        return condition.setRequiresExpression();
      });
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var _this2 = this;

      // `when a, b, c then d` → `a, b, c then d`
      //  ^^^^^
      var whenToken = this.getWhenToken();
      this.remove(whenToken.start, this.conditions[0].contentStart);

      // `a, b, c then d` → `a b c then d`
      //   ^  ^
      this.getCommaTokens().forEach(function (comma) {
        _this2.remove(comma.start, comma.end);
      });

      this.conditions.forEach(function (condition) {
        // `a b c then d` → `case a: case b: case c: then d`
        //                   ^^^^^ ^^^^^^^ ^^^^^^^ ^
        _this2.insert(condition.outerStart, 'case ');
        if (_this2.negated) {
          condition.negate();
        }
        condition.patch({ leftBrace: false, rightBrace: false });
        _this2.insert(condition.outerEnd, ':');
      });

      // `case a: case b: case c: then d → `case a: case b: case c: d`
      //                          ^^^^^
      var thenToken = this.getThenToken();
      if (thenToken) {
        if (this.consequent !== null) {
          this.remove(thenToken.start, this.consequent.contentStart);
        } else {
          this.remove(thenToken.start, thenToken.end);
        }
      }

      if (this.consequent !== null) {
        this.consequent.patch({ leftBrace: false, rightBrace: false });
      }

      var implicitReturnWillBreak = this.implicitlyReturns() && this.implicitReturnPatcher().implicitReturnWillBreak() && (!this.consequent || this.consequent.allCodePathsPresent());
      var shouldAddBreak = !this.hasExistingBreak() && !implicitReturnWillBreak;
      if (shouldAddBreak) {
        if (thenToken) {
          // `case a: case b: case c: then d → `case a: case b: case c: d break`
          //                                                             ^^^^^^
          if (this.consequent !== null) {
            this.insert(this.consequent.contentEnd, ' break');
          } else {
            this.insert(thenToken.end, ' break');
          }
        } else {
          this.appendLineAfter('break', 1);
        }
      }
    }
  }, {
    key: 'setImplicitlyReturns',
    value: function setImplicitlyReturns() {
      get(SwitchCasePatcher.prototype.__proto__ || Object.getPrototypeOf(SwitchCasePatcher.prototype), 'setImplicitlyReturns', this).call(this);
      if (this.consequent !== null) {
        this.consequent.setImplicitlyReturns();
      }
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.patchAsStatement();
    }

    /**
     * Don't actually negate the conditions until just before patching, since
     * otherwise we might accidentally overwrite a ! character that gets inserted.
     */

  }, {
    key: 'negate',
    value: function negate() {
      this.negated = !this.negated;
    }

    /**
     * @private
     */

  }, {
    key: 'getWhenToken',
    value: function getWhenToken() {
      var whenToken = this.sourceTokenAtIndex(this.contentStartTokenIndex);
      if (!whenToken) {
        throw this.error('bad token index for start of \'when\'');
      }
      if (whenToken.type !== coffeeLex.SourceType.WHEN) {
        throw this.error('unexpected ' + coffeeLex.SourceType[whenToken.type] + ' at start of \'switch\' case');
      }
      return whenToken;
    }

    /**
     * @private
     */

  }, {
    key: 'getCommaTokens',
    value: function getCommaTokens() {
      var result = [];
      for (var i = 1; i < this.conditions.length; i++) {
        var left = this.conditions[i - 1];
        var right = this.conditions[i];
        var commaIndex = this.indexOfSourceTokenBetweenPatchersMatching(left, right, function (token) {
          return token.type === coffeeLex.SourceType.COMMA;
        });
        if (!commaIndex) {
          throw this.error('unable to find comma between \'when\' conditions', left.contentEnd, right.contentStart);
        }
        result.push(this.sourceTokenAtIndex(commaIndex));
      }
      return result;
    }

    /**
     * @private
     */

  }, {
    key: 'hasExistingBreak',
    value: function hasExistingBreak() {
      if (!(this.consequent instanceof BlockPatcher)) {
        return false;
      }
      var lastStatement = this.consequent.statements[this.consequent.statements.length - 1];
      return lastStatement && lastStatement instanceof BreakPatcher;
    }

    /**
     * Gets the token representing the `then` between condition and consequent.
     *
     * @private
     */

  }, {
    key: 'getThenToken',
    value: function getThenToken() {
      var thenTokenIndex = this.indexOfSourceTokenBetweenSourceIndicesMatching(this.conditions[0].outerEnd, this.consequent !== null ? this.consequent.outerStart : this.contentEnd, function (token) {
        return token.type === coffeeLex.SourceType.THEN;
      });
      if (thenTokenIndex) {
        return this.sourceTokenAtIndex(thenTokenIndex);
      }
      // In some cases, the node bounds are wrong and the `then` is after our
      // current node, so just use that.
      var nextToken = this.nextSemanticToken();
      if (nextToken && nextToken.type === coffeeLex.SourceType.THEN) {
        return nextToken;
      }
      return null;
    }
  }]);
  return SwitchCasePatcher;
}(NodePatcher);

var SwitchPatcher = function (_NodePatcher) {
  inherits(SwitchPatcher, _NodePatcher);

  function SwitchPatcher(patcherContext, expression, cases, alternate) {
    classCallCheck(this, SwitchPatcher);

    var _this = possibleConstructorReturn(this, (SwitchPatcher.__proto__ || Object.getPrototypeOf(SwitchPatcher)).call(this, patcherContext));

    _this.expression = expression;
    _this.cases = cases;
    _this.alternate = alternate;
    return _this;
  }

  createClass(SwitchPatcher, [{
    key: 'initialize',
    value: function initialize() {
      if (this.expression) {
        this.expression.setRequiresExpression();
      }
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      if (this.expression) {
        // `switch a` → `switch (a`
        //                      ^
        if (!this.expression.isSurroundedByParentheses()) {
          this.insert(this.expression.contentStart, '(');
        }

        this.expression.patch();

        // `switch (a` → `switch (a)`
        //                         ^
        if (!this.expression.isSurroundedByParentheses()) {
          this.insert(this.expression.contentEnd, ')');
        }

        // `switch (a)` → `switch (a) {`
        //                            ^
        this.insert(this.expression.outerEnd, ' {');
      } else {
        this.cases.forEach(function (casePatcher) {
          return casePatcher.negate();
        });

        // `switch` → `switch (false) {`
        //                   ^^^^^^^^^^
        var switchToken = this.getSwitchToken();
        this.insert(switchToken.end, ' (false) {');
      }

      this.cases.forEach(function (casePatcher) {
        return casePatcher.patch();
      });

      this.overwriteElse();
      if (this.alternate) {
        this.alternate.patch({ leftBrace: false, rightBrace: false });
      }

      this.appendLineAfter('}');
    }

    /**
     * If we're a statement, our children can handle implicit return, so no need
     * to convert to an expression.
     */

  }, {
    key: 'implicitlyReturns',
    value: function implicitlyReturns() {
      return get(SwitchPatcher.prototype.__proto__ || Object.getPrototypeOf(SwitchPatcher.prototype), 'implicitlyReturns', this).call(this) && this.willPatchAsExpression();
    }
  }, {
    key: 'setImplicitlyReturns',
    value: function setImplicitlyReturns() {
      get(SwitchPatcher.prototype.__proto__ || Object.getPrototypeOf(SwitchPatcher.prototype), 'setImplicitlyReturns', this).call(this);
      this.cases.forEach(function (casePatcher) {
        return casePatcher.setImplicitlyReturns();
      });
      if (this.alternate) {
        this.alternate.setImplicitlyReturns();
      }
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _this2 = this;

      this.setImplicitlyReturns();

      this.patchInIIFE(function () {
        _this2.insert(_this2.innerStart, ' ');
        _this2.patchAsStatement();
        _this2.insert(_this2.innerEnd, ' ');
      });
    }
  }, {
    key: 'canHandleImplicitReturn',
    value: function canHandleImplicitReturn() {
      return this.willPatchAsExpression();
    }
  }, {
    key: 'patchImplicitReturnStart',
    value: function patchImplicitReturnStart(patcher) {
      if (patcher instanceof BreakPatcher) {
        if (patcher.isSurroundedByParentheses()) {
          this.remove(patcher.outerStart, patcher.innerStart);
          this.remove(patcher.innerEnd, patcher.outerEnd);
        }
        return;
      }
      get(SwitchPatcher.prototype.__proto__ || Object.getPrototypeOf(SwitchPatcher.prototype), 'patchImplicitReturnStart', this).call(this, patcher);
    }

    /**
     * @private
     */

  }, {
    key: 'overwriteElse',
    value: function overwriteElse() {
      // `else` → `default:`
      //           ^^^^^^^^
      var elseToken = this.getElseToken();
      if (elseToken) {
        this.overwrite(elseToken.start, elseToken.end, 'default:');
      }
    }

    /**
     * @private
     */

  }, {
    key: 'getElseToken',
    value: function getElseToken() {
      if (!this.alternate) {
        return null;
      }

      var tokens$$1 = this.context.sourceTokens;
      var elseTokenIndex = tokens$$1.lastIndexOfTokenMatchingPredicate(function (token) {
        return token.type === coffeeLex.SourceType.ELSE;
      }, this.alternate.contentStartTokenIndex);
      if (!elseTokenIndex || elseTokenIndex.isBefore(this.contentStartTokenIndex)) {
        throw this.alternate.error('no ELSE token found before \'switch\' alternate');
      }
      return this.sourceTokenAtIndex(elseTokenIndex);
    }

    /**
     * @private
     */

  }, {
    key: 'getSwitchToken',
    value: function getSwitchToken() {
      var switchToken = this.sourceTokenAtIndex(this.contentStartTokenIndex);
      if (!switchToken) {
        throw this.error('bad token index for start of \'switch\'');
      }
      if (switchToken.type !== coffeeLex.SourceType.SWITCH) {
        throw this.error('unexpected ' + coffeeLex.SourceType[switchToken.type] + ' token at start of \'switch\'');
      }
      return switchToken;
    }

    /**
     * Switch statements with all code paths present have a `default` case and
     * each case has all of its code paths covered.
     */

  }, {
    key: 'allCodePathsPresent',
    value: function allCodePathsPresent() {
      if (!this.alternate) {
        return false;
      }

      return this.cases.every(function (switchCase) {
        return switchCase.allCodePathsPresent();
      }) && this.alternate.allCodePathsPresent();
    }
  }]);
  return SwitchPatcher;
}(NodePatcher);

var ThrowPatcher = function (_NodePatcher) {
  inherits(ThrowPatcher, _NodePatcher);

  function ThrowPatcher(patcherContext, expression) {
    classCallCheck(this, ThrowPatcher);

    var _this = possibleConstructorReturn(this, (ThrowPatcher.__proto__ || Object.getPrototypeOf(ThrowPatcher)).call(this, patcherContext));

    _this.expression = expression;
    return _this;
  }

  /**
   * Throw in JavaScript is a statement only, so we'd prefer it stay that way.
   */


  createClass(ThrowPatcher, [{
    key: 'prefersToPatchAsExpression',
    value: function prefersToPatchAsExpression() {
      return false;
    }

    /**
     * Throw statements that are in the implicit return position should simply
     * be left alone as they're pure statements in JS and don't have a value.
     */

  }, {
    key: 'setImplicitlyReturns',
    value: function setImplicitlyReturns() {}
    // throw can't be an implicit return


    /**
     * `throw` statements cannot normally be used as expressions, so we wrap them
     * in an arrow function IIFE.
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var hasParens = this.isSurroundedByParentheses();
      if (!hasParens) {
        // `throw err` → `(throw err`
        //                ^
        this.insert(this.outerStart, '(');
      }
      // `(throw err` → `(() => { throw err`
      //                  ^^^^^^^^
      this.insert(this.innerStart, '() => { ');
      this.patchAsStatement();
      // `(() => { throw err` → `(() => { throw err }`
      //                                           ^^
      this.insert(this.innerEnd, ' }');
      if (!hasParens) {
        // `(() => { throw err }` → `(() => { throw err })`
        //                                               ^
        this.insert(this.outerEnd, ')');
      }
      // `(() => { throw err })` → `(() => { throw err })()`
      //                                                 ^^
      this.insert(this.outerEnd, '()');
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var throwToken = this.sourceTokenAtIndex(this.contentStartTokenIndex);
      if (throwToken.type !== coffeeLex.SourceType.THROW) {
        this.error('Expected to find throw token at the start of throw statement.');
      }
      var spacing = this.slice(throwToken.end, this.expression.outerStart);
      if (spacing.indexOf('\n') !== -1) {
        this.overwrite(throwToken.end, this.expression.outerStart, ' ');
      }
      this.expression.patch();
    }

    /**
     * This is here so that we can add the `()` outside any existing parens.
     */

  }, {
    key: 'allowPatchingOuterBounds',
    value: function allowPatchingOuterBounds() {
      return true;
    }
  }]);
  return ThrowPatcher;
}(NodePatcher);

function nativeFind(array, iterator, context) {
    return array.find(iterator, context);
}
function find(array, iterator, context) {
    for (var i = 0; i < array.length; i++) {
        var element = array[i];
        if (iterator.call(context, element, i, array)) {
            return element;
        }
    }
    return undefined;
}
var find$1 = Array.prototype.find ? nativeFind : find;

/**
 * Maps a list to another list by combining lists.
 */
/**
 * Maps a list to another list by combining lists.
 */function flatMap(list, map) {
  return list.reduce(function (memo, item) {
    return memo.concat(map(item));
  }, []);
}

/**
 * Gets the identifiers for the given LHS value.
 *
 * @example
 *
 *   Given `a`, returns [`a`].
 *   Given `[a, b]`, returns [`a`, `b`].
 *   Given `{a, b: c}`, returns [`a`, `c`].
 *   Given `[a, {b, c: d}]`, returns [`a`, `b`, `d`].
 */
function leftHandIdentifiers(node) {
  if (node.type === 'Identifier') {
    return [node];
  } else if (node.type === 'ArrayInitialiser') {
    return flatMap(node.members, leftHandIdentifiers);
  } else if (node.type === 'ObjectInitialiser') {
    return flatMap(node.members, function (member) {
      return leftHandIdentifiers(member.expression);
    });
  } else {
    return [];
  }
}

/**
 * Represents a CoffeeScript scope and its bindings.
 */
var Scope = function () {
  function Scope(containerNode) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    classCallCheck(this, Scope);

    this.parent = parent;
    this.bindings = Object.create(parent ? parent.bindings : null);
    this.containerNode = containerNode;
  }

  createClass(Scope, [{
    key: 'getBinding',
    value: function getBinding(name) {
      return this.bindings[this.key(name)] || null;
    }
  }, {
    key: 'isBindingAvailable',
    value: function isBindingAvailable(name) {
      return !this.getBinding(name) && !isReservedWord(name);
    }
  }, {
    key: 'hasBinding',
    value: function hasBinding(name) {
      return this.getBinding(name) !== null;
    }
  }, {
    key: 'getOwnNames',
    value: function getOwnNames() {
      var _this = this;

      return Object.getOwnPropertyNames(this.bindings).map(function (key) {
        return _this.unkey(key);
      });
    }
  }, {
    key: 'declares',
    value: function declares(name, node) {
      var key = this.key(name);
      this.bindings[key] = node;
    }
  }, {
    key: 'assigns',
    value: function assigns(name, node) {
      if (!this.bindings[this.key(name)]) {
        // Not defined in this or any parent scope.
        this.declares(name, node);
      }
    }
  }, {
    key: 'claimFreeBinding',
    value: function claimFreeBinding(node) {
      var _this2 = this;

      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (!name) {
        name = 'ref';
      }
      var names = Array.isArray(name) ? name : [name];
      var binding = find$1(names, function (name) {
        return _this2.isBindingAvailable(name);
      });

      if (!binding) {
        (function () {
          var counter = 0;
          while (!binding) {
            if (counter > 1000) {
              throw new Error('Unable to find free binding for names ' + names.toString());
            }
            counter += 1;
            binding = find$1(names, function (name) {
              return _this2.isBindingAvailable('' + name + counter);
            });
          }
          binding = '' + binding + counter;
        })();
      }

      this.declares(binding, node);
      return binding;
    }

    /**
     * @private
     */

  }, {
    key: 'key',
    value: function key(name) {
      return '$' + name;
    }

    /**
     * @private
     */

  }, {
    key: 'unkey',
    value: function unkey(key) {
      return key.slice(1);
    }

    /**
     * Handles declarations or assigns for any bindings for a given node.
     */

  }, {
    key: 'processNode',
    value: function processNode(node) {
      var _this3 = this;

      switch (node.type) {
        case 'AssignOp':
          leftHandIdentifiers(node.assignee).forEach(function (identifier) {
            return _this3.assigns(identifier.data, identifier);
          });
          break;

        case 'Function':
        case 'BoundFunction':
        case 'GeneratorFunction':
        case 'BoundGeneratorFunction':
          getBindingsForNode(node).forEach(function (identifier) {
            return _this3.declares(identifier.data, identifier);
          });
          break;

        case 'ForIn':
        case 'ForOf':
          [node.keyAssignee, node.valAssignee].forEach(function (assignee) {
            if (assignee) {
              leftHandIdentifiers(assignee).forEach(function (identifier) {
                return _this3.assigns(identifier.data, identifier);
              });
            }
          });
          break;

        case 'Try':
          if (node.catchAssignee) {
            leftHandIdentifiers(node.catchAssignee).forEach(function (identifier) {
              return _this3.assigns(identifier.data, identifier);
            });
          }
          break;

        case 'Class':
          if (node.nameAssignee && node.nameAssignee.type === 'Identifier') {
            this.assigns(node.nameAssignee.data, node.nameAssignee);
          }
          break;
      }
    }
  }, {
    key: 'toString',
    value: function toString() {
      var parts = this.getOwnNames();
      if (this.parent) {
        parts.push('parent = ' + this.parent.toString());
      }
      return this.constructor.name + ' {' + (parts.length > 0 ? ' ' + parts.join(', ') + ' ' : '') + '}';
    }
  }, {
    key: 'inspect',
    value: function inspect$$1() {
      return this.toString();
    }
  }]);
  return Scope;
}();

function getBindingsForNode(node) {
  switch (node.type) {
    case 'Function':
    case 'GeneratorFunction':
    case 'BoundFunction':
    case 'BoundGeneratorFunction':
      return flatMap(node.parameters, getBindingsForNode);

    case 'Identifier':
    case 'ArrayInitialiser':
    case 'ObjectInitialiser':
      return leftHandIdentifiers(node);

    case 'DefaultParam':
      return getBindingsForNode(node.param);

    case 'Rest':
      return getBindingsForNode(node.expression);

    case 'Expansion':
    case 'MemberAccessOp':
      return [];

    default:
      throw new Error('unexpected parameter type: ' + node.type);
  }
}

/**
 * Parses a CoffeeScript program and attaches scope information to the nodes.
 */
function parse$2(source) {
  var ast = decaffeinateParser.parse(source);
  traverse(ast, attachScope);
  return ast;
}

function attachScope(node) {
  switch (node.type) {
    case 'Program':
      node.scope = new Scope(node);
      break;

    case 'Function':
    case 'BoundFunction':
    case 'GeneratorFunction':
      node.scope = new Scope(node, node.parentNode.scope);
      break;

    default:
      node.scope = node.parentNode.scope;
      break;
  }

  node.scope.processNode(node);
}

var TransformCoffeeScriptStage = function () {
  createClass(TransformCoffeeScriptStage, null, [{
    key: 'run',
    value: function run(content, options) {
      var log = logger(this.name);
      log(content);

      var ast = parse$2(content);
      var editor = new MagicString(content);
      var stage = new this(ast, ast.context, editor, options);
      var patcher = stage.build();
      patcher.patch();
      return {
        code: editor.toString()
      };
    }
  }, {
    key: 'inputExtension',
    get: function get$$1() {
      return '.coffee';
    }
  }, {
    key: 'outputExtension',
    get: function get$$1() {
      return '.js';
    }
  }]);

  function TransformCoffeeScriptStage(ast, context, editor, options) {
    classCallCheck(this, TransformCoffeeScriptStage);

    this.ast = ast;
    this.context = context;
    this.editor = editor;
    this.options = options;
    this.root = null;
    this.patchers = [];
  }

  /**
   * This should be overridden in subclasses.
   */


  createClass(TransformCoffeeScriptStage, [{
    key: 'patcherConstructorForNode',
    value: function patcherConstructorForNode(node) {
      // eslint-disable-line no-unused-vars
      return null;
    }
  }, {
    key: 'build',
    value: function build() {
      this.root = this.patcherForNode(this.ast);
      this.patchers.forEach(function (patcher) {
        return patcher.initialize();
      });
      return this.root;
    }
  }, {
    key: 'patcherForNode',
    value: function patcherForNode(node) {
      var _this = this;

      var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var property = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var constructor = this._patcherConstructorForNode(node);

      if (parent) {
        var override = parent.patcherClassForChildNode(node, property);
        if (override) {
          constructor = override;
        }
      }

      var children = childPropertyNames(node).map(function (name) {
        var child = node[name];
        if (!child) {
          return null;
        } else if (Array.isArray(child)) {
          return child.map(function (item) {
            return _this.patcherForNode(item, constructor, name);
          });
        } else {
          return _this.patcherForNode(child, constructor, name);
        }
      });

      var patcherContext = {
        node: node,
        context: this.context,
        editor: this.editor,
        options: this.options
      };
      var patcher = new (Function.prototype.bind.apply(constructor, [null].concat([patcherContext], toConsumableArray(children))))();
      this.patchers.push(patcher);
      this.associateParent(patcher, children);

      return patcher;
    }
  }, {
    key: 'associateParent',
    value: function associateParent(parent, child) {
      var _this2 = this;

      if (Array.isArray(child)) {
        child.forEach(function (item) {
          return _this2.associateParent(parent, item);
        });
      } else if (child) {
        child.parent = parent;
      }
    }
  }, {
    key: '_patcherConstructorForNode',
    value: function _patcherConstructorForNode(node) {
      var constructor = this.patcherConstructorForNode(node);

      if (constructor === null) {
        var props = childPropertyNames(node);
        throw new (Function.prototype.bind.apply(PatchError, [null].concat(['no patcher available for node type: ' + node.type + ('' + (props.length ? ' (props: ' + props.join(', ') + ')' : '')), this.context.source], toConsumableArray(node.range))))();
      }

      return constructor.patcherClassOverrideForNode(node) || constructor;
    }
  }]);
  return TransformCoffeeScriptStage;
}();

/**
 * Handles `try` statements, e.g. `try a catch e then console.log(e)`.
 */

var TryPatcher = function (_NodePatcher) {
  inherits(TryPatcher, _NodePatcher);

  function TryPatcher(patcherContext, body, catchAssignee, catchBody, finallyBody) {
    classCallCheck(this, TryPatcher);

    var _this = possibleConstructorReturn(this, (TryPatcher.__proto__ || Object.getPrototypeOf(TryPatcher)).call(this, patcherContext));

    _this.body = body;
    _this.catchAssignee = catchAssignee;
    _this.catchBody = catchBody;
    _this.finallyBody = finallyBody;
    return _this;
  }

  createClass(TryPatcher, [{
    key: 'initialize',
    value: function initialize() {
      if (this.catchAssignee) {
        this.catchAssignee.setAssignee();
        this.catchAssignee.setRequiresExpression();
      }
    }

    /**
     * 'try' BODY ( 'catch' ASSIGNEE? CATCH-BODY? )? ( 'finally' FINALLY-BODY )?
     */

  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var tryToken = this.getTryToken();
      var catchToken = this.getCatchToken();
      var thenTokenIndex = this.getThenTokenIndex();
      var finallyToken = this.getFinallyToken();

      // `try a` → `try { a`
      //               ^^
      this.insert(tryToken.end, ' {');
      if (this.body) {
        if (this.body.inline()) {
          this.body.patch({ leftBrace: false });
        } else {
          if (catchToken || finallyToken) {
            this.body.patch({ leftBrace: false, rightBrace: false });
            // `try { a; catch err` → `try { a; } catch err`
            //                                  ^^
            this.insert((catchToken || finallyToken).start, '} ');
          } else {
            this.body.patch({ leftBrace: false });
          }
        }
      } else {
        this.insert(tryToken.end, '}');
      }

      if (thenTokenIndex) {
        var thenToken = this.sourceTokenAtIndex(thenTokenIndex);
        var nextToken = this.sourceTokenAtIndex(thenTokenIndex.next());
        // `try { a; } catch err then b` → `try { a; } catch err b`
        //                       ^^^^^
        this.remove(thenToken.start, nextToken.start);
      }

      if (catchToken) {
        var afterCatchHeader = this.catchAssignee ? this.catchAssignee.outerEnd : catchToken.end;

        if (this.catchAssignee) {
          var addErrorParens = !this.catchAssignee.isSurroundedByParentheses();
          if (addErrorParens) {
            // `try { a; } catch err` → `try { a; } catch (err`
            //                                            ^
            this.insert(this.catchAssignee.outerStart, '(');
          }
          this.catchAssignee.patch();
          if (addErrorParens) {
            // `try { a; } catch (err` → `try { a; } catch (err)`
            //                                                 ^
            this.insert(this.catchAssignee.outerEnd, ')');
          }
        } else {
          // `try { a; } catch` → `try { a; } catch (error)`
          //                                       ^^^^^^^^
          this.insert(afterCatchHeader, ' (' + this.getErrorBinding() + ')');
        }

        if (this.catchBody) {
          // `try { a; } catch (error)` → `try { a; } catch (error) {`
          //                                                       ^^
          this.insert(afterCatchHeader, ' {');
          this.catchBody.patch({ leftBrace: false });
        } else {
          this.insert(afterCatchHeader, ' {}');
        }
      } else if (!finallyToken) {
        // `try { a; }` → `try { a; } catch (error) {}`
        //                           ^^^^^^^^^^^^^^^^^
        var insertPos = this.body ? this.body.innerEnd : tryToken.end;
        this.insert(insertPos, ' catch (' + this.getErrorBinding() + ') {}');
      }

      if (finallyToken) {
        if (!this.finallyBody) {
          this.insert(finallyToken.end, ' {}');
        } else if (this.finallyBody.inline()) {
          this.finallyBody.patch();
        } else {
          // `try { a; } finally b` → `try { a; } finally { b`
          //                                             ^^
          this.insert(finallyToken.end, ' {');
          this.finallyBody.patch({ leftBrace: false });
        }
      }
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _this2 = this;

      // Make our children return since we're wrapping in a function.
      this.setImplicitlyReturns();

      this.patchInIIFE(function () {
        _this2.insert(_this2.innerStart, ' ');
        _this2.patchAsStatement();
        _this2.insert(_this2.innerEnd, ' ');
      });
    }

    /**
     * If we're a statement, our children can handle implicit return, so no need
     * to convert to an expression.
     */

  }, {
    key: 'implicitlyReturns',
    value: function implicitlyReturns() {
      return get(TryPatcher.prototype.__proto__ || Object.getPrototypeOf(TryPatcher.prototype), 'implicitlyReturns', this).call(this) && this.willPatchAsExpression();
    }
  }, {
    key: 'setImplicitlyReturns',
    value: function setImplicitlyReturns() {
      get(TryPatcher.prototype.__proto__ || Object.getPrototypeOf(TryPatcher.prototype), 'setImplicitlyReturns', this).call(this);
      if (this.body) {
        this.body.setImplicitlyReturns();
      }
      if (this.catchBody) {
        this.catchBody.setImplicitlyReturns();
      }
    }
  }, {
    key: 'statementNeedsSemicolon',
    value: function statementNeedsSemicolon() {
      return false;
    }

    /**
     * @private
     */

  }, {
    key: 'getTryToken',
    value: function getTryToken() {
      var tryTokenIndex = this.contentStartTokenIndex;
      var tryToken = this.sourceTokenAtIndex(tryTokenIndex);
      if (!tryToken || tryToken.type !== coffeeLex.SourceType.TRY) {
        throw this.error('expected \'try\' keyword at start of \'try\' statement');
      }
      return tryToken;
    }

    /**
     * @private
     */

  }, {
    key: 'getCatchToken',
    value: function getCatchToken() {
      var searchStart = void 0;
      if (this.body) {
        searchStart = this.body.outerEnd;
      } else {
        searchStart = this.getTryToken().end;
      }

      var searchEnd = void 0;
      if (this.catchAssignee) {
        searchEnd = this.catchAssignee.outerStart;
      } else if (this.catchBody) {
        searchEnd = this.catchBody.outerStart;
      } else if (this.finallyBody) {
        searchEnd = this.finallyBody.outerStart;
      } else {
        searchEnd = this.contentEnd;
      }

      var catchTokenIndex = this.indexOfSourceTokenBetweenSourceIndicesMatching(searchStart, searchEnd, function (token) {
        return token.type === coffeeLex.SourceType.CATCH;
      });
      if (!catchTokenIndex) {
        return null;
      }
      return this.sourceTokenAtIndex(catchTokenIndex);
    }

    /**
     * @private
     */

  }, {
    key: 'getThenTokenIndex',
    value: function getThenTokenIndex() {
      var searchStart = void 0;
      if (this.catchAssignee) {
        searchStart = this.catchAssignee.outerEnd;
      } else if (this.body) {
        searchStart = this.body.outerEnd;
      } else {
        searchStart = this.getTryToken().end;
      }

      var searchEnd = void 0;
      if (this.catchBody) {
        searchEnd = this.catchBody.outerStart;
      } else if (this.finallyBody) {
        searchEnd = this.finallyBody.outerStart;
      } else {
        searchEnd = this.contentEnd;
      }

      return this.indexOfSourceTokenBetweenSourceIndicesMatching(searchStart, searchEnd, function (token) {
        return token.type === coffeeLex.SourceType.THEN;
      });
    }

    /**
     * @private
     */

  }, {
    key: 'getFinallyToken',
    value: function getFinallyToken() {
      var searchStart = void 0;
      if (this.catchBody) {
        searchStart = this.catchBody.outerEnd;
      } else if (this.catchAssignee) {
        searchStart = this.catchAssignee.outerEnd;
      } else if (this.body) {
        searchStart = this.body.outerEnd;
      } else {
        searchStart = this.getTryToken().end;
      }

      var searchEnd = void 0;
      if (this.finallyBody) {
        searchEnd = this.finallyBody.outerStart;
      } else {
        searchEnd = this.contentEnd;
      }

      var finallyTokenIndex = this.indexOfSourceTokenBetweenSourceIndicesMatching(searchStart, searchEnd, function (token) {
        return token.type === coffeeLex.SourceType.FINALLY;
      });
      if (!finallyTokenIndex) {
        return null;
      }
      return this.sourceTokenAtIndex(finallyTokenIndex);
    }

    /**
     * @private
     */

  }, {
    key: 'getErrorBinding',
    value: function getErrorBinding() {
      if (!this._errorBinding) {
        this._errorBinding = this.claimFreeBinding('error');
      }
      return this._errorBinding;
    }
  }]);
  return TryPatcher;
}(NodePatcher);

/**
 * Handles unary exists, e.g. `a?`.
 */

var UnaryExistsOpPatcher = function (_UnaryOpPatcher) {
  inherits(UnaryExistsOpPatcher, _UnaryOpPatcher);

  function UnaryExistsOpPatcher() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, UnaryExistsOpPatcher);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = UnaryExistsOpPatcher.__proto__ || Object.getPrototypeOf(UnaryExistsOpPatcher)).call.apply(_ref, [this].concat(args))), _this), _this.negated = false, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(UnaryExistsOpPatcher, [{
    key: 'patchAsExpression',


    /**
     * The expression version of this sometimes needs parentheses, but we don't
     * yet have a good mechanism for determining when that is, so we just make
     * sure they're always there. For example, this doesn't need parentheses:
     *
     *   set = a?
     *
     * Because it becomes this:
     *
     *   var set = typeof a !== 'undefined' && a !== null;
     *
     * But this does:
     *
     *   'set? ' + a?
     *
     * Because this:
     *
     *   'set? ' + a != null;
     *
     * Is equivalent to this:
     *
     *   ('set? + a) != null;
     *
     * Which has a different meaning than this:
     *
     *   'set? ' + (a != null);
     */
    value: function patchAsExpression() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$needsParens = _ref2.needsParens,
          needsParens = _ref2$needsParens === undefined ? true : _ref2$needsParens;

      var addParens = needsParens && !this.isSurroundedByParentheses();
      if (addParens) {
        // `a?` → `(a?`
        //         ^
        this.insert(this.contentStart, '(');
      }
      this.patchAsStatement();
      if (addParens) {
        // `(a?` → `(a?)`
        //             ^
        this.insert(this.contentEnd, ')');
      }
    }

    /**
     * EXPRESSION '?'
     */

  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var expression = this.node.expression,
          negated = this.negated;

      var needsTypeofCheck = this.needsTypeofCheck();

      this.expression.patch();
      if (needsTypeofCheck) {
        if (negated) {
          // `a?` → `typeof a === 'undefined' && a === null`
          //  ^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          this.overwrite(this.contentStart, this.contentEnd, 'typeof ' + expression.raw + ' === \'undefined\' || ' + expression.raw + ' === null');
        } else {
          // `a?` → `typeof a !== 'undefined' && a !== null`
          //  ^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          this.overwrite(this.contentStart, this.contentEnd, 'typeof ' + expression.raw + ' !== \'undefined\' && ' + expression.raw + ' !== null');
        }
      } else {
        if (negated) {
          // `a.b?` → `a.b == null`
          //     ^        ^^^^^^^^
          this.overwrite(this.expression.outerEnd, this.contentEnd, ' == null');
        } else {
          // `a.b?` → `a.b != null`
          //     ^        ^^^^^^^^
          this.overwrite(this.expression.outerEnd, this.contentEnd, ' != null');
        }
      }
    }

    /**
     * Since we turn into an equality check, we can simply invert the operator
     * to handle negation internally rather than by prefixing with `!`.
     */

  }, {
    key: 'canHandleNegationInternally',
    value: function canHandleNegationInternally() {
      return true;
    }

    /**
     * Flips negated flag but doesn't edit anything immediately so that we can
     * use the correct operator in `patch`.
     */

  }, {
    key: 'negate',
    value: function negate() {
      this.negated = !this.negated;
    }

    /**
     * @private
     */

  }, {
    key: 'needsTypeofCheck',
    value: function needsTypeofCheck() {
      return this.expression.mayBeUnboundReference();
    }

    /**
     * When we prefix with a `typeof` check we don't need parens, otherwise
     * delegate.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      if (this.needsTypeofCheck()) {
        return false;
      } else {
        return this.expression.statementShouldAddParens();
      }
    }
  }]);
  return UnaryExistsOpPatcher;
}(UnaryOpPatcher);

/**
 * Handles unary math operators, e.g. `+a`, `-a`, `~a`.
 */

var UnaryMathOpPatcher = function (_UnaryOpPatcher) {
  inherits(UnaryMathOpPatcher, _UnaryOpPatcher);

  function UnaryMathOpPatcher() {
    classCallCheck(this, UnaryMathOpPatcher);
    return possibleConstructorReturn(this, (UnaryMathOpPatcher.__proto__ || Object.getPrototypeOf(UnaryMathOpPatcher)).apply(this, arguments));
  }

  createClass(UnaryMathOpPatcher, [{
    key: 'isRepeatable',

    /**
     * Math does not (usually) have side effects, as far as CoffeeScript is
     * concerned. It could trigger a `valueOf` call that could trigger arbitrary
     * code, but we ignore that possibility.
     */
    value: function isRepeatable() {
      return this.expression.isRepeatable();
    }
  }]);
  return UnaryMathOpPatcher;
}(UnaryOpPatcher);

/**
 * Handles `typeof`, e.g. `typeof name`.
 */

var UnaryTypeofOpPatcher = function (_UnaryOpPatcher) {
  inherits(UnaryTypeofOpPatcher, _UnaryOpPatcher);

  function UnaryTypeofOpPatcher() {
    classCallCheck(this, UnaryTypeofOpPatcher);
    return possibleConstructorReturn(this, (UnaryTypeofOpPatcher.__proto__ || Object.getPrototypeOf(UnaryTypeofOpPatcher)).apply(this, arguments));
  }

  createClass(UnaryTypeofOpPatcher, [{
    key: 'isRepeatable',

    /**
     * `typeof` does not have side-effects.
     */
    value: function isRepeatable() {
      return this.expression.isRepeatable();
    }

    /**
     * This always starts with `typeof` and doesn't need parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return false;
    }
  }]);
  return UnaryTypeofOpPatcher;
}(UnaryOpPatcher);

var YieldPatcher = function (_NodePatcher) {
  inherits(YieldPatcher, _NodePatcher);

  function YieldPatcher(patcherContext, expression) {
    classCallCheck(this, YieldPatcher);

    var _this = possibleConstructorReturn(this, (YieldPatcher.__proto__ || Object.getPrototypeOf(YieldPatcher)).call(this, patcherContext));

    _this.expression = expression;
    return _this;
  }

  createClass(YieldPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.yields();
      this.expression.setRequiresExpression();
    }

    /**
     * 'yield' EXPRESSION
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$needsParens = _ref.needsParens,
          needsParens = _ref$needsParens === undefined ? true : _ref$needsParens;

      var surroundInParens = this.needsParens() && !this.isSurroundedByParentheses();
      if (surroundInParens) {
        this.insert(this.contentStart, '(');
      }
      this.expression.patch({ needsParens: needsParens });
      if (surroundInParens) {
        this.insert(this.contentEnd, ')');
      }
    }
  }, {
    key: 'needsParens',
    value: function needsParens() {
      return !(this.parent instanceof BlockPatcher || this.parent instanceof ReturnPatcher || this.parent instanceof AssignOpPatcher && this.parent.expression === this);
    }
  }]);
  return YieldPatcher;
}(NodePatcher);

var YieldFromPatcher = function (_YieldPatcher) {
  inherits(YieldFromPatcher, _YieldPatcher);

  function YieldFromPatcher() {
    classCallCheck(this, YieldFromPatcher);
    return possibleConstructorReturn(this, (YieldFromPatcher.__proto__ || Object.getPrototypeOf(YieldFromPatcher)).apply(this, arguments));
  }

  createClass(YieldFromPatcher, [{
    key: 'patchAsExpression',

    /**
     * 'yield' 'from' EXPRESSION
     */
    value: function patchAsExpression() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$needsParens = _ref.needsParens,
          needsParens = _ref$needsParens === undefined ? true : _ref$needsParens;

      var src = this.sourceTokenAtIndex(this.contentStartTokenIndex);
      this.overwrite(src.start, src.end, 'yield*');
      get(YieldFromPatcher.prototype.__proto__ || Object.getPrototypeOf(YieldFromPatcher.prototype), 'patchAsExpression', this).call(this, { needsParens: needsParens });
    }
  }]);
  return YieldFromPatcher;
}(YieldPatcher);

var YieldReturnPatcher = function (_ReturnPatcher) {
  inherits(YieldReturnPatcher, _ReturnPatcher);

  function YieldReturnPatcher() {
    classCallCheck(this, YieldReturnPatcher);
    return possibleConstructorReturn(this, (YieldReturnPatcher.__proto__ || Object.getPrototypeOf(YieldReturnPatcher)).apply(this, arguments));
  }

  createClass(YieldReturnPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.yields();
      get(YieldReturnPatcher.prototype.__proto__ || Object.getPrototypeOf(YieldReturnPatcher.prototype), 'initialize', this).call(this);
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var yieldTokenIndex = this.contentStartTokenIndex;
      var returnTokenIndex = yieldTokenIndex.next();
      var yieldToken = this.sourceTokenAtIndex(yieldTokenIndex);
      var returnToken = this.sourceTokenAtIndex(returnTokenIndex);
      if (yieldToken.type !== coffeeLex.SourceType.YIELD || returnToken.type !== coffeeLex.SourceType.RETURN) {
        throw this.error('Unexpected token types for `yield return`.');
      }
      this.remove(yieldToken.start, returnToken.start);
      get(YieldReturnPatcher.prototype.__proto__ || Object.getPrototypeOf(YieldReturnPatcher.prototype), 'patchAsStatement', this).call(this);
    }
  }]);
  return YieldReturnPatcher;
}(ReturnPatcher);

var ContinuePatcher = function (_NodePatcher) {
  inherits(ContinuePatcher, _NodePatcher);

  function ContinuePatcher() {
    classCallCheck(this, ContinuePatcher);
    return possibleConstructorReturn(this, (ContinuePatcher.__proto__ || Object.getPrototypeOf(ContinuePatcher)).apply(this, arguments));
  }

  createClass(ContinuePatcher, [{
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      // nothing to do
    }
  }, {
    key: 'canPatchAsExpression',
    value: function canPatchAsExpression() {
      return false;
    }
  }]);
  return ContinuePatcher;
}(NodePatcher);

var MainStage = function (_TransformCoffeeScrip) {
  inherits(MainStage, _TransformCoffeeScrip);

  function MainStage() {
    classCallCheck(this, MainStage);
    return possibleConstructorReturn(this, (MainStage.__proto__ || Object.getPrototypeOf(MainStage)).apply(this, arguments));
  }

  createClass(MainStage, [{
    key: 'patcherConstructorForNode',
    value: function patcherConstructorForNode(node) {
      switch (node.type) {
        case 'Identifier':
          return IdentifierPatcher;

        case 'String':
          return StringPatcher;

        case 'Int':
        case 'Float':
        case 'Null':
        case 'Undefined':
        case 'Quasi':
          return PassthroughPatcher;

        case 'Break':
          return BreakPatcher;

        case 'Continue':
          return ContinuePatcher;

        case 'FunctionApplication':
          return FunctionApplicationPatcher;

        case 'SoakedFunctionApplication':
          return SoakedFunctionApplicationPatcher;

        case 'MemberAccessOp':
          return MemberAccessOpPatcher;

        case 'DynamicMemberAccessOp':
          return DynamicMemberAccessOpPatcher;

        case 'EQOp':
        case 'NEQOp':
        case 'LTOp':
        case 'GTOp':
        case 'LTEOp':
        case 'GTEOp':
          return EqualityPatcher;

        case 'PostIncrementOp':
        case 'PostDecrementOp':
        case 'PreIncrementOp':
        case 'PreDecrementOp':
          return IncrementDecrementPatcher;

        case 'ObjectInitialiserMember':
          return ObjectInitialiserMemberPatcher;

        case 'ObjectInitialiser':
          return ObjectInitialiserPatcher;

        case 'This':
          return ThisPatcher;

        case 'Yield':
          return YieldPatcher;

        case 'YieldFrom':
          return YieldFromPatcher;

        case 'YieldReturn':
          return YieldReturnPatcher;

        case 'GeneratorFunction':
          return GeneratorFunctionPatcher;

        case 'Function':
          return FunctionPatcher;

        case 'BoundFunction':
          return BoundFunctionPatcher;

        case 'BoundGeneratorFunction':
          return BoundGeneratorFunctionPatcher;

        case 'Bool':
          return BoolPatcher;

        case 'Conditional':
          return ConditionalPatcher;

        case 'ArrayInitialiser':
          return ArrayInitialiserPatcher;

        case 'Block':
          return BlockPatcher;

        case 'AssignOp':
          return AssignOpPatcher;

        case 'DefaultParam':
          return DefaultParamPatcher;

        case 'CompoundAssignOp':
          switch (node.op) {
            case 'LogicalAndOp':
            case 'LogicalOrOp':
              return LogicalOpCompoundAssignOpPatcher;

            case 'ExistsOp':
              return ExistsOpCompoundAssignOpPatcher;

            case 'ModuloOp':
              return ModuloOpCompoundAssignOpPatcher;

            default:
              return CompoundAssignOpPatcher;
          }

        case 'Return':
          return ReturnPatcher;

        case 'PlusOp':
        case 'SubtractOp':
        case 'DivideOp':
        case 'MultiplyOp':
        case 'RemOp':
        case 'BitAndOp':
        case 'BitOrOp':
        case 'BitXorOp':
        case 'LeftShiftOp':
        case 'SignedRightShiftOp':
        case 'UnsignedRightShiftOp':
          return BinaryOpPatcher;

        case 'ModuloOp':
          return ModuloOpPatcher;

        case 'Regex':
          return RegexPatcher;

        case 'Heregex':
          return HeregexPatcher;

        case 'ExistsOp':
          return ExistsOpPatcher;

        case 'LogicalAndOp':
        case 'LogicalOrOp':
          return LogicalOpPatcher;

        case 'LogicalNotOp':
          return LogicalNotOpPatcher;

        case 'SoakedMemberAccessOp':
          return SoakedMemberAccessOpPatcher;

        case 'SoakedDynamicMemberAccessOp':
          return SoakedDynamicMemberAccessOpPatcher;

        case 'ForIn':
          return ForInPatcher;

        case 'ForOf':
          return ForOfPatcher;

        case 'While':
          return WhilePatcher;

        case 'NewOp':
          return NewOpPatcher;

        case 'SoakedNewOp':
          return SoakedNewOpPatcher;

        case 'InOp':
          return InOpPatcher;

        case 'Slice':
          return SlicePatcher;

        case 'SoakedSlice':
          return SoakedSlicePatcher;

        case 'Expansion':
          return ExpansionPatcher;

        case 'Rest':
          return RestPatcher;

        case 'Spread':
          return SpreadPatcher;

        case 'Range':
          return RangePatcher;

        case 'Throw':
          return ThrowPatcher;

        case 'UnaryPlusOp':
        case 'UnaryNegateOp':
        case 'BitNotOp':
          return UnaryMathOpPatcher;

        case 'TypeofOp':
          return UnaryTypeofOpPatcher;

        case 'DeleteOp':
          return UnaryOpPatcher;

        case 'UnaryExistsOp':
          return UnaryExistsOpPatcher;

        case 'ClassProtoAssignOp':
          return ClassAssignOpPatcher;

        case 'Super':
          return SuperPatcher;

        case 'Class':
          return ClassPatcher;

        case 'Constructor':
          return ConstructorPatcher;

        case 'Try':
          return TryPatcher;

        case 'Switch':
          return SwitchPatcher;

        case 'SwitchCase':
          return SwitchCasePatcher;

        case 'DoOp':
          return DoOpPatcher;

        case 'Program':
          return ProgramPatcher;

        case 'InstanceofOp':
          return InstanceofOpPatcher;

        case 'OfOp':
          return OfOpPatcher;

        case 'ChainedComparisonOp':
          return ChainedComparisonOpPatcher;

        case 'SeqOp':
          return SeqOpPatcher;

        case 'JavaScript':
          return JavaScriptPatcher;

        case 'FloorDivideOp':
          return FloorDivideOpPatcher;

        case 'ExpOp':
          return ExpOpPatcher;

        case 'ExtendsOp':
          return ExtendsOpPatcher;

        default:
          return null;
      }
    }
  }]);
  return MainStage;
}(TransformCoffeeScriptStage);

/**
 * Given a list item (i.e. one element of an array literal, object literal,
 * function invocation, etc), run some normalize steps to simplify this type of
 * syntax in the normalize stage.
 */
function normalizeListItem(patcher, listItemPatcher, nextListItemPatcher) {
  // If the last token of the arg is a comma, then the actual delimiter must
  // be a newline and the comma is unnecessary and can cause a syntax error
  // when combined with other normalize stage transformations. So just
  // remove the redundant comma.
  var lastToken = listItemPatcher.lastToken();
  if (lastToken.type === coffeeLex.SourceType.COMMA) {
    patcher.remove(lastToken.start, lastToken.end);
  }
  // CoffeeScript allows semicolon-separated lists, so just change them to
  // commas if we see them.
  var nextToken = listItemPatcher.nextSemanticToken();
  if (nextToken && nextToken.type === coffeeLex.SourceType.SEMICOLON && nextToken.end <= patcher.contentEnd) {
    if (patcherEndsInStatement(listItemPatcher)) {
      patcher.remove(nextToken.start, nextToken.end);
    } else {
      patcher.overwrite(nextToken.start, nextToken.end, ',');
    }
  }

  if (nextListItemPatcher) {
    // We have two adjacent items, so do some cleanups based on the tokens
    // between them (comma tokens, or technically semicolons are treated as
    // commas as well).
    var commaTokens = patcher.getProgramSourceTokens().slice(listItemPatcher.outerEndTokenIndex.next(), nextListItemPatcher.outerStartTokenIndex).filter(function (token) {
      return token.type === coffeeLex.SourceType.COMMA || token.type === coffeeLex.SourceType.SEMICOLON;
    }).toArray();

    // Sometimes other normalize steps can cause two adjacent list items to be
    // reinterpreted as a function call, so put a comma in between them to stop
    // that, but avoid other cases where adding a comma would cause a crash.
    if (nextListItemPatcher.node.type === 'ObjectInitialiser' && !isNestedListItem(listItemPatcher) && commaTokens.length === 0) {
      patcher.insert(listItemPatcher.outerEnd, ',');
    }

    // In some rare cases (when the LHS is an implicit object initializer), the
    // parser allows two commas, so get rid of the second.
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = commaTokens.slice(1)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var extraneousComma = _step.value;

        patcher.remove(extraneousComma.start, extraneousComma.end);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }
}

/**
 * Determine if this node might end in an "unclosed" block. If so, then in some
 * cases, it's not allowed to put a comma at the end of this node, since doing
 * so could cause a parser crash.
 */
function isNestedListItem(patcher) {
  return ['BoundFunction', 'BoundGeneratorFunction', 'Conditional', 'ForIn', 'ForOf', 'Function', 'GeneratorFunction', 'Switch', 'Try', 'While'].indexOf(patcher.node.type) > -1;
}

/**
 * Determine if the given list item ends with a statement. If so, and it's
 * followed by a semicolon, then the semicolon should be seen as part of the
 * statement. The CoffeeScript lexer ignores semicolon tokens early on, so
 * they're not included in the normal statement bounds.
 */
function patcherEndsInStatement(patcher) {
  var found = false;
  traverse(patcher.node, function (child) {
    if (found) {
      return false;
    }
    if (child.type === 'Block' && child.range[1] === patcher.contentEnd) {
      found = true;
    }
  });
  return found;
}

var ArrayInitialiserPatcher$2 = function (_NodePatcher) {
  inherits(ArrayInitialiserPatcher, _NodePatcher);

  function ArrayInitialiserPatcher(patcherContext, members) {
    classCallCheck(this, ArrayInitialiserPatcher);

    var _this = possibleConstructorReturn(this, (ArrayInitialiserPatcher.__proto__ || Object.getPrototypeOf(ArrayInitialiserPatcher)).call(this, patcherContext));

    _this.members = members;
    return _this;
  }

  createClass(ArrayInitialiserPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.members.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = slicedToArray(_step.value, 2),
              i = _step$value[0],
              member = _step$value[1];

          member.patch();
          normalizeListItem(this, member, this.members[i + 1]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);
  return ArrayInitialiserPatcher;
}(NodePatcher);

var BareSuperFunctionApplicationPatcher = function (_NodePatcher) {
  inherits(BareSuperFunctionApplicationPatcher, _NodePatcher);

  function BareSuperFunctionApplicationPatcher() {
    classCallCheck(this, BareSuperFunctionApplicationPatcher);
    return possibleConstructorReturn(this, (BareSuperFunctionApplicationPatcher.__proto__ || Object.getPrototypeOf(BareSuperFunctionApplicationPatcher)).apply(this, arguments));
  }

  createClass(BareSuperFunctionApplicationPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.insert(this.contentEnd, '(arguments...)');
    }
  }]);
  return BareSuperFunctionApplicationPatcher;
}(NodePatcher);

var BlockPatcher$2 = function (_SharedBlockPatcher) {
  inherits(BlockPatcher, _SharedBlockPatcher);

  function BlockPatcher(patcherContext, statements) {
    classCallCheck(this, BlockPatcher);

    var _this = possibleConstructorReturn(this, (BlockPatcher.__proto__ || Object.getPrototypeOf(BlockPatcher)).call(this, patcherContext));

    _this.statements = statements;
    return _this;
  }

  createClass(BlockPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.patchAsStatement();
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      if (this.node.inline) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.statements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var statement = _step.value;

            statement.patch();
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return;
      }

      // Having inconsistent indentation within a block is allowed in some cases
      // when there are implicit function calls, but when function call parens are
      // added, the inconsistent indentation can make the CoffeeScript invalid. So
      // we need to correct any inconsistent indentation in the normalize step so
      // that the result CoffeeScript will always be valid.
      var blockIndentLength = null;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.statements.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _step2$value = slicedToArray(_step2.value, 2),
              i = _step2$value[0],
              _statement = _step2$value[1];

          var indentLength = this.getIndentLength(_statement);
          if (indentLength !== null) {
            if (blockIndentLength === null) {
              blockIndentLength = indentLength;
            } else {
              var charsToRemove = indentLength - blockIndentLength;
              if (charsToRemove < 0) {
                throw this.error('Unexpected statement at an earlier indentation level than an ' + 'earlier statement in the block.');
              }
              if (charsToRemove > 0) {
                this.removePrecedingSpaceChars(_statement.outerStart, charsToRemove);
              }
            }
          }
          _statement.patch();
          if (i < this.statements.length - 1) {
            this.normalizeBetweenStatements(_statement, this.statements[i + 1]);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    /**
     * Get rid of some number of spaces of indentation before this point in the
     * code. We need to be careful to only remove ranges that have not had any
     * inserts yet, since otherwise we might remove other code in addition to the
     * whitespace, or we might remove too much whitespace.
     */

  }, {
    key: 'removePrecedingSpaceChars',
    value: function removePrecedingSpaceChars(index, numToRemove) {
      var numRemaining = numToRemove;
      for (var i = index; numRemaining > 0 && i > 0; i--) {
        var contents = this.slice(i - 1, i);
        if (contents.includes('\n')) {
          throw this.error('Found start of line before removing enough indentation.');
        }
        if (contents === ' ' || contents === '\t') {
          this.remove(i - 1, i);
          numRemaining -= 1;
        }
      }
    }

    /**
     * If this statement starts immediately after its line's initial indentation,
     * return the length of that indentation. Otherwise, return null.
     */

  }, {
    key: 'getIndentLength',
    value: function getIndentLength(statement) {
      var startOfLine = getStartOfLine(this.context.source, statement.outerStart);
      var indentText = this.context.source.slice(startOfLine, statement.outerStart);
      if (/^[ \t]*$/.test(indentText)) {
        return indentText.length;
      } else {
        return null;
      }
    }

    /**
     * Statements can be comma-separated within classes, which is equivalent to
     * semicolons, so just change them to semicolons.
     */

  }, {
    key: 'normalizeBetweenStatements',
    value: function normalizeBetweenStatements(leftStatement, rightStatement) {
      var commaTokenIndex = this.indexOfSourceTokenBetweenPatchersMatching(leftStatement, rightStatement, function (t) {
        return t.type === coffeeLex.SourceType.COMMA;
      });
      if (!commaTokenIndex) {
        return;
      }
      var commaToken = this.sourceTokenAtIndex(commaTokenIndex);
      if (!commaToken) {
        return;
      }
      this.overwrite(commaToken.start, commaToken.end, ';');
    }
  }]);
  return BlockPatcher;
}(SharedBlockPatcher);

var AssignOpPatcher$2 = function (_NodePatcher) {
  inherits(AssignOpPatcher, _NodePatcher);

  function AssignOpPatcher(patcherContext, assignee, expression) {
    classCallCheck(this, AssignOpPatcher);

    var _this = possibleConstructorReturn(this, (AssignOpPatcher.__proto__ || Object.getPrototypeOf(AssignOpPatcher)).call(this, patcherContext, assignee, expression));

    _this.assignee = assignee;
    _this.expression = expression;
    return _this;
  }

  createClass(AssignOpPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.assignee.patch();
      this.removeUnnecessaryThenToken();
      this.expression.patch();
    }

    /**
     * Assignment operators are allowed to have a `then` token after them for some
     * reason, and it doesn't do anything, so just get rid of it.
     */

  }, {
    key: 'removeUnnecessaryThenToken',
    value: function removeUnnecessaryThenToken() {
      var thenIndex = this.indexOfSourceTokenBetweenPatchersMatching(this.assignee, this.expression, function (token) {
        return token.type === coffeeLex.SourceType.THEN;
      });
      if (thenIndex) {
        var thenToken = this.sourceTokenAtIndex(thenIndex);
        if (this.slice(thenToken.start - 1, thenToken.start) === ' ') {
          this.remove(thenToken.start - 1, thenToken.end);
        } else {
          this.remove(thenToken.start, thenToken.end);
        }
      }
    }
  }]);
  return AssignOpPatcher;
}(NodePatcher);

var ConstructorPatcher$2 = function (_PassthroughPatcher) {
  inherits(ConstructorPatcher, _PassthroughPatcher);

  function ConstructorPatcher(patcherContext, assignee, expression) {
    classCallCheck(this, ConstructorPatcher);

    var _this = possibleConstructorReturn(this, (ConstructorPatcher.__proto__ || Object.getPrototypeOf(ConstructorPatcher)).call(this, patcherContext, assignee, expression));

    _this.assignee = assignee;
    _this.expression = expression;
    return _this;
  }

  return ConstructorPatcher;
}(PassthroughPatcher);

var DoOpPatcher$2 = function (_PassthroughPatcher) {
  inherits(DoOpPatcher, _PassthroughPatcher);

  function DoOpPatcher() {
    classCallCheck(this, DoOpPatcher);
    return possibleConstructorReturn(this, (DoOpPatcher.__proto__ || Object.getPrototypeOf(DoOpPatcher)).apply(this, arguments));
  }

  return DoOpPatcher;
}(PassthroughPatcher);

var DefaultParamPatcher$4 = function (_PassthroughPatcher) {
  inherits(DefaultParamPatcher, _PassthroughPatcher);

  function DefaultParamPatcher() {
    classCallCheck(this, DefaultParamPatcher);
    return possibleConstructorReturn(this, (DefaultParamPatcher.__proto__ || Object.getPrototypeOf(DefaultParamPatcher)).apply(this, arguments));
  }

  return DefaultParamPatcher;
}(PassthroughPatcher);

var ObjectInitialiserMemberPatcher$2 = function (_PassthroughPatcher) {
  inherits(ObjectInitialiserMemberPatcher, _PassthroughPatcher);

  function ObjectInitialiserMemberPatcher(patcherContext, key, expression) {
    classCallCheck(this, ObjectInitialiserMemberPatcher);

    var _this = possibleConstructorReturn(this, (ObjectInitialiserMemberPatcher.__proto__ || Object.getPrototypeOf(ObjectInitialiserMemberPatcher)).call(this, patcherContext, key, expression));

    _this.key = key;
    _this.expression = expression;
    return _this;
  }

  return ObjectInitialiserMemberPatcher;
}(PassthroughPatcher);

var MemberAccessOpPatcher$2 = function (_PassthroughPatcher) {
  inherits(MemberAccessOpPatcher, _PassthroughPatcher);

  function MemberAccessOpPatcher() {
    classCallCheck(this, MemberAccessOpPatcher);
    return possibleConstructorReturn(this, (MemberAccessOpPatcher.__proto__ || Object.getPrototypeOf(MemberAccessOpPatcher)).apply(this, arguments));
  }

  createClass(MemberAccessOpPatcher, [{
    key: 'shouldTrimContentRange',
    value: function shouldTrimContentRange() {
      return true;
    }
  }, {
    key: 'patch',
    value: function patch() {
      get(MemberAccessOpPatcher.prototype.__proto__ || Object.getPrototypeOf(MemberAccessOpPatcher.prototype), 'patch', this).call(this);
      var callback = this.findAddThisAssignmentCallback();
      if (callback) {
        var content = this.slice(this.contentStart, this.contentEnd);
        this.overwrite(this.contentStart, this.contentEnd, callback(this.node.member.data, content));
      }
    }
  }, {
    key: 'findAddThisAssignmentCallback',
    value: function findAddThisAssignmentCallback() {
      var patcher = this;

      while (patcher) {
        if (patcher.addThisAssignmentAtScopeHeader) {
          return patcher.addThisAssignmentAtScopeHeader;
        }
        // Don't consider this node if we're on the right side of a default param
        // (e.g. `(foo = @bar) ->`) or if we're on the left side of an object
        // destructure (e.g. the logical `a` key in `({@a}) ->`).
        if (patcher.parent instanceof DefaultParamPatcher$2 && patcher.parent.value === patcher) {
          break;
        }
        if (patcher.parent instanceof ObjectInitialiserMemberPatcher$2 && patcher.parent.key === patcher) {
          break;
        }
        patcher = patcher.parent;
      }
      return null;
    }
  }]);
  return MemberAccessOpPatcher;
}(PassthroughPatcher);

var DefaultParamPatcher$2 = function (_PassthroughPatcher) {
  inherits(DefaultParamPatcher, _PassthroughPatcher);

  function DefaultParamPatcher(patcherContext, param, value) {
    classCallCheck(this, DefaultParamPatcher);

    var _this = possibleConstructorReturn(this, (DefaultParamPatcher.__proto__ || Object.getPrototypeOf(DefaultParamPatcher)).call(this, patcherContext, param, value));

    _this.param = param;
    _this.value = value;
    return _this;
  }

  createClass(DefaultParamPatcher, [{
    key: 'patch',
    value: function patch() {
      // Note that when there is both a `this` assignment and a default param
      // assignment (e.g. `(@a=b()) -> c`), assignment callbacks are run
      // bottom-up, so by the time this code runs, any necessary parameter
      // renaming will have already happened. This means that `paramCode` will
      // naturally have the renamed parameter, so we don't need to do anything
      // special.
      get(DefaultParamPatcher.prototype.__proto__ || Object.getPrototypeOf(DefaultParamPatcher.prototype), 'patch', this).call(this);
      if (this.shouldExtractToConditionalAssign()) {
        var callback = this.findAddDefaultParamAssignmentCallback();
        if (callback) {
          var paramCode = this.slice(this.param.contentStart, this.param.contentEnd);
          var valueCode = this.slice(this.value.contentStart, this.value.contentEnd);
          var assigneeIsValidExpression = this.param instanceof DefaultParamPatcher$4 || this.param instanceof MemberAccessOpPatcher$2;

          var newParamCode = callback(paramCode, valueCode, assigneeIsValidExpression);
          this.overwrite(this.param.contentStart, this.param.contentEnd, newParamCode);
          this.remove(this.param.outerEnd, this.value.outerEnd);
        }
      }
    }
  }, {
    key: 'findAddDefaultParamAssignmentCallback',
    value: function findAddDefaultParamAssignmentCallback() {
      var patcher = this;

      while (patcher) {
        if (patcher.addDefaultParamAssignmentAtScopeHeader) {
          return patcher.addDefaultParamAssignmentAtScopeHeader;
        }
        // Don't consider this node if we're on the right side of another default
        // param (e.g. `(foo = (bar=3) ->) ->`).
        if (patcher.parent instanceof DefaultParamPatcher && patcher.parent.value === patcher) {
          break;
        }
        patcher = patcher.parent;
      }
      return null;
    }

    /**
     * For correctness reasons, we usually need to extract the assignment into a
     * statement that checks null and undefined rather than just undefined. But
     * skip that step if the user opted out of it in favor of cleaner code, and
     * also in a case like `do (a=1) -> a`, which is handled later as a special
     * case and doesn't use JS default params.
     */

  }, {
    key: 'shouldExtractToConditionalAssign',
    value: function shouldExtractToConditionalAssign() {
      if (this.options.looseDefaultParams) {
        return false;
      }
      if (this.parent instanceof FunctionPatcher$2 && this.parent.parent instanceof DoOpPatcher$2) {
        return false;
      }
      if (this.parent instanceof FunctionPatcher$2 && this.parent.parent instanceof AssignOpPatcher$2 && this.parent.parent.parent instanceof DoOpPatcher$2) {
        return false;
      }
      return true;
    }
  }]);
  return DefaultParamPatcher;
}(PassthroughPatcher);

var ExpansionPatcher$2 = function (_PassthroughPatcher) {
  inherits(ExpansionPatcher, _PassthroughPatcher);

  function ExpansionPatcher() {
    classCallCheck(this, ExpansionPatcher);
    return possibleConstructorReturn(this, (ExpansionPatcher.__proto__ || Object.getPrototypeOf(ExpansionPatcher)).apply(this, arguments));
  }

  return ExpansionPatcher;
}(PassthroughPatcher);

var SpreadPatcher$2 = function (_PassthroughPatcher) {
  inherits(SpreadPatcher, _PassthroughPatcher);

  function SpreadPatcher(patcherContext, expression) {
    classCallCheck(this, SpreadPatcher);

    var _this = possibleConstructorReturn(this, (SpreadPatcher.__proto__ || Object.getPrototypeOf(SpreadPatcher)).call(this, patcherContext, expression));

    _this.expression = expression;
    return _this;
  }

  return SpreadPatcher;
}(PassthroughPatcher);

var FunctionPatcher$2 = function (_NodePatcher) {
  inherits(FunctionPatcher, _NodePatcher);

  function FunctionPatcher(patcherContext, parameters, body) {
    classCallCheck(this, FunctionPatcher);

    var _this = possibleConstructorReturn(this, (FunctionPatcher.__proto__ || Object.getPrototypeOf(FunctionPatcher)).call(this, patcherContext));

    _this.parameters = parameters;
    _this.body = body;
    return _this;
  }

  createClass(FunctionPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      // Make sure there is at least one character of whitespace between the ->
      // and the body, since otherwise the main stage can run into subtle
      // magic-string issues later.
      if (this.body && !this.slice(this.body.contentStart - 1, this.body.contentStart).match(/\s/)) {
        this.insert(this.body.contentStart, ' ');
      }

      var firstRestParamIndex = this.getFirstRestParamIndex();
      var assignments = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.parameters.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = slicedToArray(_step.value, 2),
              i = _step$value[0],
              parameter = _step$value[1];

          if (firstRestParamIndex === -1 || i < firstRestParamIndex) {
            assignments.push.apply(assignments, toConsumableArray(this.patchParameterAndGetAssignments(parameter)));
          } else {
            parameter.patch();
          }
          normalizeListItem(this, parameter, this.parameters[i + 1]);
          if (i === this.parameters.length - 1) {
            // Parameter lists allow trailing semicolons but not trailing commas, so
            // just get rid of it as a special case if it's there.
            var nextToken = parameter.nextSemanticToken();
            if (nextToken && nextToken.type === coffeeLex.SourceType.SEMICOLON) {
              this.remove(nextToken.start, nextToken.end);
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (firstRestParamIndex !== -1) {
        if (firstRestParamIndex === this.parameters.length - 1 && this.parameters[this.parameters.length - 1] instanceof ExpansionPatcher$2) {
          // Just get rid of the ... at the end if it's there.
          if (firstRestParamIndex === 0) {
            this.remove(this.parameters[0].contentStart, this.parameters[0].contentEnd);
          } else {
            this.remove(this.parameters[firstRestParamIndex - 1].outerEnd, this.parameters[this.parameters.length - 1].outerEnd);
          }
        } else {
          // Move expansion or intermediate rest params into an array destructure
          // on the first line.
          var candidateName = firstRestParamIndex === 0 ? 'args' : 'rest';
          var paramName = this.claimFreeBinding(candidateName);
          var restParamsStart = this.parameters[firstRestParamIndex].contentStart;
          var restParamsEnd = this.parameters[this.parameters.length - 1].contentEnd;
          var paramCode = this.slice(restParamsStart, restParamsEnd);
          paramCode = this.fixGeneratedAssigneeWhitespace(paramCode);
          this.overwrite(restParamsStart, restParamsEnd, paramName + '...');
          assignments.push('[' + paramCode + '] = ' + paramName);
        }
      }

      // If there were assignments from parameters insert them
      if (this.body) {
        // before the actual body
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = assignments[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var assignment = _step2.value;

            this.body.insertLineBefore(assignment);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        this.body.patch();
      } else if (assignments.length) {
        // as the body if there is no body
        // Add a return statement for non-constructor methods without body to avoid bad implicit return
        if (this.node.parentNode.type !== 'Constructor') {
          assignments.push('return');
        }
        var indent = this.getIndent(1);
        var text = assignments.join('\n' + indent);
        this.insert(this.contentEnd, '\n' + indent + text);
      }
    }
  }, {
    key: 'patchParameterAndGetAssignments',
    value: function patchParameterAndGetAssignments(parameter) {
      var _this2 = this;

      var thisAssignments = [];
      var defaultParamAssignments = [];

      // To avoid knowledge of all the details how assignments can be nested in nodes,
      // we add a callback to the function node before patching the parameters and remove it afterwards.
      // This is detected and used by the MemberAccessOpPatcher to claim a free binding for this parameter
      // (from the functions scope, not the body's scope)
      this.addThisAssignmentAtScopeHeader = function (memberName) {
        var varName = _this2.claimFreeBinding(memberName);
        thisAssignments.push('@' + memberName + ' = ' + varName);
        _this2.log('Replacing parameter @' + memberName + ' with ' + varName);
        return varName;
      };
      this.addDefaultParamAssignmentAtScopeHeader = function (assigneeCode, initCode, assigneeIsValidExpression) {
        if (assigneeIsValidExpression) {
          // Wrap in parens to avoid precedence issues for inline statements. The
          // parens will be removed later in normal situations.
          defaultParamAssignments.push('(' + assigneeCode + ' ?= ' + initCode + ')');
          return assigneeCode;
        } else {
          // Handle cases like `({a}={}) ->`, where we need to check for default
          // with the param as a normal variable, then include the destructure.
          assigneeCode = _this2.fixGeneratedAssigneeWhitespace(assigneeCode);
          var paramName = _this2.claimFreeBinding('param');
          defaultParamAssignments.push('(' + paramName + ' ?= ' + initCode + ')');
          defaultParamAssignments.push(assigneeCode + ' = ' + paramName);
          return paramName;
        }
      };

      parameter.patch();

      delete this.addDefaultParamAssignmentAtScopeHeader;
      delete this.addThisAssignmentAtScopeHeader;

      return [].concat(defaultParamAssignments, thisAssignments);
    }

    /**
     * If the assignee in a generated code is multiline and we're not careful, we
     * might end up placing code before the function body indentation level, which
     * will make the CoffeeScript parser complain later. To fix, adjust the
     * indentation to the desired level. Note that this potentially could add
     * whitespace to multiline strings, but all types of multiline strings in
     * CoffeeScript strip common leading whitespace, so the resulting code is
     * still the same.
     */

  }, {
    key: 'fixGeneratedAssigneeWhitespace',
    value: function fixGeneratedAssigneeWhitespace(assigneeCode) {
      var firstNewlineIndex = assigneeCode.indexOf('\n');
      if (firstNewlineIndex < 0) {
        return assigneeCode;
      }
      var indent = this.body ? this.body.getIndent(0) : this.getIndent(1);
      var firstLine = assigneeCode.substr(0, firstNewlineIndex);
      var otherLines = assigneeCode.substr(firstNewlineIndex + 1);
      otherLines = stripSharedIndent(otherLines);
      otherLines = otherLines.replace(/\n/g, '\n' + indent);
      return firstLine + '\n' + indent + otherLines;
    }

    /**
     * Get the index of the first parameter that will be included in the rest
     * parameters (if any). All parameters from this point forward will be moved
     * to an array destructure at the start of the function.
     *
     * The main stage handles the fully general case for array destructuring,
     * including things like nested expansions and defaults, so anything requiring
     * that level of generality should be extracted to an array destructure.
     * Simpler cases that only use param defaults and this-assignment are better
     * off being handled as normal parameters if we can get away with it. Also,
     * any array destructure in a parameter needs to be extracted so that we can
     * properly wrap it in Array.from.
     */

  }, {
    key: 'getFirstRestParamIndex',
    value: function getFirstRestParamIndex() {
      for (var i = 0; i < this.parameters.length; i++) {
        var parameter = this.parameters[i];

        // We have separate code to handle relatively simple default params that
        // results in better code, so use that.
        if (parameter instanceof DefaultParamPatcher$2 && canPatchAssigneeToJavaScript(parameter.param.node)) {
          continue;
        }

        // A rest assignment at the very end can be converted correctly as long as
        // it does not expand the rest array in a complicated way.
        if (i === this.parameters.length - 1 && parameter instanceof SpreadPatcher$2 && parameter.expression instanceof DefaultParamPatcher$4) {
          continue;
        }

        if (parameter instanceof ArrayInitialiserPatcher$2 || !canPatchAssigneeToJavaScript(parameter.node)) {
          return i;
        }
      }
      return -1;
    }
  }]);
  return FunctionPatcher;
}(NodePatcher);

var ProgramPatcher$3 = function (_SharedProgramPatcher) {
  inherits(ProgramPatcher, _SharedProgramPatcher);

  function ProgramPatcher() {
    classCallCheck(this, ProgramPatcher);
    return possibleConstructorReturn(this, (ProgramPatcher.__proto__ || Object.getPrototypeOf(ProgramPatcher)).apply(this, arguments));
  }

  createClass(ProgramPatcher, [{
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      if (this.body) {
        this.body.patch();
      }
      this.patchHelpers();
    }
  }]);
  return ProgramPatcher;
}(ProgramPatcher$2);

var ClassPatcher$2 = function (_NodePatcher) {
  inherits(ClassPatcher, _NodePatcher);

  function ClassPatcher(patcherContext, nameAssignee, parent, body) {
    classCallCheck(this, ClassPatcher);

    var _this = possibleConstructorReturn(this, (ClassPatcher.__proto__ || Object.getPrototypeOf(ClassPatcher)).call(this, patcherContext));

    _this.nameAssignee = nameAssignee;
    _this.superclass = parent;
    _this.body = body;
    return _this;
  }

  /**
   * Handle code within class bodies by restructuring the class to use a static
   * method instead.
   *
   * Current limitations:
   * - Doesn't deconflict the "initClass" name of the static method.
   * - Technically this changes the execution order of the class body, although
   *   it does so in a way that is unlikely to cause problems in reasonable
   *   code.
   */


  createClass(ClassPatcher, [{
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      // Indentation needs to happen before child patching in case we have child
      // classes or other nested indentation situations.
      if (this.needsIndent()) {
        this.indent(1, { skipFirstLine: true });
      }
      var indent = this.getIndent();

      if (this.nameAssignee) {
        this.nameAssignee.patch();
      }
      if (this.superclass) {
        this.superclass.patch();
      }
      if (this.body) {
        this.body.patch();
      }

      this.removeThenTokenIfNecessary();

      if (!this.needsInitClass()) {
        return;
      }

      var insertPoint = this.getInitClassInsertPoint();
      var nonMethodPatchers = this.getNonMethodPatchers();
      var customConstructorInfo = this.extractCustomConstructorInfo();

      var shouldUseIIFE = this.shouldUseIIFE();

      if (shouldUseIIFE) {
        // If the class declaration might introduce a variable, we need to make
        // sure that assignment happens outside the IIFE so that it can be used
        // by the outside world.
        if (this.nameAssignee instanceof DefaultParamPatcher$4) {
          this.insert(this.outerStart, this.nameAssignee.node.data + ' = ');
        }
        this.insert(this.outerStart, 'do ->\n' + indent);
      }

      var needsTmpName = !(this.nameAssignee instanceof DefaultParamPatcher$4);
      var classRef = void 0;
      if (needsTmpName) {
        classRef = this.claimFreeBinding('Cls');
      } else {
        classRef = this.nameAssignee.node.data;
      }

      var assignmentNames = this.generateInitClassMethod(nonMethodPatchers, customConstructorInfo, insertPoint);
      this.insert(this.outerEnd, '\n' + indent + classRef + '.initClass()');
      if (shouldUseIIFE) {
        this.insert(this.outerEnd, '\n' + indent + 'return ' + classRef);
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = assignmentNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var assignmentName = _step.value;

          this.insert(this.outerStart, assignmentName + ' = undefined\n' + indent);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (needsTmpName) {
        this.insert(this.outerStart, classRef + ' = ');
      }
    }

    /**
     * For now, code in class bodies is only supported for statement classes.
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.body.patch();
    }
  }, {
    key: 'needsIndent',
    value: function needsIndent() {
      return this.needsInitClass() && this.shouldUseIIFE();
    }
  }, {
    key: 'needsInitClass',
    value: function needsInitClass() {
      if (!this.body) {
        return false;
      }
      if (this.body.statements.length === 0) {
        return false;
      }

      var nonMethodPatchers = this.getNonMethodPatchers();

      if (nonMethodPatchers.length === 0 && !this.needsCustomConstructor()) {
        return false;
      }
      return true;
    }
  }, {
    key: 'removeThenTokenIfNecessary',
    value: function removeThenTokenIfNecessary() {
      var searchStart = void 0;
      if (this.superclass) {
        searchStart = this.superclass.outerEnd;
      } else if (this.nameAssignee) {
        searchStart = this.nameAssignee.outerEnd;
      } else {
        searchStart = this.contentStart;
      }
      var searchEnd = void 0;
      if (this.body) {
        searchEnd = this.body.outerStart;
      } else {
        searchEnd = this.contentEnd;
      }
      var index = this.indexOfSourceTokenBetweenSourceIndicesMatching(searchStart, searchEnd, function (token) {
        return token.type === coffeeLex.SourceType.THEN;
      });
      if (index) {
        this.overwrite(searchStart, searchEnd, '\n' + this.getIndent(1));
      }
    }
  }, {
    key: 'shouldUseIIFE',
    value: function shouldUseIIFE() {
      var nonMethodPatchers = this.getNonMethodPatchers();
      if (this.hasAnyAssignments(nonMethodPatchers)) {
        return true;
      }
      // It's safe to use the more straightforward class init approach as long as
      // we know that a statement can be added after us and we're not in an
      // implicit return position.
      if (this.parent instanceof BlockPatcher$2) {
        var statements = this.parent.statements;

        if (!(this.parent.parent instanceof ProgramPatcher$3) && this === statements[statements.length - 1]) {
          return true;
        }
        return false;
      }
      return true;
    }
  }, {
    key: 'getInitClassInsertPoint',
    value: function getInitClassInsertPoint() {
      if (this.superclass) {
        return this.superclass.outerEnd;
      }
      if (this.nameAssignee) {
        return this.nameAssignee.outerEnd;
      }
      return this.firstToken().end;
    }

    /**
     * Find the statements in the class body that can't be converted to JS
     * methods. These will later be moved to the top of the class in a static
     * method.
     */

  }, {
    key: 'getNonMethodPatchers',
    value: function getNonMethodPatchers() {
      var nonMethodPatchers = [];
      var deleteStart = this.getInitClassInsertPoint();
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.body.statements[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var patcher = _step2.value;

          if (!this.isClassMethod(patcher)) {
            nonMethodPatchers.push({
              patcher: patcher,
              deleteStart: deleteStart
            });
          }
          deleteStart = patcher.outerEnd;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return nonMethodPatchers;
    }
  }, {
    key: 'isClassMethod',
    value: function isClassMethod(patcher) {
      if (patcher instanceof ConstructorPatcher$2) {
        return true;
      }
      if (this.isClassAssignment(patcher.node)) {
        if (patcher.expression instanceof FunctionPatcher$2) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: 'isClassAssignment',
    value: function isClassAssignment(node) {
      if (node.type === 'ClassProtoAssignOp') {
        return true;
      }
      if (node.type === 'AssignOp') {
        var assignee = node.assignee;

        if (assignee.type === 'MemberAccessOp') {
          if (assignee.expression.type === 'This') {
            return true;
          }
          if (this.nameAssignee) {
            var className = this.nameAssignee.node.data;
            if (assignee.expression.type === 'Identifier' && assignee.expression.data === className) {
              return true;
            }
          }
        }
      }
      return false;
    }
  }, {
    key: 'needsCustomConstructor',
    value: function needsCustomConstructor() {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.body.statements[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var patcher = _step3.value;

          if (patcher instanceof ConstructorPatcher$2 && !(patcher.expression instanceof FunctionPatcher$2)) {
            return true;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return false;
    }

    /**
     * Constructors in CoffeeScript can be arbitrary expressions, so if that's the
     * case, we need to save that expression so we can compute it at class init
     * time and call it from the real constructor. If this is such a case, pick a
     * name for the constructor, get the code to evaluate the constructor
     * function, and overwrite the constructor with a function that forwards to
     * that constructor function.
     */

  }, {
    key: 'extractCustomConstructorInfo',
    value: function extractCustomConstructorInfo() {
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this.body.statements[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var patcher = _step4.value;

          if (patcher instanceof ConstructorPatcher$2) {
            if (!(patcher.expression instanceof FunctionPatcher$2)) {
              var expressionCode = this.slice(patcher.expression.contentStart, patcher.expression.contentEnd);
              var ctorName = void 0;
              if (this.nameAssignee instanceof DefaultParamPatcher$4) {
                var className = this.nameAssignee.node.data;
                ctorName = this.claimFreeBinding('create' + className);
              } else {
                ctorName = this.claimFreeBinding('createInstance');
              }

              var bodyIndent = this.getBodyIndent();
              var indentString = this.getProgramIndentString();

              this.overwrite(patcher.expression.outerStart, patcher.expression.outerEnd, '->\n' + bodyIndent + indentString + 'return ' + ctorName + '.apply(this, arguments)');

              return {
                ctorName: ctorName,
                expressionCode: expressionCode
              };
            }
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return null;
    }

    /**
     * Create the initClass static method by moving nodes from the class body into
     * the static method and indenting them one level.
     *
     * Also return an array of variables that were assigned so that later code can
     * declare them outside the class body to make them accessible within the
     * class.
     */

  }, {
    key: 'generateInitClassMethod',
    value: function generateInitClassMethod(nonMethodPatchers, customConstructorInfo, insertPoint) {
      var bodyIndent = this.getBodyIndent();
      var indentString = this.getProgramIndentString();
      this.insert(insertPoint, '\n' + bodyIndent + '@initClass: ->');
      var assignmentNames = [];
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = nonMethodPatchers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _step5$value = _step5.value,
              patcher = _step5$value.patcher,
              deleteStart = _step5$value.deleteStart;

          var assignmentName = this.getAssignmentName(patcher);
          if (assignmentName) {
            assignmentNames.push(assignmentName);
          }
          var statementCode = this.getNonMethodStatementCode(patcher, deleteStart);
          statementCode = statementCode.replace(/\n/g, '\n' + indentString);
          this.insert(insertPoint, statementCode);
          this.remove(deleteStart, patcher.outerEnd);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      if (customConstructorInfo) {
        var ctorName = customConstructorInfo.ctorName,
            expressionCode = customConstructorInfo.expressionCode;

        this.insert(insertPoint, '\n' + bodyIndent + indentString + ctorName + ' = ' + expressionCode);
        assignmentNames.push(ctorName);
      }

      this.insert(insertPoint, '\n' + bodyIndent + indentString + 'return');
      return assignmentNames;
    }
  }, {
    key: 'hasAnyAssignments',
    value: function hasAnyAssignments(nonMethodPatchers) {
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = nonMethodPatchers[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var patcher = _step6.value.patcher;

          if (this.getAssignmentName(patcher)) {
            return true;
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return false;
    }
  }, {
    key: 'getBodyIndent',
    value: function getBodyIndent() {
      var bodyNodeIndent = this.body.getIndent();
      // If the body is inline, generate code at one indent level up instead of
      // at the class indentation level.
      if (bodyNodeIndent === this.getIndent()) {
        return this.getIndent(1);
      } else {
        return bodyNodeIndent;
      }
    }

    /**
     * Determine the variable assigned in the given statement, if any, since any
     * assigned variables need to be declared externally so they are available
     * within the class body. Note that this is incomplete at the moment and only
     * covers the common case of a single variable being defined.
     */

  }, {
    key: 'getAssignmentName',
    value: function getAssignmentName(statementPatcher) {
      if (statementPatcher.node.type === 'AssignOp' && statementPatcher.assignee instanceof DefaultParamPatcher$4) {
        return statementPatcher.node.assignee.data;
      }
      if (statementPatcher instanceof ClassPatcher && statementPatcher.nameAssignee instanceof DefaultParamPatcher$4) {
        return statementPatcher.nameAssignee.node.data;
      }
      return null;
    }
  }, {
    key: 'getNonMethodStatementCode',
    value: function getNonMethodStatementCode(statementPatcher, deleteStart) {
      if (statementPatcher instanceof AssignOpPatcher$2 && this.isClassAssignment(statementPatcher.node)) {
        var assignee = statementPatcher.assignee,
            expression = statementPatcher.expression;

        var prefixCode = this.slice(deleteStart, assignee.outerStart);
        var keyCode = this.slice(assignee.outerStart, assignee.outerEnd);
        var suffixCode = this.slice(assignee.outerEnd, expression.outerEnd);

        var equalIndex = suffixCode.indexOf('=');
        var colonIndex = suffixCode.indexOf(':');
        if (equalIndex === -1 || colonIndex < equalIndex) {
          suffixCode = suffixCode.replace(/:/, ' =');
        }

        if (statementPatcher.node.type === 'ClassProtoAssignOp') {
          // a: b -> @prototype.a = b
          return prefixCode + '@prototype.' + keyCode + suffixCode;
        } else {
          // @a: b -> @a = b
          return '' + prefixCode + keyCode + suffixCode;
        }
      } else {
        return this.slice(deleteStart, statementPatcher.outerEnd);
      }
    }
  }]);
  return ClassPatcher;
}(NodePatcher);

/**
 * Rewriting a postfix if/while/for will fail if any intermediate expressions
 * use `then` or contain a newline. In both cases, surrounding the expression in
 * parens is enough to rearrange the code without introducing a parse error.
 */
/**
 * Rewriting a postfix if/while/for will fail if any intermediate expressions
 * use `then` or contain a newline. In both cases, surrounding the expression in
 * parens is enough to rearrange the code without introducing a parse error.
 */function postfixExpressionRequiresParens(exprCode) {
  return exprCode.includes('then') || exprCode.includes('\n');
}

/**
 * Determine if the given postfix if/while/for needs to have parens wrapped
 * around it while it is reordered. This happens when the expression has a comma
 * after it as part of a list (function args, array initializer, or object
 * initializer). It also happens when there is a semicolong immediately
 * afterward, since without the parens the next statement would be pulled into
 * the block.
 */
function postfixNodeNeedsOuterParens(patcher) {
  var nextToken = patcher.nextSemanticToken();
  if (nextToken) {
    return nextToken.type === coffeeLex.SourceType.COMMA || nextToken.type === coffeeLex.SourceType.SEMICOLON;
  }
  return false;
}

/**
 * Normalizes conditionals by rewriting post-`if` into standard `if`, e.g.
 *
 *   return [] unless list?
 *
 * becomes
 *
 *   unless list? then return []
 */
var ConditionalPatcher$2 = function (_NodePatcher) {
  inherits(ConditionalPatcher, _NodePatcher);

  function ConditionalPatcher(patcherContext, condition, consequent, alternate) {
    classCallCheck(this, ConditionalPatcher);

    var _this = possibleConstructorReturn(this, (ConditionalPatcher.__proto__ || Object.getPrototypeOf(ConditionalPatcher)).call(this, patcherContext));

    _this.condition = condition;
    _this.consequent = consequent;
    _this.alternate = alternate;
    return _this;
  }

  createClass(ConditionalPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      if (this.isPostIf()) {
        this.patchPostIf();
      } else {
        this.condition.patch();
        if (this.consequent !== null) {
          this.consequent.patch();
        }
        if (this.alternate !== null) {
          this.alternate.patch();
        }
      }
    }

    /**
     * `CONSEQUENT 'if' CONDITION` → `if CONDITION then CONSEQUENT`
     * `CONSEQUENT 'unless' CONDITION` → `unless CONDITION then CONSEQUENT`
     */

  }, {
    key: 'patchPostIf',
    value: function patchPostIf() {
      this.condition.patch();
      if (postfixExpressionRequiresParens(this.slice(this.condition.contentStart, this.condition.contentEnd)) && !this.condition.isSurroundedByParentheses()) {
        this.condition.surroundInParens();
      }

      var ifTokenIndex = this.getIfTokenIndex();
      var ifToken = this.sourceTokenAtIndex(ifTokenIndex);
      if (!ifToken) {
        throw this.error('Unable to find `if` token.');
      }

      var needsParens = postfixNodeNeedsOuterParens(this);
      var ifAndConditionCode = this.slice(ifToken.start, this.condition.outerEnd);
      if (needsParens) {
        this.insert(this.consequent.outerStart, '(');
      }
      this.insert(this.consequent.outerStart, ifAndConditionCode + ' then ');
      this.consequent.patch();
      if (needsParens) {
        this.insert(this.consequent.outerEnd, ')');
      }
      this.remove(this.consequent.outerEnd, this.contentEnd);
    }
  }, {
    key: 'isPostIf',
    value: function isPostIf() {
      return this.consequent !== null && this.condition.contentStart > this.consequent.contentStart;
    }
  }, {
    key: 'getIfTokenIndex',
    value: function getIfTokenIndex() {
      var start = this.contentStartTokenIndex;
      var index = this.condition.outerStartTokenIndex;

      while (index !== start) {
        var token = this.sourceTokenAtIndex(index);
        if (token && token.type === coffeeLex.SourceType.IF) {
          break;
        }
        index = index.previous();
      }

      if (!index) {
        throw this.error('unable to find `if` token in conditional');
      }

      return index;
    }
  }]);
  return ConditionalPatcher;
}(NodePatcher);

var ForPatcher$2 = function (_NodePatcher) {
  inherits(ForPatcher, _NodePatcher);

  function ForPatcher(patcherContext, keyAssignee, valAssignee, target, filter, body) {
    classCallCheck(this, ForPatcher);

    var _this = possibleConstructorReturn(this, (ForPatcher.__proto__ || Object.getPrototypeOf(ForPatcher)).call(this, patcherContext));

    _this.keyAssignee = keyAssignee;
    _this.valAssignee = valAssignee;
    _this.target = target;
    _this.filter = filter;
    _this.body = body;
    return _this;
  }

  createClass(ForPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var bodyPrefixLine = null;
      if (this.keyAssignee) {
        // The key assignee can't be a complex expression, so we don't need to
        // worry about checking canPatchAssigneeToJavaScript.
        this.keyAssignee.patch();
      }
      if (this.valAssignee) {
        bodyPrefixLine = this.patchValAssignee();
      }
      this.target.patch();
      if (this.filter) {
        this.filter.patch();
      }

      if (this.isPostFor()) {
        this.surroundThenUsagesInParens();
        var forToken = this.getForToken();
        var forThroughEnd = this.slice(forToken.start, this.contentEnd);

        var needsParens = postfixNodeNeedsOuterParens(this);
        this.remove(this.body.outerEnd, this.contentEnd);
        if (needsParens) {
          this.insert(this.body.outerStart, '(');
        }
        this.insert(this.body.outerStart, forThroughEnd + ' then ');
        if (needsParens) {
          this.insert(this.contentEnd, ')');
        }
      }

      if (bodyPrefixLine !== null) {
        this.body.insertLineBefore(bodyPrefixLine);
      }
      this.body.patch();
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      this.patchAsExpression();
    }

    /**
     * Patch the value assignee, and if we need to add a line to the start of the
     * body, return that line. Otherwise, return null.
     */

  }, {
    key: 'patchValAssignee',
    value: function patchValAssignee() {
      if (canPatchAssigneeToJavaScript(this.valAssignee.node)) {
        this.valAssignee.patch();
        return null;
      } else {
        var assigneeName = this.claimFreeBinding('value');
        var assigneeCode = this.valAssignee.patchAndGetCode();
        this.overwrite(this.valAssignee.contentStart, this.valAssignee.contentEnd, assigneeName);
        return assigneeCode + ' = ' + assigneeName;
      }
    }

    /**
     * @private
     */

  }, {
    key: 'isPostFor',
    value: function isPostFor() {
      return this.body.contentStart < this.target.contentStart;
    }

    /**
     * Defensively wrap expressions in parens if they might contain a `then`
     * token, since that would mess up the parsing when we rearrange the for loop.
     *
     * This method can be subclassed to account for additional fields.
     */

  }, {
    key: 'surroundThenUsagesInParens',
    value: function surroundThenUsagesInParens() {
      if (postfixExpressionRequiresParens(this.slice(this.target.contentStart, this.target.contentEnd))) {
        this.target.surroundInParens();
      }
      if (this.filter && postfixExpressionRequiresParens(this.slice(this.filter.contentStart, this.filter.contentEnd))) {
        this.filter.surroundInParens();
      }
    }

    /**
     * @private
     */

  }, {
    key: 'getForToken',
    value: function getForToken() {
      if (this.isPostFor()) {
        var afterForToken = this.getFirstHeaderPatcher();
        var index = this.indexOfSourceTokenBetweenPatchersMatching(this.body, afterForToken, function (token) {
          return token.type === coffeeLex.SourceType.FOR;
        });

        if (!index) {
          throw this.error('cannot find \'for\' token in loop');
        }

        return this.sourceTokenAtIndex(index);
      } else {
        var token = this.sourceTokenAtIndex(this.contentStartTokenIndex);

        if (!token || token.type !== coffeeLex.SourceType.FOR) {
          throw this.error('expected \'for\' at start of loop');
        }

        return token;
      }
    }

    /**
     * @private
     */

  }, {
    key: 'getFirstHeaderPatcher',
    value: function getFirstHeaderPatcher() {
      var candidates = [this.keyAssignee, this.valAssignee, this.target];
      var result = null;
      candidates.forEach(function (candidate) {
        if (!candidate) {
          return;
        }
        if (result === null || candidate.contentStart < result.contentStart) {
          result = candidate;
        }
      });
      if (result === null) {
        throw this.error('cannot get first patcher of \'for\' loop header');
      }
      return result;
    }
  }]);
  return ForPatcher;
}(NodePatcher);

var ForInPatcher$2 = function (_ForPatcher) {
  inherits(ForInPatcher, _ForPatcher);

  function ForInPatcher(patcherContext, keyAssignee, valAssignee, target, step, filter, body) {
    classCallCheck(this, ForInPatcher);

    var _this = possibleConstructorReturn(this, (ForInPatcher.__proto__ || Object.getPrototypeOf(ForInPatcher)).call(this, patcherContext, keyAssignee, valAssignee, target, filter, body));

    _this.step = step;
    return _this;
  }

  createClass(ForInPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      if (this.step) {
        this.step.patch();
      }
      get(ForInPatcher.prototype.__proto__ || Object.getPrototypeOf(ForInPatcher.prototype), 'patchAsExpression', this).call(this);
    }
  }, {
    key: 'surroundThenUsagesInParens',
    value: function surroundThenUsagesInParens() {
      if (this.step && postfixExpressionRequiresParens(this.slice(this.step.contentStart, this.step.contentEnd))) {
        this.step.surroundInParens();
      }
      get(ForInPatcher.prototype.__proto__ || Object.getPrototypeOf(ForInPatcher.prototype), 'surroundThenUsagesInParens', this).call(this);
    }
  }]);
  return ForInPatcher;
}(ForPatcher$2);

var ForOfPatcher$2 = function (_ForPatcher) {
  inherits(ForOfPatcher, _ForPatcher);

  function ForOfPatcher() {
    classCallCheck(this, ForOfPatcher);
    return possibleConstructorReturn(this, (ForOfPatcher.__proto__ || Object.getPrototypeOf(ForOfPatcher)).apply(this, arguments));
  }

  return ForOfPatcher;
}(ForPatcher$2);

var FunctionApplicationPatcher$2 = function (_NodePatcher) {
  inherits(FunctionApplicationPatcher, _NodePatcher);

  function FunctionApplicationPatcher(patcherContext, fn, args) {
    classCallCheck(this, FunctionApplicationPatcher);

    var _this = possibleConstructorReturn(this, (FunctionApplicationPatcher.__proto__ || Object.getPrototypeOf(FunctionApplicationPatcher)).call(this, patcherContext));

    _this.fn = fn;
    _this.args = args;
    return _this;
  }

  createClass(FunctionApplicationPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var implicitCall = this.isImplicitCall();
      var args = this.args;


      this.fn.patch();

      if (implicitCall) {
        var firstArg = args[0];
        var firstArgIsOnNextLine = !firstArg ? false : /\n/.test(this.context.source.slice(this.fn.outerEnd, firstArg.outerStart));
        var funcEnd = this.getFuncEnd();
        if (firstArgIsOnNextLine) {
          this.insert(funcEnd, '(');
        } else {
          this.overwrite(funcEnd, firstArg.outerStart, '(');
        }
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = args.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = slicedToArray(_step.value, 2),
              i = _step$value[0],
              arg = _step$value[1];

          arg.patch();
          normalizeListItem(this, arg, args[i + 1]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (implicitCall) {
        this.insertImplicitCloseParen();
      }
    }

    /**
     * We need to be careful when inserting the close-paren after a function call,
     * since an incorrectly-placed close-paren can cause a parsing error in the
     * MainStage due to subtle indentation rules in the CoffeeScript parser.
     *
     * In particular, we prefer to place the close paren after an existing } or ],
     * or before an existing ), if we can, since that is least likely to confuse
     * any indentation parsing. But in some cases it's best to instead insert the
     * close-paren properly-indented on its own line.
     */

  }, {
    key: 'insertImplicitCloseParen',
    value: function insertImplicitCloseParen() {
      var argListCode = this.slice(this.args[0].contentStart, this.args[this.args.length - 1].contentEnd);
      var isArgListMultiline = argListCode.indexOf('\n') !== -1;
      var lastTokenType = this.lastToken().type;
      if (!isArgListMultiline || lastTokenType === coffeeLex.SourceType.RBRACE || lastTokenType === coffeeLex.SourceType.RBRACKET) {
        this.insert(this.contentEnd, ')');
        return;
      }

      var followingCloseParen = this.getFollowingCloseParenIfExists();
      if (followingCloseParen) {
        // In some cases, (e.g. within function args) our bounds are extended to
        // allow us to patch the close-paren all the way up to the start of the
        // following close-paren, but don't patch past the end of those bounds.
        this.insert(Math.min(followingCloseParen.start, this.getMaxCloseParenInsertPoint()), ')');
        return;
      }

      var args = this.args;

      var lastArg = args[args.length - 1];
      if (lastArg.isMultiline()) {
        // The CoffeeScript compiler will sometimes reject `.` that is starting a
        // new line following a `)` token. Also, in some cases, it will complain
        // about an indentation error if the `)` is too far indented. So handle
        // this case by moving the `.` to be right after the new `)`.
        var nextSemanticToken = this.getFirstSemanticToken(this.contentEnd);
        if (nextSemanticToken && nextSemanticToken.type === coffeeLex.SourceType.DOT) {
          this.overwrite(this.outerEnd, nextSemanticToken.start, ')');
        } else {
          this.insert(this.contentEnd, '\n' + this.getIndent() + ')');
        }
        return;
      }

      this.insert(this.contentEnd, ')');
    }
  }, {
    key: 'getFollowingCloseParenIfExists',
    value: function getFollowingCloseParenIfExists() {
      var tokenIndex = this.contentEndTokenIndex;
      var token = void 0;
      do {
        tokenIndex = tokenIndex.next();
        if (tokenIndex === null) {
          return null;
        }
        token = this.sourceTokenAtIndex(tokenIndex);
        if (token === null) {
          return null;
        }
      } while (token.type === coffeeLex.SourceType.NEWLINE);

      if (token.type === coffeeLex.SourceType.CALL_END || token.type === coffeeLex.SourceType.RPAREN) {
        return token;
      }
      return null;
    }

    /**
     * Normally we can edit up to the end of our editing bounds (but no further),
     * but be especially careful here to not place a close-paren before the
     * indentation level of our statement.
     */

  }, {
    key: 'getMaxCloseParenInsertPoint',
    value: function getMaxCloseParenInsertPoint() {
      var maxInsertionPoint = this.getEditingBounds()[1];
      var enclosingIndentedPatcher = this;
      while (!enclosingIndentedPatcher.isFirstNodeInLine(enclosingIndentedPatcher.contentStart) && enclosingIndentedPatcher.parent) {
        enclosingIndentedPatcher = enclosingIndentedPatcher.parent;
      }
      return Math.min(maxInsertionPoint, enclosingIndentedPatcher.contentEnd);
    }

    /**
     * Determine if parens need to be inserted. Needs to handle implicit soaked
     * function calls (where there's a question mark between the function and the
     * args).
     *
     * Note that we do not add parentheses for constructor invocations with no
     * arguments and no parentheses; that usage is correct in JavaScript, so we
     * leave it as-is.
     */

  }, {
    key: 'isImplicitCall',
    value: function isImplicitCall() {
      if (this.args.length === 0) {
        return false;
      }
      var searchStart = this.fn.outerEnd;
      var searchEnd = this.args[0].outerStart;
      return this.indexOfSourceTokenBetweenSourceIndicesMatching(searchStart, searchEnd, function (token) {
        return token.type === coffeeLex.SourceType.CALL_START;
      }) === null;
    }

    /**
     * Get the source index after the function and the question mark, if any.
     * This is the start of the region to insert an open-paren if necessary
     */

  }, {
    key: 'getFuncEnd',
    value: function getFuncEnd() {
      if (this.node.type === 'SoakedFunctionApplication' || this.node.type === 'SoakedNewOp') {
        var questionMarkTokenIndex = this.indexOfSourceTokenAfterSourceTokenIndex(this.fn.outerEndTokenIndex, coffeeLex.SourceType.EXISTENCE);
        var questionMarkToken = this.sourceTokenAtIndex(questionMarkTokenIndex);
        return questionMarkToken.end;
      } else {
        return this.fn.outerEnd;
      }
    }
  }]);
  return FunctionApplicationPatcher;
}(NodePatcher);

/**
 * Normalizes `loop` loops by rewriting into standard `while`, e.g.
 *
 *   loop
 *     b()
 *
 * becomes
 *
 *   while true
 *     b()
 */
var LoopPatcher$2 = function (_NodePatcher) {
  inherits(LoopPatcher, _NodePatcher);

  function LoopPatcher(patcherContext, body) {
    classCallCheck(this, LoopPatcher);

    var _this = possibleConstructorReturn(this, (LoopPatcher.__proto__ || Object.getPrototypeOf(LoopPatcher)).call(this, patcherContext));

    _this.body = body;
    return _this;
  }

  createClass(LoopPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var loop = this.firstToken();
      var next = this.sourceTokenAtIndex(this.contentStartTokenIndex.next());

      if (loop.type !== coffeeLex.SourceType.LOOP) {
        throw this.error('expected first token of loop to be LOOP, but got: ' + coffeeLex.SourceType[loop.type]);
      }

      if (next.type === coffeeLex.SourceType.THEN || !this.body.node.inline) {
        this.overwrite(loop.start, loop.end, 'while true');
      } else {
        this.overwrite(loop.start, loop.end, 'while true then');
      }

      this.body.patch();
    }
  }]);
  return LoopPatcher;
}(NodePatcher);

/**
 * Handles object literals.
 */
var ObjectInitialiserPatcher$2 = function (_NodePatcher) {
  inherits(ObjectInitialiserPatcher, _NodePatcher);

  function ObjectInitialiserPatcher(patcherContext, members) {
    classCallCheck(this, ObjectInitialiserPatcher);

    var _this = possibleConstructorReturn(this, (ObjectInitialiserPatcher.__proto__ || Object.getPrototypeOf(ObjectInitialiserPatcher)).call(this, patcherContext));

    _this.members = members;
    return _this;
  }

  createClass(ObjectInitialiserPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.members.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = slicedToArray(_step.value, 2),
              i = _step$value[0],
              member = _step$value[1];

          member.patch();
          normalizeListItem(this, member, this.members[i + 1]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);
  return ObjectInitialiserPatcher;
}(NodePatcher);

var ProtoMemberAccessOpPatcher = function (_NodePatcher) {
  inherits(ProtoMemberAccessOpPatcher, _NodePatcher);

  function ProtoMemberAccessOpPatcher(patcherContext, expression) {
    classCallCheck(this, ProtoMemberAccessOpPatcher);

    var _this = possibleConstructorReturn(this, (ProtoMemberAccessOpPatcher.__proto__ || Object.getPrototypeOf(ProtoMemberAccessOpPatcher)).call(this, patcherContext));

    _this.expression = expression;
    return _this;
  }

  createClass(ProtoMemberAccessOpPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.expression.patch();
      // `a::b` → `a.prototype.b`
      //   ^^       ^^^^^^^^^^
      var protoToken = this.getProtoToken();
      if (this.parent instanceof MemberAccessOpPatcher$2) {
        this.overwrite(protoToken.start, protoToken.end, '.prototype.');
      } else {
        this.overwrite(protoToken.start, protoToken.end, '.prototype');
      }
    }
  }, {
    key: 'getProtoToken',
    value: function getProtoToken() {
      var protoIndex = this.indexOfSourceTokenBetweenSourceIndicesMatching(this.expression.outerEnd, this.contentEnd, function (token) {
        return token.type === coffeeLex.SourceType.PROTO;
      });

      if (protoIndex) {
        var protoToken = this.sourceTokenAtIndex(protoIndex);

        if (protoToken) {
          return protoToken;
        }
      }

      throw this.error('unable to find \'::\' token after proto member access');
    }
  }]);
  return ProtoMemberAccessOpPatcher;
}(NodePatcher);

var TryPatcher$2 = function (_NodePatcher) {
  inherits(TryPatcher, _NodePatcher);

  function TryPatcher(patcherContext, body, catchAssignee, catchBody, finallyBody) {
    classCallCheck(this, TryPatcher);

    var _this = possibleConstructorReturn(this, (TryPatcher.__proto__ || Object.getPrototypeOf(TryPatcher)).call(this, patcherContext));

    _this.body = body;
    _this.catchAssignee = catchAssignee;
    _this.catchBody = catchBody;
    _this.finallyBody = finallyBody;
    return _this;
  }

  createClass(TryPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      if (this.body) {
        this.body.patch();
      }
      var bodyPrefixLine = this.patchCatchAssignee();
      if (bodyPrefixLine !== null) {
        if (this.catchBody) {
          this.catchBody.insertLineBefore(bodyPrefixLine);
        } else {
          this.insert(this.catchAssignee.outerEnd, ' then ' + bodyPrefixLine);
        }
      }
      if (this.catchBody) {
        this.catchBody.patch();
      }
      if (this.finallyBody) {
        this.finallyBody.patch();
      }
    }
  }, {
    key: 'patchCatchAssignee',
    value: function patchCatchAssignee() {
      if (!this.catchAssignee) {
        return null;
      }
      if (this.needsExpressionExtracted()) {
        var assigneeName = this.claimFreeBinding('error');
        var assigneeCode = this.catchAssignee.patchAndGetCode();
        this.overwrite(this.catchAssignee.contentStart, this.catchAssignee.contentEnd, assigneeName);
        return assigneeCode + ' = ' + assigneeName;
      } else {
        this.catchAssignee.patch();
        return null;
      }
    }

    /**
     * Catch assignees in CoffeeScript can have (mostly) arbitrary assignees,
     * while JS is more limited. Generally JS only supports assignees that can
     * create variables.
     *
     * Also, JavaScript exception assignees are scoped to the catch block while
     * CoffeeScript exception assignees follow function scoping, so pull the
     * variable out into an assignment if the variable is used externally.
     */

  }, {
    key: 'needsExpressionExtracted',
    value: function needsExpressionExtracted() {
      if (!this.catchAssignee) {
        return false;
      }
      if (!(this.catchAssignee instanceof DefaultParamPatcher$4)) {
        return true;
      }
      var varName = this.catchAssignee.node.data;
      var exceptionVarUsages = this.catchBody ? countVariableUsages(this.catchBody.node, varName) + 1 : 1;
      var totalVarUsages = countVariableUsages(this.node.scope.containerNode, varName);
      return totalVarUsages > exceptionVarUsages;
    }
  }]);
  return TryPatcher;
}(NodePatcher);

/**
 * Normalizes `while` loops by rewriting post-`while` into standard `while`, e.g.
 *
 *   a() while b()
 *
 * becomes
 *
 *   while b() then a()
 */
var WhilePatcher$2 = function (_NodePatcher) {
  inherits(WhilePatcher, _NodePatcher);

  function WhilePatcher(patcherContext, condition, guard, body) {
    classCallCheck(this, WhilePatcher);

    var _this = possibleConstructorReturn(this, (WhilePatcher.__proto__ || Object.getPrototypeOf(WhilePatcher)).call(this, patcherContext));

    _this.condition = condition;
    _this.guard = guard;
    _this.body = body;
    return _this;
  }

  createClass(WhilePatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.condition.patch();
      if (this.guard) {
        this.guard.patch();
      }
      if (this.body) {
        this.body.patch();
      }

      if (this.isPostWhile()) {
        this.normalize();
      }
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      this.patchAsExpression();
    }

    /**
     * `BODY 'while' CONDITION ('when' GUARD)?` → `while CONDITION [when GUARD] then BODY`
     * `BODY 'until' CONDITION ('when' GUARD)?` → `until CONDITION [when GUARD] then BODY`
     *
     * @private
     */

  }, {
    key: 'normalize',
    value: function normalize() {
      var patchedCondition = this.slice(this.condition.outerStart, this.condition.outerEnd);
      if (postfixExpressionRequiresParens(patchedCondition) && !this.condition.isSurroundedByParentheses()) {
        patchedCondition = '(' + patchedCondition + ')';
      }
      var patchedBody = this.slice(this.body.outerStart, this.body.outerEnd);
      var patchedGuard = this.guard ? this.slice(this.guard.outerStart, this.guard.outerEnd) : null;
      if (patchedGuard !== null && postfixExpressionRequiresParens(patchedGuard) && !this.guard.isSurroundedByParentheses()) {
        patchedGuard = '(' + patchedGuard + ')';
      }
      var whileToken = this.node.isUntil ? 'until' : 'while';
      var newContent = whileToken + ' ' + patchedCondition + ' ' + (patchedGuard ? 'when ' + patchedGuard + ' ' : '') + 'then ' + patchedBody;
      if (postfixNodeNeedsOuterParens(this)) {
        newContent = '(' + newContent + ')';
      }
      this.overwrite(this.contentStart, this.contentEnd, newContent);
    }

    /**
     * @private
     */

  }, {
    key: 'isPostWhile',
    value: function isPostWhile() {
      return this.condition.contentStart > this.body.contentStart;
    }
  }]);
  return WhilePatcher;
}(NodePatcher);

var NormalizeStage = function (_TransformCoffeeScrip) {
  inherits(NormalizeStage, _TransformCoffeeScrip);

  function NormalizeStage() {
    classCallCheck(this, NormalizeStage);
    return possibleConstructorReturn(this, (NormalizeStage.__proto__ || Object.getPrototypeOf(NormalizeStage)).apply(this, arguments));
  }

  createClass(NormalizeStage, [{
    key: 'patcherConstructorForNode',
    value: function patcherConstructorForNode(node) {
      switch (node.type) {
        case 'ArrayInitialiser':
          return ArrayInitialiserPatcher$2;

        case 'MemberAccessOp':
          return MemberAccessOpPatcher$2;

        case 'Block':
          return BlockPatcher$2;

        case 'BoundFunction':
        case 'Function':
        case 'BoundGeneratorFunction':
        case 'GeneratorFunction':
          return FunctionPatcher$2;

        case 'Conditional':
          return ConditionalPatcher$2;

        case 'Constructor':
          return ConstructorPatcher$2;

        case 'DoOp':
          return DoOpPatcher$2;

        case 'Expansion':
          return ExpansionPatcher$2;

        case 'ForIn':
          return ForInPatcher$2;

        case 'ForOf':
          return ForOfPatcher$2;

        case 'FunctionApplication':
        case 'NewOp':
        case 'SoakedFunctionApplication':
        case 'SoakedNewOp':
          return FunctionApplicationPatcher$2;

        case 'BareSuperFunctionApplication':
          return BareSuperFunctionApplicationPatcher;

        case 'Identifier':
          return DefaultParamPatcher$4;

        case 'While':
          return WhilePatcher$2;

        case 'Loop':
          return LoopPatcher$2;

        case 'Class':
          return ClassPatcher$2;

        case 'AssignOp':
        case 'ClassProtoAssignOp':
        case 'CompoundAssignOp':
          return AssignOpPatcher$2;

        case 'Program':
          return ProgramPatcher$3;

        case 'DefaultParam':
          return DefaultParamPatcher$2;

        case 'Rest':
        case 'Spread':
          return SpreadPatcher$2;

        case 'ObjectInitialiser':
          return ObjectInitialiserPatcher$2;

        case 'ObjectInitialiserMember':
          return ObjectInitialiserMemberPatcher$2;

        case 'ProtoMemberAccessOp':
        case 'SoakedProtoMemberAccessOp':
          return ProtoMemberAccessOpPatcher;

        case 'Try':
          return TryPatcher$2;

        default:
          return PassthroughPatcher;
      }
    }
  }], [{
    key: 'outputExtension',
    get: function get$$1() {
      return '.coffee';
    }
  }]);
  return NormalizeStage;
}(TransformCoffeeScriptStage);

/**
 * Convert the given code to use the specified newline string, either '\n' or
 * '\r\n'.
 */
/**
 * Convert the given code to use the specified newline string, either '\n' or
 * '\r\n'.
 */function convertNewlines(source, newlineStr) {
    if (newlineStr === '\n') {
        return source.replace(/\r\n/g, '\n');
    } else if (newlineStr === '\r\n') {
        source = source.replace(/\r\n/g, '\n');
        return source.replace(/\n/g, '\r\n');
    } else {
        throw new Error("Unexpected newline string to convert to: " + JSON.stringify(newlineStr));
    }
}

/**
 * Determine the most common newline string in the given code, either '\n' or
 * '\r\n'. Prefer '\n' in the case of a tie.
 */
/**
 * Determine the most common newline string in the given code, either '\n' or
 * '\r\n'. Prefer '\n' in the case of a tie.
 */function detectNewlineStr(source) {
    var numLFs = 0;
    var numCRLFs = 0;
    for (var i = 0; i < source.length; i++) {
        if (source[i] === '\n' && (i === 0 || source[i - 1] !== '\r')) {
            numLFs++;
        }
        if (source.slice(i, i + 2) === '\r\n') {
            numCRLFs++;
        }
    }
    return numCRLFs > numLFs ? '\r\n' : '\n';
}

/**
 * Display a range of code, e.g. for a token or an AST node.
 *
 * The line and column are displayed as 1-indexed, to agree with most editors,
 * and the actual 0-indexed code index is also displayed.
 *
 * For example, if a program is just "foo", then the "foo" token has this range:
 * [1:1(0)-1:4(3)]
 */
function formatRange(startIndex, endIndex, context) {
  return "[" + formatIndex(startIndex, context) + "-" + formatIndex(endIndex, context) + "]";
}

function formatIndex(index, context) {
  if (index > context.source.length) {
    index = context.source.length;
  }

  var _context$linesAndColu = context.linesAndColumns.locationForIndex(index),
      line = _context$linesAndColu.line,
      column = _context$linesAndColu.column;

  return line + 1 + ":" + (column + 1) + "(" + index + ")";
}

function formatCoffeeLexTokens(context) {
  var tokens$$1 = context.sourceTokens;
  var resultLines = tokens$$1.map(function (token) {
    return formatRange(token.start, token.end, context) + ': ' + coffeeLex.SourceType[token.type];
  });
  return resultLines.map(function (line) {
    return line + '\n';
  }).join('');
}

function formatCoffeeScriptLocationData(locationData, context) {
  var first_line = locationData.first_line,
      first_column = locationData.first_column,
      last_line = locationData.last_line,
      last_column = locationData.last_column;

  var firstIndex = context.linesAndColumns.indexForLocation({ line: first_line, column: first_column });
  var lastIndex = context.linesAndColumns.indexForLocation({ line: last_line, column: last_column }) + 1;
  return formatRange(firstIndex, lastIndex, context);
}

function formatCoffeeScriptAst(context) {
  var resultLines = formatAstNodeLines(context.ast, context);
  return resultLines.map(function (line) {
    return line + '\n';
  }).join('');
}

function formatAstNodeLines(node, context) {
  var propLines = [];
  var blacklistedProps = ['locationData'];
  // Show the non-node children first.
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.keys(node)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      var value = node[key];
      if (shouldTraverse(value) || blacklistedProps.indexOf(key) !== -1) {
        continue;
      }
      var valueText = void 0;
      try {
        valueText = JSON.stringify(value);
      } catch (e) {
        valueText = '(error)';
      }
      propLines.push(key + ': ' + valueText);
    }

    // Then show the node children.
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = Object.keys(node)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _key = _step2.value;

      var _value = node[_key];
      if (!shouldTraverse(_value)) {
        continue;
      }

      if (Array.isArray(_value) && _value.length === 0) {
        propLines.push(_key + ': []');
      } else if (Array.isArray(_value)) {
        propLines.push(_key + ': [');
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = _value[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var child = _step3.value;

            if (Array.isArray(child)) {
              propLines.push('  [');
              var _iteratorNormalCompletion4 = true;
              var _didIteratorError4 = false;
              var _iteratorError4 = undefined;

              try {
                for (var _iterator4 = child[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                  var grandchild = _step4.value;

                  propLines.push.apply(propLines, toConsumableArray(formatAstNodeLines(grandchild, context).map(function (s) {
                    return '    ' + s;
                  })));
                }
              } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion4 && _iterator4.return) {
                    _iterator4.return();
                  }
                } finally {
                  if (_didIteratorError4) {
                    throw _iteratorError4;
                  }
                }
              }

              propLines.push('  ]');
            } else {
              propLines.push.apply(propLines, toConsumableArray(formatAstNodeLines(child, context).map(function (s) {
                return '  ' + s;
              })));
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        propLines.push(']');
      } else {
        var childLines = formatAstNodeLines(_value, context);
        childLines[0] = _key + ': ' + childLines[0];
        propLines.push.apply(propLines, toConsumableArray(childLines));
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return [node.constructor.name + ' ' + formatCoffeeScriptLocationData(node.locationData, context) + ' {'].concat(toConsumableArray(propLines.map(function (s) {
    return '  ' + s;
  })), ['}']);
}

function shouldTraverse(value) {
  if (Array.isArray(value)) {
    return value.length === 0 || shouldTraverse(value[0]);
  }
  return isNode(value);
}

/**
 * CoffeeScript AST nodes are always instances of a custom class, so use the
 * constructor name to distinguish between node children and non-node children.
 */
function isNode(value) {
  if (!value) {
    return false;
  }
  return ['String', 'Number', 'Boolean', 'Array', 'Object'].indexOf(value.constructor.name) === -1;
}

function formatCoffeeScriptLexerTokens(tokens$$1, context) {
  var resultLines = tokens$$1.map(function (_ref) {
    var _ref2 = slicedToArray(_ref, 3),
        tag = _ref2[0],
        value = _ref2[1],
        locationData = _ref2[2];

    return formatCoffeeScriptLocationData(locationData, context) + ': ' + tag + ': ' + JSON.stringify(value);
  });
  return resultLines.map(function (line) {
    return line + '\n';
  }).join('');
}

function formatDecaffeinateParserAst(ast) {
  var resultLines = formatAstNodeLines$1(ast, ast.context);
  return resultLines.map(function (line) {
    return line + '\n';
  }).join('');
}

function formatAstNodeLines$1(node, context) {
  var propLines = [];
  var childPropNames = childPropertyNames(node);
  var blacklistedProps = childPropNames.concat(['raw', 'line', 'column', 'type', 'range', 'scope', 'parentNode', 'context', 'start', 'end']);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.keys(node)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      if (blacklistedProps.indexOf(key) !== -1) {
        continue;
      }
      var valueText = void 0;
      try {
        valueText = JSON.stringify(node[key]);
      } catch (e) {
        valueText = '(error)';
      }
      propLines.push(key + ': ' + valueText);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = childPropNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var childProp = _step2.value;

      var value = node[childProp];
      if (value === null) {
        propLines.push(childProp + ': null');
      } else if (Array.isArray(value) && value.length === 0) {
        propLines.push(childProp + ': []');
      } else if (Array.isArray(value)) {
        propLines.push(childProp + ': [');
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = value[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var child = _step3.value;

            propLines.push.apply(propLines, toConsumableArray(formatAstNodeLines$1(child, context).map(function (s) {
              return '  ' + s;
            })));
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        propLines.push(']');
      } else {
        var childLines = formatAstNodeLines$1(value, context);
        childLines[0] = childProp + ': ' + childLines[0];
        propLines.push.apply(propLines, toConsumableArray(childLines));
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var rangeStr = formatRange(node.range[0], node.range[1], context);
  return [node.type + ' ' + rangeStr + ' {'].concat(toConsumableArray(propLines.map(function (s) {
    return '  ' + s;
  })), ['}']);
}

/**
 * If the source code starts with a Unicode BOM, CoffeeScript will just ignore
 * it and provide source code locations that assume that it was removed, so we
 * should do the same.
 */
/**
 * If the source code starts with a Unicode BOM, CoffeeScript will just ignore
 * it and provide source code locations that assume that it was removed, so we
 * should do the same.
 */function removeUnicodeBOMIfNecessary(source) {
    if (source[0] === '\uFEFF') {
        return source.slice(1);
    } else {
        return source;
    }
}

/**
 * If the given exception is an error with code location information, extract
 * its start and end position and return a PatchError to use in its place.
 * Otherwise, return null.
 */
function resolveToPatchError(err, content, stageName) {
  var makePatchError = function makePatchError(start, end, source) {
    return new PatchError(stageName + ' failed to parse: ' + err.message, source, start, end);
  };

  if (err.pos) {
    // Handle JavaScript parse errors.
    var pos = err.pos;

    if (pos === content.length) {
      pos--;
    }
    // In most cases, we can use the source code we already have, but for
    // esnext, the code might be an intermediate code state, so use that from
    // the exception if possible.
    var source = err.source || content;
    return makePatchError(pos, pos + 1, source);
  } else if (err.syntaxError) {
    // Handle CoffeeScript parse errors.
    var _err$syntaxError$loca = err.syntaxError.location,
        first_line = _err$syntaxError$loca.first_line,
        first_column = _err$syntaxError$loca.first_column,
        last_line = _err$syntaxError$loca.last_line,
        last_column = _err$syntaxError$loca.last_column;

    var lineMap = new LinesAndColumns(content);
    var firstIndex = lineMap.indexForLocation({ line: first_line, column: first_column });
    var lastIndex = lineMap.indexForLocation({ line: last_line, column: last_column }) + 1;
    if (!lastIndex && lastIndex !== 0) {
      lastIndex = firstIndex + 1;
    }
    if (firstIndex !== null && firstIndex !== undefined && lastIndex !== null && lastIndex !== undefined) {
      return makePatchError(firstIndex, lastIndex, content);
    }
  }
  return null;
}

/* eslint-disable no-process-exit */

/**
 * Run the script with the user-supplied arguments.
 */
function run$$1(args) {
  var options = parseArguments(args);

  if (options.paths.length) {
    runWithPaths(options.paths, options.baseOptions);
  } else {
    runWithStream('stdin', process.stdin, process.stdout, options.baseOptions);
  }
}

function parseArguments(args) {
  var paths = [];
  var baseOptions = {};

  for (var i = 0; i < args.length; i++) {
    var arg = args[i];
    switch (arg) {
      case '-h':
      case '--help':
        usage();
        process.exit(0);
        break;

      case '--keep-commonjs':
        baseOptions.keepCommonJS = true;
        break;

      case '--prefer-const':
        baseOptions.preferConst = true;
        break;

      case '--loose-default-params':
        baseOptions.looseDefaultParams = true;
        break;

      case '--loose-for-expressions':
        baseOptions.looseForExpressions = true;
        break;

      case '--loose-for-of':
        baseOptions.looseForOf = true;
        break;

      case '--loose-includes':
        baseOptions.looseIncludes = true;
        break;

      case '--loose-comparison-negation':
        baseOptions.looseComparisonNegation = true;
        break;

      case '--allow-invalid-constructors':
        baseOptions.allowInvalidConstructors = true;
        break;

      case '--enable-babel-constructor-workaround':
        baseOptions.enableBabelConstructorWorkaround = true;
        break;

      default:
        if (arg.startsWith('-')) {
          console.error('Error: unrecognized option \'' + arg + '\'');
          process.exit(1);
        }
        paths.push(arg);
        break;
    }
  }

  return { paths: paths, baseOptions: baseOptions };
}

/**
 * Run decaffeinate on the given paths, changing them in place.
 */
function runWithPaths(paths, baseOptions) {
  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  var errors = [];
  var pending = paths.slice();

  function processPath(path$$1) {
    fs.stat(path$$1, function (err, info) {
      if (err) {
        errors.push(err);
      } else if (info.isDirectory()) {
        processDirectory(path$$1);
      } else {
        processFile(path$$1);
      }
    });
  }

  function processDirectory(path$$1) {
    fs.readdir(path$$1, function (err, children) {
      if (err) {
        errors.push(err);
      } else {
        pending.unshift.apply(pending, toConsumableArray(children.filter(function (child) {
          return path.extname(child) === '.coffee';
        }).map(function (child) {
          return path.join(path$$1, child);
        })));
      }
      processNext();
    });
  }

  function processFile(path$$1) {
    var outputPath = path.join(path.dirname(path$$1), path.basename(path$$1, path.extname(path$$1))) + '.js';
    console.log(path$$1 + ' \u2192 ' + outputPath);
    runWithStream(path$$1, fs.createReadStream(path$$1, { encoding: 'utf8' }), fs.createWriteStream(outputPath, { encoding: 'utf8' }), baseOptions, function (err) {
      if (err) {
        errors.push(err);
      }
      processNext();
    });
  }

  function processNext() {
    if (pending.length > 0) {
      processPath(pending.shift());
    } else if (callback) {
      callback(errors);
    }
  }

  processNext();
}

/**
 * Run decaffeinate reading from input and writing to corresponding output.
 */
function runWithStream(name, input, output, baseOptions) {
  var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

  var error = null;
  var data = '';

  input.setEncoding('utf8');

  input.on('data', function (chunk) {
    return data += chunk;
  });

  input.on('end', function () {
    var converted = void 0;
    var options = Object.assign({ filename: name }, baseOptions);
    try {
      converted = convert$1(data, options);
    } catch (err) {
      if (PatchError.detect(err)) {
        console.error(name + ': ' + PatchError.prettyPrint(err));
        process.exit(1);
      } else {
        throw err;
      }
    }
    if (converted) {
      var _converted = converted,
          code = _converted.code;

      output.end(code, function () {
        if (callback) {
          callback(error);
        }
      });
    }
  });

  output.on('error', function (err) {
    return error = err;
  });
}

/**
 * Print usage help.
 */
function usage() {
  var exe = path.basename(process.argv[1]);
  console.log('%s [OPTIONS] PATH [PATH …]', exe);
  console.log('%s [OPTIONS] < INPUT', exe);
  console.log();
  console.log('Move your CoffeeScript source to JavaScript using modern syntax.');
  console.log();
  console.log('OPTIONS');
  console.log();
  console.log('  -h, --help               Display this help message.');
  console.log('  --keep-commonjs          Do not convert require and module.exports to import and export.');
  console.log('  --prefer-const           Use the const keyword for variables when possible.');
  console.log('  --loose-default-params   Convert CS default params to JS default params.');
  console.log('  --loose-for-expressions  Do not wrap expression loop targets in Array.from.');
  console.log('  --loose-for-of           Do not wrap JS for...of loop targets in Array.from.');
  console.log('  --loose-includes         Do not wrap in Array.from when converting in to includes.');
  console.log('  --loose-comparison-negation');
  console.log('                           Allow unsafe simplifications like `!(a > b)` to `a <= b`.');
  console.log('  --allow-invalid-constructors');
  console.log('                           Don\'t error when constructors use this before super or omit');
  console.log('                           the super call in a subclass.');
  console.log('  --enable-babel-constructor-workaround');
  console.log('                           Use a hacky Babel-specific workaround to allow this before');
  console.log('                           super in constructors. Also works when using TypeScript.');
  console.log();
  console.log('EXAMPLES');
  console.log();
  console.log('  # Convert a .coffee file to a .js file.');
  console.log('  $ decaffeinate index.coffee');
  console.log();
  console.log('  # Pipe an example from the command-line.');
  console.log('  $ echo "a = 1" | decaffeinate');
  console.log();
  console.log('  # On OS X this may come in handy:');
  console.log('  $ pbpaste | decaffeinate | pbcopy');
  console.log();
  console.log('  # Process everything in a directory.');
  console.log('  $ decaffeinate src/');
  console.log();
  console.log('  # Redirect input from a file.');
  console.log('  $ decaffeinate < index.coffee');
}

var DEFAULT_OPTIONS = {
  filename: 'input.coffee',
  runToStage: null,
  keepCommonJS: false,
  preferConst: false,
  looseDefaultParams: false,
  looseForExpressions: false,
  looseForOf: false,
  looseIncludes: false,
  looseComparisonNegation: false,
  allowInvalidConstructors: false,
  enableBabelConstructorWorkaround: false
};

/**
 * Convert CoffeeScript source code into modern JavaScript preserving comments
 * and formatting.
 */
function convert$1(source) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  source = removeUnicodeBOMIfNecessary(source);
  options = Object.assign({}, DEFAULT_OPTIONS, options);
  var originalNewlineStr = detectNewlineStr(source);
  source = convertNewlines(source, '\n');
  var stages = [NormalizeStage, MainStage, AddVariableDeclarationsStage, SemicolonsStage, EsnextStage];
  var runToStage = options.runToStage;
  if (runToStage !== null && runToStage !== undefined) {
    var stageIndex = stages.findIndex(function (stage) {
      return stage.name === runToStage;
    });
    if (stageIndex !== -1) {
      stages = stages.slice(0, stageIndex + 1);
    } else {
      return convertCustomStage(source, runToStage);
    }
  }
  var result = runStages(source, options, stages);
  result.code = convertNewlines(result.code, originalNewlineStr);
  return result;
}

function runStages(initialContent, options, stages) {
  var content = initialContent;
  stages.forEach(function (stage) {
    var _runStage = runStage(stage, content, options),
        code = _runStage.code;

    content = code;
  });
  return { code: content };
}

function runStage(stage, content, options) {
  try {
    return stage.run(content, options);
  } catch (err) {
    var patchError = resolveToPatchError(err, content, stage.name);
    if (patchError !== null) {
      throw patchError;
    }
    throw err;
  }
}

function convertCustomStage(source, stageName) {
  var ast = parse$2(source);
  if (stageName === 'coffeescript-lexer') {
    return {
      code: formatCoffeeScriptLexerTokens(decaffeinateCoffeescript.tokens(source), ast.context)
    };
  } else if (stageName === 'coffeescript-parser') {
    return {
      code: formatCoffeeScriptAst(ast.context)
    };
  } else if (stageName === 'coffee-lex') {
    return {
      code: formatCoffeeLexTokens(ast.context)
    };
  } else if (stageName === 'decaffeinate-parser') {
    return {
      code: formatDecaffeinateParserAst(ast)
    };
  } else {
    throw new Error('Unrecognized stage name: ' + stageName);
  }
}

exports.PatchError = PatchError;
exports.convert = convert$1;
exports.run = run$$1;


}).call(this,require('_process'))
},{"_process":367,"add-variable-declarations":1,"ast-processor-babylon-config":5,"automatic-semicolon-insertion":6,"babylon":62,"coffee-lex":72,"decaffeinate-coffeescript":179,"decaffeinate-parser":188,"detect-indent":190,"esnext":192,"fs":64,"lines-and-columns":206,"magic-string":362,"path":366,"repeating":368,"util":375}],190:[function(require,module,exports){
/* eslint-disable guard-for-in */
'use strict';
var repeating = require('repeating');

// detect either spaces or tabs but not both to properly handle tabs
// for indentation and spaces for alignment
var INDENT_RE = /^(?:( )+|\t+)/;

function getMostUsed(indents) {
	var result = 0;
	var maxUsed = 0;
	var maxWeight = 0;

	for (var n in indents) {
		var indent = indents[n];
		var u = indent[0];
		var w = indent[1];

		if (u > maxUsed || u === maxUsed && w > maxWeight) {
			maxUsed = u;
			maxWeight = w;
			result = Number(n);
		}
	}

	return result;
}

module.exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	// used to see if tabs or spaces are the most used
	var tabs = 0;
	var spaces = 0;

	// remember the size of previous line's indentation
	var prev = 0;

	// remember how many indents/unindents as occurred for a given size
	// and how much lines follow a given indentation
	//
	// indents = {
	//    3: [1, 0],
	//    4: [1, 5],
	//    5: [1, 0],
	//   12: [1, 0],
	// }
	var indents = {};

	// pointer to the array of last used indent
	var current;

	// whether the last action was an indent (opposed to an unindent)
	var isIndent;

	str.split(/\n/g).forEach(function (line) {
		if (!line) {
			// ignore empty lines
			return;
		}

		var indent;
		var matches = line.match(INDENT_RE);

		if (!matches) {
			indent = 0;
		} else {
			indent = matches[0].length;

			if (matches[1]) {
				spaces++;
			} else {
				tabs++;
			}
		}

		var diff = indent - prev;
		prev = indent;

		if (diff) {
			// an indent or unindent has been detected

			isIndent = diff > 0;

			current = indents[isIndent ? diff : -diff];

			if (current) {
				current[0]++;
			} else {
				current = indents[diff] = [1, 0];
			}
		} else if (current) {
			// if the last action was an indent, increment the weight
			current[1] += Number(isIndent);
		}
	});

	var amount = getMostUsed(indents);

	var type;
	var actual;
	if (!amount) {
		type = null;
		actual = '';
	} else if (spaces >= tabs) {
		type = 'space';
		actual = repeating(' ', amount);
	} else {
		type = 'tab';
		actual = repeating('\t', amount);
	}

	return {
		amount: amount,
		type: type,
		indent: actual
	};
};

},{"repeating":368}],191:[function(require,module,exports){
'use strict';

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

module.exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.replace(matchOperatorsRe, '\\$&');
};

},{}],192:[function(require,module,exports){
(function (process){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('babylon'), require('magic-string'), require('babel-types'), require('util'), require('shebang-regex'), require('babel-traverse'), require('path'), require('fs'), require('mkdirp')) :
  typeof define === 'function' && define.amd ? define(['exports', 'babylon', 'magic-string', 'babel-types', 'util', 'shebang-regex', 'babel-traverse', 'path', 'fs', 'mkdirp'], factory) :
  (factory((global.esnext = global.esnext || {}),global.babylon,global.MagicString,global.t,global.util,global.shebangRegex,global.traverse,global.path,global.fs,global.mkdirp));
}(this, (function (exports,babylon,MagicString,t,util,shebangRegex,traverse,path,fs,mkdirp) { 'use strict';

MagicString = 'default' in MagicString ? MagicString['default'] : MagicString;
shebangRegex = 'default' in shebangRegex ? shebangRegex['default'] : shebangRegex;
traverse = 'default' in traverse ? traverse['default'] : traverse;
mkdirp = 'default' in mkdirp ? mkdirp['default'] : mkdirp;

function clone(object) {
  return JSON.parse(JSON.stringify(object));
}

var BABEL_PARSE_OPTIONS = {
  sourceType: 'module',
  strictMode: true,
  allowImportExportEverywhere: false, // consistent with espree
  allowReturnOutsideFunction: true,
  allowSuperOutsideMethod: true,
  plugins: ['flow', 'jsx', 'asyncFunctions', 'asyncGenerators', 'classConstructorCall', 'classProperties', 'decorators', 'doExpressions', 'exponentiationOperator', 'exportExtensions', 'functionBind', 'functionSent', 'objectRestSpread', 'trailingFunctionCommas']
};

Object.defineProperty(babylon.tokTypes.backQuote, 'updateContext', {
  value: babylon.tokTypes.backQuote.updateContext,
  configurable: false
});

var parse$1 = function (source) {
  return babylon.parse(source, BABEL_PARSE_OPTIONS);
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();









var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};





var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var Module = function () {
  function Module(id, source) {
    classCallCheck(this, Module);
    this.metadata = {};
    this.warnings = [];

    this.id = id;
    this.reinit(source);
  }

  /**
   * @private
   */


  createClass(Module, [{
    key: 'reinit',
    value: function reinit(source) {
      this.source = source;
      this.ast = parse$1(source);
      this.tokens = this.ast.tokens;
      this.magicString = new MagicString(source, {
        filename: this.id
      });
    }
  }, {
    key: 'commit',
    value: function commit() {
      var source = this.magicString.toString();

      if (source !== this.source) {
        this.reinit(source);
      }
    }
  }, {
    key: 'warn',
    value: function warn(node, type, message) {
      this.warnings.push({ node: clone(node), type: type, message: message });
    }
  }, {
    key: 'tokensForNode',
    value: function tokensForNode(node) {
      return this.tokensInRange(node.start, node.end);
    }
  }, {
    key: 'tokensInRange',
    value: function tokensInRange(start, end) {
      var tokenRange = this.tokenIndexRangeForSourceRange(start, end);

      if (!tokenRange) {
        return [];
      }

      return this.tokens.slice(tokenRange.start, tokenRange.end);
    }
  }, {
    key: 'tokenIndexRangeForSourceRange',
    value: function tokenIndexRangeForSourceRange(start, end) {
      var location = null;
      var length = 0;
      var tokens = this.tokens;

      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        if (token.end > end) {
          break;
        } else if (token.start >= start) {
          if (location === null) {
            location = i;
          }
          length++;
        }
      }

      if (location === null) {
        return null;
      }

      return { start: location, end: location + length };
    }
  }, {
    key: 'render',
    value: function render() {
      return {
        code: this.magicString.toString(),
        ast: this.ast,
        warnings: this.warnings.slice(),
        metadata: this.metadata
      };
    }
  }, {
    key: 'sourceOf',
    value: function sourceOf(node) {
      return this.source.slice(node.start, node.end);
    }
  }]);
  return Module;
}();

function cleanNode(node) {
  if (!t.isNode(node)) {
    throw new Error('node must be a valid node type, got: ' + util.inspect(node));
  }

  var result = Object.create(null);
  var fields = t.NODE_FIELDS[node.type];

  result.type = node.type;

  Object.keys(fields).forEach(function (field) {
    if (field in node) {
      var value = node[field];

      if (t.isNode(value)) {
        result[field] = cleanNode(value);
      } else if (Array.isArray(value)) {
        result[field] = value.map(function (element) {
          return t.isNode(element) ? cleanNode(element) : element;
        });
      } else {
        result[field] = value;
      }
    } else {
      result[field] = fields[field].default;
    }
  });

  return result;
}

function replace(destination, source) {
  for (var key in destination) {
    delete destination[key];
  }

  for (var _key in source) {
    destination[_key] = source[_key];
  }

  return destination;
}

function hasParens(path$$1, module) {
  var tokens = module.tokens;

  var _module$tokenIndexRan = module.tokenIndexRangeForSourceRange(path$$1.node.start, path$$1.node.end),
      start = _module$tokenIndexRan.start,
      end = _module$tokenIndexRan.end;

  var tokenBefore = tokens[start - 1];
  var tokenAfter = tokens[end];

  return tokenBefore.type.label === '(' && tokenAfter.type.label === ')';
}

function needsParens(path$$1) {
  var node = path$$1.node,
      parent = path$$1.parent;


  if (t.isArrowFunctionExpression(node)) {
    if (t.isMemberExpression(parent)) {
      return parent.object === node;
    } else if (t.isCallExpression(parent)) {
      return parent.callee === node;
    } else if (t.isBinaryExpression(parent)) {
      return true;
    } else if (t.isLogicalExpression(parent)) {
      return true;
    }
  }

  return false;
}

function indexOfElementMatchingPredicate(list, predicate) {
  var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  var index = start;
  while (index < list.length) {
    var _element = list[index];
    if (predicate(_element)) {
      return index;
    }
    index++;
  }
  return ~index;
}

function findToken(label, tokens) {
  var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  return findTokenMatchingPredicate(function (token) {
    return token.type.label === label;
  }, tokens, start);
}

function findTokenMatchingPredicate(predicate, tokens) {
  var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  var index = indexOfElementMatchingPredicate(tokens, predicate, start);
  if (index < 0) {
    var loc = tokens[start].loc.start;
    throw new Error('unexpected token after ' + loc.line + ':' + (loc.column + 1));
  }
  return { index: index, token: tokens[index] };
}

function findEndBraceTokenBalanced(tokens) {
  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  // We count '{' and '${' as left tokens because string interpolations start
  // with '${' and end with the same '}' as objects and blocks.
  return findEndTokenBalanced(['{', '${'], '}', tokens, start);
}

function findEndParenthesisTokenBalanced(tokens) {
  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  return findEndTokenBalanced('(', ')', tokens, start);
}

function findEndTokenBalanced(left, right, tokens) {
  var start = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  var index = indexOfBalancedToken(tokens, tokenMatcher(left), tokenMatcher(right), start);
  if (index < 0) {
    var loc = tokens[start].loc.start;
    throw new Error('expected balanced tokens starting at ' + loc.line + ':' + (loc.column + 1));
  }
  return { index: index, token: tokens[index] };
}

function tokenMatcher(label) {
  if (typeof label === 'string') {
    return function (token) {
      return token.type.label === label;
    };
  } else {
    return function (token) {
      return label.indexOf(token.type.label) >= 0;
    };
  }
}

function indexOfBalancedToken(tokens, leftPredicate, rightPredicate) {
  var start = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  var depth = 0;
  return indexOfElementMatchingPredicate(tokens, function (token) {
    if (leftPredicate(token)) {
      depth++;
    }
    if (rightPredicate(token)) {
      depth--;
    }
    return depth === 0;
  }, start);
}

var name = 'functions.arrow';
var description = 'Transform regular functions to arrow functions as appropriate.';

function visitor(module) {
  var editor = module.magicString;
  var functions = metadata(module).functions;

  return {
    FunctionExpression: function FunctionExpression(path$$1) {
      var node = path$$1.node,
          parent = path$$1.parent;

      // Skip generator functions.

      if (node.generator) {
        return;
      }

      // Only process anonymous functions.
      if (node.id) {
        return;
      }

      // Skip object literal methods.
      if (t.isProperty(parent) && parent.method) {
        return;
      }

      // Skip class methods.
      if (t.isClassMethod(parent) && parent.value === node) {
        return;
      }

      // Only process functions with a single return statement.
      if (node.body.body.length !== 1) {
        return;
      }

      // A directive like "use strict" is syntactically its own line, so if any
      // exist, we can't assume this is a single-line function.
      if (node.body.directives.length > 0) {
        return;
      }

      // `new` can't be called on arrow functions.
      if (t.isNewExpression(parent)) {
        return;
      }

      var _node$body$body = slicedToArray(node.body.body, 1),
          statement = _node$body$body[0];

      if (!t.isReturnStatement(statement) || !statement.argument) {
        return;
      }

      // Skip functions referencing `this` or `arguments`.
      if (referencesThisOrArguments(path$$1)) {
        return;
      }

      rewriteBlocklessArrowFunction(path$$1, module, functions);

      // Remove extra parentheses if they're no longer needed.
      if (t.isExpressionStatement(parent) && hasParens(path$$1, module)) {
        var _module$tokenIndexRan = module.tokenIndexRangeForSourceRange(node.start, node.end),
            start = _module$tokenIndexRan.start,
            end = _module$tokenIndexRan.end;

        var tokens = module.tokens;

        var lparen = tokens[start - 1];
        var rparen = tokens[end];
        editor.remove(lparen.start, node.start);
        editor.remove(node.end, rparen.end);
      }
    },


    /**
     * Look for functions that are manually bound, e.g.
     *
     *   this.onclick = (function() {
     *     console.log('registering');
     *     this.register();
     *   }).bind(this);
     */
    CallExpression: function CallExpression(path$$1) {
      var node = path$$1.node,
          callee = path$$1.node.callee,
          parent = path$$1.parent;


      if (!t.isMemberExpression(callee)) {
        return;
      }

      var object = callee.object,
          property = callee.property;


      if (!t.isFunctionExpression(object) || object.id) {
        return;
      }

      if (!t.isIdentifier(property) || property.name !== 'bind') {
        return;
      }

      if (node.arguments.length !== 1 || !t.isThisExpression(node.arguments[0])) {
        return;
      }

      var objectPath = path$$1.get('callee').get('object');

      if (referencesArguments(objectPath)) {
        return;
      }

      if (objectPath.node.generator) {
        return;
      }

      // `new` can't be called on arrow functions.
      if (t.isNewExpression(parent)) {
        path$$1.skip();
        return;
      }

      rewriteBlockArrowFunction(objectPath, module, functions);

      // `() => {}.bind(this)` -> `() => {}bind(this)`
      //          ^

      var _module$tokenIndexRan2 = module.tokenIndexRangeForSourceRange(object.end, property.start),
          start = _module$tokenIndexRan2.start,
          end = _module$tokenIndexRan2.end;

      var tokens = module.tokens;

      for (var i = start; i < end; i++) {
        var token = tokens[i];
        if (token.type.label === '.') {
          editor.remove(token.start, token.end);
        }
      }

      // `() => {}bind(this)` -> `() => {}`
      //          ^^^^^^^^^^
      editor.remove(property.start, node.end);

      replace(node, object);
    }
  };
}

function referencesThisOrArguments(path$$1) {
  var result = false;

  path$$1.scope.traverse(path$$1.node, {
    'FunctionDeclaration|FunctionExpression': function FunctionDeclarationFunctionExpression(fnPath) {
      // Skip nested functions.
      fnPath.skip();
    },
    ThisExpression: function ThisExpression(thisPath) {
      result = true;
      thisPath.stop();
    },
    Identifier: function Identifier(identPath) {
      if (identPath.node.name === 'arguments') {
        result = true;
        identPath.stop();
      }
    }
  });

  return result;
}

function referencesArguments(path$$1) {
  var result = false;

  path$$1.scope.traverse(path$$1.node, {
    Function: function Function(fnPath) {
      // Skip nested functions.
      fnPath.skip();
    },
    Identifier: function Identifier(identPath) {
      if (identPath.node.name === 'arguments') {
        result = true;
        identPath.stop();
      }
    }
  });

  return result;
}

function metadata(module) {
  if (!module.metadata[name]) {
    module.metadata[name] = { functions: [] };
  }
  return module.metadata[name];
}

function rewriteBlocklessArrowFunction(path$$1, module, functions) {
  var node = path$$1.node;

  var _node$body$body2 = slicedToArray(node.body.body, 1),
      statement = _node$body$body2[0];

  functions.push(cleanNode(node));

  var _getFunctionPunctuati = getFunctionPunctuation(node, module),
      fn = _getFunctionPunctuati.fn,
      paramsStart = _getFunctionPunctuati.paramsStart,
      paramsEnd = _getFunctionPunctuati.paramsEnd,
      blockStart = _getFunctionPunctuati.blockStart,
      blockEnd = _getFunctionPunctuati.blockEnd;

  // Only remove parens for a single simple parameter on the same line as the `=>`.


  var paramsNeedParens = node.params.length !== 1 || !t.isIdentifier(node.params[0]) || node.params[0].loc.end.line !== paramsEnd.loc.start.line;

  var editor = module.magicString;
  if (!paramsNeedParens) {
    // `(a)` -> `a`
    //  ^ ^
    editor.remove(paramsStart.start, paramsStart.end);
    editor.remove(paramsEnd.start, paramsEnd.end);
  }

  // `function() {` -> `() =>`
  editor.remove(fn.start, paramsStart.start);
  editor.overwrite(blockStart.start, blockStart.end, '=>');

  var contentBetweenBlockStartBraceAndReturn = module.source.slice(blockStart.end, statement.start);
  var contentOfReturnArgument = module.sourceOf(statement.argument);

  var shouldCollapseToOneLine =
  // Wouldn't remove anything interesting.
  /^\s*$/.test(contentBetweenBlockStartBraceAndReturn) &&
  // Returned value isn't multi-line.
  /^[^\n\r]*$/.test(contentOfReturnArgument);

  if (shouldCollapseToOneLine) {
    // Removes whitespace between `{` and `return` and `foo;` and `}`.
    //
    //  function() {
    //    return foo;
    //  }
    //
    if (blockStart.end === statement.start) {
      editor.appendLeft(statement.start, ' ');
    } else {
      editor.overwrite(blockStart.end, statement.start, ' ');
    }
    editor.remove(statement.end, blockEnd.end);
  }

  var returnArgumentNeedsParens = t.isSequenceExpression(statement.argument);

  // `return foo;` -> `foo`
  //  ^^^^^^^   ^
  editor.overwrite(statement.start, statement.argument.start, returnArgumentNeedsParens ? '(' : '');
  if (statement.argument.end === statement.end) {
    editor.appendLeft(statement.end, returnArgumentNeedsParens ? ')' : '');
  } else {
    editor.overwrite(statement.argument.end, statement.end, returnArgumentNeedsParens ? ')' : '');
  }

  // `…}` -> `…`
  editor.remove(blockEnd.start, blockEnd.end);

  node.type = 'ArrowFunctionExpression';
  node.body = statement.argument;
  node.expression = true;

  if (needsParens(path$$1) && !hasParens(path$$1, module)) {
    editor.appendRight(node.start, '(');
    editor.appendLeft(node.end, ')');
  }

  if (bodyNeedsParens(node.body, module.source)) {
    editor.appendRight(node.body.start, '(');
    editor.appendLeft(node.body.end, ')');
  }
}

/**
 * Rewrites a function expression to an arrow function, preserving the block.
 */
function rewriteBlockArrowFunction(path$$1, module, functions) {
  var node = path$$1.node;


  functions.push(cleanNode(node));

  var _getFunctionPunctuati2 = getFunctionPunctuation(node, module),
      fn = _getFunctionPunctuati2.fn,
      paramsStart = _getFunctionPunctuati2.paramsStart,
      paramsEnd = _getFunctionPunctuati2.paramsEnd,
      blockStart = _getFunctionPunctuati2.blockStart;

  var paramsNeedsParens = node.params.length !== 1 || !t.isIdentifier(node.params[0]);
  var editor = module.magicString;

  if (!paramsNeedsParens) {
    // `(a)` -> `a`
    //  ^ ^
    editor.remove(paramsStart.start, paramsStart.end);
    editor.remove(paramsEnd.start, paramsEnd.end);
  }

  // `function() {` -> `() =>`
  //  ^^^^^^^^   ^         ^^
  editor.remove(fn.start, paramsStart.start);
  editor.appendLeft(blockStart.start, '=> ');

  node.type = 'ArrowFunctionExpression';
}

/**
 * Get the tokens for the relevant function punctuation, i.e.
 *
 *            paramsStart    paramsEnd
 *             fn       |    |
 *              |       |    |
 *              v       v    v
 *   let add = (function(a, b) { <- blockStart
 *     return a + b;
 *   });
 *   ^
 *   |
 *   blockEnd
 */
function getFunctionPunctuation(node, module) {
  var tokens = module.tokensForNode(node);

  var _findToken = findToken('function', tokens, 0),
      functionTokenIndex = _findToken.index,
      fn = _findToken.token;

  var _findToken2 = findToken('(', tokens, functionTokenIndex),
      paramsStartIndex = _findToken2.index,
      paramsStart = _findToken2.token;

  var _findEndParenthesisTo = findEndParenthesisTokenBalanced(tokens, paramsStartIndex),
      paramsEndIndex = _findEndParenthesisTo.index,
      paramsEnd = _findEndParenthesisTo.token;

  var _findToken3 = findToken('{', tokens, paramsEndIndex),
      blockStartIndex = _findToken3.index,
      blockStart = _findToken3.token;

  var _findEndBraceTokenBal = findEndBraceTokenBalanced(tokens, blockStartIndex),
      blockEnd = _findEndBraceTokenBal.token;

  return {
    fn: fn,
    paramsStart: paramsStart,
    paramsEnd: paramsEnd,
    blockStart: blockStart,
    blockEnd: blockEnd
  };
}

function bodyNeedsParens(body, source) {
  return source[body.start] === '{';
}



var functionsArrow = Object.freeze({
	name: name,
	description: description,
	visitor: visitor
});

// FIXME: This is only capable of unindenting one level.
function unindent(magicString) {
  var original = magicString.original;

  var indentString = magicString.getIndentString();

  var atStartOfLine = true;
  for (var i = 0; i < original.length; i++) {
    if (original[i] === '\n' || original[i] === '\r') {
      atStartOfLine = true;
    } else if (atStartOfLine) {
      atStartOfLine = false;
      if (original.slice(i, i + indentString.length) === indentString) {
        magicString.remove(i, i + indentString.length);
      }
    }
  }
}

/**
 * Represents a module binding for either an import or export statement.
 */
var Binding = function () {
  function Binding(localName, exportName) {
    classCallCheck(this, Binding);

    this.localName = localName;
    this.exportName = exportName;
  }

  createClass(Binding, [{
    key: 'isAliased',
    value: function isAliased() {
      return this.localName !== this.exportName;
    }
  }, {
    key: 'isDefaultExport',
    value: function isDefaultExport() {
      return this.exportName === 'default';
    }
  }]);
  return Binding;
}();

/**
 * Builds an export specifier list string for use in an export statement.
 */
var ExportSpecifierListStringBuilder = function () {
  function ExportSpecifierListStringBuilder(bindings) {
    classCallCheck(this, ExportSpecifierListStringBuilder);

    this.bindings = bindings;
  }

  createClass(ExportSpecifierListStringBuilder, [{
    key: 'toString',
    value: function toString() {
      return '{ ' + this.bindings.map(function (binding) {
        if (!binding.isAliased()) {
          return binding.localName;
        } else {
          return binding.localName + ' as ' + binding.exportName;
        }
      }).join(', ') + ' }';
    }
  }], [{
    key: 'build',
    value: function build(bindings) {
      return new ExportSpecifierListStringBuilder(bindings).toString();
    }
  }]);
  return ExportSpecifierListStringBuilder;
}();

/**
 * Builds an import specifier list string for use in an import statement.
 */
var ImportSpecifierListStringBuilder = function () {
  function ImportSpecifierListStringBuilder(bindings) {
    classCallCheck(this, ImportSpecifierListStringBuilder);

    this.bindings = bindings;
  }

  createClass(ImportSpecifierListStringBuilder, [{
    key: 'toString',
    value: function toString() {
      var defaultBinding = void 0;
      var namedBindings = [];

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.bindings[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var binding = _step.value;

          if (binding.isDefaultExport()) {
            defaultBinding = binding;
          } else {
            namedBindings.push(binding);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var result = '';

      var hasNamedBindings = namedBindings.length > 0;
      if (defaultBinding) {
        result += defaultBinding.localName;
        if (hasNamedBindings) {
          result += ', ';
        }
      }

      if (hasNamedBindings) {
        result += '{ ' + namedBindings.map(function (binding) {
          if (!binding.isAliased()) {
            return binding.localName;
          } else {
            return binding.exportName + ' as ' + binding.localName;
          }
        }).join(', ') + ' }';
      }

      return result;
    }
  }], [{
    key: 'build',
    value: function build(bindings) {
      return new ImportSpecifierListStringBuilder(bindings).toString();
    }
  }]);
  return ImportSpecifierListStringBuilder;
}();

function claim(scope) {
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'ref';

  if (isUsedName(scope, name)) {
    var suffix = 1;
    var prefix = name;
    do {
      name = prefix + '$' + suffix++;
    } while (isUsedName(scope, name));
  }

  var program = scope.getProgramParent();
  program.references[name] = true;
  program.uids[name] = true;
  return t.identifier(name);
}

function isDeclaredName(scope, name) {
  return scope.hasBinding(name);
}

function isUsedName(scope, name) {
  return scope.hasBinding(name) || scope.hasGlobal(name)
  // FIXME: Do we want this?
  // scope.hasReference(name)
  ;
}

var name$1 = 'modules.commonjs';
var description$1 = 'Transform CommonJS modules into ES6 modules.';

function visitor$1(module) {
  metadata$1(module);

  return {
    Program: function Program(path$$1) {
      unwrapIIFE(path$$1, module);
      removeUseStrictDirective(path$$1, module);
      rewriteImportsAndExports(path$$1, module);
    },
    ReferencedIdentifier: function ReferencedIdentifier(path$$1) {
      // TODO: Warn about `require`, `module`, and `exports` global references.
      var node = path$$1.node;


      if (node.name === 'require' && !path$$1.scope.hasBinding('require')) {
        var source = extractRequirePathNode(path$$1.parent);

        if (source) {
          module.warn(path$$1.parent, 'unsupported-import', 'Unsupported \'require\' call cannot be transformed into an import');
        }
      } else if (node.name === 'exports') {
        module.warn(node, 'unsupported-export', 'Unsupported export cannot be turned into an \'export\' statement');
      }
    }
  };
}

/**
 * Unwrap an IIFE at program scope if that's the only thing that's there.
 *
 *   (function() {
 *     // All program body here.
 *   })();
 */
function unwrapIIFE(path$$1, module) {
  var node = path$$1.node;

  var iife = extractModuleIIFE(node);

  if (!iife) {
    return;
  }

  var _node$body = slicedToArray(node.body, 1),
      statement = _node$body[0];

  var body = iife.body.body;


  node.body = body;
  metadata$1(module).unwrapped = cleanNode(iife);

  var tokens = module.tokensForNode(iife);
  var iifeHeaderEnd = body[0].start;

  var _findToken = findToken('{', tokens),
      iifeBlockStartIndex = _findToken.index,
      iifeBlockStart = _findToken.token;

  for (var p = iifeBlockStart.end; p < iifeHeaderEnd; p++) {
    if (module.source.charAt(p) === '\n') {
      iifeHeaderEnd = p + 1;
      break;
    }
  }

  var iifeFooterStart = body[body.length - 1].end;

  var _findEndTokenBalanced = findEndTokenBalanced('{', '}', tokens, iifeBlockStartIndex),
      iifeBlockEnd = _findEndTokenBalanced.token;

  for (var _p = iifeBlockEnd.start; _p > iifeFooterStart; _p--) {
    if (module.source.charAt(_p) === '\n') {
      if (module.source.charAt(_p) === '\r') {
        _p--;
      }
      iifeFooterStart = _p;
      break;
    }
  }

  // `(function() {\n  foo();\n})();` -> `foo();`
  //  ^^^^^^^^^^^^^^^^^      ^^^^^^^
  module.magicString.remove(statement.start, iifeHeaderEnd);
  module.magicString.remove(iifeFooterStart, statement.end);
  unindent(module.magicString);
}

/**
 * Remove a 'use strict' directive in `path`'s body.
 */
function removeUseStrictDirective(path$$1, module) {
  var directives = path$$1.node.directives;

  for (var i = 0; i < directives.length; i++) {
    var directive = directives[i];

    if (directive.value.value === 'use strict') {
      var start = directive.start,
          end = directive.end;

      // Eat any trailing newlines.

      while (module.source.charAt(end) === '\n') {
        end++;
      }

      module.magicString.remove(start, end);
      directives.splice(i, 1);
      metadata$1(module).directives.push(cleanNode(directive));
    }
  }
}

/**
 * Re-write requires as imports/exports and exports sets as export statements.
 */
function rewriteImportsAndExports(path$$1, module) {
  var body = path$$1.get('body');

  if (!Array.isArray(body)) {
    throw new Error('expected body paths from program node, got: ' + body);
  }

  body.forEach(function (statement) {
    return rewriteAsExport(statement, module) || rewriteAsImport(statement, module);
  });
}

function rewriteAsExport(path$$1, module) {
  var node = path$$1.node;


  if (!t.isExpressionStatement(node)) {
    return false;
  }

  var expression = node.expression;


  if (!t.isAssignmentExpression(expression)) {
    return false;
  }

  var left = expression.left,
      right = expression.right;


  if (isExportsObject(path$$1.get('expression.left'))) {
    return rewriteSingleExportAsDefaultExport(path$$1, module);
  } else if (t.isMemberExpression(left) && !left.computed) {
    if (!isExportsObject(path$$1.get('expression.left.object'))) {
      return false;
    }

    if (t.isFunctionExpression(right)) {
      return rewriteNamedFunctionExpressionExport(path$$1, module);
    } else if (t.isIdentifier(right)) {
      return rewriteNamedIdentifierExport(path$$1, module);
    } else {
      return rewriteNamedValueExport(path$$1, module);
    }
  } else {
    return false;
  }
}

function isExportsObject(path$$1) {
  var node = path$$1.node;


  if (t.isMemberExpression(node)) {
    return !path$$1.scope.hasBinding('module') && t.isIdentifier(node.object, { name: 'module' }) && t.isIdentifier(node.property, { name: 'exports' });
  } else if (t.isIdentifier(node, { name: 'exports' })) {
    return !path$$1.scope.hasBinding('exports');
  } else {
    return t.isThisExpression(node);
  }
}

function isSimpleObjectExpression(node) {
  if (!t.isObjectExpression(node)) {
    return false;
  }
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = node.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var property = _step.value;

      if (!t.isObjectProperty(property) || !t.isIdentifier(property.key) || !t.isIdentifier(property.value)) {
        return false;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return true;
}

function rewriteSingleExportAsDefaultExport(path$$1, module) {
  var node = path$$1.node,
      right = path$$1.node.expression.right;


  if (isSimpleObjectExpression(right)) {
    var _bindings = [];

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = right.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _step2$value = _step2.value,
            key = _step2$value.key,
            value = _step2$value.value;

        _bindings.push(new Binding(value.name, key.name));
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    metadata$1(module).exports.push({
      type: 'named-export',
      bindings: _bindings,
      node: cleanNode(node)
    });

    module.magicString.overwrite(node.start, node.end, 'export ' + ExportSpecifierListStringBuilder.build(_bindings) + ';');

    path$$1.replaceWith(t.exportNamedDeclaration(null, _bindings.map(function (binding) {
      return t.exportSpecifier(t.identifier(binding.localName), t.identifier(binding.exportName));
    }), null));
  } else {
    var _pathNode = extractRequirePathNode(right);

    if (_pathNode) {
      module.magicString.overwrite(node.expression.start, node.expression.end, 'export * from ' + module.source.slice(_pathNode.start, _pathNode.end));

      metadata$1(module).exports.push({
        type: 'namespace-export',
        bindings: [],
        node: cleanNode(node)
      });

      path$$1.replaceWith(t.exportAllDeclaration(_pathNode));
    } else {
      metadata$1(module).exports.push({ type: 'default-export', node: cleanNode(node) });

      var equalsToken = findToken('=', module.tokensForNode(node));
      var equalsEnd = equalsToken.token.end;
      if (module.magicString.slice(equalsEnd, equalsEnd + 1) === ' ') {
        equalsEnd++;
      }
      module.magicString.overwrite(node.start, equalsEnd, 'export default ');

      path$$1.replaceWith(t.exportDefaultDeclaration(right));
    }
  }

  return true;
}

function rewriteNamedFunctionExpressionExport(path$$1, module) {
  var node = path$$1.node,
      _path$node$expression = path$$1.node.expression,
      exportName = _path$node$expression.left.property.name,
      right = _path$node$expression.right,
      id = _path$node$expression.right.id;


  var fnBinding = id ? id.name : null;
  var localId = claim(path$$1.scope, fnBinding || exportName);
  var localName = localId.name;

  metadata$1(module).exports.push({
    type: 'named-export',
    bindings: [{
      exportName: exportName,
      localName: localName
    }],
    node: cleanNode(node)
  });

  var isFunctionDeclaration = true;

  if (localName === exportName) {
    // `exports.foo = function foo() {}` → `export function foo() {}`
    //  ^^^^^^^^^^^^^^                      ^^^^^^^
    module.magicString.overwrite(node.start, right.start, 'export ');

    if (!id) {
      module.magicString.appendLeft(right.start + 'function'.length, ' ' + localName);
      right.id = t.identifier(exportName);
    }

    right.type = 'FunctionDeclaration';
    right.expression = false;
    right.id = t.identifier(exportName);
    delete right.start;
    delete right.end;

    path$$1.replaceWith(t.exportNamedDeclaration(right, [], null));
  } else {
    var declaration = right;

    if (!id) {
      module.magicString.remove(node.start, right.start);
      module.magicString.appendLeft(right.start + 'function'.length, ' ' + localName);
      right.type = 'FunctionDeclaration';
      right.id = localId;
    } else if (fnBinding === localName) {
      right.type = 'FunctionDeclaration';
      module.magicString.remove(node.start, right.start);
    } else {
      isFunctionDeclaration = false;
      module.magicString.overwrite(node.start, right.start, 'let ' + localName + ' = ');
      declaration = t.variableDeclaration('let', [t.variableDeclarator(localId, right)]);
    }

    module.magicString.appendRight(node.end, '\nexport { ' + localName + ' as ' + exportName + ' };');

    path$$1.replaceWithMultiple([declaration, t.exportNamedDeclaration(null, [t.exportSpecifier(localId, t.identifier(exportName))])]);
  }

  if (isFunctionDeclaration) {
    var lastCharacterPosition = node.end - 1;

    if (module.source.charAt(lastCharacterPosition) === ';') {
      module.magicString.remove(lastCharacterPosition, node.end);
    }
  }
}

function rewriteNamedIdentifierExport(path$$1, module) {
  var node = path$$1.node,
      _path$node$expression2 = path$$1.node.expression,
      property = _path$node$expression2.left.property,
      right = _path$node$expression2.right;


  var replacements = void 0;
  var localBinding = void 0;

  if (isDeclaredName(path$$1.scope, right.name)) {
    localBinding = right.name;

    if (right.name === property.name) {
      module.magicString.overwrite(node.start, node.end, 'export { ' + right.name + ' };');
    } else {
      module.magicString.overwrite(node.start, node.end, 'export { ' + right.name + ' as ' + property.name + ' };');
    }

    replacements = [t.exportNamedDeclaration(null, [t.exportSpecifier(right, property)], null)];
  } else {
    localBinding = claim(path$$1.scope, property.name).name;

    if (localBinding === property.name) {
      module.magicString.overwrite(node.start, right.start, 'export let ' + localBinding + ' = ');
      replacements = [t.exportNamedDeclaration(t.variableDeclaration('let', [t.variableDeclarator(t.identifier(localBinding), right)]), [], null)];
    } else {
      module.magicString.overwrite(node.start, right.start, 'let ' + localBinding + ' = ');
      module.magicString.appendRight(node.end, '\nexport { ' + localBinding + ' as ' + property.name + ' };');
      replacements = [t.variableDeclaration('let', [t.variableDeclarator(t.identifier(localBinding), right)]), t.exportNamedDeclaration(null, [t.exportSpecifier(t.identifier(localBinding), property)], null)];
    }
  }

  metadata$1(module).exports.push({
    type: 'named-export',
    bindings: [{
      exportName: property.name,
      localName: localBinding
    }],
    node: cleanNode(node)
  });

  path$$1.replaceWithMultiple(replacements);

  return true;
}

function rewriteNamedValueExport(path$$1, module) {
  var node = path$$1.node,
      _path$node$expression3 = path$$1.node.expression,
      property = _path$node$expression3.left.property,
      right = _path$node$expression3.right;

  var localBinding = claim(path$$1.scope, property.name).name;

  metadata$1(module).exports.push({
    type: 'named-export',
    bindings: [{
      exportName: property.name,
      localName: localBinding
    }],
    node: cleanNode(node)
  });

  if (localBinding === property.name) {
    // `exports.foo = 99;` → `export let foo = 99;`
    //  ^^^^^^^^              ^^^^^^^^^^^
    module.magicString.overwrite(node.start, property.start, 'export let ');

    path$$1.replaceWith(t.exportNamedDeclaration(t.variableDeclaration('let', [t.variableDeclarator(t.identifier(property.name), right)]), [], null));
  } else {
    // `exports.foo = 99;` → `let foo$1 = 99;`
    //  ^^^^^^^^^^^^^^        ^^^^^^^^^^^^
    module.magicString.overwrite(node.start, right.start, 'let ' + localBinding + ' = ');

    var nodeIndex = path$$1.parent.body.indexOf(node);

    if (nodeIndex < 0) {
      throw new Error('could not locate ' + node.type + ' at ' + node.line + ':' + node.column + ' in its parent block');
    }

    var nextStatement = path$$1.parent.body[nodeIndex + 1];

    // `export { foo$1 as foo };`
    var exportStatement = 'export { ' + localBinding + ' as ' + property.name + ' };';

    if (nextStatement) {
      // Insert before the next statement…
      module.magicString.appendRight(nextStatement.start, exportStatement + '\n');
    } else {
      // …or after the last one of the program.
      module.magicString.appendLeft(node.end, '\n' + exportStatement);
    }

    path$$1.replaceWithMultiple([t.variableDeclaration('let', [t.variableDeclarator(t.identifier(localBinding), right)]), t.exportNamedDeclaration(null, [t.exportSpecifier(t.identifier(localBinding), t.identifier(property.name))], null)]);
  }

  return true;
}

function rewriteAsImport(path$$1, module) {
  if (isDeclaredName(path$$1.scope, 'require')) {
    return false;
  }

  return rewriteSingleExportRequire(path$$1, module) || rewriteNamedExportRequire(path$$1, module) || rewriteDeconstructedImportRequire(path$$1, module) || rewriteSideEffectRequire(path$$1, module);
}

function rewriteSingleExportRequire(path$$1, module) {
  var node = path$$1.node;


  if (!t.isVariableDeclaration(node)) {
    return false;
  }

  var declarations = node.declarations;

  var extractableDeclarations = [];

  declarations.forEach(function (declaration) {
    var id = declaration.id,
        init = declaration.init;


    if (!t.isIdentifier(id)) {
      return;
    }

    var pathNode = extractRequirePathNode(init);

    if (!pathNode) {
      return;
    }

    extractableDeclarations.push({
      declaration: declaration, id: id, pathNode: pathNode
    });
  });

  if (declarations.length === 0) {
    return false;
  }

  if (declarations.length !== extractableDeclarations.length) {
    // TODO: We have to replace only part of it.
    return false;
  }

  rewriteRequireAsImports('default-import', path$$1, module, extractableDeclarations.map(function (_ref) {
    var id = _ref.id,
        pathNode = _ref.pathNode;
    return {
      bindings: [new Binding(id.name, 'default')],
      pathNode: pathNode
    };
  }));

  path$$1.replaceWithMultiple(extractableDeclarations.map(function (_ref2) {
    var id = _ref2.id,
        pathNode = _ref2.pathNode;
    return t.importDeclaration([t.importDefaultSpecifier(id)], pathNode);
  }));

  return true;
}

function rewriteNamedExportRequire(path$$1, module) {
  var declaration = extractSingleDeclaration(path$$1.node);

  if (!declaration) {
    return false;
  }

  var id = declaration.id,
      init = declaration.init;


  if (!t.isIdentifier(id) || !init || !t.isMemberExpression(init) || init.computed) {
    return false;
  }

  var pathNode = extractRequirePathNode(init.object);

  if (!pathNode) {
    return false;
  }

  rewriteRequireAsImport('named-import', path$$1, module, [new Binding(id.name, init.property.name)], pathNode);

  path$$1.replaceWith(t.importDeclaration([t.importSpecifier(id, init.property)], pathNode));

  return true;
}

function rewriteDeconstructedImportRequire(path$$1, module) {
  var declaration = extractSingleDeclaration(path$$1.node);

  if (!declaration) {
    return false;
  }

  var id = declaration.id,
      init = declaration.init;


  if (!t.isObjectPattern(id)) {
    return false;
  }

  var bindings = [];

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = id.properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var _step3$value = _step3.value,
          key = _step3$value.key,
          value = _step3$value.value;

      if (!t.isIdentifier(value)) {
        return false;
      }
      bindings.push(new Binding(value.name, key.name));
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  var pathNode = extractRequirePathNode(init);

  if (!pathNode) {
    return false;
  }

  rewriteRequireAsImport('named-import', path$$1, module, bindings, pathNode);

  path$$1.replaceWith(t.importDeclaration(bindings.map(function (binding) {
    return t.importSpecifier(t.identifier(binding.localName), t.identifier(binding.exportName));
  }), pathNode));

  return true;
}

function rewriteSideEffectRequire(path$$1, module) {
  var node = path$$1.node;


  if (!t.isExpressionStatement(node)) {
    return false;
  }

  var pathNode = extractRequirePathNode(node.expression);

  if (!pathNode) {
    return false;
  }

  rewriteRequireAsImport('bare-import', path$$1, module, [], pathNode);

  path$$1.replaceWith(t.importDeclaration([], pathNode));

  return true;
}

function rewriteRequireAsImport(type, path$$1, module, bindings, pathNode) {
  rewriteRequireAsImports(type, path$$1, module, [{ bindings: bindings, pathNode: pathNode }]);
}

function rewriteRequireAsImports(type, path$$1, module, imports) {
  var node = path$$1.node;

  var importStatements = [];

  imports.forEach(function (_ref3) {
    var bindings = _ref3.bindings,
        pathNode = _ref3.pathNode;

    metadata$1(module).imports.push({
      type: type,
      node: cleanNode(node),
      bindings: bindings,
      path: pathNode.value
    });

    var pathString = module.source.slice(pathNode.start, pathNode.end);

    if (bindings.length === 0) {
      importStatements.push('import ' + pathString + ';');
    } else {
      importStatements.push('import ' + ImportSpecifierListStringBuilder.build(bindings) + ' from ' + pathString + ';');
    }
  });

  module.magicString.overwrite(node.start, node.end, importStatements.join('\n'));
}

function metadata$1(module) {
  if (!module.metadata[name$1]) {
    module.metadata[name$1] = {
      imports: [],
      exports: [],
      directives: []
    };
  }
  return module.metadata[name$1];
}

function extractSingleDeclaration(node) {
  if (!t.isVariableDeclaration(node)) {
    return null;
  }

  if (node.declarations.length !== 1) {
    return null;
  }

  return node.declarations[0];
}

function extractRequirePathNode(node) {
  if (!node || !t.isCallExpression(node)) {
    return null;
  }

  if (!t.isIdentifier(node.callee, { name: 'require' })) {
    return null;
  }

  if (node.arguments.length !== 1) {
    return null;
  }

  var arg = node.arguments[0];

  if (!t.isStringLiteral(arg)) {
    return null;
  }

  return arg;
}

/**
 * @private
 */
function extractModuleIIFE(node) {
  if (!t.isProgram(node)) {
    return null;
  }

  if (node.body.length !== 1) {
    return null;
  }

  var _node$body2 = slicedToArray(node.body, 1),
      statement = _node$body2[0];

  if (!t.isExpressionStatement(statement)) {
    return null;
  }

  var call = statement.expression;


  if (t.isUnaryExpression(call) && call.operator === 'void') {
    // e.g. `void function(){}();`
    call = call.argument;
  }

  if (!t.isCallExpression(call)) {
    return null;
  }

  var _call = call,
      callee = _call.callee,
      args = _call.arguments;


  var iife = void 0;

  if (t.isFunctionExpression(callee)) {
    // e.g. `(function() {})();`
    if (args.length !== 0) {
      return null;
    }

    iife = callee;
  } else if (t.isMemberExpression(callee)) {
    // e.g. `(function() {}).call(this);`
    var object = callee.object,
        property = callee.property,
        computed = callee.computed;


    if (computed || !t.isFunctionExpression(object)) {
      return null;
    }

    if (!t.isIdentifier(property, { name: 'call' })) {
      return null;
    }

    if (args.length !== 1 || !t.isThisExpression(args[0])) {
      return null;
    }

    iife = object;
  } else {
    return null;
  }

  if (iife.id || iife.params.length > 0 || iife.generator) {
    return null;
  }

  return iife;
}



var modulesCommonjs = Object.freeze({
	name: name$1,
	description: description$1,
	visitor: visitor$1
});

/**
 * Determines the most restrictive declaration kind for a variable declaration.
 * `const` is preferred, followed by `let` if one or more bindings are
 * reassigned, then `var` if block scoping cannot be used.
 */
function mostRestrictiveKindForDeclaration(path$$1) {
  var ids = path$$1.getBindingIdentifiers();
  var scope = path$$1.scope;

  var isConst = path$$1.node.declarations.every(function (declaration) {
    return declaration.init;
  });

  for (var id in ids) {
    var binding = scope.getBinding(id);

    // Does this binding disqualify block scoping for this declaration entirely?
    if (!bindingCouldBeBlockScope(binding)) {
      return 'var';
    }

    // Is this binding reassigned?
    if (isConst && !binding.constant) {
      isConst = false;
    }
  }

  return isConst ? 'const' : 'let';
}

/**
 * Does this binding meet the requirements for block scoping?
 */
function bindingCouldBeBlockScope(binding) {
  // Are there duplicate declarations?
  if (binding.constantViolations.some(function (path$$1) {
    return t.isVariableDeclarator(path$$1.node);
  })) {
    return false;
  }

  var definition = binding.path;
  var definitionBlockParent = definition.findParent(function (path$$1) {
    return path$$1.isBlockParent();
  });

  if ([].concat(toConsumableArray(binding.referencePaths), toConsumableArray(binding.constantViolations)).some(function (reference) {
    return (
      // Does this reference come before the definition?
      reference.node.start < definition.node.start ||
      // Does this reference exist outside the declaration block?
      !reference.isDescendant(definitionBlockParent) ||
      // Is this reference the initial binding value?
      reference === binding.path.get('init') ||
      // Is this reference inside the initial binding value?
      reference.isDescendant(binding.path.get('init'))
    );
  })) {
    return false;
  }

  var functionParent = definition.getFunctionParent();
  var loopParent = definition.findParent(function (path$$1) {
    return path$$1.isLoop();
  });

  // Is this declaration within a loop in the current function scope?
  if (loopParent !== null && loopParent.isDescendant(functionParent)) {
    // Is any reference within a closure?
    if (binding.referencePaths.some(function (reference) {
      return reference.getFunctionParent() !== functionParent;
    })) {
      return false;
    }

    if (!isBindingAssignedBeforeUse(binding)) {
      return false;
    }
  }

  return true;
}

/**
 * Return true if we can statically determine that this variable always assigned
 * a value in its block before it is used. In other words, check if we can be
 * sure that the variable will never hold a value from a previous loop
 * iteration.
 */
function isBindingAssignedBeforeUse(binding) {
  // Loop assignees are always initialized before use.
  var loopParent = binding.path.findParent(function (path$$1) {
    return path$$1.isLoop();
  });
  if (loopParent !== null) {
    if (loopParent.isForAwaitStatement() || loopParent.isForInStatement() || loopParent.isForOfStatement()) {
      if (binding.path.isDescendant(loopParent.get('left'))) {
        return true;
      }
    }
  }

  // Variables with an explicit init are always assigned before use.
  if (binding.path.isVariableDeclarator() && binding.path.node.init !== null) {
    return true;
  }

  // Find simple top-level assignments that occur before all usages. This could
  // theoretically be extended to do more advanced static analysis, e.g.
  // traversing into conditional blocks and ternary expressions to see if all
  // code paths assign to this variable, but this should get the common case.
  var blockParent = binding.path.findParent(function (path$$1) {
    return path$$1.isBlockParent();
  });
  var earliestUsage = Math.min.apply(Math, toConsumableArray(binding.referencePaths.map(function (reference) {
    return reference.node.start;
  })));
  if (binding.constantViolations.some(function (path$$1) {
    return path$$1.node.end < earliestUsage && path$$1.isAssignmentExpression() && path$$1.parentPath.isExpressionStatement() && path$$1.parentPath.parentPath === blockParent;
  })) {
    return true;
  }

  return false;
}

var name$2 = 'declarations.block-scope';
var description$2 = 'Transform `var` into `let` and `const` as appropriate.';

function visitor$2(module) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _metadata = metadata$2(module),
      declarations = _metadata.declarations;

  return {
    VariableDeclaration: function VariableDeclaration(path$$1) {
      var node = path$$1.node;


      if (node.kind !== 'var') {
        return;
      }

      var kind = mostRestrictiveKindForDeclaration(path$$1);

      if (kind !== 'var') {
        if (kind === 'const' && !constAllowed(path$$1, options)) {
          kind = 'let';
        }
        module.magicString.overwrite(node.start, node.start + 'var'.length, kind);
        declarations.push(cleanNode(node));
        node.kind = kind;
      } else {
        module.warn(node, 'unsupported-declaration', '\'var\' declaration cannot be converted to block scope');
      }
    }
  };
}

/**
 * Delegates to user-supplied options to determine whether `let` is allowed.
 */
function constAllowed(path$$1, options) {
  var disableConst = options.disableConst;

  if (typeof disableConst === 'function') {
    return !disableConst(path$$1);
  } else {
    return !disableConst;
  }
}

function metadata$2(module) {
  if (!module.metadata[name$2]) {
    module.metadata[name$2] = { declarations: [] };
  }
  return module.metadata[name$2];
}

var declarationsBlockScope = Object.freeze({
	name: name$2,
	description: description$2,
	visitor: visitor$2
});

var name$3 = 'objects.destructuring';
var description$3 = 'Transform some declarations and assignments to the more compact destructuring form.';

function visitor$3(module) {
  var meta = metadata$3(module);

  return {
    VariableDeclaration: function VariableDeclaration(path$$1) {
      var node = path$$1.node;


      for (var index = 0; index < node.declarations.length; index++) {
        var elements = extractSequentialDestructurableElements(module, node.declarations, index);
        rewriteDestructurableElements(module, elements);

        if (elements.length !== 0) {
          // Add information about the transformation.
          meta.push({
            ids: elements.map(function (_ref) {
              var id = _ref.id;
              return cleanNode(id);
            }),
            inits: elements.map(function (_ref2) {
              var init = _ref2.init;
              return cleanNode(init);
            })
          });

          // Mutate the AST to reflect the new reality.
          node.declarations.splice(index, elements.length, t.variableDeclarator(t.objectPattern(elements.map(function (declarator) {
            return t.objectProperty(declarator.id, declarator.id, false, true);
          })), elements[0].init.object));
        }
      }
    },
    AssignmentExpression: function AssignmentExpression(path$$1) {
      if (!t.isExpressionStatement(path$$1.parent)) {
        return;
      }

      var node = path$$1.node;

      var assignments = extractSequentialDestructurableElements(module, [node]);

      if (assignments.length === 0) {
        return;
      }

      // `a = obj.a;` -> `(a = obj.a);`
      //                  ^         ^
      module.magicString.appendLeft(assignments[0].start, '(');
      module.magicString.appendRight(assignments[assignments.length - 1].end, ')');

      rewriteDestructurableElements(module, assignments);

      // Add information about the transformation.
      meta.push({
        ids: assignments.map(function (assignment) {
          return cleanNode(assignment.left);
        }),
        inits: assignments.map(function (assignment) {
          return cleanNode(assignment.right);
        })
      });

      path$$1.replaceWith(t.assignmentExpression('=', t.objectPattern(assignments.map(function (assignment) {
        return t.objectProperty(t.identifier(assignment.left.name), t.identifier(assignment.left.name), false, true);
      })), node.right.object));
    },
    SequenceExpression: function SequenceExpression(path$$1) {
      var expressions = path$$1.node.expressions;


      for (var index = 0; index < expressions.length; index++) {
        var assignments = extractSequentialDestructurableElements(module, expressions, index);

        if (assignments.length > 0 && index === 0) {
          // `a = obj.a;` -> `(a = obj.a);`
          module.magicString.appendLeft(assignments[0].start, '(');
          module.magicString.appendRight(assignments[assignments.length - 1].end, ')');
        }

        if (assignments.length > 0) {
          rewriteDestructurableElements(module, assignments);

          meta.push({
            ids: assignments.map(function (assignment) {
              return cleanNode(assignment.left);
            }),
            inits: assignments.map(function (assignment) {
              return cleanNode(assignment.right);
            })
          });

          expressions.splice(index, assignments.length, t.assignmentExpression('=', t.objectPattern(assignments.map(function (_ref3) {
            var left = _ref3.left;
            return t.objectProperty(left, left, false, true);
          })), assignments[0].right.object));
        }
      }

      if (expressions.length === 1) {
        path$$1.replaceWith(expressions[0]);
      }
    }
  };
}

function extractSequentialDestructurableElements(module, elements) {
  var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  var result = [];
  var objectSource = null;

  for (var i = start; i < elements.length; i++) {
    var element = elements[i];

    var _ref4 = leftRightOfAssignment(element) || {},
        _left = _ref4.left,
        _right = _ref4.right;

    if (!t.isIdentifier(_left)) {
      break;
    }

    if (!t.isMemberExpression(_right)) {
      break;
    }

    if (_right.computed) {
      break;
    }

    if (_left.name !== _right.property.name) {
      break;
    }

    var thisObjectSource = module.sourceOf(_right.object);

    if (!objectSource) {
      objectSource = thisObjectSource;
    } else if (objectSource !== thisObjectSource) {
      break;
    }

    result.push(element);

    if (!isSafeToConsolidate(_right.object)) {
      break;
    }
  }

  return result;
}

function rewriteDestructurableElements(module, elements) {
  if (elements.length === 0) {
    return;
  }

  var firstElement = elements[0];

  // `const a = obj.a, b = obj.b;` -> `const { a = obj.a, b = obj.b;`
  //                                         ^^
  module.magicString.appendLeft(leftRightOfAssignment(firstElement).left.start, '{ ');

  for (var i = 0; i < elements.length - 1; i++) {
    var _leftRightOfAssignmen = leftRightOfAssignment(elements[i]),
        _left2 = _leftRightOfAssignmen.left,
        _right2 = _leftRightOfAssignmen.right;
    // `const { a = obj.a, b = obj.b;` -> `const { a, b = obj.b;`
    //           ^^^^^^^^


    module.magicString.remove(_left2.end, _right2.end);
  }

  var lastElement = elements[elements.length - 1];

  var _leftRightOfAssignmen2 = leftRightOfAssignment(lastElement),
      lastLeft = _leftRightOfAssignmen2.left,
      lastRight = _leftRightOfAssignmen2.right;

  // `const { a, b = obj.b;` -> `const { a, b } = obj.b;`
  //                                         ^^


  module.magicString.appendRight(lastLeft.end, ' }');

  var dotToken = getDotToken(module, lastRight);
  // `const { a, b } = obj.b;` -> `const { a, b } = obj;`
  //                      ^^
  module.magicString.remove(dotToken.start, lastRight.end);
}

function getDotToken(module, memberAccessExpression) {
  var intermediateTokens = module.tokensInRange(memberAccessExpression.object.end, memberAccessExpression.property.start);
  var dotTokenIndex = intermediateTokens.length - 1;
  while (dotTokenIndex >= 0 && intermediateTokens[dotTokenIndex].type.label !== '.') {
    dotTokenIndex -= 1;
  }
  if (dotTokenIndex < 0) {
    throw new Error('Expected to find a dot token in a member access expression.');
  }
  return intermediateTokens[dotTokenIndex];
}

function metadata$3(module) {
  if (!module.metadata[name$3]) {
    module.metadata[name$3] = [];
  }
  return module.metadata[name$3];
}

function leftRightOfAssignment(node) {
  if (t.isVariableDeclarator(node)) {
    return { left: node.id, right: node.init };
  } else if (t.isAssignmentExpression(node) && node.operator === '=') {
    return { left: node.left, right: node.right };
  } else {
    return null;
  }
}

function isSafeToConsolidate(node) {
  return t.isIdentifier(node);
}

var objectsDestructuring = Object.freeze({
	name: name$3,
	description: description$3,
	visitor: visitor$3
});

function escape(char, start, end, charAt, insert) {
  for (var i = start; i < end; i++) {
    if (charAt(i) === char) {
      // If this character is preceded by an odd number of backslashes, then it
      // is already escaped, so we shouldn't add another backslash.
      var numPrecedingBackslashes = 0;
      while (i - numPrecedingBackslashes - 1 >= start && charAt(i - numPrecedingBackslashes - 1) === '\\') {
        numPrecedingBackslashes++;
      }
      if (numPrecedingBackslashes % 2 == 0) {
        insert(i, '\\');
      }
    }
  }
}

function escapeString(char, string) {
  var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var end = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : string.length;
  var magicString = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new MagicString(string);

  escape(char, start, end, function (index) {
    return string[index];
  }, function (index, string) {
    return magicString.appendRight(index, string);
  });
  return magicString.toString();
}

function unescape(char, start, end, charAt, remove) {
  for (var i = start; i < end; i++) {
    if (charAt(i) === '\\' && charAt(i + 1) === char) {
      remove(i, i + 1);
      i++;
    }
  }
}

function unescapeString(char, string) {
  var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var end = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : string.length;
  var magicString = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new MagicString(string);

  unescape(char, start, end, function (index) {
    return string[index];
  }, function (start, end) {
    return magicString.remove(start, end);
  });
  return magicString.toString();
}

var name$4 = 'strings.template';
var description$4 = 'Transforms manual string concatenation into template strings.';

function visitor$4(module) {
  var meta = metadata$4(module);

  return {
    BinaryExpression: function BinaryExpression(path$$1) {
      var node = path$$1.node;

      var parts = flatten(node);

      if (parts) {
        meta.concatenations.push({
          node: cleanNode(node),
          parts: parts.map(cleanNode)
        });

        path$$1.replaceWith(combine(module, node, parts));
      }
    }
  };
}

function flatten(node) {
  if (!t.isBinaryExpression(node) || node.operator !== '+') {
    return null;
  }

  if (node.loc.start.line !== node.loc.end.line) {
    return null;
  }

  var left = node.left,
      right = node.right;

  // A string ending with \0 could make an octal literal if combined with
  // the next string, so just ignore it.

  if (t.isStringLiteral(left) && left.value.endsWith('\0') || t.isStringLiteral(right) && right.value.endsWith('\0')) {
    return null;
  }

  if (t.isStringLiteral(left)) {
    // This is the root.
    return [left, right];
  } else {
    // We need to go deeper.
    var flattenedLeft = flatten(left);

    if (!flattenedLeft) {
      return null;
    }

    return [].concat(toConsumableArray(flattenedLeft), [right]);
  }
}

function combine(module, node, parts) {
  var annotatedParts = parts.map(function (part, i) {
    var previousPart = parts[i - 1];
    var nextPart = parts[i + 1];
    var annotatedPart = {
      node: part,
      prefix: '',
      suffix: ''
    };

    if (previousPart) {
      var _insignificantContent = insignificantContentSeparatedByPlus(module, previousPart, part),
          _insignificantContent2 = slicedToArray(_insignificantContent, 2),
          prefix = _insignificantContent2[1];

      annotatedPart.prefix = prefix.replace(/^\s*/, '');
    }

    if (nextPart) {
      var _insignificantContent3 = insignificantContentSeparatedByPlus(module, part, nextPart),
          _insignificantContent4 = slicedToArray(_insignificantContent3, 1),
          suffix = _insignificantContent4[0];

      annotatedPart.suffix = suffix.replace(/\s*$/, '');
    }

    return annotatedPart;
  });

  if (annotatedParts.every(function (part) {
    return t.isStringLiteral(part.node) && !part.prefix && !part.suffix;
  })) {
    return combineStrings(module, parts);
  } else {
    return buildTemplateString(module, node, annotatedParts);
  }
}

function combineStrings(module, parts) {
  var quote = module.source.charAt(parts[0].start);
  var value = parts[0].value;


  for (var i = 0; i < parts.length; i++) {
    var thisPart = parts[i];
    var nextPart = parts[i + 1];
    if (nextPart) {
      // Remove the space between the strings.
      module.magicString.remove(thisPart.end - 1, nextPart.start + 1);
      value += nextPart.value;
    }
    var thisPartQuote = module.source.charAt(parts[i].start);
    if (thisPartQuote !== quote) {
      unescapeString(thisPartQuote, module.source, thisPart.start + 1, thisPart.end - 1, module.magicString);
      escapeString(quote, module.source, thisPart.start + 1, thisPart.end - 1, module.magicString);
    }
  }

  var lastPart = parts[parts.length - 1];
  module.magicString.overwrite(lastPart.end - 1, lastPart.end, quote);

  return t.stringLiteral(value);
}

function buildTemplateString(module, node, parts) {
  var expressions = [];
  var quasis = [];

  var firstPart = parts[0];
  var firstNode = firstPart.node;
  var cooked = '';
  var raw = '';

  module.magicString.appendLeft(firstNode.start, '`');

  parts.forEach(function (_ref, i) {
    var node = _ref.node,
        prefix = _ref.prefix,
        suffix = _ref.suffix;

    if (prefix || suffix || !t.isStringLiteral(node)) {
      // This one has to be an interpolated expression.
      module.magicString.appendRight(node.start, '${' + prefix);
      module.magicString.appendLeft(node.end, suffix + '}');
      expressions.push(node);
      quasis.push(t.templateElement({ cooked: cooked, raw: escapeString('`', raw) }, false));
      cooked = '';
      raw = '';
    } else {
      // This one can become a quasi,
      cooked += node.value;
      raw += unescapeString(node.extra.raw[0], node.extra.raw.slice(1, -1));
      module.magicString.remove(node.start, node.start + 1);
      module.magicString.remove(node.end - 1, node.end);
      var thisPartQuote = module.source.charAt(node.start);
      unescapeString(thisPartQuote, module.source, node.start + 1, node.end - 1, module.magicString);
      escapeString('`', module.source, node.start, node.end, module.magicString);
    }

    var nextPart = parts[i + 1];

    if (nextPart) {
      module.magicString.remove(node.end, nextPart.node.start);
    }
  });

  quasis.push(t.templateElement({ cooked: cooked, raw: raw }, true));

  var lastPart = parts[parts.length - 1];

  if (lastPart.node.end === node.end) {
    module.magicString.appendRight(node.end, '`');
  } else {
    module.magicString.overwrite(lastPart.node.end, node.end, '`');
  }

  return t.templateLiteral(quasis, expressions);
}

function insignificantContentSeparatedByPlus(module, left, right) {
  var tokens = module.tokensInRange(left.end, right.start);
  var leftComments = [];
  var rightComments = [];
  var hasFoundPlusToken = false;
  var last = left;

  tokens.forEach(function (token, i) {
    var next = tokens[i + 1] || right;
    if (token.type.label === '+/-' && token.value === '+') {
      hasFoundPlusToken = true;
    } else if (token.type === 'CommentBlock') {
      var expandedSource = module.source.slice(last.end, next.start);
      (hasFoundPlusToken ? rightComments : leftComments).push(expandedSource);
    }
    last = token;
  });

  return [leftComments.join(''), rightComments.join('')];
}

function metadata$4(module) {
  if (!module.metadata[name$4]) {
    module.metadata[name$4] = { concatenations: [] };
  }
  return module.metadata[name$4];
}



var stringsTemplate = Object.freeze({
	name: name$4,
	description: description$4,
	visitor: visitor$4
});

var name$5 = 'objects.shorthand';
var description$5 = 'Use shorthand notation for object properties.';

function visitor$5(module) {
  var meta = metadata$5(module);

  return {
    ObjectProperty: function ObjectProperty(path$$1) {
      var node = path$$1.node;


      if (node.computed || node.shorthand) {
        return;
      }

      if (!t.isIdentifier(node.key) || !t.isIdentifier(node.value)) {
        return;
      }

      if (node.key.name !== node.value.name) {
        return;
      }

      var tokens = module.tokensForNode(node);

      var _findTokenMatchingPre = findTokenMatchingPredicate(function (token) {
        return token.start === node.key.start;
      }, tokens),
          keyTokenIndex = _findTokenMatchingPre.index,
          keyToken = _findTokenMatchingPre.token;

      var _findTokenMatchingPre2 = findTokenMatchingPredicate(function (token) {
        return token.type.label === ':';
      }, tokens, keyTokenIndex),
          colonTokenIndex = _findTokenMatchingPre2.index,
          colonToken = _findTokenMatchingPre2.token;

      var _findTokenMatchingPre3 = findTokenMatchingPredicate(function (token) {
        return token.start === node.value.start;
      }, tokens, colonTokenIndex),
          valueToken = _findTokenMatchingPre3.token;

      var sourceBetweenKeyAndColon = module.source.slice(keyToken.end, colonToken.start);
      var sourceBetweenColonAndValue = module.source.slice(colonToken.end, valueToken.start);

      // `a /* 1 */ : /* 2 */ a` -> `/* 1 *//* 2 */a`
      //  ^^^^^^^^^^^                ^^^^^^^
      module.magicString.overwrite(keyToken.start, colonToken.end, sourceBetweenKeyAndColon.trim());

      // `a /* 1 */ : /* 2 */ a` -> `/* 1 *//* 2 */a`
      //             ^^^^^^^^^              ^^^^^^^
      if (colonToken.end !== valueToken.start) {
        module.magicString.overwrite(colonToken.end, valueToken.start, sourceBetweenColonAndValue.trim());
      }

      meta.properties.push(cleanNode(node));
      node.shorthand = true;
    }
  };
}

function metadata$5(module) {
  if (!module.metadata[name$5]) {
    module.metadata[name$5] = { properties: [] };
  }
  return module.metadata[name$5];
}

var objectsShorthand = Object.freeze({
	name: name$5,
	description: description$5,
	visitor: visitor$5
});

var name$6 = 'objects.concise';
var description$6 = 'Use concise object property method syntax.';

function visitor$6(module) {
  return {
    ObjectProperty: function ObjectProperty(path$$1) {
      var node = path$$1.node;


      if (node.method) {
        return;
      }

      if (!t.isFunctionExpression(node.value) || node.value.id) {
        return;
      }

      var tokens = module.tokensForNode(node);
      var keyEnd = node.key.end;
      var functionEnd = void 0;

      if (node.computed) {
        var _findToken = findToken('[', tokens, 0),
            startBracketIndex = _findToken.index;

        var _findEndTokenBalanced = findEndTokenBalanced('[', ']', tokens, startBracketIndex),
            endBracketIndex = _findEndTokenBalanced.index,
            endBracket = _findEndTokenBalanced.token;

        keyEnd = endBracket.end;
        functionEnd = findToken('function', tokens, endBracketIndex).token.end;
      } else {
        functionEnd = findToken('function', tokens, 0).token.end;
      }

      module.magicString.remove(keyEnd, functionEnd);
      metadata$6(module).properties.push(cleanNode(node));

      path$$1.replaceWith(t.objectMethod('method', node.key, node.value.params, node.value.body, node.computed));
    }
  };
}

function metadata$6(module) {
  if (!module.metadata[name$6]) {
    module.metadata[name$6] = {
      properties: []
    };
  }
  return module.metadata[name$6];
}

var objectsConcise = Object.freeze({
	name: name$6,
	description: description$6,
	visitor: visitor$6
});

var allPlugins = [objectsShorthand, objectsConcise, modulesCommonjs, functionsArrow, declarationsBlockScope, objectsDestructuring, stringsTemplate];

/* eslint-disable no-console */

var OptionError = function (_Error) {
  inherits(OptionError, _Error);

  function OptionError(message) {
    classCallCheck(this, OptionError);

    var _this = possibleConstructorReturn(this, (OptionError.__proto__ || Object.getPrototypeOf(OptionError)).call(this, message));

    _this.message = message;
    return _this;
  }

  return OptionError;
}(Error);

var DelayedWritableFileStream = function () {
  function DelayedWritableFileStream(path$$1, options) {
    classCallCheck(this, DelayedWritableFileStream);

    this.path = path$$1;
    this.options = options;
  }

  createClass(DelayedWritableFileStream, [{
    key: 'write',
    value: function write(chunk) {
      return this.stream.write(chunk);
    }
  }, {
    key: 'end',
    value: function end() {
      return this.stream.end();
    }
  }, {
    key: 'stream',
    get: function get$$1() {
      if (!this._stream) {
        mkdirp.sync(path.dirname(this.path));
        this._stream = fs.createWriteStream(this.path, this.options);
      }
      return this._stream;
    }
  }]);
  return DelayedWritableFileStream;
}();

function run$$1(args) {
  var options = parseArguments(args);

  if (options.error) {
    process.stderr.write(options.error + '\n');
    help(process.stderr);
    process.exit(1);
  } else if (options.help) {
    help(process.stdout);
  } else {
    var _input = options.input ? fs.createReadStream(options.input, { encoding: 'utf8' }) : process.stdin;
    var _output = options.output ? new DelayedWritableFileStream(options.output, { encoding: 'utf8' }) : process.stdout;

    var plugins = allPlugins.filter(function (plugin) {
      if (options.blacklist) {
        return options.blacklist[plugin.name] !== true;
      } else if (options.whitelist) {
        return options.whitelist[plugin.name] === true;
      } else {
        return true;
      }
    });

    readStream(_input).then(function (source) {
      return convert(source, { plugins: plugins, validate: options.validate, parse: options.parse });
    }).then(function (result) {
      printWarnings(_input.path || '[stdin]', result.warnings);
      _output.write(result.code);
    }).catch(function (error) {
      console.error(error.stack);
      process.exit(1);
    });
  }
}

function printWarnings(path$$1, warnings) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = warnings[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var warning = _step.value;

      printWarning(path$$1, warning);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

function printWarning(path$$1, warning) {
  var loc = warning.node.loc;
  process.stderr.write('WARNING: ' + path$$1 + ':' + loc.start.line + ':' + (loc.start.column + 1) + '  ' + warning.type + '  ' + warning.message + '\n');
}

function readStream(stream) {
  return new Promise(function (resolve, reject) {
    var data = '';
    stream.setEncoding('utf8');
    stream.on('data', function (chunk) {
      return data += chunk;
    });
    stream.on('error', reject);
    stream.on('end', function () {
      return resolve(data);
    });
  });
}

function parseArguments(args) {
  var blacklist = null;
  var whitelist = null;
  var input = void 0;
  var output = void 0;
  var validate = void 0;
  var inline = false;
  var parse$$1 = void 0;

  for (var i = 0; i < args.length; i++) {
    switch (args[i]) {
      case '-i':
      case '--input':
        if (input) {
          return { error: 'Encountered duplicate input option: ' + args[i + 1] };
        }
        input = parsePath(args[++i]);
        break;

      case '-o':
      case '--output':
        if (output) {
          return { error: 'Encountered duplicate output option: ' + args[i + 1] };
        }
        output = parsePath(args[++i]);
        break;

      case '-h':
      case '--help':
        return { help: true };

      case '-w':
      case '--whitelist':
        if (blacklist) {
          return { error: 'Encountered whitelist after blacklist: ' + args[i + 1] };
        }
        if (!whitelist) {
          whitelist = blank();
        }
        parseList(args[++i]).forEach(function (name) {
          return whitelist[name] = true;
        });
        break;

      case '-b':
      case '--blacklist':
        if (whitelist) {
          return { error: 'Encountered blacklist after whitelist: ' + args[i + 1] };
        }
        if (!blacklist) {
          blacklist = blank();
        }
        parseList(args[++i]).forEach(function (name) {
          return blacklist[name] = true;
        });
        break;

      case '-I':
      case '--inline':
        inline = true;
        break;

      case '--validate':
      case '--no-validate':
        validate = args[i] === '--validate';
        break;

      default:
        if (args[i][0] === '-') {
          return { error: 'Unknown option: ' + args[i] };
        }
        if (input) {
          return { error: 'Duplicate input option: ' + args[i] };
        }
        input = args[i];
        break;
    }
  }

  if (inline) {
    if (!input) {
      return { error: 'Asked to replace input inline but no input was given' };
    } else if (output) {
      return { error: 'Asked to replace input inline but output is already set: ' + output };
    }
    output = input;
  }

  return { input: input, output: output, blacklist: blacklist, whitelist: whitelist, validate: validate, parse: parse$$1 };
}

function parseList(arg) {
  if (arg === '') {
    return [];
  } else if (!arg || arg[0] === '-') {
    throw new OptionError('Expected a list but got: ' + arg);
  }
  return arg.split(',').filter(function (item) {
    return item;
  });
}

function parsePath(arg) {
  if (!arg || arg[0] === '-') {
    throw new OptionError('Expected a path but got: ' + arg);
  }
  return arg;
}

function help(out) {
  var $0 = path.basename(process.argv[1]);
  out.write($0 + ' -o output.js input.js   # read and write files directly\n');
  out.write($0 + ' input.js > output.js    # read file and write stdout\n');
  out.write($0 + ' < input.js > output.js  # read stdin and write stdout\n');
  out.write($0 + ' -I file.js              # rewrite a file inline\n');
  out.write($0 + ' -b modules.commonjs     # blacklist plugins\n');
  out.write($0 + ' -w modules.commonjs     # whitelist plugins\n');
  out.write('\n');
  writeSectionHeader(out, 'Built-in Plugins');
  out.write('\n');
  table({ out: out, padding: 2, indent: 2 }, allPlugins.sort(function (left, right) {
    return left.name.localeCompare(right.name);
  }).map(function (_ref) {
    var name = _ref.name,
        description = _ref.description;
    return [name, description];
  }));
  out.write('\n');
  writeSectionHeader(out, 'Additional Options');
  out.write('\n');
  table({ out: out, padding: 4, indent: 2 }, [['--[no-]validate', 'Turn validation on or off (default: on).']]);
}

function writeSectionHeader(out, title) {
  if (out.isTTY) {
    out.write('\x1b[1m');
  }
  out.write(title + '\n');
  if (out.isTTY) {
    out.write('\x1b[0m');
  }
}

function table(options, data) {
  var padding = options.padding || 0;
  var indent = options.indent || 0;
  var out = options.out;
  var longest = [];

  data.forEach(function (row) {
    row.forEach(function (value, i) {
      if (!(i in longest) || value.length > longest[i]) {
        longest[i] = value.length;
      }
    });
  });

  data.forEach(function (row) {
    for (var j = indent; j--;) {
      out.write(' ');
    }
    row.forEach(function (value, i) {
      out.write(value);
      for (var _j = longest[i] + padding - value.length; _j--;) {
        out.write(' ');
      }
    });
    out.write('\n');
  });
}

function blank() {
  return Object.create(null);
}

function convert(source) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (Array.isArray(options)) {
    console.warn('convert(source, plugins) is deprecated, please call as convert(source, options)'); // eslint-disable-line no-console
    options = { plugins: options };
  }

  var _options = options,
      _options$validate = _options.validate,
      validate = _options$validate === undefined ? true : _options$validate,
      _options$plugins = _options.plugins,
      plugins = _options$plugins === undefined ? allPlugins : _options$plugins;

  var shebangMatch = source.match(shebangRegex);

  if (shebangMatch) {
    source = source.slice(shebangMatch.index + shebangMatch[0].length);
  }

  var module = new Module(null, source, parse$1(source));

  plugins.forEach(function (plugin) {
    var name = plugin.name,
        visitor = plugin.visitor;

    var pluginOptions = options[name];
    try {
      traverse(module.ast, visitor(module, pluginOptions));
      module.commit();
    } catch (e) {
      e.message = 'Error running plugin ' + name + ': ' + e.message;
      e.source = module.source;
      throw e;
    }
  });

  var result = module.render();

  if (validate) {
    var error = validateResult(result);
    if (error) {
      result.warnings.push({
        type: 'output-validation-failure',
        message: error.message,
        node: {
          loc: {
            start: error.loc
          }
        }
      });
    }
  }

  if (shebangMatch) {
    result.code = shebangMatch[0] + result.code;
  }

  return result;
}

function validateResult(_ref) {
  var code = _ref.code;

  try {
    parse$1(code);
    return null;
  } catch (ex) {
    return ex;
  }
}

exports.allPlugins = allPlugins;
exports.convert = convert;
exports.run = run$$1;

Object.defineProperty(exports, '__esModule', { value: true });

})));

}).call(this,require('_process'))
},{"_process":367,"babel-traverse":25,"babel-types":58,"babylon":62,"fs":64,"magic-string":193,"mkdirp":363,"path":366,"shebang-regex":369,"util":375}],193:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"_process":367,"buffer":65,"dup":2,"vlq":376}],194:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    function isExpression(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'ArrayExpression':
            case 'AssignmentExpression':
            case 'BinaryExpression':
            case 'CallExpression':
            case 'ConditionalExpression':
            case 'FunctionExpression':
            case 'Identifier':
            case 'Literal':
            case 'LogicalExpression':
            case 'MemberExpression':
            case 'NewExpression':
            case 'ObjectExpression':
            case 'SequenceExpression':
            case 'ThisExpression':
            case 'UnaryExpression':
            case 'UpdateExpression':
                return true;
        }
        return false;
    }

    function isIterationStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'DoWhileStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'WhileStatement':
                return true;
        }
        return false;
    }

    function isStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'BlockStatement':
            case 'BreakStatement':
            case 'ContinueStatement':
            case 'DebuggerStatement':
            case 'DoWhileStatement':
            case 'EmptyStatement':
            case 'ExpressionStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'IfStatement':
            case 'LabeledStatement':
            case 'ReturnStatement':
            case 'SwitchStatement':
            case 'ThrowStatement':
            case 'TryStatement':
            case 'VariableDeclaration':
            case 'WhileStatement':
            case 'WithStatement':
                return true;
        }
        return false;
    }

    function isSourceElement(node) {
      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
    }

    function trailingStatement(node) {
        switch (node.type) {
        case 'IfStatement':
            if (node.alternate != null) {
                return node.alternate;
            }
            return node.consequent;

        case 'LabeledStatement':
        case 'ForStatement':
        case 'ForInStatement':
        case 'WhileStatement':
        case 'WithStatement':
            return node.body;
        }
        return null;
    }

    function isProblematicIfStatement(node) {
        var current;

        if (node.type !== 'IfStatement') {
            return false;
        }
        if (node.alternate == null) {
            return false;
        }
        current = node.consequent;
        do {
            if (current.type === 'IfStatement') {
                if (current.alternate == null)  {
                    return true;
                }
            }
            current = trailingStatement(current);
        } while (current);

        return false;
    }

    module.exports = {
        isExpression: isExpression,
        isStatement: isStatement,
        isIterationStatement: isIterationStatement,
        isSourceElement: isSourceElement,
        isProblematicIfStatement: isProblematicIfStatement,

        trailingStatement: trailingStatement
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],195:[function(require,module,exports){
/*
  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;

    // See `tools/generate-identifier-regex.js`.
    ES5Regex = {
        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    };

    ES6Regex = {
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };

    function isDecimalDigit(ch) {
        return 0x30 <= ch && ch <= 0x39;  // 0..9
    }

    function isHexDigit(ch) {
        return 0x30 <= ch && ch <= 0x39 ||  // 0..9
            0x61 <= ch && ch <= 0x66 ||     // a..f
            0x41 <= ch && ch <= 0x46;       // A..F
    }

    function isOctalDigit(ch) {
        return ch >= 0x30 && ch <= 0x37;  // 0..7
    }

    // 7.2 White Space

    NON_ASCII_WHITESPACES = [
        0x1680, 0x180E,
        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
        0x202F, 0x205F,
        0x3000,
        0xFEFF
    ];

    function isWhiteSpace(ch) {
        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||
            ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
    }

    // 7.6 Identifier Names and Identifiers

    function fromCodePoint(cp) {
        if (cp <= 0xFFFF) { return String.fromCharCode(cp); }
        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
        var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);
        return cu1 + cu2;
    }

    IDENTIFIER_START = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_START[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    IDENTIFIER_PART = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_PART[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch >= 0x30 && ch <= 0x39 ||  // 0..9
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    function isIdentifierStartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    function isIdentifierStartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStartES5: isIdentifierStartES5,
        isIdentifierPartES5: isIdentifierPartES5,
        isIdentifierStartES6: isIdentifierStartES6,
        isIdentifierPartES6: isIdentifierPartES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],196:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var code = require('./code');

    function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isKeywordES5(id, strict) {
        // yield should not be treated as keyword under non-strict mode.
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    function isReservedWordES5(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
    }

    function isReservedWordES6(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierNameES5(id) {
        var i, iz, ch;

        if (id.length === 0) { return false; }

        ch = id.charCodeAt(0);
        if (!code.isIdentifierStartES5(ch)) {
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code.isIdentifierPartES5(ch)) {
                return false;
            }
        }
        return true;
    }

    function decodeUtf16(lead, trail) {
        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
    }

    function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check;

        if (id.length === 0) { return false; }

        check = code.isIdentifierStartES6;
        for (i = 0, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (0xD800 <= ch && ch <= 0xDBFF) {
                ++i;
                if (i >= iz) { return false; }
                lowCh = id.charCodeAt(i);
                if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
                    return false;
                }
                ch = decodeUtf16(ch, lowCh);
            }
            if (!check(ch)) {
                return false;
            }
            check = code.isIdentifierPartES6;
        }
        return true;
    }

    function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
    }

    function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
    }

    module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isReservedWordES5: isReservedWordES5,
        isReservedWordES6: isReservedWordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierNameES5: isIdentifierNameES5,
        isIdentifierNameES6: isIdentifierNameES6,
        isIdentifierES5: isIdentifierES5,
        isIdentifierES6: isIdentifierES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./code":195}],197:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


(function () {
    'use strict';

    exports.ast = require('./ast');
    exports.code = require('./code');
    exports.keyword = require('./keyword');
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./ast":194,"./code":195,"./keyword":196}],198:[function(require,module,exports){
module.exports={
	"builtin": {
		"Array": false,
		"ArrayBuffer": false,
		"Boolean": false,
		"constructor": false,
		"DataView": false,
		"Date": false,
		"decodeURI": false,
		"decodeURIComponent": false,
		"encodeURI": false,
		"encodeURIComponent": false,
		"Error": false,
		"escape": false,
		"eval": false,
		"EvalError": false,
		"Float32Array": false,
		"Float64Array": false,
		"Function": false,
		"hasOwnProperty": false,
		"Infinity": false,
		"Int16Array": false,
		"Int32Array": false,
		"Int8Array": false,
		"isFinite": false,
		"isNaN": false,
		"isPrototypeOf": false,
		"JSON": false,
		"Map": false,
		"Math": false,
		"NaN": false,
		"Number": false,
		"Object": false,
		"parseFloat": false,
		"parseInt": false,
		"Promise": false,
		"propertyIsEnumerable": false,
		"Proxy": false,
		"RangeError": false,
		"ReferenceError": false,
		"Reflect": false,
		"RegExp": false,
		"Set": false,
		"String": false,
		"Symbol": false,
		"SyntaxError": false,
		"System": false,
		"toLocaleString": false,
		"toString": false,
		"TypeError": false,
		"Uint16Array": false,
		"Uint32Array": false,
		"Uint8Array": false,
		"Uint8ClampedArray": false,
		"undefined": false,
		"unescape": false,
		"URIError": false,
		"valueOf": false,
		"WeakMap": false,
		"WeakSet": false
	},
	"es5": {
		"Array": false,
		"Boolean": false,
		"constructor": false,
		"Date": false,
		"decodeURI": false,
		"decodeURIComponent": false,
		"encodeURI": false,
		"encodeURIComponent": false,
		"Error": false,
		"escape": false,
		"eval": false,
		"EvalError": false,
		"Function": false,
		"hasOwnProperty": false,
		"Infinity": false,
		"isFinite": false,
		"isNaN": false,
		"isPrototypeOf": false,
		"JSON": false,
		"Math": false,
		"NaN": false,
		"Number": false,
		"Object": false,
		"parseFloat": false,
		"parseInt": false,
		"propertyIsEnumerable": false,
		"RangeError": false,
		"ReferenceError": false,
		"RegExp": false,
		"String": false,
		"SyntaxError": false,
		"toLocaleString": false,
		"toString": false,
		"TypeError": false,
		"undefined": false,
		"unescape": false,
		"URIError": false,
		"valueOf": false
	},
	"es6": {
		"Array": false,
		"ArrayBuffer": false,
		"Boolean": false,
		"constructor": false,
		"DataView": false,
		"Date": false,
		"decodeURI": false,
		"decodeURIComponent": false,
		"encodeURI": false,
		"encodeURIComponent": false,
		"Error": false,
		"escape": false,
		"eval": false,
		"EvalError": false,
		"Float32Array": false,
		"Float64Array": false,
		"Function": false,
		"hasOwnProperty": false,
		"Infinity": false,
		"Int16Array": false,
		"Int32Array": false,
		"Int8Array": false,
		"isFinite": false,
		"isNaN": false,
		"isPrototypeOf": false,
		"JSON": false,
		"Map": false,
		"Math": false,
		"NaN": false,
		"Number": false,
		"Object": false,
		"parseFloat": false,
		"parseInt": false,
		"Promise": false,
		"propertyIsEnumerable": false,
		"Proxy": false,
		"RangeError": false,
		"ReferenceError": false,
		"Reflect": false,
		"RegExp": false,
		"Set": false,
		"String": false,
		"Symbol": false,
		"SyntaxError": false,
		"System": false,
		"toLocaleString": false,
		"toString": false,
		"TypeError": false,
		"Uint16Array": false,
		"Uint32Array": false,
		"Uint8Array": false,
		"Uint8ClampedArray": false,
		"undefined": false,
		"unescape": false,
		"URIError": false,
		"valueOf": false,
		"WeakMap": false,
		"WeakSet": false
	},
	"browser": {
		"addEventListener": false,
		"alert": false,
		"AnalyserNode": false,
		"Animation": false,
		"AnimationEffectReadOnly": false,
		"AnimationEffectTiming": false,
		"AnimationEffectTimingReadOnly": false,
		"AnimationEvent": false,
		"AnimationPlaybackEvent": false,
		"AnimationTimeline": false,
		"applicationCache": false,
		"ApplicationCache": false,
		"ApplicationCacheErrorEvent": false,
		"atob": false,
		"Attr": false,
		"Audio": false,
		"AudioBuffer": false,
		"AudioBufferSourceNode": false,
		"AudioContext": false,
		"AudioDestinationNode": false,
		"AudioListener": false,
		"AudioNode": false,
		"AudioParam": false,
		"AudioProcessingEvent": false,
		"AutocompleteErrorEvent": false,
		"BarProp": false,
		"BatteryManager": false,
		"BeforeUnloadEvent": false,
		"BiquadFilterNode": false,
		"Blob": false,
		"blur": false,
		"btoa": false,
		"Cache": false,
		"caches": false,
		"CacheStorage": false,
		"cancelAnimationFrame": false,
		"CanvasGradient": false,
		"CanvasPattern": false,
		"CanvasRenderingContext2D": false,
		"CDATASection": false,
		"ChannelMergerNode": false,
		"ChannelSplitterNode": false,
		"CharacterData": false,
		"clearInterval": false,
		"clearTimeout": false,
		"clientInformation": false,
		"ClientRect": false,
		"ClientRectList": false,
		"ClipboardEvent": false,
		"close": false,
		"closed": false,
		"CloseEvent": false,
		"Comment": false,
		"CompositionEvent": false,
		"confirm": false,
		"console": false,
		"ConvolverNode": false,
		"Credential": false,
		"CredentialsContainer": false,
		"crypto": false,
		"Crypto": false,
		"CryptoKey": false,
		"CSS": false,
		"CSSAnimation": false,
		"CSSFontFaceRule": false,
		"CSSImportRule": false,
		"CSSKeyframeRule": false,
		"CSSKeyframesRule": false,
		"CSSMediaRule": false,
		"CSSPageRule": false,
		"CSSRule": false,
		"CSSRuleList": false,
		"CSSStyleDeclaration": false,
		"CSSStyleRule": false,
		"CSSStyleSheet": false,
		"CSSSupportsRule": false,
		"CSSTransition": false,
		"CSSUnknownRule": false,
		"CSSViewportRule": false,
		"customElements": false,
		"CustomEvent": false,
		"DataTransfer": false,
		"DataTransferItem": false,
		"DataTransferItemList": false,
		"Debug": false,
		"defaultStatus": false,
		"defaultstatus": false,
		"DelayNode": false,
		"DeviceMotionEvent": false,
		"DeviceOrientationEvent": false,
		"devicePixelRatio": false,
		"dispatchEvent": false,
		"document": false,
		"Document": false,
		"DocumentFragment": false,
		"DocumentTimeline": false,
		"DocumentType": false,
		"DOMError": false,
		"DOMException": false,
		"DOMImplementation": false,
		"DOMParser": false,
		"DOMSettableTokenList": false,
		"DOMStringList": false,
		"DOMStringMap": false,
		"DOMTokenList": false,
		"DragEvent": false,
		"DynamicsCompressorNode": false,
		"Element": false,
		"ElementTimeControl": false,
		"ErrorEvent": false,
		"event": false,
		"Event": false,
		"EventSource": false,
		"EventTarget": false,
		"external": false,
		"FederatedCredential": false,
		"fetch": false,
		"File": false,
		"FileError": false,
		"FileList": false,
		"FileReader": false,
		"find": false,
		"focus": false,
		"FocusEvent": false,
		"FontFace": false,
		"FormData": false,
		"frameElement": false,
		"frames": false,
		"GainNode": false,
		"Gamepad": false,
		"GamepadButton": false,
		"GamepadEvent": false,
		"getComputedStyle": false,
		"getSelection": false,
		"HashChangeEvent": false,
		"Headers": false,
		"history": false,
		"History": false,
		"HTMLAllCollection": false,
		"HTMLAnchorElement": false,
		"HTMLAppletElement": false,
		"HTMLAreaElement": false,
		"HTMLAudioElement": false,
		"HTMLBaseElement": false,
		"HTMLBlockquoteElement": false,
		"HTMLBodyElement": false,
		"HTMLBRElement": false,
		"HTMLButtonElement": false,
		"HTMLCanvasElement": false,
		"HTMLCollection": false,
		"HTMLContentElement": false,
		"HTMLDataListElement": false,
		"HTMLDetailsElement": false,
		"HTMLDialogElement": false,
		"HTMLDirectoryElement": false,
		"HTMLDivElement": false,
		"HTMLDListElement": false,
		"HTMLDocument": false,
		"HTMLElement": false,
		"HTMLEmbedElement": false,
		"HTMLFieldSetElement": false,
		"HTMLFontElement": false,
		"HTMLFormControlsCollection": false,
		"HTMLFormElement": false,
		"HTMLFrameElement": false,
		"HTMLFrameSetElement": false,
		"HTMLHeadElement": false,
		"HTMLHeadingElement": false,
		"HTMLHRElement": false,
		"HTMLHtmlElement": false,
		"HTMLIFrameElement": false,
		"HTMLImageElement": false,
		"HTMLInputElement": false,
		"HTMLIsIndexElement": false,
		"HTMLKeygenElement": false,
		"HTMLLabelElement": false,
		"HTMLLayerElement": false,
		"HTMLLegendElement": false,
		"HTMLLIElement": false,
		"HTMLLinkElement": false,
		"HTMLMapElement": false,
		"HTMLMarqueeElement": false,
		"HTMLMediaElement": false,
		"HTMLMenuElement": false,
		"HTMLMetaElement": false,
		"HTMLMeterElement": false,
		"HTMLModElement": false,
		"HTMLObjectElement": false,
		"HTMLOListElement": false,
		"HTMLOptGroupElement": false,
		"HTMLOptionElement": false,
		"HTMLOptionsCollection": false,
		"HTMLOutputElement": false,
		"HTMLParagraphElement": false,
		"HTMLParamElement": false,
		"HTMLPictureElement": false,
		"HTMLPreElement": false,
		"HTMLProgressElement": false,
		"HTMLQuoteElement": false,
		"HTMLScriptElement": false,
		"HTMLSelectElement": false,
		"HTMLShadowElement": false,
		"HTMLSourceElement": false,
		"HTMLSpanElement": false,
		"HTMLStyleElement": false,
		"HTMLTableCaptionElement": false,
		"HTMLTableCellElement": false,
		"HTMLTableColElement": false,
		"HTMLTableElement": false,
		"HTMLTableRowElement": false,
		"HTMLTableSectionElement": false,
		"HTMLTemplateElement": false,
		"HTMLTextAreaElement": false,
		"HTMLTitleElement": false,
		"HTMLTrackElement": false,
		"HTMLUListElement": false,
		"HTMLUnknownElement": false,
		"HTMLVideoElement": false,
		"IDBCursor": false,
		"IDBCursorWithValue": false,
		"IDBDatabase": false,
		"IDBEnvironment": false,
		"IDBFactory": false,
		"IDBIndex": false,
		"IDBKeyRange": false,
		"IDBObjectStore": false,
		"IDBOpenDBRequest": false,
		"IDBRequest": false,
		"IDBTransaction": false,
		"IDBVersionChangeEvent": false,
		"Image": false,
		"ImageBitmap": false,
		"ImageData": false,
		"indexedDB": false,
		"innerHeight": false,
		"innerWidth": false,
		"InputEvent": false,
		"InputMethodContext": false,
		"IntersectionObserver": false,
		"IntersectionObserverEntry": false,
		"Intl": false,
		"KeyboardEvent": false,
		"KeyframeEffect": false,
		"KeyframeEffectReadOnly": false,
		"length": false,
		"localStorage": false,
		"location": false,
		"Location": false,
		"locationbar": false,
		"matchMedia": false,
		"MediaElementAudioSourceNode": false,
		"MediaEncryptedEvent": false,
		"MediaError": false,
		"MediaKeyError": false,
		"MediaKeyEvent": false,
		"MediaKeyMessageEvent": false,
		"MediaKeys": false,
		"MediaKeySession": false,
		"MediaKeyStatusMap": false,
		"MediaKeySystemAccess": false,
		"MediaList": false,
		"MediaQueryList": false,
		"MediaQueryListEvent": false,
		"MediaSource": false,
		"MediaRecorder": false,
		"MediaStream": false,
		"MediaStreamAudioDestinationNode": false,
		"MediaStreamAudioSourceNode": false,
		"MediaStreamEvent": false,
		"MediaStreamTrack": false,
		"menubar": false,
		"MessageChannel": false,
		"MessageEvent": false,
		"MessagePort": false,
		"MIDIAccess": false,
		"MIDIConnectionEvent": false,
		"MIDIInput": false,
		"MIDIInputMap": false,
		"MIDIMessageEvent": false,
		"MIDIOutput": false,
		"MIDIOutputMap": false,
		"MIDIPort": false,
		"MimeType": false,
		"MimeTypeArray": false,
		"MouseEvent": false,
		"moveBy": false,
		"moveTo": false,
		"MutationEvent": false,
		"MutationObserver": false,
		"MutationRecord": false,
		"name": false,
		"NamedNodeMap": false,
		"navigator": false,
		"Navigator": false,
		"Node": false,
		"NodeFilter": false,
		"NodeIterator": false,
		"NodeList": false,
		"Notification": false,
		"OfflineAudioCompletionEvent": false,
		"OfflineAudioContext": false,
		"offscreenBuffering": false,
		"onbeforeunload": true,
		"onblur": true,
		"onerror": true,
		"onfocus": true,
		"onload": true,
		"onresize": true,
		"onunload": true,
		"open": false,
		"openDatabase": false,
		"opener": false,
		"opera": false,
		"Option": false,
		"OscillatorNode": false,
		"outerHeight": false,
		"outerWidth": false,
		"PageTransitionEvent": false,
		"pageXOffset": false,
		"pageYOffset": false,
		"parent": false,
		"PasswordCredential": false,
		"Path2D": false,
		"performance": false,
		"Performance": false,
		"PerformanceEntry": false,
		"PerformanceMark": false,
		"PerformanceMeasure": false,
		"PerformanceNavigation": false,
		"PerformanceResourceTiming": false,
		"PerformanceTiming": false,
		"PeriodicWave": false,
		"Permissions": false,
		"PermissionStatus": false,
		"personalbar": false,
		"Plugin": false,
		"PluginArray": false,
		"PopStateEvent": false,
		"postMessage": false,
		"print": false,
		"ProcessingInstruction": false,
		"ProgressEvent": false,
		"PromiseRejectionEvent": false,
		"prompt": false,
		"PushManager": false,
		"PushSubscription": false,
		"RadioNodeList": false,
		"Range": false,
		"ReadableByteStream": false,
		"ReadableStream": false,
		"removeEventListener": false,
		"Request": false,
		"requestAnimationFrame": false,
		"requestIdleCallback": false,
		"resizeBy": false,
		"resizeTo": false,
		"Response": false,
		"RTCIceCandidate": false,
		"RTCSessionDescription": false,
		"RTCPeerConnection": false,
		"screen": false,
		"Screen": false,
		"screenLeft": false,
		"ScreenOrientation": false,
		"screenTop": false,
		"screenX": false,
		"screenY": false,
		"ScriptProcessorNode": false,
		"scroll": false,
		"scrollbars": false,
		"scrollBy": false,
		"scrollTo": false,
		"scrollX": false,
		"scrollY": false,
		"SecurityPolicyViolationEvent": false,
		"Selection": false,
		"self": false,
		"ServiceWorker": false,
		"ServiceWorkerContainer": false,
		"ServiceWorkerRegistration": false,
		"sessionStorage": false,
		"setInterval": false,
		"setTimeout": false,
		"ShadowRoot": false,
		"SharedKeyframeList": false,
		"SharedWorker": false,
		"showModalDialog": false,
		"SiteBoundCredential": false,
		"speechSynthesis": false,
		"SpeechSynthesisEvent": false,
		"SpeechSynthesisUtterance": false,
		"status": false,
		"statusbar": false,
		"stop": false,
		"Storage": false,
		"StorageEvent": false,
		"styleMedia": false,
		"StyleSheet": false,
		"StyleSheetList": false,
		"SubtleCrypto": false,
		"SVGAElement": false,
		"SVGAltGlyphDefElement": false,
		"SVGAltGlyphElement": false,
		"SVGAltGlyphItemElement": false,
		"SVGAngle": false,
		"SVGAnimateColorElement": false,
		"SVGAnimatedAngle": false,
		"SVGAnimatedBoolean": false,
		"SVGAnimatedEnumeration": false,
		"SVGAnimatedInteger": false,
		"SVGAnimatedLength": false,
		"SVGAnimatedLengthList": false,
		"SVGAnimatedNumber": false,
		"SVGAnimatedNumberList": false,
		"SVGAnimatedPathData": false,
		"SVGAnimatedPoints": false,
		"SVGAnimatedPreserveAspectRatio": false,
		"SVGAnimatedRect": false,
		"SVGAnimatedString": false,
		"SVGAnimatedTransformList": false,
		"SVGAnimateElement": false,
		"SVGAnimateMotionElement": false,
		"SVGAnimateTransformElement": false,
		"SVGAnimationElement": false,
		"SVGCircleElement": false,
		"SVGClipPathElement": false,
		"SVGColor": false,
		"SVGColorProfileElement": false,
		"SVGColorProfileRule": false,
		"SVGComponentTransferFunctionElement": false,
		"SVGCSSRule": false,
		"SVGCursorElement": false,
		"SVGDefsElement": false,
		"SVGDescElement": false,
		"SVGDiscardElement": false,
		"SVGDocument": false,
		"SVGElement": false,
		"SVGElementInstance": false,
		"SVGElementInstanceList": false,
		"SVGEllipseElement": false,
		"SVGEvent": false,
		"SVGExternalResourcesRequired": false,
		"SVGFEBlendElement": false,
		"SVGFEColorMatrixElement": false,
		"SVGFEComponentTransferElement": false,
		"SVGFECompositeElement": false,
		"SVGFEConvolveMatrixElement": false,
		"SVGFEDiffuseLightingElement": false,
		"SVGFEDisplacementMapElement": false,
		"SVGFEDistantLightElement": false,
		"SVGFEDropShadowElement": false,
		"SVGFEFloodElement": false,
		"SVGFEFuncAElement": false,
		"SVGFEFuncBElement": false,
		"SVGFEFuncGElement": false,
		"SVGFEFuncRElement": false,
		"SVGFEGaussianBlurElement": false,
		"SVGFEImageElement": false,
		"SVGFEMergeElement": false,
		"SVGFEMergeNodeElement": false,
		"SVGFEMorphologyElement": false,
		"SVGFEOffsetElement": false,
		"SVGFEPointLightElement": false,
		"SVGFESpecularLightingElement": false,
		"SVGFESpotLightElement": false,
		"SVGFETileElement": false,
		"SVGFETurbulenceElement": false,
		"SVGFilterElement": false,
		"SVGFilterPrimitiveStandardAttributes": false,
		"SVGFitToViewBox": false,
		"SVGFontElement": false,
		"SVGFontFaceElement": false,
		"SVGFontFaceFormatElement": false,
		"SVGFontFaceNameElement": false,
		"SVGFontFaceSrcElement": false,
		"SVGFontFaceUriElement": false,
		"SVGForeignObjectElement": false,
		"SVGGElement": false,
		"SVGGeometryElement": false,
		"SVGGlyphElement": false,
		"SVGGlyphRefElement": false,
		"SVGGradientElement": false,
		"SVGGraphicsElement": false,
		"SVGHKernElement": false,
		"SVGICCColor": false,
		"SVGImageElement": false,
		"SVGLangSpace": false,
		"SVGLength": false,
		"SVGLengthList": false,
		"SVGLinearGradientElement": false,
		"SVGLineElement": false,
		"SVGLocatable": false,
		"SVGMarkerElement": false,
		"SVGMaskElement": false,
		"SVGMatrix": false,
		"SVGMetadataElement": false,
		"SVGMissingGlyphElement": false,
		"SVGMPathElement": false,
		"SVGNumber": false,
		"SVGNumberList": false,
		"SVGPaint": false,
		"SVGPathElement": false,
		"SVGPathSeg": false,
		"SVGPathSegArcAbs": false,
		"SVGPathSegArcRel": false,
		"SVGPathSegClosePath": false,
		"SVGPathSegCurvetoCubicAbs": false,
		"SVGPathSegCurvetoCubicRel": false,
		"SVGPathSegCurvetoCubicSmoothAbs": false,
		"SVGPathSegCurvetoCubicSmoothRel": false,
		"SVGPathSegCurvetoQuadraticAbs": false,
		"SVGPathSegCurvetoQuadraticRel": false,
		"SVGPathSegCurvetoQuadraticSmoothAbs": false,
		"SVGPathSegCurvetoQuadraticSmoothRel": false,
		"SVGPathSegLinetoAbs": false,
		"SVGPathSegLinetoHorizontalAbs": false,
		"SVGPathSegLinetoHorizontalRel": false,
		"SVGPathSegLinetoRel": false,
		"SVGPathSegLinetoVerticalAbs": false,
		"SVGPathSegLinetoVerticalRel": false,
		"SVGPathSegList": false,
		"SVGPathSegMovetoAbs": false,
		"SVGPathSegMovetoRel": false,
		"SVGPatternElement": false,
		"SVGPoint": false,
		"SVGPointList": false,
		"SVGPolygonElement": false,
		"SVGPolylineElement": false,
		"SVGPreserveAspectRatio": false,
		"SVGRadialGradientElement": false,
		"SVGRect": false,
		"SVGRectElement": false,
		"SVGRenderingIntent": false,
		"SVGScriptElement": false,
		"SVGSetElement": false,
		"SVGStopElement": false,
		"SVGStringList": false,
		"SVGStylable": false,
		"SVGStyleElement": false,
		"SVGSVGElement": false,
		"SVGSwitchElement": false,
		"SVGSymbolElement": false,
		"SVGTests": false,
		"SVGTextContentElement": false,
		"SVGTextElement": false,
		"SVGTextPathElement": false,
		"SVGTextPositioningElement": false,
		"SVGTitleElement": false,
		"SVGTransform": false,
		"SVGTransformable": false,
		"SVGTransformList": false,
		"SVGTRefElement": false,
		"SVGTSpanElement": false,
		"SVGUnitTypes": false,
		"SVGURIReference": false,
		"SVGUseElement": false,
		"SVGViewElement": false,
		"SVGViewSpec": false,
		"SVGVKernElement": false,
		"SVGZoomAndPan": false,
		"SVGZoomEvent": false,
		"Text": false,
		"TextDecoder": false,
		"TextEncoder": false,
		"TextEvent": false,
		"TextMetrics": false,
		"TextTrack": false,
		"TextTrackCue": false,
		"TextTrackCueList": false,
		"TextTrackList": false,
		"TimeEvent": false,
		"TimeRanges": false,
		"toolbar": false,
		"top": false,
		"Touch": false,
		"TouchEvent": false,
		"TouchList": false,
		"TrackEvent": false,
		"TransitionEvent": false,
		"TreeWalker": false,
		"UIEvent": false,
		"URL": false,
		"URLSearchParams": false,
		"ValidityState": false,
		"VTTCue": false,
		"WaveShaperNode": false,
		"WebGLActiveInfo": false,
		"WebGLBuffer": false,
		"WebGLContextEvent": false,
		"WebGLFramebuffer": false,
		"WebGLProgram": false,
		"WebGLRenderbuffer": false,
		"WebGLRenderingContext": false,
		"WebGLShader": false,
		"WebGLShaderPrecisionFormat": false,
		"WebGLTexture": false,
		"WebGLUniformLocation": false,
		"WebSocket": false,
		"WheelEvent": false,
		"window": false,
		"Window": false,
		"Worker": false,
		"XDomainRequest": false,
		"XMLDocument": false,
		"XMLHttpRequest": false,
		"XMLHttpRequestEventTarget": false,
		"XMLHttpRequestProgressEvent": false,
		"XMLHttpRequestUpload": false,
		"XMLSerializer": false,
		"XPathEvaluator": false,
		"XPathException": false,
		"XPathExpression": false,
		"XPathNamespace": false,
		"XPathNSResolver": false,
		"XPathResult": false,
		"XSLTProcessor": false
	},
	"worker": {
		"applicationCache": false,
		"atob": false,
		"Blob": false,
		"BroadcastChannel": false,
		"btoa": false,
		"Cache": false,
		"caches": false,
		"clearInterval": false,
		"clearTimeout": false,
		"close": true,
		"console": false,
		"fetch": false,
		"FileReaderSync": false,
		"FormData": false,
		"Headers": false,
		"IDBCursor": false,
		"IDBCursorWithValue": false,
		"IDBDatabase": false,
		"IDBFactory": false,
		"IDBIndex": false,
		"IDBKeyRange": false,
		"IDBObjectStore": false,
		"IDBOpenDBRequest": false,
		"IDBRequest": false,
		"IDBTransaction": false,
		"IDBVersionChangeEvent": false,
		"ImageData": false,
		"importScripts": true,
		"indexedDB": false,
		"location": false,
		"MessageChannel": false,
		"MessagePort": false,
		"name": false,
		"navigator": false,
		"Notification": false,
		"onclose": true,
		"onconnect": true,
		"onerror": true,
		"onlanguagechange": true,
		"onmessage": true,
		"onoffline": true,
		"ononline": true,
		"onrejectionhandled": true,
		"onunhandledrejection": true,
		"performance": false,
		"Performance": false,
		"PerformanceEntry": false,
		"PerformanceMark": false,
		"PerformanceMeasure": false,
		"PerformanceNavigation": false,
		"PerformanceResourceTiming": false,
		"PerformanceTiming": false,
		"postMessage": true,
		"Promise": false,
		"Request": false,
		"Response": false,
		"self": true,
		"ServiceWorkerRegistration": false,
		"setInterval": false,
		"setTimeout": false,
		"TextDecoder": false,
		"TextEncoder": false,
		"URL": false,
		"URLSearchParams": false,
		"WebSocket": false,
		"Worker": false,
		"XMLHttpRequest": false
	},
	"node": {
		"__dirname": false,
		"__filename": false,
		"arguments": false,
		"Buffer": false,
		"clearImmediate": false,
		"clearInterval": false,
		"clearTimeout": false,
		"console": false,
		"exports": true,
		"GLOBAL": false,
		"global": false,
		"Intl": false,
		"module": false,
		"process": false,
		"require": false,
		"root": false,
		"setImmediate": false,
		"setInterval": false,
		"setTimeout": false
	},
	"commonjs": {
		"exports": true,
		"module": false,
		"require": false,
		"global": false
	},
	"amd": {
		"define": false,
		"require": false
	},
	"mocha": {
		"after": false,
		"afterEach": false,
		"before": false,
		"beforeEach": false,
		"context": false,
		"describe": false,
		"it": false,
		"mocha": false,
		"run": false,
		"setup": false,
		"specify": false,
		"suite": false,
		"suiteSetup": false,
		"suiteTeardown": false,
		"teardown": false,
		"test": false,
		"xcontext": false,
		"xdescribe": false,
		"xit": false,
		"xspecify": false
	},
	"jasmine": {
		"afterAll": false,
		"afterEach": false,
		"beforeAll": false,
		"beforeEach": false,
		"describe": false,
		"expect": false,
		"fail": false,
		"fdescribe": false,
		"fit": false,
		"it": false,
		"jasmine": false,
		"pending": false,
		"runs": false,
		"spyOn": false,
		"waits": false,
		"waitsFor": false,
		"xdescribe": false,
		"xit": false
	},
	"jest": {
		"afterAll": false,
		"afterEach": false,
		"beforeAll": false,
		"beforeEach": false,
		"check": false,
		"describe": false,
		"expect": false,
		"gen": false,
		"it": false,
		"fdescribe": false,
		"fit": false,
		"jest": false,
		"pit": false,
		"require": false,
		"test": false,
		"xdescribe": false,
		"xit": false,
		"xtest": false
	},
	"qunit": {
		"asyncTest": false,
		"deepEqual": false,
		"equal": false,
		"expect": false,
		"module": false,
		"notDeepEqual": false,
		"notEqual": false,
		"notOk": false,
		"notPropEqual": false,
		"notStrictEqual": false,
		"ok": false,
		"propEqual": false,
		"QUnit": false,
		"raises": false,
		"start": false,
		"stop": false,
		"strictEqual": false,
		"test": false,
		"throws": false
	},
	"phantomjs": {
		"console": true,
		"exports": true,
		"phantom": true,
		"require": true,
		"WebPage": true
	},
	"couch": {
		"emit": false,
		"exports": false,
		"getRow": false,
		"log": false,
		"module": false,
		"provides": false,
		"require": false,
		"respond": false,
		"send": false,
		"start": false,
		"sum": false
	},
	"rhino": {
		"defineClass": false,
		"deserialize": false,
		"gc": false,
		"help": false,
		"importClass": false,
		"importPackage": false,
		"java": false,
		"load": false,
		"loadClass": false,
		"Packages": false,
		"print": false,
		"quit": false,
		"readFile": false,
		"readUrl": false,
		"runCommand": false,
		"seal": false,
		"serialize": false,
		"spawn": false,
		"sync": false,
		"toint32": false,
		"version": false
	},
	"nashorn": {
		"__DIR__": false,
		"__FILE__": false,
		"__LINE__": false,
		"com": false,
		"edu": false,
		"exit": false,
		"Java": false,
		"java": false,
		"javafx": false,
		"JavaImporter": false,
		"javax": false,
		"JSAdapter": false,
		"load": false,
		"loadWithNewGlobal": false,
		"org": false,
		"Packages": false,
		"print": false,
		"quit": false
	},
	"wsh": {
		"ActiveXObject": true,
		"Enumerator": true,
		"GetObject": true,
		"ScriptEngine": true,
		"ScriptEngineBuildVersion": true,
		"ScriptEngineMajorVersion": true,
		"ScriptEngineMinorVersion": true,
		"VBArray": true,
		"WScript": true,
		"WSH": true,
		"XDomainRequest": true
	},
	"jquery": {
		"$": false,
		"jQuery": false
	},
	"yui": {
		"Y": false,
		"YUI": false,
		"YUI_config": false
	},
	"shelljs": {
		"cat": false,
		"cd": false,
		"chmod": false,
		"config": false,
		"cp": false,
		"dirs": false,
		"echo": false,
		"env": false,
		"error": false,
		"exec": false,
		"exit": false,
		"find": false,
		"grep": false,
		"ls": false,
		"ln": false,
		"mkdir": false,
		"mv": false,
		"popd": false,
		"pushd": false,
		"pwd": false,
		"rm": false,
		"sed": false,
		"set": false,
		"target": false,
		"tempdir": false,
		"test": false,
		"touch": false,
		"which": false
	},
	"prototypejs": {
		"$": false,
		"$$": false,
		"$A": false,
		"$break": false,
		"$continue": false,
		"$F": false,
		"$H": false,
		"$R": false,
		"$w": false,
		"Abstract": false,
		"Ajax": false,
		"Autocompleter": false,
		"Builder": false,
		"Class": false,
		"Control": false,
		"Draggable": false,
		"Draggables": false,
		"Droppables": false,
		"Effect": false,
		"Element": false,
		"Enumerable": false,
		"Event": false,
		"Field": false,
		"Form": false,
		"Hash": false,
		"Insertion": false,
		"ObjectRange": false,
		"PeriodicalExecuter": false,
		"Position": false,
		"Prototype": false,
		"Scriptaculous": false,
		"Selector": false,
		"Sortable": false,
		"SortableObserver": false,
		"Sound": false,
		"Template": false,
		"Toggle": false,
		"Try": false
	},
	"meteor": {
		"$": false,
		"_": false,
		"Accounts": false,
		"AccountsClient": false,
		"AccountsServer": false,
		"AccountsCommon": false,
		"App": false,
		"Assets": false,
		"Blaze": false,
		"check": false,
		"Cordova": false,
		"DDP": false,
		"DDPServer": false,
		"DDPRateLimiter": false,
		"Deps": false,
		"EJSON": false,
		"Email": false,
		"HTTP": false,
		"Log": false,
		"Match": false,
		"Meteor": false,
		"Mongo": false,
		"MongoInternals": false,
		"Npm": false,
		"Package": false,
		"Plugin": false,
		"process": false,
		"Random": false,
		"ReactiveDict": false,
		"ReactiveVar": false,
		"Router": false,
		"ServiceConfiguration": false,
		"Session": false,
		"share": false,
		"Spacebars": false,
		"Template": false,
		"Tinytest": false,
		"Tracker": false,
		"UI": false,
		"Utils": false,
		"WebApp": false,
		"WebAppInternals": false
	},
	"mongo": {
		"_isWindows": false,
		"_rand": false,
		"BulkWriteResult": false,
		"cat": false,
		"cd": false,
		"connect": false,
		"db": false,
		"getHostName": false,
		"getMemInfo": false,
		"hostname": false,
		"ISODate": false,
		"listFiles": false,
		"load": false,
		"ls": false,
		"md5sumFile": false,
		"mkdir": false,
		"Mongo": false,
		"NumberInt": false,
		"NumberLong": false,
		"ObjectId": false,
		"PlanCache": false,
		"print": false,
		"printjson": false,
		"pwd": false,
		"quit": false,
		"removeFile": false,
		"rs": false,
		"sh": false,
		"UUID": false,
		"version": false,
		"WriteResult": false
	},
	"applescript": {
		"$": false,
		"Application": false,
		"Automation": false,
		"console": false,
		"delay": false,
		"Library": false,
		"ObjC": false,
		"ObjectSpecifier": false,
		"Path": false,
		"Progress": false,
		"Ref": false
	},
	"serviceworker": {
		"caches": false,
		"Cache": false,
		"CacheStorage": false,
		"Client": false,
		"clients": false,
		"Clients": false,
		"ExtendableEvent": false,
		"ExtendableMessageEvent": false,
		"FetchEvent": false,
		"importScripts": false,
		"registration": false,
		"self": false,
		"ServiceWorker": false,
		"ServiceWorkerContainer": false,
		"ServiceWorkerGlobalScope": false,
		"ServiceWorkerMessageEvent": false,
		"ServiceWorkerRegistration": false,
		"skipWaiting": false,
		"WindowClient": false
	},
	"atomtest": {
		"advanceClock": false,
		"fakeClearInterval": false,
		"fakeClearTimeout": false,
		"fakeSetInterval": false,
		"fakeSetTimeout": false,
		"resetTimeouts": false,
		"waitsForPromise": false
	},
	"embertest": {
		"andThen": false,
		"click": false,
		"currentPath": false,
		"currentRouteName": false,
		"currentURL": false,
		"fillIn": false,
		"find": false,
		"findWithAssert": false,
		"keyEvent": false,
		"pauseTest": false,
		"resumeTest": false,
		"triggerEvent": false,
		"visit": false
	},
	"protractor": {
		"$": false,
		"$$": false,
		"browser": false,
		"By": false,
		"by": false,
		"DartObject": false,
		"element": false,
		"protractor": false
	},
	"shared-node-browser": {
		"clearInterval": false,
		"clearTimeout": false,
		"console": false,
		"setInterval": false,
		"setTimeout": false
	},
	"webextensions": {
		"browser": false,
		"chrome": false,
		"opr": false
	},
	"greasemonkey": {
		"GM_addStyle": false,
		"GM_deleteValue": false,
		"GM_getResourceText": false,
		"GM_getResourceURL": false,
		"GM_getValue": false,
		"GM_info": false,
		"GM_listValues": false,
		"GM_log": false,
		"GM_openInTab": false,
		"GM_registerMenuCommand": false,
		"GM_setClipboard": false,
		"GM_setValue": false,
		"GM_xmlhttpRequest": false,
		"unsafeWindow": false
	}
}

},{}],199:[function(require,module,exports){
module.exports = require('./globals.json');

},{"./globals.json":198}],200:[function(require,module,exports){
'use strict';
var ansiRegex = require('ansi-regex');
var re = new RegExp(ansiRegex().source); // remove the `g` flag
module.exports = re.test.bind(re);

},{"ansi-regex":3}],201:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],202:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],203:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

}).call(this,require('_process'))
},{"_process":367}],204:[function(require,module,exports){
'use strict';
var numberIsNan = require('number-is-nan');

module.exports = Number.isFinite || function (val) {
	return !(typeof val !== 'number' || numberIsNan(val) || val === Infinity || val === -Infinity);
};

},{"number-is-nan":365}],205:[function(require,module,exports){
// Copyright 2014, 2015, 2016, 2017 Simon Lydell
// License: MIT. (See LICENSE.)

Object.defineProperty(exports, "__esModule", {
  value: true
})

// This regex comes from regex.coffee, and is inserted here by generate-index.js
// (run `npm run build`).
exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyu]{1,5}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g

exports.matchToToken = function(match) {
  var token = {type: "invalid", value: match[0]}
       if (match[ 1]) token.type = "string" , token.closed = !!(match[3] || match[4])
  else if (match[ 5]) token.type = "comment"
  else if (match[ 6]) token.type = "comment", token.closed = !!match[7]
  else if (match[ 8]) token.type = "regex"
  else if (match[ 9]) token.type = "number"
  else if (match[10]) token.type = "name"
  else if (match[11]) token.type = "punctuator"
  else if (match[12]) token.type = "whitespace"
  return token
}

},{}],206:[function(require,module,exports){
"use strict";
var LF = '\n';
var CR = '\r';
var LinesAndColumns = (function () {
    function LinesAndColumns(string) {
        this.string = string;
        var offsets = [0];
        for (var offset = 0; offset < string.length;) {
            switch (string[offset]) {
                case LF:
                    offset += LF.length;
                    offsets.push(offset);
                    break;
                case CR:
                    offset += CR.length;
                    if (string[offset] === LF) {
                        offset += LF.length;
                    }
                    offsets.push(offset);
                    break;
                default:
                    offset++;
                    break;
            }
        }
        this.offsets = offsets;
    }
    LinesAndColumns.prototype.locationForIndex = function (index) {
        if (index < 0 || index > this.string.length) {
            return null;
        }
        var line = 0;
        var offsets = this.offsets;
        while (offsets[line + 1] <= index) {
            line++;
        }
        var column = index - offsets[line];
        return { line: line, column: column };
    };
    LinesAndColumns.prototype.indexForLocation = function (location) {
        var line = location.line, column = location.column;
        if (line < 0 || line >= this.offsets.length) {
            return null;
        }
        if (column < 0 || column > this.lengthOfLine(line)) {
            return null;
        }
        return this.offsets[line] + column;
    };
    LinesAndColumns.prototype.lengthOfLine = function (line) {
        var offset = this.offsets[line];
        var nextOffset = line === this.offsets.length - 1 ? this.string.length : this.offsets[line + 1];
        return nextOffset - offset;
    };
    return LinesAndColumns;
}());
exports.__esModule = true;
exports["default"] = LinesAndColumns;

},{}],207:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

},{"./_getNative":278,"./_root":316}],208:[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":285,"./_hashDelete":286,"./_hashGet":287,"./_hashHas":288,"./_hashSet":289}],209:[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":298,"./_listCacheDelete":299,"./_listCacheGet":300,"./_listCacheHas":301,"./_listCacheSet":302}],210:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":278,"./_root":316}],211:[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":303,"./_mapCacheDelete":304,"./_mapCacheGet":305,"./_mapCacheHas":306,"./_mapCacheSet":307}],212:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

},{"./_getNative":278,"./_root":316}],213:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

},{"./_getNative":278,"./_root":316}],214:[function(require,module,exports){
var MapCache = require('./_MapCache'),
    setCacheAdd = require('./_setCacheAdd'),
    setCacheHas = require('./_setCacheHas');

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;

},{"./_MapCache":211,"./_setCacheAdd":317,"./_setCacheHas":318}],215:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":209,"./_stackClear":322,"./_stackDelete":323,"./_stackGet":324,"./_stackHas":325,"./_stackSet":326}],216:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":316}],217:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":316}],218:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":278,"./_root":316}],219:[function(require,module,exports){
/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

module.exports = addMapEntry;

},{}],220:[function(require,module,exports){
/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

module.exports = addSetEntry;

},{}],221:[function(require,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],222:[function(require,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],223:[function(require,module,exports){
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;

},{}],224:[function(require,module,exports){
var baseIndexOf = require('./_baseIndexOf');

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;

},{"./_baseIndexOf":240}],225:[function(require,module,exports){
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;

},{}],226:[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isIndex = require('./_isIndex'),
    isTypedArray = require('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":251,"./_isIndex":293,"./isArguments":337,"./isArray":338,"./isBuffer":340,"./isTypedArray":349}],227:[function(require,module,exports){
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],228:[function(require,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],229:[function(require,module,exports){
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;

},{}],230:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":234,"./eq":334}],231:[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":334}],232:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keys = require('./keys');

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

},{"./_copyObject":266,"./keys":350}],233:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

},{"./_copyObject":266,"./keysIn":351}],234:[function(require,module,exports){
var defineProperty = require('./_defineProperty');

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":273}],235:[function(require,module,exports){
var Stack = require('./_Stack'),
    arrayEach = require('./_arrayEach'),
    assignValue = require('./_assignValue'),
    baseAssign = require('./_baseAssign'),
    baseAssignIn = require('./_baseAssignIn'),
    cloneBuffer = require('./_cloneBuffer'),
    copyArray = require('./_copyArray'),
    copySymbols = require('./_copySymbols'),
    copySymbolsIn = require('./_copySymbolsIn'),
    getAllKeys = require('./_getAllKeys'),
    getAllKeysIn = require('./_getAllKeysIn'),
    getTag = require('./_getTag'),
    initCloneArray = require('./_initCloneArray'),
    initCloneByTag = require('./_initCloneByTag'),
    initCloneObject = require('./_initCloneObject'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isObject = require('./isObject'),
    keys = require('./keys');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

},{"./_Stack":215,"./_arrayEach":222,"./_assignValue":230,"./_baseAssign":232,"./_baseAssignIn":233,"./_cloneBuffer":258,"./_copyArray":265,"./_copySymbols":267,"./_copySymbolsIn":268,"./_getAllKeys":275,"./_getAllKeysIn":276,"./_getTag":283,"./_initCloneArray":290,"./_initCloneByTag":291,"./_initCloneObject":292,"./isArray":338,"./isBuffer":340,"./isObject":343,"./keys":350}],236:[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;

},{"./isObject":343}],237:[function(require,module,exports){
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;

},{}],238:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isArray = require('./isArray');

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

},{"./_arrayPush":228,"./isArray":338}],239:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":216,"./_getRawTag":280,"./_objectToString":313}],240:[function(require,module,exports){
var baseFindIndex = require('./_baseFindIndex'),
    baseIsNaN = require('./_baseIsNaN'),
    strictIndexOf = require('./_strictIndexOf');

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;

},{"./_baseFindIndex":237,"./_baseIsNaN":242,"./_strictIndexOf":327}],241:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":239,"./isObjectLike":344}],242:[function(require,module,exports){
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;

},{}],243:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":296,"./_toSource":328,"./isFunction":341,"./isObject":343}],244:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var regexpTag = '[object RegExp]';

/**
 * The base implementation of `_.isRegExp` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 */
function baseIsRegExp(value) {
  return isObjectLike(value) && baseGetTag(value) == regexpTag;
}

module.exports = baseIsRegExp;

},{"./_baseGetTag":239,"./isObjectLike":344}],245:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":239,"./isLength":342,"./isObjectLike":344}],246:[function(require,module,exports){
var isPrototype = require('./_isPrototype'),
    nativeKeys = require('./_nativeKeys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":297,"./_nativeKeys":310}],247:[function(require,module,exports){
var isObject = require('./isObject'),
    isPrototype = require('./_isPrototype'),
    nativeKeysIn = require('./_nativeKeysIn');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":297,"./_nativeKeysIn":311,"./isObject":343}],248:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor;

/**
 * The base implementation of `_.repeat` which doesn't coerce arguments.
 *
 * @private
 * @param {string} string The string to repeat.
 * @param {number} n The number of times to repeat the string.
 * @returns {string} Returns the repeated string.
 */
function baseRepeat(string, n) {
  var result = '';
  if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
    return result;
  }
  // Leverage the exponentiation by squaring algorithm for a faster repeat.
  // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
  do {
    if (n % 2) {
      result += string;
    }
    n = nativeFloor(n / 2);
    if (n) {
      string += string;
    }
  } while (n);

  return result;
}

module.exports = baseRepeat;

},{}],249:[function(require,module,exports){
var identity = require('./identity'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

},{"./_overRest":315,"./_setToString":320,"./identity":335}],250:[function(require,module,exports){
var constant = require('./constant'),
    defineProperty = require('./_defineProperty'),
    identity = require('./identity');

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

},{"./_defineProperty":273,"./constant":332,"./identity":335}],251:[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],252:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    arrayMap = require('./_arrayMap'),
    isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;

},{"./_Symbol":216,"./_arrayMap":227,"./isArray":338,"./isSymbol":348}],253:[function(require,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],254:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arrayIncludes = require('./_arrayIncludes'),
    arrayIncludesWith = require('./_arrayIncludesWith'),
    cacheHas = require('./_cacheHas'),
    createSet = require('./_createSet'),
    setToArray = require('./_setToArray');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;

},{"./_SetCache":214,"./_arrayIncludes":224,"./_arrayIncludesWith":225,"./_cacheHas":256,"./_createSet":271,"./_setToArray":319}],255:[function(require,module,exports){
var arrayMap = require('./_arrayMap');

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;

},{"./_arrayMap":227}],256:[function(require,module,exports){
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

},{}],257:[function(require,module,exports){
var Uint8Array = require('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":217}],258:[function(require,module,exports){
var root = require('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":316}],259:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

},{"./_cloneArrayBuffer":257}],260:[function(require,module,exports){
var addMapEntry = require('./_addMapEntry'),
    arrayReduce = require('./_arrayReduce'),
    mapToArray = require('./_mapToArray');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

module.exports = cloneMap;

},{"./_addMapEntry":219,"./_arrayReduce":229,"./_mapToArray":308}],261:[function(require,module,exports){
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

},{}],262:[function(require,module,exports){
var addSetEntry = require('./_addSetEntry'),
    arrayReduce = require('./_arrayReduce'),
    setToArray = require('./_setToArray');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

module.exports = cloneSet;

},{"./_addSetEntry":220,"./_arrayReduce":229,"./_setToArray":319}],263:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

},{"./_Symbol":216}],264:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":257}],265:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],266:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    baseAssignValue = require('./_baseAssignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":230,"./_baseAssignValue":234}],267:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbols = require('./_getSymbols');

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

},{"./_copyObject":266,"./_getSymbols":281}],268:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbolsIn = require('./_getSymbolsIn');

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

},{"./_copyObject":266,"./_getSymbolsIn":282}],269:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":316}],270:[function(require,module,exports){
var baseRest = require('./_baseRest'),
    isIterateeCall = require('./_isIterateeCall');

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"./_baseRest":249,"./_isIterateeCall":294}],271:[function(require,module,exports){
var Set = require('./_Set'),
    noop = require('./noop'),
    setToArray = require('./_setToArray');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

module.exports = createSet;

},{"./_Set":213,"./_setToArray":319,"./noop":352}],272:[function(require,module,exports){
var eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */
function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === undefined ||
      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
    return srcValue;
  }
  return objValue;
}

module.exports = customDefaultsAssignIn;

},{"./eq":334}],273:[function(require,module,exports){
var getNative = require('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":278}],274:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],275:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbols = require('./_getSymbols'),
    keys = require('./keys');

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

},{"./_baseGetAllKeys":238,"./_getSymbols":281,"./keys":350}],276:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbolsIn = require('./_getSymbolsIn'),
    keysIn = require('./keysIn');

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

},{"./_baseGetAllKeys":238,"./_getSymbolsIn":282,"./keysIn":351}],277:[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":295}],278:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":243,"./_getValue":284}],279:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":314}],280:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":216}],281:[function(require,module,exports){
var arrayFilter = require('./_arrayFilter'),
    stubArray = require('./stubArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;

},{"./_arrayFilter":223,"./stubArray":354}],282:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    getPrototype = require('./_getPrototype'),
    getSymbols = require('./_getSymbols'),
    stubArray = require('./stubArray');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;

},{"./_arrayPush":228,"./_getPrototype":279,"./_getSymbols":281,"./stubArray":354}],283:[function(require,module,exports){
var DataView = require('./_DataView'),
    Map = require('./_Map'),
    Promise = require('./_Promise'),
    Set = require('./_Set'),
    WeakMap = require('./_WeakMap'),
    baseGetTag = require('./_baseGetTag'),
    toSource = require('./_toSource');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;

},{"./_DataView":207,"./_Map":210,"./_Promise":212,"./_Set":213,"./_WeakMap":218,"./_baseGetTag":239,"./_toSource":328}],284:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],285:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":309}],286:[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],287:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":309}],288:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":309}],289:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":309}],290:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],291:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer'),
    cloneDataView = require('./_cloneDataView'),
    cloneMap = require('./_cloneMap'),
    cloneRegExp = require('./_cloneRegExp'),
    cloneSet = require('./_cloneSet'),
    cloneSymbol = require('./_cloneSymbol'),
    cloneTypedArray = require('./_cloneTypedArray');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

},{"./_cloneArrayBuffer":257,"./_cloneDataView":259,"./_cloneMap":260,"./_cloneRegExp":261,"./_cloneSet":262,"./_cloneSymbol":263,"./_cloneTypedArray":264}],292:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":236,"./_getPrototype":279,"./_isPrototype":297}],293:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],294:[function(require,module,exports){
var eq = require('./eq'),
    isArrayLike = require('./isArrayLike'),
    isIndex = require('./_isIndex'),
    isObject = require('./isObject');

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;

},{"./_isIndex":293,"./eq":334,"./isArrayLike":339,"./isObject":343}],295:[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],296:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":269}],297:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],298:[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],299:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":231}],300:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":231}],301:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":231}],302:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":231}],303:[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":208,"./_ListCache":209,"./_Map":210}],304:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":277}],305:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":277}],306:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":277}],307:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":277}],308:[function(require,module,exports){
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

},{}],309:[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":278}],310:[function(require,module,exports){
var overArg = require('./_overArg');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

},{"./_overArg":314}],311:[function(require,module,exports){
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;

},{}],312:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":274}],313:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],314:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],315:[function(require,module,exports){
var apply = require('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

},{"./_apply":221}],316:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":274}],317:[function(require,module,exports){
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;

},{}],318:[function(require,module,exports){
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

},{}],319:[function(require,module,exports){
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

},{}],320:[function(require,module,exports){
var baseSetToString = require('./_baseSetToString'),
    shortOut = require('./_shortOut');

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

},{"./_baseSetToString":250,"./_shortOut":321}],321:[function(require,module,exports){
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

},{}],322:[function(require,module,exports){
var ListCache = require('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":209}],323:[function(require,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],324:[function(require,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],325:[function(require,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],326:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    Map = require('./_Map'),
    MapCache = require('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":209,"./_Map":210,"./_MapCache":211}],327:[function(require,module,exports){
/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;

},{}],328:[function(require,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],329:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    copyObject = require('./_copyObject'),
    createAssigner = require('./_createAssigner'),
    isArrayLike = require('./isArrayLike'),
    isPrototype = require('./_isPrototype'),
    keys = require('./keys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assign({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3 }
 */
var assign = createAssigner(function(object, source) {
  if (isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keys(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty.call(source, key)) {
      assignValue(object, key, source[key]);
    }
  }
});

module.exports = assign;

},{"./_assignValue":230,"./_copyObject":266,"./_createAssigner":270,"./_isPrototype":297,"./isArrayLike":339,"./keys":350}],330:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    createAssigner = require('./_createAssigner'),
    keysIn = require('./keysIn');

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});

module.exports = assignInWith;

},{"./_copyObject":266,"./_createAssigner":270,"./keysIn":351}],331:[function(require,module,exports){
var baseClone = require('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;

},{"./_baseClone":235}],332:[function(require,module,exports){
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

},{}],333:[function(require,module,exports){
var apply = require('./_apply'),
    assignInWith = require('./assignInWith'),
    baseRest = require('./_baseRest'),
    customDefaultsAssignIn = require('./_customDefaultsAssignIn');

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var defaults = baseRest(function(args) {
  args.push(undefined, customDefaultsAssignIn);
  return apply(assignInWith, undefined, args);
});

module.exports = defaults;

},{"./_apply":221,"./_baseRest":249,"./_customDefaultsAssignIn":272,"./assignInWith":330}],334:[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],335:[function(require,module,exports){
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],336:[function(require,module,exports){
var baseIndexOf = require('./_baseIndexOf'),
    isArrayLike = require('./isArrayLike'),
    isString = require('./isString'),
    toInteger = require('./toInteger'),
    values = require('./values');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'a': 1, 'b': 2 }, 1);
 * // => true
 *
 * _.includes('abcd', 'bc');
 * // => true
 */
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike(collection) ? collection : values(collection);
  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax(length + fromIndex, 0);
  }
  return isString(collection)
    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
}

module.exports = includes;

},{"./_baseIndexOf":240,"./isArrayLike":339,"./isString":347,"./toInteger":357,"./values":361}],337:[function(require,module,exports){
var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":241,"./isObjectLike":344}],338:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],339:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":341,"./isLength":342}],340:[function(require,module,exports){
var root = require('./_root'),
    stubFalse = require('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":316,"./stubFalse":355}],341:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":239,"./isObject":343}],342:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],343:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],344:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],345:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

},{"./_baseGetTag":239,"./_getPrototype":279,"./isObjectLike":344}],346:[function(require,module,exports){
var baseIsRegExp = require('./_baseIsRegExp'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;

/**
 * Checks if `value` is classified as a `RegExp` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 * @example
 *
 * _.isRegExp(/abc/);
 * // => true
 *
 * _.isRegExp('/abc/');
 * // => false
 */
var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

module.exports = isRegExp;

},{"./_baseIsRegExp":244,"./_baseUnary":253,"./_nodeUtil":312}],347:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isArray = require('./isArray'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;

},{"./_baseGetTag":239,"./isArray":338,"./isObjectLike":344}],348:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;

},{"./_baseGetTag":239,"./isObjectLike":344}],349:[function(require,module,exports){
var baseIsTypedArray = require('./_baseIsTypedArray'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":245,"./_baseUnary":253,"./_nodeUtil":312}],350:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeys = require('./_baseKeys'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":226,"./_baseKeys":246,"./isArrayLike":339}],351:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeysIn = require('./_baseKeysIn'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":226,"./_baseKeysIn":247,"./isArrayLike":339}],352:[function(require,module,exports){
/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;

},{}],353:[function(require,module,exports){
var baseRepeat = require('./_baseRepeat'),
    isIterateeCall = require('./_isIterateeCall'),
    toInteger = require('./toInteger'),
    toString = require('./toString');

/**
 * Repeats the given string `n` times.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to repeat.
 * @param {number} [n=1] The number of times to repeat the string.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the repeated string.
 * @example
 *
 * _.repeat('*', 3);
 * // => '***'
 *
 * _.repeat('abc', 2);
 * // => 'abcabc'
 *
 * _.repeat('abc', 0);
 * // => ''
 */
function repeat(string, n, guard) {
  if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
    n = 1;
  } else {
    n = toInteger(n);
  }
  return baseRepeat(toString(string), n);
}

module.exports = repeat;

},{"./_baseRepeat":248,"./_isIterateeCall":294,"./toInteger":357,"./toString":359}],354:[function(require,module,exports){
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

},{}],355:[function(require,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],356:[function(require,module,exports){
var toNumber = require('./toNumber');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

},{"./toNumber":358}],357:[function(require,module,exports){
var toFinite = require('./toFinite');

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;

},{"./toFinite":356}],358:[function(require,module,exports){
var isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isObject":343,"./isSymbol":348}],359:[function(require,module,exports){
var baseToString = require('./_baseToString');

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

},{"./_baseToString":252}],360:[function(require,module,exports){
var baseUniq = require('./_baseUniq');

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each element
 * is kept. The order of result values is determined by the order they occur
 * in the array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return (array && array.length) ? baseUniq(array) : [];
}

module.exports = uniq;

},{"./_baseUniq":254}],361:[function(require,module,exports){
var baseValues = require('./_baseValues'),
    keys = require('./keys');

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;

},{"./_baseValues":255,"./keys":350}],362:[function(require,module,exports){
(function (process,Buffer){
'use strict';

var vlq = require('vlq');

function Chunk ( start, end, content ) {
	this.start = start;
	this.end = end;
	this.original = content;

	this.intro = '';
	this.outro = '';

	this.content = content;
	this.storeName = false;
	this.edited = false;

	// we make these non-enumerable, for sanity while debugging
	Object.defineProperties( this, {
		previous: { writable: true, value: null },
		next: { writable: true, value: null }
	});
}

Chunk.prototype = {
	appendLeft: function appendLeft ( content ) {
		this.outro += content;
	},

	appendRight: function appendRight ( content ) {
		this.intro = this.intro + content;
	},

	clone: function clone () {
		var chunk = new Chunk( this.start, this.end, this.original );

		chunk.intro = this.intro;
		chunk.outro = this.outro;
		chunk.content = this.content;
		chunk.storeName = this.storeName;
		chunk.edited = this.edited;

		return chunk;
	},

	contains: function contains ( index ) {
		return this.start < index && index < this.end;
	},

	eachNext: function eachNext ( fn ) {
		var chunk = this;
		while ( chunk ) {
			fn( chunk );
			chunk = chunk.next;
		}
	},

	eachPrevious: function eachPrevious ( fn ) {
		var chunk = this;
		while ( chunk ) {
			fn( chunk );
			chunk = chunk.previous;
		}
	},

	edit: function edit ( content, storeName ) {
		this.content = content;
		this.intro = '';
		this.outro = '';
		this.storeName = storeName;

		this.edited = true;

		return this;
	},

	prependLeft: function prependLeft ( content ) {
		this.outro = content + this.outro;
	},

	prependRight: function prependRight ( content ) {
		this.intro = content + this.intro;
	},

	split: function split ( index ) {
		var sliceIndex = index - this.start;

		var originalBefore = this.original.slice( 0, sliceIndex );
		var originalAfter = this.original.slice( sliceIndex );

		this.original = originalBefore;

		var newChunk = new Chunk( index, this.end, originalAfter );
		newChunk.outro = this.outro;
		this.outro = '';

		this.end = index;

		if ( this.edited ) {
			// TODO is this block necessary?...
			newChunk.edit( '', false );
			this.content = '';
		} else {
			this.content = originalBefore;
		}

		newChunk.next = this.next;
		if ( newChunk.next ) { newChunk.next.previous = newChunk; }
		newChunk.previous = this;
		this.next = newChunk;

		return newChunk;
	},

	toString: function toString () {
		return this.intro + this.content + this.outro;
	},

	trimEnd: function trimEnd ( rx ) {
		this.outro = this.outro.replace( rx, '' );
		if ( this.outro.length ) { return true; }

		var trimmed = this.content.replace( rx, '' );

		if ( trimmed.length ) {
			if ( trimmed !== this.content ) {
				this.split( this.start + trimmed.length ).edit( '', false );
			}

			return true;
		} else {
			this.edit( '', false );

			this.intro = this.intro.replace( rx, '' );
			if ( this.intro.length ) { return true; }
		}
	},

	trimStart: function trimStart ( rx ) {
		this.intro = this.intro.replace( rx, '' );
		if ( this.intro.length ) { return true; }

		var trimmed = this.content.replace( rx, '' );

		if ( trimmed.length ) {
			if ( trimmed !== this.content ) {
				this.split( this.end - trimmed.length );
				this.edit( '', false );
			}

			return true;
		} else {
			this.edit( '', false );

			this.outro = this.outro.replace( rx, '' );
			if ( this.outro.length ) { return true; }
		}
	}
};

var _btoa;

if ( typeof window !== 'undefined' && typeof window.btoa === 'function' ) {
	_btoa = window.btoa;
} else if ( typeof Buffer === 'function' ) {
	_btoa = function (str) { return new Buffer( str ).toString( 'base64' ); };
} else {
	_btoa = function () {
		throw new Error( 'Unsupported environment: `window.btoa` or `Buffer` should be supported.' );
	};
}

var btoa = _btoa;

function SourceMap ( properties ) {
	this.version = 3;

	this.file           = properties.file;
	this.sources        = properties.sources;
	this.sourcesContent = properties.sourcesContent;
	this.names          = properties.names;
	this.mappings       = properties.mappings;
}

SourceMap.prototype = {
	toString: function toString () {
		return JSON.stringify( this );
	},

	toUrl: function toUrl () {
		return 'data:application/json;charset=utf-8;base64,' + btoa( this.toString() );
	}
};

function guessIndent ( code ) {
	var lines = code.split( '\n' );

	var tabbed = lines.filter( function (line) { return /^\t+/.test( line ); } );
	var spaced = lines.filter( function (line) { return /^ {2,}/.test( line ); } );

	if ( tabbed.length === 0 && spaced.length === 0 ) {
		return null;
	}

	// More lines tabbed than spaced? Assume tabs, and
	// default to tabs in the case of a tie (or nothing
	// to go on)
	if ( tabbed.length >= spaced.length ) {
		return '\t';
	}

	// Otherwise, we need to guess the multiple
	var min = spaced.reduce( function ( previous, current ) {
		var numSpaces = /^ +/.exec( current )[0].length;
		return Math.min( numSpaces, previous );
	}, Infinity );

	return new Array( min + 1 ).join( ' ' );
}

function getSemis ( str ) {
	return new Array( str.split( '\n' ).length ).join( ';' );
}

function getLocator ( source ) {
	var originalLines = source.split( '\n' );

	var start = 0;
	var lineRanges = originalLines.map( function ( line, i ) {
		var end = start + line.length + 1;
		var range = { start: start, end: end, line: i };

		start = end;
		return range;
	});

	var i = 0;

	function rangeContains ( range, index ) {
		return range.start <= index && index < range.end;
	}

	function getLocation ( range, index ) {
		return { line: range.line, column: index - range.start };
	}

	return function locate ( index ) {
		var range = lineRanges[i];

		var d = index >= range.end ? 1 : -1;

		while ( range ) {
			if ( rangeContains( range, index ) ) { return getLocation( range, index ); }

			i += d;
			range = lineRanges[i];
		}
	};
}

var nonWhitespace = /\S/;

function encodeMappings ( original, intro, outro, chunk, hires, sourcemapLocations, sourceIndex, offsets, names ) {
	var rawLines = [];

	var generatedCodeLine = intro.split( '\n' ).length - 1;
	var rawSegments = rawLines[ generatedCodeLine ] = [];

	var generatedCodeColumn = 0;

	var locate = getLocator( original );

	function addEdit ( content, original, loc, nameIndex, i ) {
		if ( i || ( content.length && nonWhitespace.test( content ) ) ) {
			rawSegments.push({
				generatedCodeLine: generatedCodeLine,
				generatedCodeColumn: generatedCodeColumn,
				sourceCodeLine: loc.line,
				sourceCodeColumn: loc.column,
				sourceCodeName: nameIndex,
				sourceIndex: sourceIndex
			});
		}

		var lines = content.split( '\n' );
		var lastLine = lines.pop();

		if ( lines.length ) {
			generatedCodeLine += lines.length;
			rawLines[ generatedCodeLine ] = rawSegments = [];
			generatedCodeColumn = lastLine.length;
		} else {
			generatedCodeColumn += lastLine.length;
		}

		lines = original.split( '\n' );
		lastLine = lines.pop();

		if ( lines.length ) {
			loc.line += lines.length;
			loc.column = lastLine.length;
		} else {
			loc.column += lastLine.length;
		}
	}

	function addUneditedChunk ( chunk, loc ) {
		var originalCharIndex = chunk.start;
		var first = true;

		while ( originalCharIndex < chunk.end ) {
			if ( hires || first || sourcemapLocations[ originalCharIndex ] ) {
				rawSegments.push({
					generatedCodeLine: generatedCodeLine,
					generatedCodeColumn: generatedCodeColumn,
					sourceCodeLine: loc.line,
					sourceCodeColumn: loc.column,
					sourceCodeName: -1,
					sourceIndex: sourceIndex
				});
			}

			if ( original[ originalCharIndex ] === '\n' ) {
				loc.line += 1;
				loc.column = 0;
				generatedCodeLine += 1;
				rawLines[ generatedCodeLine ] = rawSegments = [];
				generatedCodeColumn = 0;
			} else {
				loc.column += 1;
				generatedCodeColumn += 1;
			}

			originalCharIndex += 1;
			first = false;
		}
	}

	var hasContent = false;

	while ( chunk ) {
		var loc = locate( chunk.start );

		if ( chunk.intro.length ) {
			addEdit( chunk.intro, '', loc, -1, hasContent );
		}

		if ( chunk.edited ) {
			addEdit( chunk.content, chunk.original, loc, chunk.storeName ? names.indexOf( chunk.original ) : -1, hasContent );
		} else {
			addUneditedChunk( chunk, loc );
		}

		if ( chunk.outro.length ) {
			addEdit( chunk.outro, '', loc, -1, hasContent );
		}

		if ( chunk.content || chunk.intro || chunk.outro ) { hasContent = true; }

		var nextChunk = chunk.next;
		chunk = nextChunk;
	}

	offsets.sourceIndex = offsets.sourceIndex || 0;
	offsets.sourceCodeLine = offsets.sourceCodeLine || 0;
	offsets.sourceCodeColumn = offsets.sourceCodeColumn || 0;
	offsets.sourceCodeName = offsets.sourceCodeName || 0;

	return rawLines.map( function (segments) {
		var generatedCodeColumn = 0;

		return segments.map( function (segment) {
			var arr = [
				segment.generatedCodeColumn - generatedCodeColumn,
				segment.sourceIndex - offsets.sourceIndex,
				segment.sourceCodeLine - offsets.sourceCodeLine,
				segment.sourceCodeColumn - offsets.sourceCodeColumn
			];

			generatedCodeColumn = segment.generatedCodeColumn;
			offsets.sourceIndex = segment.sourceIndex;
			offsets.sourceCodeLine = segment.sourceCodeLine;
			offsets.sourceCodeColumn = segment.sourceCodeColumn;

			if ( ~segment.sourceCodeName ) {
				arr.push( segment.sourceCodeName - offsets.sourceCodeName );
				offsets.sourceCodeName = segment.sourceCodeName;
			}

			return vlq.encode( arr );
		}).join( ',' );
	}).join( ';' ) + getSemis(outro);
}

function getRelativePath ( from, to ) {
	var fromParts = from.split( /[\/\\]/ );
	var toParts = to.split( /[\/\\]/ );

	fromParts.pop(); // get dirname

	while ( fromParts[0] === toParts[0] ) {
		fromParts.shift();
		toParts.shift();
	}

	if ( fromParts.length ) {
		var i = fromParts.length;
		while ( i-- ) { fromParts[i] = '..'; }
	}

	return fromParts.concat( toParts ).join( '/' );
}

var toString$1 = Object.prototype.toString;

function isObject ( thing ) {
	return toString$1.call( thing ) === '[object Object]';
}

var Stats = function Stats () {
	Object.defineProperties( this, {
		startTimes: { value: {} }
	});
};

Stats.prototype.time = function time ( label ) {
	this.startTimes[ label ] = process.hrtime();
};

Stats.prototype.timeEnd = function timeEnd ( label ) {
	var elapsed = process.hrtime( this.startTimes[ label ] );

	if ( !this[ label ] ) { this[ label ] = 0; }
	this[ label ] += elapsed[0] * 1e3 + elapsed[1] * 1e-6;
};

var warned = {
	insertLeft: false,
	insertRight: false
};

function MagicString$1 ( string, options ) {
	if ( options === void 0 ) options = {};

	var chunk = new Chunk( 0, string.length, string );

	Object.defineProperties( this, {
		original:              { writable: true, value: string },
		outro:                 { writable: true, value: '' },
		intro:                 { writable: true, value: '' },
		firstChunk:            { writable: true, value: chunk },
		lastChunk:             { writable: true, value: chunk },
		lastSearchedChunk:     { writable: true, value: chunk },
		byStart:               { writable: true, value: {} },
		byEnd:                 { writable: true, value: {} },
		filename:              { writable: true, value: options.filename },
		indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
		sourcemapLocations:    { writable: true, value: {} },
		storedNames:           { writable: true, value: {} },
		indentStr:             { writable: true, value: guessIndent( string ) }
	});

	this.byStart[ 0 ] = chunk;
	this.byEnd[ string.length ] = chunk;
}

MagicString$1.prototype = {
	addSourcemapLocation: function addSourcemapLocation ( char ) {
		this.sourcemapLocations[ char ] = true;
	},

	append: function append ( content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'outro content must be a string' ); }

		this.outro += content;
		return this;
	},

	appendLeft: function appendLeft ( index, content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }

		this._split( index );

		var chunk = this.byEnd[ index ];

		if ( chunk ) {
			chunk.appendLeft( content );
		} else {
			this.intro += content;
		}

		return this;
	},

	appendRight: function appendRight ( index, content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }

		this._split( index );

		var chunk = this.byStart[ index ];

		if ( chunk ) {
			chunk.appendRight( content );
		} else {
			this.outro += content;
		}

		return this;
	},

	clone: function clone () {
		var cloned = new MagicString$1( this.original, { filename: this.filename });

		var originalChunk = this.firstChunk;
		var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();

		while ( originalChunk ) {
			cloned.byStart[ clonedChunk.start ] = clonedChunk;
			cloned.byEnd[ clonedChunk.end ] = clonedChunk;

			var nextOriginalChunk = originalChunk.next;
			var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();

			if ( nextClonedChunk ) {
				clonedChunk.next = nextClonedChunk;
				nextClonedChunk.previous = clonedChunk;

				clonedChunk = nextClonedChunk;
			}

			originalChunk = nextOriginalChunk;
		}

		cloned.lastChunk = clonedChunk;

		if ( this.indentExclusionRanges ) {
			cloned.indentExclusionRanges = typeof this.indentExclusionRanges[0] === 'number' ?
				[ this.indentExclusionRanges[0], this.indentExclusionRanges[1] ] :
				this.indentExclusionRanges.map( function (range) { return [ range.start, range.end ]; } );
		}

		Object.keys( this.sourcemapLocations ).forEach( function (loc) {
			cloned.sourcemapLocations[ loc ] = true;
		});

		return cloned;
	},

	generateMap: function generateMap ( options ) {
		options = options || {};

		var names = Object.keys( this.storedNames );

		var map = new SourceMap({
			file: ( options.file ? options.file.split( /[\/\\]/ ).pop() : null ),
			sources: [ options.source ? getRelativePath( options.file || '', options.source ) : null ],
			sourcesContent: options.includeContent ? [ this.original ] : [ null ],
			names: names,
			mappings: this.getMappings( options, 0, {}, names )
		});
		return map;
	},

	getIndentString: function getIndentString () {
		return this.indentStr === null ? '\t' : this.indentStr;
	},

	getMappings: function getMappings ( options, sourceIndex, offsets, names ) {
		return encodeMappings( this.original, this.intro, this.outro, this.firstChunk, options.hires, this.sourcemapLocations, sourceIndex, offsets, names );
	},

	indent: function indent ( indentStr, options ) {
		var this$1 = this;

		var pattern = /^[^\r\n]/gm;

		if ( isObject( indentStr ) ) {
			options = indentStr;
			indentStr = undefined;
		}

		indentStr = indentStr !== undefined ? indentStr : ( this.indentStr || '\t' );

		if ( indentStr === '' ) { return this; } // noop

		options = options || {};

		// Process exclusion ranges
		var isExcluded = {};

		if ( options.exclude ) {
			var exclusions = typeof options.exclude[0] === 'number' ? [ options.exclude ] : options.exclude;
			exclusions.forEach( function (exclusion) {
				for ( var i = exclusion[0]; i < exclusion[1]; i += 1 ) {
					isExcluded[i] = true;
				}
			});
		}

		var shouldIndentNextCharacter = options.indentStart !== false;
		var replacer = function (match) {
			if ( shouldIndentNextCharacter ) { return ("" + indentStr + match); }
			shouldIndentNextCharacter = true;
			return match;
		};

		this.intro = this.intro.replace( pattern, replacer );

		var charIndex = 0;

		var chunk = this.firstChunk;

		while ( chunk ) {
			var end = chunk.end;

			if ( chunk.edited ) {
				if ( !isExcluded[ charIndex ] ) {
					chunk.content = chunk.content.replace( pattern, replacer );

					if ( chunk.content.length ) {
						shouldIndentNextCharacter = chunk.content[ chunk.content.length - 1 ] === '\n';
					}
				}
			} else {
				charIndex = chunk.start;

				while ( charIndex < end ) {
					if ( !isExcluded[ charIndex ] ) {
						var char = this$1.original[ charIndex ];

						if ( char === '\n' ) {
							shouldIndentNextCharacter = true;
						} else if ( char !== '\r' && shouldIndentNextCharacter ) {
							shouldIndentNextCharacter = false;

							if ( charIndex === chunk.start ) {
								chunk.prependRight( indentStr );
							} else {
								var rhs = chunk.split( charIndex );
								rhs.prependRight( indentStr );

								this$1.byStart[ charIndex ] = rhs;
								this$1.byEnd[ charIndex ] = chunk;

								chunk = rhs;
							}
						}
					}

					charIndex += 1;
				}
			}

			charIndex = chunk.end;
			chunk = chunk.next;
		}

		this.outro = this.outro.replace( pattern, replacer );

		return this;
	},

	insert: function insert () {
		throw new Error( 'magicString.insert(...) is deprecated. Use insertRight(...) or insertLeft(...)' );
	},

	insertLeft: function insertLeft ( index, content ) {
		if ( !warned.insertLeft ) {
			console.warn( 'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead' ); // eslint-disable-line no-console
			warned.insertLeft = true;
		}

		return this.appendLeft( index, content );
	},

	insertRight: function insertRight ( index, content ) {
		if ( !warned.insertRight ) {
			console.warn( 'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead' ); // eslint-disable-line no-console
			warned.insertRight = true;
		}

		return this.prependRight( index, content );
	},

	move: function move ( start, end, index ) {
		if ( index >= start && index <= end ) { throw new Error( 'Cannot move a selection inside itself' ); }

		this._split( start );
		this._split( end );
		this._split( index );

		var first = this.byStart[ start ];
		var last = this.byEnd[ end ];

		var oldLeft = first.previous;
		var oldRight = last.next;

		var newRight = this.byStart[ index ];
		if ( !newRight && last === this.lastChunk ) { return this; }
		var newLeft = newRight ? newRight.previous : this.lastChunk;

		if ( oldLeft ) { oldLeft.next = oldRight; }
		if ( oldRight ) { oldRight.previous = oldLeft; }

		if ( newLeft ) { newLeft.next = first; }
		if ( newRight ) { newRight.previous = last; }

		if ( !first.previous ) { this.firstChunk = last.next; }
		if ( !last.next ) {
			this.lastChunk = first.previous;
			this.lastChunk.next = null;
		}

		first.previous = newLeft;
		last.next = newRight;

		if ( !newLeft ) { this.firstChunk = first; }
		if ( !newRight ) { this.lastChunk = last; }

		return this;
	},

	overwrite: function overwrite ( start, end, content, storeName ) {
		var this$1 = this;

		if ( typeof content !== 'string' ) { throw new TypeError( 'replacement content must be a string' ); }

		while ( start < 0 ) { start += this$1.original.length; }
		while ( end < 0 ) { end += this$1.original.length; }

		if ( end > this.original.length ) { throw new Error( 'end is out of bounds' ); }
		if ( start === end ) { throw new Error( 'Cannot overwrite a zero-length range – use insertLeft or insertRight instead' ); }

		this._split( start );
		this._split( end );

		if ( storeName ) {
			var original = this.original.slice( start, end );
			this.storedNames[ original ] = true;
		}

		var first = this.byStart[ start ];
		var last = this.byEnd[ end ];

		if ( first ) {
			first.edit( content, storeName );

			if ( first !== last ) {
				var chunk = first.next;
				while ( chunk !== last ) {
					chunk.edit( '', false );
					chunk = chunk.next;
				}

				chunk.edit( '', false );
			}
		}

		else {
			// must be inserting at the end
			var newChunk = new Chunk( start, end, '' ).edit( content, storeName );

			// TODO last chunk in the array may not be the last chunk, if it's moved...
			last.next = newChunk;
			newChunk.previous = last;
		}

		return this;
	},

	prepend: function prepend ( content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'outro content must be a string' ); }

		this.intro = content + this.intro;
		return this;
	},

	prependLeft: function prependLeft ( index, content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }

		this._split( index );

		var chunk = this.byEnd[ index ];

		if ( chunk ) {
			chunk.prependLeft( content );
		} else {
			this.intro = content + this.intro;
		}

		return this;
	},

	prependRight: function prependRight ( index, content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }

		this._split( index );

		var chunk = this.byStart[ index ];

		if ( chunk ) {
			chunk.prependRight( content );
		} else {
			this.outro = content + this.outro;
		}

		return this;
	},

	remove: function remove ( start, end ) {
		var this$1 = this;

		while ( start < 0 ) { start += this$1.original.length; }
		while ( end < 0 ) { end += this$1.original.length; }

		if ( start === end ) { return this; }

		if ( start < 0 || end > this.original.length ) { throw new Error( 'Character is out of bounds' ); }
		if ( start > end ) { throw new Error( 'end must be greater than start' ); }

		return this.overwrite( start, end, '', false );
	},

	slice: function slice ( start, end ) {
		var this$1 = this;
		if ( start === void 0 ) start = 0;
		if ( end === void 0 ) end = this.original.length;

		while ( start < 0 ) { start += this$1.original.length; }
		while ( end < 0 ) { end += this$1.original.length; }

		var result = '';

		// find start chunk
		var chunk = this.firstChunk;
		while ( chunk && ( chunk.start > start || chunk.end <= start ) ) {

			// found end chunk before start
			if ( chunk.start < end && chunk.end >= end ) {
				return result;
			}

			chunk = chunk.next;
		}

		if ( chunk && chunk.edited && chunk.start !== start ) { throw new Error(("Cannot use replaced character " + start + " as slice start anchor.")); }

		var startChunk = chunk;
		while ( chunk ) {
			if ( chunk.intro && ( startChunk !== chunk || chunk.start === start ) ) {
				result += chunk.intro;
			}

			var containsEnd = chunk.start < end && chunk.end >= end;
			if ( containsEnd && chunk.edited && chunk.end !== end ) { throw new Error(("Cannot use replaced character " + end + " as slice end anchor.")); }

			var sliceStart = startChunk === chunk ? start - chunk.start : 0;
			var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;

			result += chunk.content.slice( sliceStart, sliceEnd );

			if ( chunk.outro && ( !containsEnd || chunk.end === end ) ) {
				result += chunk.outro;
			}

			if ( containsEnd ) {
				break;
			}

			chunk = chunk.next;
		}

		return result;
	},

	// TODO deprecate this? not really very useful
	snip: function snip ( start, end ) {
		var clone = this.clone();
		clone.remove( 0, start );
		clone.remove( end, clone.original.length );

		return clone;
	},

	_split: function _split ( index ) {
		var this$1 = this;

		if ( this.byStart[ index ] || this.byEnd[ index ] ) { return; }

		var chunk = this.lastSearchedChunk;
		var searchForward = index > chunk.end;

		while ( true ) {
			if ( chunk.contains( index ) ) { return this$1._splitChunk( chunk, index ); }

			chunk = searchForward ?
				this$1.byStart[ chunk.end ] :
				this$1.byEnd[ chunk.start ];
		}
	},

	_splitChunk: function _splitChunk ( chunk, index ) {
		if ( chunk.edited && chunk.content.length ) { // zero-length edited chunks are a special case (overlapping replacements)
			var loc = getLocator( this.original )( index );
			throw new Error( ("Cannot split a chunk that has already been edited (" + (loc.line) + ":" + (loc.column) + " – \"" + (chunk.original) + "\")") );
		}

		var newChunk = chunk.split( index );

		this.byEnd[ index ] = chunk;
		this.byStart[ index ] = newChunk;
		this.byEnd[ newChunk.end ] = newChunk;

		if ( chunk === this.lastChunk ) { this.lastChunk = newChunk; }

		this.lastSearchedChunk = chunk;
		return true;
	},

	toString: function toString () {
		var str = this.intro;

		var chunk = this.firstChunk;
		while ( chunk ) {
			str += chunk.toString();
			chunk = chunk.next;
		}

		return str + this.outro;
	},

	trimLines: function trimLines () {
		return this.trim('[\\r\\n]');
	},

	trim: function trim ( charType ) {
		return this.trimStart( charType ).trimEnd( charType );
	},

	trimEnd: function trimEnd ( charType ) {
		var this$1 = this;

		var rx = new RegExp( ( charType || '\\s' ) + '+$' );

		this.outro = this.outro.replace( rx, '' );
		if ( this.outro.length ) { return this; }

		var chunk = this.lastChunk;

		do {
			var end = chunk.end;
			var aborted = chunk.trimEnd( rx );

			// if chunk was trimmed, we have a new lastChunk
			if ( chunk.end !== end ) {
				this$1.lastChunk = chunk.next;

				this$1.byEnd[ chunk.end ] = chunk;
				this$1.byStart[ chunk.next.start ] = chunk.next;
			}

			if ( aborted ) { return this$1; }
			chunk = chunk.previous;
		} while ( chunk );

		return this;
	},

	trimStart: function trimStart ( charType ) {
		var this$1 = this;

		var rx = new RegExp( '^' + ( charType || '\\s' ) + '+' );

		this.intro = this.intro.replace( rx, '' );
		if ( this.intro.length ) { return this; }

		var chunk = this.firstChunk;

		do {
			var end = chunk.end;
			var aborted = chunk.trimStart( rx );

			if ( chunk.end !== end ) {
				// special case...
				if ( chunk === this$1.lastChunk ) { this$1.lastChunk = chunk.next; }

				this$1.byEnd[ chunk.end ] = chunk;
				this$1.byStart[ chunk.next.start ] = chunk.next;
			}

			if ( aborted ) { return this$1; }
			chunk = chunk.next;
		} while ( chunk );

		return this;
	}
};

var hasOwnProp = Object.prototype.hasOwnProperty;

function Bundle ( options ) {
	if ( options === void 0 ) options = {};

	this.intro = options.intro || '';
	this.separator = options.separator !== undefined ? options.separator : '\n';

	this.sources = [];

	this.uniqueSources = [];
	this.uniqueSourceIndexByFilename = {};
}

Bundle.prototype = {
	addSource: function addSource ( source ) {
		if ( source instanceof MagicString$1 ) {
			return this.addSource({
				content: source,
				filename: source.filename,
				separator: this.separator
			});
		}

		if ( !isObject( source ) || !source.content ) {
			throw new Error( 'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`' );
		}

		[ 'filename', 'indentExclusionRanges', 'separator' ].forEach( function (option) {
			if ( !hasOwnProp.call( source, option ) ) { source[ option ] = source.content[ option ]; }
		});

		if ( source.separator === undefined ) { // TODO there's a bunch of this sort of thing, needs cleaning up
			source.separator = this.separator;
		}

		if ( source.filename ) {
			if ( !hasOwnProp.call( this.uniqueSourceIndexByFilename, source.filename ) ) {
				this.uniqueSourceIndexByFilename[ source.filename ] = this.uniqueSources.length;
				this.uniqueSources.push({ filename: source.filename, content: source.content.original });
			} else {
				var uniqueSource = this.uniqueSources[ this.uniqueSourceIndexByFilename[ source.filename ] ];
				if ( source.content.original !== uniqueSource.content ) {
					throw new Error( ("Illegal source: same filename (" + (source.filename) + "), different contents") );
				}
			}
		}

		this.sources.push( source );
		return this;
	},

	append: function append ( str, options ) {
		this.addSource({
			content: new MagicString$1( str ),
			separator: ( options && options.separator ) || ''
		});

		return this;
	},

	clone: function clone () {
		var bundle = new Bundle({
			intro: this.intro,
			separator: this.separator
		});

		this.sources.forEach( function (source) {
			bundle.addSource({
				filename: source.filename,
				content: source.content.clone(),
				separator: source.separator
			});
		});

		return bundle;
	},

	generateMap: function generateMap ( options ) {
		if ( options === void 0 ) options = {};

		var names = [];
		this.sources.forEach( function (source) {
			Object.keys( source.content.storedNames ).forEach( function (name) {
				if ( !~names.indexOf( name ) ) { names.push( name ); }
			});
		});

		return new SourceMap({
			file: ( options.file ? options.file.split( /[\/\\]/ ).pop() : null ),
			sources: this.uniqueSources.map( function (source) {
				return options.file ? getRelativePath( options.file, source.filename ) : source.filename;
			}),
			sourcesContent: this.uniqueSources.map( function (source) {
				return options.includeContent ? source.content : null;
			}),
			names: names,
			mappings: this.getMappings( options, names )
		});
	},

	getMappings: function getMappings ( options, names ) {
		var this$1 = this;

		var offsets = {};

		return (
			getSemis( this.intro ) +
			this.sources.map( function ( source, i ) {
				var prefix = ( i > 0 ) ? ( getSemis( source.separator ) || ',' ) : '';
				var mappings;

				// we don't bother encoding sources without a filename
				if ( !source.filename ) {
					mappings = getSemis( source.content.toString() );
				} else {
					var sourceIndex = this$1.uniqueSourceIndexByFilename[ source.filename ];
					mappings = source.content.getMappings( options, sourceIndex, offsets, names );
				}

				return prefix + mappings;
			}).join( '' )
		);
	},

	getIndentString: function getIndentString () {
		var indentStringCounts = {};

		this.sources.forEach( function (source) {
			var indentStr = source.content.indentStr;

			if ( indentStr === null ) { return; }

			if ( !indentStringCounts[ indentStr ] ) { indentStringCounts[ indentStr ] = 0; }
			indentStringCounts[ indentStr ] += 1;
		});

		return ( Object.keys( indentStringCounts ).sort( function ( a, b ) {
			return indentStringCounts[a] - indentStringCounts[b];
		})[0] ) || '\t';
	},

	indent: function indent ( indentStr ) {
		var this$1 = this;

		if ( !arguments.length ) {
			indentStr = this.getIndentString();
		}

		if ( indentStr === '' ) { return this; } // noop

		var trailingNewline = !this.intro || this.intro.slice( -1 ) === '\n';

		this.sources.forEach( function ( source, i ) {
			var separator = source.separator !== undefined ? source.separator : this$1.separator;
			var indentStart = trailingNewline || ( i > 0 && /\r?\n$/.test( separator ) );

			source.content.indent( indentStr, {
				exclude: source.indentExclusionRanges,
				indentStart: indentStart//: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )
			});

			// TODO this is a very slow way to determine this
			trailingNewline = source.content.toString().slice( 0, -1 ) === '\n';
		});

		if ( this.intro ) {
			this.intro = indentStr + this.intro.replace( /^[^\n]/gm, function ( match, index ) {
				return index > 0 ? indentStr + match : match;
			});
		}

		return this;
	},

	prepend: function prepend ( str ) {
		this.intro = str + this.intro;
		return this;
	},

	toString: function toString () {
		var this$1 = this;

		var body = this.sources.map( function ( source, i ) {
			var separator = source.separator !== undefined ? source.separator : this$1.separator;
			var str = ( i > 0 ? separator : '' ) + source.content.toString();

			return str;
		}).join( '' );

		return this.intro + body;
	},

	trimLines: function trimLines () {
		return this.trim('[\\r\\n]');
	},

	trim: function trim ( charType ) {
		return this.trimStart( charType ).trimEnd( charType );
	},

	trimStart: function trimStart ( charType ) {
		var this$1 = this;

		var rx = new RegExp( '^' + ( charType || '\\s' ) + '+' );
		this.intro = this.intro.replace( rx, '' );

		if ( !this.intro ) {
			var source;
			var i = 0;

			do {
				source = this$1.sources[i];

				if ( !source ) {
					break;
				}

				source.content.trimStart( charType );
				i += 1;
			} while ( source.content.toString() === '' ); // TODO faster way to determine non-empty source?
		}

		return this;
	},

	trimEnd: function trimEnd ( charType ) {
		var this$1 = this;

		var rx = new RegExp( ( charType || '\\s' ) + '+$' );

		var source;
		var i = this.sources.length - 1;

		do {
			source = this$1.sources[i];

			if ( !source ) {
				this$1.intro = this$1.intro.replace( rx, '' );
				break;
			}

			source.content.trimEnd( charType );
			i -= 1;
		} while ( source.content.toString() === '' ); // TODO faster way to determine non-empty source?

		return this;
	}
};

MagicString$1.Bundle = Bundle;

module.exports = MagicString$1;


}).call(this,require('_process'),require("buffer").Buffer)
},{"_process":367,"buffer":65,"vlq":376}],363:[function(require,module,exports){
(function (process){
var path = require('path');
var fs = require('fs');
var _0777 = parseInt('0777', 8);

module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

function mkdirP (p, opts, f, made) {
    if (typeof opts === 'function') {
        f = opts;
        opts = {};
    }
    else if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = _0777 & (~process.umask());
    }
    if (!made) made = null;
    
    var cb = f || function () {};
    p = path.resolve(p);
    
    xfs.mkdir(p, mode, function (er) {
        if (!er) {
            made = made || p;
            return cb(null, made);
        }
        switch (er.code) {
            case 'ENOENT':
                mkdirP(path.dirname(p), opts, function (er, made) {
                    if (er) cb(er, made);
                    else mkdirP(p, opts, cb, made);
                });
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                xfs.stat(p, function (er2, stat) {
                    // if the stat fails, then that's super weird.
                    // let the original error be the failure reason.
                    if (er2 || !stat.isDirectory()) cb(er, made)
                    else cb(null, made);
                });
                break;
        }
    });
}

mkdirP.sync = function sync (p, opts, made) {
    if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = _0777 & (~process.umask());
    }
    if (!made) made = null;

    p = path.resolve(p);

    try {
        xfs.mkdirSync(p, mode);
        made = made || p;
    }
    catch (err0) {
        switch (err0.code) {
            case 'ENOENT' :
                made = sync(path.dirname(p), opts, made);
                sync(p, opts, made);
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                var stat;
                try {
                    stat = xfs.statSync(p);
                }
                catch (err1) {
                    throw err0;
                }
                if (!stat.isDirectory()) throw err0;
                break;
        }
    }

    return made;
};

}).call(this,require('_process'))
},{"_process":367,"fs":64,"path":366}],364:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000
var m = s * 60
var h = m * 60
var d = h * 24
var y = d * 365.25

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {}
  var type = typeof val
  if (type === 'string' && val.length > 0) {
    return parse(val)
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ?
			fmtLong(val) :
			fmtShort(val)
  }
  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))
}

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str)
  if (str.length > 10000) {
    return
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)
  if (!match) {
    return
  }
  var n = parseFloat(match[1])
  var type = (match[2] || 'ms').toLowerCase()
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y
    case 'days':
    case 'day':
    case 'd':
      return n * d
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n
    default:
      return undefined
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd'
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h'
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm'
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's'
  }
  return ms + 'ms'
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms'
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name
  }
  return Math.ceil(ms / n) + ' ' + name + 's'
}

},{}],365:[function(require,module,exports){
'use strict';
module.exports = Number.isNaN || function (x) {
	return x !== x;
};

},{}],366:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":367}],367:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],368:[function(require,module,exports){
'use strict';
var isFinite = require('is-finite');

module.exports = function (str, n) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected `input` to be a string');
	}

	if (n < 0 || !isFinite(n)) {
		throw new TypeError('Expected `count` to be a positive finite number');
	}

	var ret = '';

	do {
		if (n & 1) {
			ret += str;
		}

		str += str;
	} while ((n >>= 1));

	return ret;
};

},{"is-finite":204}],369:[function(require,module,exports){
'use strict';
module.exports = /^#!(.*)/;

},{}],370:[function(require,module,exports){
'use strict';
var ansiRegex = require('ansi-regex')();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};

},{"ansi-regex":3}],371:[function(require,module,exports){
(function (process){
'use strict';
var argv = process.argv;

var terminator = argv.indexOf('--');
var hasFlag = function (flag) {
	flag = '--' + flag;
	var pos = argv.indexOf(flag);
	return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
};

module.exports = (function () {
	if ('FORCE_COLOR' in process.env) {
		return true;
	}

	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false')) {
		return false;
	}

	if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		return true;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return false;
	}

	if (process.platform === 'win32') {
		return true;
	}

	if ('COLORTERM' in process.env) {
		return true;
	}

	if (process.env.TERM === 'dumb') {
		return false;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return true;
	}

	return false;
})();

}).call(this,require('_process'))
},{"_process":367}],372:[function(require,module,exports){
'use strict';
module.exports = function toFastProperties(obj) {
	function f() {}
	f.prototype = obj;
	new f();
	return;
	eval(obj);
};

},{}],373:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],374:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],375:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":374,"_process":367,"inherits":373}],376:[function(require,module,exports){
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.vlq = global.vlq || {})));
}(this, (function (exports) { 'use strict';

var charToInteger = {};
var integerToChar = {};

'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split( '' ).forEach( function ( char, i ) {
	charToInteger[ char ] = i;
	integerToChar[ i ] = char;
});

function decode ( string ) {
	var result = [];
	var shift = 0;
	var value = 0;

	for ( var i = 0; i < string.length; i += 1 ) {
		var integer = charToInteger[ string[i] ];

		if ( integer === undefined ) {
			throw new Error( 'Invalid character (' + string[i] + ')' );
		}

		var hasContinuationBit = integer & 32;

		integer &= 31;
		value += integer << shift;

		if ( hasContinuationBit ) {
			shift += 5;
		} else {
			var shouldNegate = value & 1;
			value >>= 1;

			result.push( shouldNegate ? -value : value );

			// reset
			value = shift = 0;
		}
	}

	return result;
}

function encode ( value ) {
	var result;

	if ( typeof value === 'number' ) {
		result = encodeInteger( value );
	} else {
		result = '';
		for ( var i = 0; i < value.length; i += 1 ) {
			result += encodeInteger( value[i] );
		}
	}

	return result;
}

function encodeInteger ( num ) {
	var result = '';

	if ( num < 0 ) {
		num = ( -num << 1 ) | 1;
	} else {
		num <<= 1;
	}

	do {
		var clamped = num & 31;
		num >>= 5;

		if ( num > 0 ) {
			clamped |= 32;
		}

		result += integerToChar[ clamped ];
	} while ( num > 0 );

	return result;
}

exports.decode = decode;
exports.encode = encode;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],377:[function(require,module,exports){
var indexOf = require('indexof');

var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    forEach(Object_keys(ctx), function (key) {
        context[key] = ctx[key];
    });

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};

},{"indexof":202}]},{},[189])(189)
});